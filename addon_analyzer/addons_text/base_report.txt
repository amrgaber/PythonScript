Addon: base

Manifest: __manifest__.py
Content:
```python
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.


{
    'name': 'Base',
    'version': '1.3',
    'category': 'Hidden',
    'description': """
The kernel of Odoo, needed for all installation.
===================================================
""",
    'data': [
        'data/res_bank.xml',
        'data/res.lang.csv',
        'data/res_lang_data.xml',
        'data/res_partner_data.xml',
        'data/res_currency_data.xml',
        'data/res_company_data.xml',
        'data/res_users_data.xml',
        'data/report_paperformat_data.xml',
        'data/res_country_data.xml',
        'data/ir_demo_data.xml',
        'security/base_groups.xml',
        'security/base_security.xml',
        'views/base_menus.xml',
        'views/decimal_precision_views.xml',
        'views/res_config_views.xml',
        'data/res.country.state.csv',
        'views/ir_actions_views.xml',
        'views/ir_asset_views.xml',
        'views/ir_config_parameter_views.xml',
        'views/ir_cron_views.xml',
        'views/ir_cron_trigger_views.xml',
        'views/ir_filters_views.xml',
        'views/ir_mail_server_views.xml',
        'views/ir_model_views.xml',
        'views/ir_attachment_views.xml',
        'views/ir_rule_views.xml',
        'views/ir_sequence_views.xml',
        'views/ir_ui_menu_views.xml',
        'views/ir_ui_view_views.xml',
        'views/ir_default_views.xml',
        'data/ir_cron_data.xml',
        'report/ir_model_report.xml',
        'report/ir_model_templates.xml',
        'views/ir_logging_views.xml',
        'views/ir_qweb_widget_templates.xml',
        'views/ir_module_views.xml',
        'data/ir_module_category_data.xml',
        'data/ir_module_module.xml',
        'report/ir_module_reports.xml',
        'report/ir_module_report_templates.xml',
        'wizard/base_module_update_views.xml',
        'wizard/base_language_install_views.xml',
        'wizard/base_import_language_views.xml',
        'wizard/base_module_upgrade_views.xml',
        'wizard/base_module_uninstall_views.xml',
        'wizard/base_export_language_views.xml',
        'wizard/base_partner_merge_views.xml',
        'data/ir_demo_failure_data.xml',
        'views/ir_profile_views.xml',
        'views/res_company_views.xml',
        'views/res_lang_views.xml',
        'views/res_partner_views.xml',
        'views/res_bank_views.xml',
        'views/res_country_views.xml',
        'views/res_currency_views.xml',
        'views/res_users_views.xml',
        'views/res_users_identitycheck_views.xml',
        'views/ir_property_views.xml',
        'views/res_config_settings_views.xml',
        'views/report_paperformat_views.xml',
        'security/ir.model.access.csv',
    ],
    'demo': [
        'data/res_users_demo.xml',
        'data/res_partner_bank_demo.xml',
        'data/res_currency_demo.xml',
        'data/res_currency_rate_demo.xml',
        'data/res_bank_demo.xml',
        'data/res_partner_demo.xml',
        'data/res_partner_image_demo.xml',
    ],
    'assets': {
        'web.assets_tests': [
            'base/static/tests/**/*',
        ],
    },
    'installable': True,
    'auto_install': True,
    'post_init_hook': 'post_init',
    'license': 'LGPL-3',
}

```

__init__.py:
Content:
```python
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import controllers
from . import models
from . import populate
from . import report
from . import wizard


def post_init(env):
    """Rewrite ICP's to force groups"""
    env['ir.config_parameter'].init(force=True)

```

Models:
  File: models/__init__.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import assetsbundle

from . import ir_model
from . import ir_sequence
from . import ir_ui_menu
from . import ir_ui_view
from . import ir_asset
from . import ir_actions
from . import ir_actions_report
from . import ir_attachment
from . import ir_binary
from . import ir_cron
from . import ir_filters
from . import ir_default
from . import ir_exports
from . import ir_rule
from . import ir_config_parameter
from . import ir_autovacuum
from . import ir_mail_server
from . import ir_fields
from . import ir_qweb
from . import ir_qweb_fields
from . import ir_http
from . import ir_logging
from . import ir_property
from . import ir_module
from . import ir_demo
from . import ir_demo_failure
from . import report_layout
from . import report_paperformat

from . import ir_profile
from . import image_mixin
from . import avatar_mixin

from . import res_country
from . import res_lang
from . import res_partner
from . import res_bank
from . import res_config
from . import res_currency
from . import res_company
from . import res_users
from . import res_users_settings
from . import res_users_deletion

from . import decimal_precision

```

  File: models/assetsbundle.py
  Content:
```
# -*- coding: utf-8 -*-
from contextlib import closing
from collections import OrderedDict
from datetime import datetime
from lxml import etree
from subprocess import Popen, PIPE
import base64
import copy
import hashlib
import io
import itertools
import json
import logging
import os
import re
import textwrap
import uuid

import psycopg2
try:
    import sass as libsass
except ImportError:
    # If the `sass` python library isn't found, we fallback on the
    # `sassc` executable in the path.
    libsass = None

from rjsmin import jsmin as rjsmin

from odoo import release, SUPERUSER_ID, _
from odoo.http import request
from odoo.tools import (func, misc, transpile_javascript,
    is_odoo_module, SourceMapGenerator, profiler,
    apply_inheritance_specs)
from odoo.tools.constants import SCRIPT_EXTENSIONS, STYLE_EXTENSIONS
from odoo.tools.misc import file_open, file_path
from odoo.tools.pycompat import to_text

_logger = logging.getLogger(__name__)

ANY_UNIQUE = '_' * 7
EXTENSIONS = (".js", ".css", ".scss", ".sass", ".less", ".xml")

class CompileError(RuntimeError): pass

class AssetError(Exception):
    pass


class AssetNotFound(AssetError):
    pass


class AssetsBundle(object):
    rx_css_import = re.compile("(@import[^;{]+;?)", re.M)
    rx_preprocess_imports = re.compile(r"""(@import\s?['"]([^'"]+)['"](;?))""")
    rx_css_split = re.compile(r"\/\*\! ([a-f0-9-]+) \*\/")

    TRACKED_BUNDLES = ['web.assets_web']

    def __init__(self, name, files, external_assets=(), env=None, css=True, js=True, debug_assets=False, rtl=False, assets_params=None):
        """
        :param name: bundle name
        :param files: files to be added to the bundle
        :param css: if css is True, the stylesheets files are added to the bundle
        :param js: if js is True, the javascript files are added to the bundle
        """
        self.name = name
        self.env = request.env if env is None else env
        self.javascripts = []
        self.templates = []
        self.stylesheets = []
        self.css_errors = []
        self.files = files
        self.rtl = rtl
        self.assets_params = assets_params or {}
        self.has_css = css
        self.has_js = js
        self._checksum_cache = {}
        self.is_debug_assets = debug_assets
        self.external_assets = [
            url
            for url in external_assets
            if (css and url.rpartition('.')[2] in STYLE_EXTENSIONS) or (js and url.rpartition('.')[2] in SCRIPT_EXTENSIONS)
        ]

        # asset-wide html "media" attribute
        for f in files:
            extension = f['url'].rpartition('.')[2]
            params = {
                'url': f['url'],
                'filename': f['filename'],
                'inline': f['content'],
                'last_modified': None if self.is_debug_assets else f.get('last_modified'),
            }
            if css:
                css_params = {
                    'rtl': self.rtl,
                }
                if extension == 'sass':
                    self.stylesheets.append(SassStylesheetAsset(self, **params, **css_params))
                elif extension == 'scss':
                    self.stylesheets.append(ScssStylesheetAsset(self, **params, **css_params))
                elif extension == 'less':
                    self.stylesheets.append(LessStylesheetAsset(self, **params, **css_params))
                elif extension == 'css':
                    self.stylesheets.append(StylesheetAsset(self, **params, **css_params))
            if js:
                if extension == 'js':
                    self.javascripts.append(JavascriptAsset(self, **params))
                elif extension == 'xml':
                    self.templates.append(XMLAsset(self, **params))

    def get_links(self):
        """
        :returns a list of tuple. a tuple can be (url, None) or (None, inlineContent)
        """
        response = []

        if self.has_css and self.stylesheets:
            response.append(self.get_link('css'))

        if self.has_js and self.javascripts:
            response.append(self.get_link('js'))

        return self.external_assets + response

    def get_link(self, asset_type):
        unique = self.get_version(asset_type) if not self.is_debug_assets else 'debug'
        extension = asset_type if self.is_debug_assets else f'min.{asset_type}'
        return self.get_asset_url(unique=unique, extension=extension)

    def get_version(self, asset_type):
        return self.get_checksum(asset_type)[0:7]

    def get_checksum(self, asset_type):
        """
        Not really a full checksum.
        We compute a SHA512/256 on the rendered bundle + combined linked files last_modified date
        """
        if asset_type not in self._checksum_cache:
            if asset_type == 'css':
                assets = self.stylesheets
            elif asset_type == 'js':
                assets = self.javascripts + self.templates
            else:
                raise ValueError(f'Asset type {asset_type} not known')

            unique_descriptor = ','.join(asset.unique_descriptor for asset in assets)

            self._checksum_cache[asset_type] = hashlib.sha512(unique_descriptor.encode()).hexdigest()[:64]
        return self._checksum_cache[asset_type]

    def get_asset_url(self, unique=ANY_UNIQUE, extension='%', ignore_params=False):
        direction = '.rtl' if self.is_css(extension) and self.rtl else ''
        bundle_name = f"{self.name}{direction}.{extension}"
        return self.env['ir.asset']._get_asset_bundle_url(bundle_name, unique, self.assets_params, ignore_params)

    def _unlink_attachments(self, attachments):
        """ Unlinks attachments without actually calling unlink, so that the ORM cache is not cleared.

        Specifically, if an attachment is generated while a view is rendered, clearing the ORM cache
        could unload fields loaded with a sudo(), and expected to be readable by the view.
        Such a view would be website.layout when main_object is an ir.ui.view.
        """
        to_delete = set(attach.store_fname for attach in attachments if attach.store_fname)
        self.env.cr.execute(f"""DELETE FROM {attachments._table} WHERE id IN (
            SELECT id FROM {attachments._table} WHERE id in %s FOR NO KEY UPDATE SKIP LOCKED
        )""", [tuple(attachments.ids)])
        for fpath in to_delete:
            attachments._file_delete(fpath)

    def is_css(self, extension):
        return extension in ['css', 'min.css', 'css.map']

    def _clean_attachments(self, extension, keep_url):
        """ Takes care of deleting any outdated ir.attachment records associated to a bundle before
        saving a fresh one.

        When `extension` is js we need to check that we are deleting a different version (and not *any*
        version) because, as one of the creates in `save_attachment` can trigger a rollback, the
        call to `clean_attachments ` is made at the end of the method in order to avoid the rollback
        of an ir.attachment unlink (because we cannot rollback a removal on the filestore), thus we
        must exclude the current bundle.
        """
        ira = self.env['ir.attachment']
        to_clean_pattern = self.get_asset_url(
            unique=ANY_UNIQUE,
            extension=extension,
        )
        domain = [
            ('url', '=like', to_clean_pattern),
            ('url', '!=', keep_url),
            ('public', '=', True),
        ]

        attachments = ira.sudo().search(domain)
        # avoid to invalidate cache if it's already empty (mainly useful for test)

        if attachments:
            _logger.info('Deleting attachments %s (matching %s) because it was replaced with %s', attachments.ids, to_clean_pattern, keep_url)
            self._unlink_attachments(attachments)
            # clear_cache was removed

        return True

    def get_attachments(self, extension, ignore_version=False):
        """ Return the ir.attachment records for a given bundle. This method takes care of mitigating
        an issue happening when parallel transactions generate the same bundle: while the file is not
        duplicated on the filestore (as it is stored according to its hash), there are multiple
        ir.attachment records referencing the same version of a bundle. As we don't want to source
        multiple time the same bundle in our `to_html` function, we group our ir.attachment records
        by file name and only return the one with the max id for each group.

        :param extension: file extension (js, min.js, css)
        :param ignore_version: if ignore_version, the url contains a version => web/assets/%/name.extension
                                (the second '%' corresponds to the version),
                               else: the url contains a version equal to that of the self.get_version(type)
                                => web/assets/self.get_version(type)/name.extension.
        """
        unique = ANY_UNIQUE if ignore_version else self.get_version('css' if self.is_css(extension) else 'js')
        url_pattern = self.get_asset_url(
            unique=unique,
            extension=extension,
        )
        query = """
             SELECT max(id)
               FROM ir_attachment
              WHERE create_uid = %s
                AND url like %s
                AND res_model = 'ir.ui.view'
                AND res_id = 0
                AND public = true
           GROUP BY name
           ORDER BY name
        """
        self.env.cr.execute(query, [SUPERUSER_ID, url_pattern])

        attachment_id = [r[0] for r in self.env.cr.fetchall()]
        if not attachment_id and not ignore_version:
            fallback_url_pattern = self.get_asset_url(
                unique=unique,
                extension=extension,
                ignore_params=True,
            )
            self.env.cr.execute(query, [SUPERUSER_ID, fallback_url_pattern])
            similar_attachment_ids = [r[0] for r in self.env.cr.fetchall()]
            if similar_attachment_ids:
                similar = self.env['ir.attachment'].sudo().browse(similar_attachment_ids)
                _logger.info('Found a similar attachment for %s, copying from %s', url_pattern, similar.url)
                url = url_pattern
                values = {
                    'name': similar.name,
                    'mimetype': similar.mimetype,
                    'res_model': 'ir.ui.view',
                    'res_id': False,
                    'type': 'binary',
                    'public': True,
                    'raw': similar.raw,
                    'url': url,
                }
                attachment = self.env['ir.attachment'].with_user(SUPERUSER_ID).create(values)
                attachment_id = attachment.id
                self._clean_attachments(extension, url)

        return self.env['ir.attachment'].sudo().browse(attachment_id)

    def save_attachment(self, extension, content):
        """Record the given bundle in an ir.attachment and delete
        all other ir.attachments referring to this bundle (with the same name and extension).

        :param extension: extension of the bundle to be recorded
        :param content: bundle content to be recorded

        :return the ir.attachment records for a given bundle.
        """
        assert extension in ('js', 'min.js', 'js.map', 'css', 'min.css', 'css.map', 'xml', 'min.xml')
        ira = self.env['ir.attachment']

        # Set user direction in name to store two bundles
        # 1 for ltr and 1 for rtl, this will help during cleaning of assets bundle
        # and allow to only clear the current direction bundle
        # (this applies to css bundles only)
        fname = '%s.%s' % (self.name, extension)
        mimetype = (
            'text/css' if extension in ['css', 'min.css'] else
            'text/xml' if extension in ['xml', 'min.xml'] else
            'application/json' if extension in ['js.map', 'css.map'] else
            'application/javascript'
        )
        unique = self.get_version('css' if self.is_css(extension) else 'js')
        url = self.get_asset_url(
            unique=unique,
            extension=extension,
        )
        values = {
            'name': fname,
            'mimetype': mimetype,
            'res_model': 'ir.ui.view',
            'res_id': False,
            'type': 'binary',
            'public': True,
            'raw': content.encode('utf8'),
            'url': url,
        }
        attachment = ira.with_user(SUPERUSER_ID).create(values)

        _logger.info('Generating a new asset bundle attachment %s (id:%s)', attachment.url, attachment.id)

        self._clean_attachments(extension, url)

        # For end-user assets (common and backend), send a message on the bus
        # to invite the user to refresh their browser
        if self.env and 'bus.bus' in self.env and self.name in self.TRACKED_BUNDLES:
            self.env['bus.bus']._sendone('broadcast', 'bundle_changed', {
                'server_version': release.version # Needs to be dynamically imported
            })
            _logger.debug('Asset Changed: bundle: %s -- version: %s', self.name, unique)

        return attachment

    def js(self):
        is_minified = not self.is_debug_assets
        extension = 'min.js' if is_minified else 'js'
        js_attachment = self.get_attachments(extension)

        if not js_attachment:
            template_bundle = ''
            if self.templates:
                content = ['<?xml version="1.0" encoding="UTF-8"?>']
                content.append('<templates xml:space="preserve">')
                content.append(self.xml(show_inherit_info=not is_minified))
                content.append('</templates>')
                templates = '\n'.join(content).replace("\\", "\\\\").replace("`", "\\`").replace("${", "\\${")
                template_bundle = textwrap.dedent(f"""

                    /*******************************************
                    *  Templates                               *
                    *******************************************/

                    odoo.define('{self.name}.bundle.xml', ['@web/core/registry'], function(require){{
                        'use strict';
                        const {{ registry }} = require('@web/core/registry');
                        registry.category(`xml_templates`).add(`{self.name}`, `{templates}`);
                    }});""")

            if is_minified:
                content_bundle = ';\n'.join(asset.minify() for asset in self.javascripts)
                content_bundle += template_bundle
                js_attachment = self.save_attachment(extension, content_bundle)
            else:
                js_attachment = self.js_with_sourcemap(template_bundle=template_bundle)

        return js_attachment[0]

    def js_with_sourcemap(self, template_bundle=None):
        """Create the ir.attachment representing the not-minified content of the bundleJS
        and create/modify the ir.attachment representing the linked sourcemap.

        :return ir.attachment representing the un-minified content of the bundleJS
        """
        sourcemap_attachment = self.get_attachments('js.map') \
                        or self.save_attachment('js.map', '')
        generator = SourceMapGenerator(
            source_root="/".join(
                [".." for i in range(0, len(self.get_asset_url().split("/")) - 2)]
                ) + "/",
        )
        content_bundle_list = []
        content_line_count = 0
        line_header = 5  # number of lines added by with_header()
        for asset in self.javascripts:
            if asset.is_transpiled:
                # '+ 3' corresponds to the 3 lines added at the beginning of the file during transpilation.
                generator.add_source(
                    asset.url, asset._content, content_line_count, start_offset=line_header + 3)
            else:
                generator.add_source(
                    asset.url, asset.content, content_line_count, start_offset=line_header)

            content_bundle_list.append(asset.with_header(asset.content, minimal=False))
            content_line_count += len(asset.content.split("\n")) + line_header

        content_bundle = ';\n'.join(content_bundle_list)
        if template_bundle:
            content_bundle += template_bundle

        content_bundle += "\n\n//# sourceMappingURL=" + sourcemap_attachment.url
        js_attachment = self.save_attachment('js', content_bundle)

        generator._file = js_attachment.url
        sourcemap_attachment.write({
            "raw": generator.get_content()
        })

        return js_attachment

    def xml(self, show_inherit_info=False):
        """
        Create the ir.attachment representing the content of the bundle XML.
        The xml contents are loaded and parsed with etree. Inheritances are
        applied in the order of files and templates.

        Used parsed attributes:
        * `t-name`: template name
        * `t-inherit`: inherited template name. The template use the
            `apply_inheritance_specs` method from `ir.ui.view` to apply
            inheritance (with xpath and position).
        * 't-inherit-mode':  'primary' to create a new template with the
            update, or 'extension' to apply the update on the inherited
            template.
        * `t-extend` deprecated attribute, used by the JavaScript Qweb.

        :param show_inherit_info: if true add the file url and inherit
            information in the template.
        :return ir.attachment representing the content of the bundle XML
        """
        template_dict = OrderedDict()
        parser = etree.XMLParser(ns_clean=True, recover=True, remove_comments=True)

        for asset in self.templates:
            # Load content.
            try:
                content = asset.content.strip()
                template = content if content.startswith('<odoo>') else f'<templates>{asset.content}</templates>'
                io_content = io.BytesIO(template.encode('utf-8'))
                content_templates_tree = etree.parse(io_content, parser=parser).getroot()
            except etree.ParseError as e:
                _logger.error("Could not parse file %s: %s", asset.url, e.msg)
                raise
            addon = asset.url.split('/')[1]
            template_dict.setdefault(addon, OrderedDict())
            # Process every templates.
            for template_tree in list(content_templates_tree):
                template_name = None
                if 't-name' in template_tree.attrib:
                    template_name = template_tree.attrib['t-name']
                    dotted_names = template_name.split('.', 1)
                    if len(dotted_names) > 1 and dotted_names[0] == addon:
                        template_name = dotted_names[1]

                if 't-inherit' in template_tree.attrib:
                    inherit_mode = template_tree.attrib.get('t-inherit-mode', 'primary')
                    if inherit_mode not in ['primary', 'extension']:
                        raise ValueError(_("Invalid inherit mode. Module %r and template name %r", addon, template_name))

                    # Get inherited template, the identifier can be "addon.name", just "name" or (silly) "just.name.with.dots"
                    parent_dotted_name = template_tree.attrib['t-inherit']
                    split_name_attempt = parent_dotted_name.split('.', 1)
                    parent_addon, parent_name = split_name_attempt if len(split_name_attempt) == 2 else (addon, parent_dotted_name)
                    if parent_addon not in template_dict:
                        if parent_dotted_name in template_dict[addon]:
                            parent_addon = addon
                            parent_name = parent_dotted_name
                        else:
                            raise ValueError(_("Module %r not loaded or inexistent (try to inherit %r), or templates of addon being loaded %r are misordered (template %r)", parent_addon, parent_name, addon, template_name))
                    if parent_name not in template_dict[parent_addon]:
                        raise ValueError(_("Cannot create %r because the template to inherit %r is not found.", '%s.%s' % (addon, template_name), '%s.%s' % (parent_addon, parent_name)))

                    # After several performance tests, we found out that deepcopy is the most efficient
                    # solution in this case (compared with copy, xpath with '.' and stringifying).
                    parent_tree, parent_urls = template_dict[parent_addon][parent_name]
                    parent_tree = copy.deepcopy(parent_tree)

                    if show_inherit_info:
                        # Add inheritance information as xml comment for debugging.
                        xpaths = []
                        for item in template_tree:
                            position = item.get('position')
                            attrib = dict(**item.attrib)
                            attrib.pop('position', None)
                            comment = etree.Comment(f""" Filepath: {asset.url} ; position="{position}" ; {attrib} """)
                            if position == "attributes":
                                if item.get('expr'):
                                    comment_node = etree.Element('xpath', {'expr': item.get('expr'), 'position': 'before'})
                                else:
                                    comment_node = etree.Element(item.tag, item.attrib)
                                    comment_node.attrib['position'] = 'before'
                                comment_node.append(comment)
                                xpaths.append(comment_node)
                            else:
                                if len(item) > 0:
                                    item[0].addprevious(comment)
                                else:
                                    item.append(comment)
                            xpaths.append(item)
                    else:
                        xpaths = list(template_tree)

                    # Apply inheritance.
                    if inherit_mode == 'primary':
                        parent_tree.tag = template_tree.tag
                    inherited_template = apply_inheritance_specs(parent_tree, xpaths)
                    if inherit_mode == 'primary':  # New template_tree: A' = B(A)
                        for attr_name, attr_val in template_tree.attrib.items():
                            if attr_name not in ('t-inherit', 't-inherit-mode'):
                                inherited_template.set(attr_name, attr_val)
                        if not template_name:
                            raise ValueError(_("Template name is missing in file %r.", asset.url))
                        template_dict[addon][template_name] = (inherited_template, parent_urls + [asset.url])
                    else:  # Modifies original: A = B(A)
                        template_dict[parent_addon][parent_name] = (inherited_template, parent_urls + [asset.url])
                elif template_name:
                    if template_name in template_dict[addon]:
                        raise ValueError(_("Template %r already exists in module %r", template_name, addon))
                    template_dict[addon][template_name] = (template_tree, [asset.url])
                elif template_tree.attrib.get('t-extend'):
                    template_name = '%s__extend_%s' % (template_tree.attrib.get('t-extend'), len(template_dict[addon]))
                    template_dict[addon][template_name] = (template_tree, [asset.url])
                else:
                    raise ValueError(_("Template name is missing in file %r.", asset.url))

        # Concat and render inherited templates
        root = etree.Element('root')
        for addon in template_dict.values():
            for template, urls in addon.values():
                if show_inherit_info:
                    tail = "\n"
                    if len(root) > 0:
                        tail = root[-1].tail
                        root[-1].tail = "\n\n"
                    comment = etree.Comment(f""" Filepath: {' => '.join(urls)} """)
                    comment.tail = tail
                    root.append(comment)
                root.append(template)

        # Returns the string by removing the <root> tag.
        return etree.tostring(root, encoding='unicode')[6:-7]

    def css(self):
        is_minified = not self.is_debug_assets
        extension = 'min.css' if is_minified else 'css'
        attachments = self.get_attachments(extension)
        if attachments:
            return attachments

        css = self.preprocess_css()
        if self.css_errors:
            error_message = '\n'.join(self.css_errors).replace('"', r'\"').replace('\n', r'\A').replace('*', r'\*')
            previous_attachment = self.get_attachments(extension, ignore_version=True)
            previous_css = previous_attachment.raw.decode() if previous_attachment else ''
            css_error_message_header = '\n\n/* ## CSS error message ##*/'
            previous_css = previous_css.split(css_error_message_header)[0]
            css = css_error_message_header.join([
                previous_css, """
body::before {
  font-weight: bold;
  content: "A css error occured, using an old style to render this page";
  position: fixed;
  left: 0;
  bottom: 0;
  z-index: 100000000000;
  background-color: #C00;
  color: #DDD;
}

css_error_message {
  content: "%s";
}
""" % error_message
            ])
            return self.save_attachment(extension, css)

        matches = []
        css = re.sub(self.rx_css_import, lambda matchobj: matches.append(matchobj.group(0)) and '', css)

        if is_minified:
            # move up all @import rules to the top
            matches.append(css)
            css = u'\n'.join(matches)

            return self.save_attachment(extension, css)
        else:
            return self.css_with_sourcemap(u'\n'.join(matches))

    def css_with_sourcemap(self, content_import_rules):
        """Create the ir.attachment representing the not-minified content of the bundleCSS
        and create/modify the ir.attachment representing the linked sourcemap.

        :param content_import_rules: string containing all the @import rules to put at the beginning of the bundle
        :return ir.attachment representing the un-minified content of the bundleCSS
        """
        sourcemap_attachment = self.get_attachments('css.map') \
                                or self.save_attachment('css.map', '')
        debug_asset_url = self.get_asset_url(unique='debug')
        generator = SourceMapGenerator(
            source_root="/".join(
                [".." for i in range(0, len(debug_asset_url.split("/")) - 2)]
                ) + "/",
        )

        # adds the @import rules at the beginning of the bundle
        content_bundle_list = [content_import_rules]
        content_line_count = len(content_import_rules.split("\n"))
        for asset in self.stylesheets:
            if asset.content:
                content = asset.with_header(asset.content)
                if asset.url:
                    generator.add_source(asset.url, content, content_line_count)
                # comments all @import rules that have been added at the beginning of the bundle
                content = re.sub(self.rx_css_import, lambda matchobj: f"/* {matchobj.group(0)} */", content)
                content_bundle_list.append(content)
                content_line_count += len(content.split("\n"))

        content_bundle = '\n'.join(content_bundle_list) + f"\n/*# sourceMappingURL={sourcemap_attachment.url} */"
        css_attachment = self.save_attachment('css', content_bundle)

        generator._file = css_attachment.url
        sourcemap_attachment.write({
            "raw": generator.get_content(),
        })

        return css_attachment

    def preprocess_css(self, debug=False, old_attachments=None):
        """
            Checks if the bundle contains any sass/less content, then compiles it to css.
            If user language direction is Right to Left then consider css files to call run_rtlcss,
            css files are also stored in ir.attachment after processing done by rtlcss.
            Returns the bundle's flat css.
        """
        if self.stylesheets:
            compiled = ""
            for atype in (SassStylesheetAsset, ScssStylesheetAsset, LessStylesheetAsset):
                assets = [asset for asset in self.stylesheets if isinstance(asset, atype)]
                if assets:
                    source = '\n'.join([asset.get_source() for asset in assets])
                    compiled += self.compile_css(assets[0].compile, source)

            # We want to run rtlcss on normal css, so merge it in compiled
            if self.rtl:
                stylesheet_assets = [asset for asset in self.stylesheets if not isinstance(asset, (SassStylesheetAsset, ScssStylesheetAsset, LessStylesheetAsset))]
                compiled += '\n'.join([asset.get_source() for asset in stylesheet_assets])
                compiled = self.run_rtlcss(compiled)

            if not self.css_errors and old_attachments:
                self._unlink_attachments(old_attachments)
                old_attachments = None

            fragments = self.rx_css_split.split(compiled)
            at_rules = fragments.pop(0)
            if at_rules:
                # Sass and less moves @at-rules to the top in order to stay css 2.1 compatible
                self.stylesheets.insert(0, StylesheetAsset(self, inline=at_rules))
            while fragments:
                asset_id = fragments.pop(0)
                asset = next(asset for asset in self.stylesheets if asset.id == asset_id)
                asset._content = fragments.pop(0)

        return '\n'.join(asset.minify() for asset in self.stylesheets)

    def compile_css(self, compiler, source):
        """Sanitizes @import rules, remove duplicates @import rules, then compile"""
        imports = []
        def handle_compile_error(e, source):
            error = self.get_preprocessor_error(e, source=source)
            _logger.warning(error)
            self.css_errors.append(error)
            return ''
        def sanitize(matchobj):
            ref = matchobj.group(2)
            line = '@import "%s"%s' % (ref, matchobj.group(3))
            if '.' not in ref and line not in imports and not ref.startswith(('.', '/', '~')):
                imports.append(line)
                return line
            msg = "Local import '%s' is forbidden for security reasons. Please remove all @import {your_file} imports in your custom files. In Odoo you have to import all files in the assets, and not through the @import statement." % ref
            _logger.warning(msg)
            self.css_errors.append(msg)
            return ''
        source = re.sub(self.rx_preprocess_imports, sanitize, source)

        compiled = ''
        try:
            compiled = compiler(source)
        except CompileError as e:
            return handle_compile_error(e, source=source)

        compiled = compiled.strip()

        # Post process the produced css to add required vendor prefixes here
        compiled = re.sub(r'(appearance: (\w+);)', r'-webkit-appearance: \2; -moz-appearance: \2; \1', compiled)

        # Most of those are only useful for wkhtmltopdf (some for old PhantomJS)
        compiled = re.sub(r'(display: ((?:inline-)?)flex((?: ?!important)?);)', r'display: -webkit-\2box\3; display: -webkit-\2flex\3; \1', compiled)
        compiled = re.sub(r'(justify-content: flex-(\w+)((?: ?!important)?);)', r'-webkit-box-pack: \2\3; \1', compiled)
        compiled = re.sub(r'(flex-flow: (\w+ \w+);)', r'-webkit-flex-flow: \2; \1', compiled)
        compiled = re.sub(r'(flex-direction: (column);)', r'-webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: \2; \1', compiled)
        compiled = re.sub(r'(flex-wrap: (\w+);)', r'-webkit-flex-wrap: \2; \1', compiled)
        compiled = re.sub(r'(flex: ((\d)+ \d+ (?:\d+|auto));)', r'-webkit-box-flex: \3; -webkit-flex: \2; \1', compiled)

        return compiled

    def run_rtlcss(self, source):
        rtlcss = 'rtlcss'
        if os.name == 'nt':
            try:
                rtlcss = misc.find_in_path('rtlcss.cmd')
            except IOError:
                rtlcss = 'rtlcss'

        cmd = [rtlcss, '-c', file_path("base/data/rtlcss.json"), '-']

        try:
            rtlcss = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        except Exception:

            # Check the presence of rtlcss, if rtlcss not available then we should return normal less file
            try:
                process = Popen(
                    ['rtlcss', '--version'], stdout=PIPE, stderr=PIPE
                )
            except (OSError, IOError):
                _logger.warning('You need https://rtlcss.com/ to convert css file to right to left compatiblity. Use: npm install -g rtlcss')
                return source

            msg = "Could not execute command %r" % cmd[0]
            _logger.error(msg)
            self.css_errors.append(msg)
            return ''

        result = rtlcss.communicate(input=source.encode('utf-8'))
        if rtlcss.returncode:
            cmd_output = ''.join(misc.ustr(result))
            if not cmd_output:
                cmd_output = "Process exited with return code %d\n" % rtlcss.returncode
            error = self.get_rtlcss_error(cmd_output, source=source)
            _logger.warning(error)
            self.css_errors.append(error)
            return ''
        rtlcss_result = result[0].strip().decode('utf8')
        return rtlcss_result

    def get_preprocessor_error(self, stderr, source=None):
        """Improve and remove sensitive information from sass/less compilator error messages"""
        error = misc.ustr(stderr).split('Load paths')[0].replace('  Use --trace for backtrace.', '')
        if 'Cannot load compass' in error:
            error += "Maybe you should install the compass gem using this extra argument:\n\n" \
                     "    $ sudo gem install compass --pre\n"
        error += "This error occurred while compiling the bundle '%s' containing:" % self.name
        for asset in self.stylesheets:
            if isinstance(asset, PreprocessedCSS):
                error += '\n    - %s' % (asset.url if asset.url else '<inline sass>')
        return error

    def get_rtlcss_error(self, stderr, source=None):
        """Improve and remove sensitive information from sass/less compilator error messages"""
        error = misc.ustr(stderr).split('Load paths')[0].replace('  Use --trace for backtrace.', '')
        error += "This error occurred while compiling the bundle '%s' containing:" % self.name
        return error


class WebAsset(object):
    _content = None
    _filename = None
    _ir_attach = None
    _id = None

    def __init__(self, bundle, inline=None, url=None, filename=None, last_modified=None):
        self.bundle = bundle
        self.inline = inline
        self._filename = filename
        self.url = url
        self._last_modified = last_modified
        if not inline and not url:
            raise Exception("An asset should either be inlined or url linked, defined in bundle '%s'" % bundle.name)

    @func.lazy_property
    def id(self):
        if self._id is None: self._id = str(uuid.uuid4())
        return self._id

    @func.lazy_property
    def unique_descriptor(self):
        return f'{self.url or self.inline},{self.last_modified}'

    @func.lazy_property
    def name(self):
        return '<inline asset>' if self.inline else self.url

    def stat(self):
        if not (self.inline or self._filename or self._ir_attach):
            try:
                # Test url against ir.attachments
                self._ir_attach = self.bundle.env['ir.attachment'].sudo()._get_serve_attachment(self.url)
                self._ir_attach.ensure_one()
            except ValueError:
                raise AssetNotFound("Could not find %s" % self.name)

    @property
    def last_modified(self):
        if self._last_modified is None:
            try:
                self.stat()
            except Exception:  # most likely nor a file or an attachment, skip it
                pass
            if self._filename and self.bundle.is_debug_assets:  # usually _last_modified should be set exept in debug=assets
                self._last_modified = os.path.getmtime(self._filename)
            elif self._ir_attach:
                self._last_modified = self._ir_attach.write_date.timestamp()
            if not self._last_modified:
                self._last_modified = -1
        return self._last_modified

    @property
    def content(self):
        if self._content is None:
            self._content = self.inline or self._fetch_content()
        return self._content

    def _fetch_content(self):
        """ Fetch content from file or database"""
        try:
            self.stat()
            if self._filename:
                with closing(file_open(self._filename, 'rb', filter_ext=EXTENSIONS)) as fp:
                    return fp.read().decode('utf-8')
            else:
                return self._ir_attach.raw.decode()
        except UnicodeDecodeError:
            raise AssetError('%s is not utf-8 encoded.' % self.name)
        except IOError:
            raise AssetNotFound('File %s does not exist.' % self.name)
        except:
            raise AssetError('Could not get content for %s.' % self.name)

    def minify(self):
        return self.content

    def with_header(self, content=None):
        if content is None:
            content = self.content
        return f'\n/* {self.name} */\n{content}'


class JavascriptAsset(WebAsset):

    def __init__(self, bundle, **kwargs):
        super().__init__(bundle, **kwargs)
        self._is_transpiled = None
        self._converted_content = None

    @property
    def bundle_version(self):
        return self.bundle.get_version('js')

    @property
    def is_transpiled(self):
        if self._is_transpiled is None:
            self._is_transpiled = bool(is_odoo_module(super().content))
        return self._is_transpiled

    @property
    def content(self):
        content = super().content
        if self.is_transpiled:
            if not self._converted_content:
                self._converted_content = transpile_javascript(self.url, content)
            return self._converted_content
        return content

    def minify(self):
        return self.with_header(rjsmin(self.content))

    def _fetch_content(self):
        try:
            return super()._fetch_content()
        except AssetError as e:
            return u"console.error(%s);" % json.dumps(to_text(e))


    def with_header(self, content=None, minimal=True):
        if minimal:
            return super().with_header(content)

        # format the header like
        #   /**************************
        #   *  Filepath: <asset_url>  *
        #   *  Lines: 42              *
        #   **************************/
        line_count = content.count('\n')
        lines = [
            f"Filepath: {self.url}",
            f"Lines: {line_count}",
        ]
        length = max(map(len, lines))
        return "\n".join([
            "",
            "/" + "*" * (length + 5),
            *(f"*  {line:<{length}}  *" for line in lines),
            "*" * (length + 5) + "/",
            content,
        ])


class XMLAsset(WebAsset):
    def _fetch_content(self):
        try:
            content = super()._fetch_content()
        except AssetError as e:
            return u"console.error(%s);" % json.dumps(to_text(e))

        parser = etree.XMLParser(ns_clean=True, remove_comments=True, resolve_entities=False)
        try:
            root = etree.fromstring(content.encode('utf-8'), parser=parser)
        except etree.XMLSyntaxError as e:
            return f'<t t-name="parsing_error{self.url.replace("/","_")}"><parsererror>Invalid XML template: {self.url} \n {e.msg} </parsererror></t>'
        if root.tag in ('templates', 'template'):
            return ''.join(etree.tostring(el, encoding='unicode') for el in root)
        return etree.tostring(root, encoding='unicode')

    @property
    def bundle_version(self):
        return self.bundle.get_version('js')

    def with_header(self, content=None):
        if content is None:
            content = self.content

        # format the header like
        #   <!--=========================-->
        #   <!--  Filepath: <asset_url>  -->
        #   <!--  Bundle: <name>         -->
        #   <!--  Lines: 42              -->
        #   <!--=========================-->
        line_count = content.count('\n')
        lines = [
            f"Filepath: {self.url}",
            f"Lines: {line_count}",
        ]
        length = max(map(len, lines))
        return "\n".join([
            "",
            "<!--  " + "=" * length + "  -->",
            *(f"<!--  {line:<{length}}  -->" for line in lines),
            "<!--  " + "=" * length + "  -->",
            content,
        ])


class StylesheetAsset(WebAsset):
    rx_import = re.compile(r"""@import\s+('|")(?!'|"|/|https?://)""", re.U)
    rx_url = re.compile(r"""(?<!")url\s*\(\s*('|"|)(?!'|"|/|https?://|data:|#{str)""", re.U)
    rx_sourceMap = re.compile(r'(/\*# sourceMappingURL=.*)', re.U)
    rx_charset = re.compile(r'(@charset "[^"]+";)', re.U)

    def __init__(self, *args, rtl=False, **kw):
        self.rtl = rtl
        super().__init__(*args, **kw)

    @property
    def bundle_version(self):
        return self.bundle.get_version('css')

    @func.lazy_property
    def unique_descriptor(self):
        direction = (self.rtl and 'rtl') or 'ltr'
        return f'{self.url or self.inline},{self.last_modified},{direction}'

    def _fetch_content(self):
        try:
            content = super()._fetch_content()
            web_dir = os.path.dirname(self.url)

            if self.rx_import:
                content = self.rx_import.sub(
                    r"""@import \1%s/""" % (web_dir,),
                    content,
                )

            if self.rx_url:
                content = self.rx_url.sub(
                    r"url(\1%s/" % (web_dir,),
                    content,
                )

            if self.rx_charset:
                # remove charset declarations, we only support utf-8
                content = self.rx_charset.sub('', content)

            return content
        except AssetError as e:
            self.bundle.css_errors.append(str(e))
            return ''

    def get_source(self):
        content = self.inline or self._fetch_content()
        return "/*! %s */\n%s" % (self.id, content)

    def minify(self):
        # remove existing sourcemaps, make no sense after re-mini
        content = self.rx_sourceMap.sub('', self.content)
        # comments
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.S)
        # space
        content = re.sub(r'\s+', ' ', content)
        content = re.sub(r' *([{}]) *', r'\1', content)
        return self.with_header(content)


class PreprocessedCSS(StylesheetAsset):
    rx_import = None

    def get_command(self):
        raise NotImplementedError

    def compile(self, source):
        command = self.get_command()
        try:
            compiler = Popen(command, stdin=PIPE, stdout=PIPE,
                             stderr=PIPE)
        except Exception:
            raise CompileError("Could not execute command %r" % command[0])

        (out, err) = compiler.communicate(input=source.encode('utf-8'))
        if compiler.returncode:
            cmd_output = misc.ustr(out) + misc.ustr(err)
            if not cmd_output:
                cmd_output = u"Process exited with return code %d\n" % compiler.returncode
            raise CompileError(cmd_output)
        return out.decode('utf8')

class SassStylesheetAsset(PreprocessedCSS):
    rx_indent = re.compile(r'^( +|\t+)', re.M)
    indent = None
    reindent = '    '

    def minify(self):
        return self.with_header()

    def get_source(self):
        content = textwrap.dedent(self.inline or self._fetch_content())

        def fix_indent(m):
            # Indentation normalization
            ind = m.group()
            if self.indent is None:
                self.indent = ind
                if self.indent == self.reindent:
                    # Don't reindent the file if identation is the final one (reindent)
                    raise StopIteration()
            return ind.replace(self.indent, self.reindent)

        try:
            content = self.rx_indent.sub(fix_indent, content)
        except StopIteration:
            pass
        return "/*! %s */\n%s" % (self.id, content)

    def get_command(self):
        try:
            sass = misc.find_in_path('sass')
        except IOError:
            sass = 'sass'
        return [sass, '--stdin', '-t', 'compressed', '--unix-newlines', '--compass',
                '-r', 'bootstrap-sass']


class ScssStylesheetAsset(PreprocessedCSS):
    @property
    def bootstrap_path(self):
        return file_path('web/static/lib/bootstrap/scss')

    precision = 8
    output_style = 'expanded'

    def compile(self, source):
        if libsass is None:
            return super().compile(source)

        try:
            profiler.force_hook()
            return libsass.compile(
                string=source,
                include_paths=[
                    self.bootstrap_path,
                ],
                output_style=self.output_style,
                precision=self.precision,
            )
        except libsass.CompileError as e:
            raise CompileError(e.args[0])

    def get_command(self):
        try:
            sassc = misc.find_in_path('sassc')
        except IOError:
            sassc = 'sassc'
        return [sassc, '--stdin', '--precision', str(self.precision), '--load-path', self.bootstrap_path, '-t', self.output_style]


class LessStylesheetAsset(PreprocessedCSS):
    def get_command(self):
        try:
            if os.name == 'nt':
                lessc = misc.find_in_path('lessc.cmd')
            else:
                lessc = misc.find_in_path('lessc')
        except IOError:
            lessc = 'lessc'
        return [lessc, '-', '--no-js', '--no-color']

```

  File: models/avatar_mixin.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from base64 import b64encode
from hashlib import sha512
from odoo import models, fields, api
from odoo.tools import html_escape, file_open


def get_hsl_from_seed(seed):
    hashed_seed = sha512(seed.encode()).hexdigest()
    # full range of colors, in degree
    hue = int(hashed_seed[0:2], 16) * 360 / 255
    # colorful result but not too flashy, in percent
    sat = int(hashed_seed[2:4], 16) * ((70 - 40) / 255) + 40
    # not too bright and not too dark, in percent
    lig = 45
    return f'hsl({hue:.0f}, {sat:.0f}%, {lig:.0f}%)'


class AvatarMixin(models.AbstractModel):
    _name = 'avatar.mixin'
    _inherit = ['image.mixin']
    _description = "Avatar Mixin"
    _avatar_name_field = "name"

    # all image fields are base64 encoded and PIL-supported
    avatar_1920 = fields.Image("Avatar", compute="_compute_avatar_1920")
    avatar_1024 = fields.Image("Avatar 1024", compute="_compute_avatar_1024")
    avatar_512 = fields.Image("Avatar 512", compute="_compute_avatar_512")
    avatar_256 = fields.Image("Avatar 256", compute="_compute_avatar_256")
    avatar_128 = fields.Image("Avatar 128", compute="_compute_avatar_128")

    def _compute_avatar(self, avatar_field, image_field):
        for record in self:
            avatar = record[image_field]
            if not avatar:
                if record.id and record[record._avatar_name_field]:
                    avatar = record._avatar_generate_svg()
                else:
                    avatar = b64encode(record._avatar_get_placeholder())
            record[avatar_field] = avatar

    @api.depends(lambda self: [self._avatar_name_field, 'image_1920'])
    def _compute_avatar_1920(self):
        self._compute_avatar('avatar_1920', 'image_1920')

    @api.depends(lambda self: [self._avatar_name_field, 'image_1024'])
    def _compute_avatar_1024(self):
        self._compute_avatar('avatar_1024', 'image_1024')

    @api.depends(lambda self: [self._avatar_name_field, 'image_512'])
    def _compute_avatar_512(self):
        self._compute_avatar('avatar_512', 'image_512')

    @api.depends(lambda self: [self._avatar_name_field, 'image_256'])
    def _compute_avatar_256(self):
        self._compute_avatar('avatar_256', 'image_256')

    @api.depends(lambda self: [self._avatar_name_field, 'image_128'])
    def _compute_avatar_128(self):
        self._compute_avatar('avatar_128', 'image_128')

    def _avatar_generate_svg(self):
        initial = html_escape(self[self._avatar_name_field][0].upper())
        bgcolor = get_hsl_from_seed(self[self._avatar_name_field] + str(self.create_date.timestamp() if self.create_date else ""))
        return b64encode((
            "<?xml version='1.0' encoding='UTF-8' ?>"
            "<svg height='180' width='180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>"
            f"<rect fill='{bgcolor}' height='180' width='180'/>"
            f"<text fill='#ffffff' font-size='96' text-anchor='middle' x='90' y='125' font-family='sans-serif'>{initial}</text>"
            "</svg>"
        ).encode())

    def _avatar_get_placeholder_path(self):
        return "base/static/img/avatar_grey.png"

    def _avatar_get_placeholder(self):
        return file_open(self._avatar_get_placeholder_path(), 'rb').read()

```

  File: models/decimal_precision.py
  Content:
```
# -*- encoding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, tools, _
import odoo.addons

import logging
import sys
_logger = logging.getLogger(__name__)


def get_precision(application):
    _logger.warning("Deprecated call to decimal_precision.get_precision(<application>), use digits=<application> instead")
    return application


class DecimalPrecision(models.Model):
    _name = 'decimal.precision'
    _description = 'Decimal Precision'

    name = fields.Char('Usage', required=True)
    digits = fields.Integer('Digits', required=True, default=2)

    _sql_constraints = [
        ('name_uniq', 'unique (name)', """Only one value can be defined for each given usage!"""),
    ]

    @api.model
    @tools.ormcache('application')
    def precision_get(self, application):
        self.flush_model(['name', 'digits'])
        self.env.cr.execute('select digits from decimal_precision where name=%s', (application,))
        res = self.env.cr.fetchone()
        return res[0] if res else 2

    @api.model_create_multi
    def create(self, vals_list):
        res = super(DecimalPrecision, self).create(vals_list)
        self.env.registry.clear_cache()
        return res

    def write(self, data):
        res = super(DecimalPrecision, self).write(data)
        self.env.registry.clear_cache()
        return res

    def unlink(self):
        res = super(DecimalPrecision, self).unlink()
        self.env.registry.clear_cache()
        return res

    @api.onchange('digits')
    def _onchange_digits_warning(self):
        if self.digits < self._origin.digits:
            return {
                'warning': {
                    'title': _("Warning for %s", self.name),
                    'message': _(
                        "The precision has been reduced for %s.\n"
                        "Note that existing data WON'T be updated by this change.\n\n"
                        "As decimal precisions impact the whole system, this may cause critical issues.\n"
                        "E.g. reducing the precision could disturb your financial balance.\n\n"
                        "Therefore, changing decimal precisions in a running database is not recommended.",
                        self.name,
                    )
                }
            }

# compatibility for decimal_precision.get_precision(): expose the module in addons namespace
dp = sys.modules['odoo.addons.base.models.decimal_precision']
odoo.addons.decimal_precision = dp
sys.modules['odoo.addons.decimal_precision'] = dp
sys.modules['openerp.addons.decimal_precision'] = dp

```

  File: models/image_mixin.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models, fields


class ImageMixin(models.AbstractModel):
    _name = 'image.mixin'
    _description = "Image Mixin"

    # all image fields are base64 encoded and PIL-supported

    image_1920 = fields.Image("Image", max_width=1920, max_height=1920)

    # resized fields stored (as attachment) for performance
    image_1024 = fields.Image("Image 1024", related="image_1920", max_width=1024, max_height=1024, store=True)
    image_512 = fields.Image("Image 512", related="image_1920", max_width=512, max_height=512, store=True)
    image_256 = fields.Image("Image 256", related="image_1920", max_width=256, max_height=256, store=True)
    image_128 = fields.Image("Image 128", related="image_1920", max_width=128, max_height=128, store=True)

```

  File: models/ir_actions.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import odoo
from odoo import api, fields, models, tools, _, Command
from odoo.exceptions import MissingError, ValidationError, AccessError, UserError
from odoo.tools import frozendict
from odoo.tools.safe_eval import safe_eval, test_python_expr
from odoo.tools.float_utils import float_compare
from odoo.http import request
import base64
from collections import defaultdict
from functools import partial, reduce
import logging
from operator import getitem
import requests
import json
import contextlib

from pytz import timezone

_logger = logging.getLogger(__name__)
_server_action_logger = _logger.getChild("server_action_safe_eval")


class LoggerProxy:
    """ Proxy of the `_logger` element in order to be used in server actions.
    We purposefully restrict its method as it will be executed in `safe_eval`.
    """
    @staticmethod
    def log(level, message, *args, stack_info=False, exc_info=False):
        _server_action_logger.log(level, message, *args, stack_info=stack_info, exc_info=exc_info)

    @staticmethod
    def info(message, *args, stack_info=False, exc_info=False):
        _server_action_logger.info(message, *args, stack_info=stack_info, exc_info=exc_info)

    @staticmethod
    def warning(message, *args, stack_info=False, exc_info=False):
        _server_action_logger.warning(message, *args, stack_info=stack_info, exc_info=exc_info)

    @staticmethod
    def error(message, *args, stack_info=False, exc_info=False):
        _server_action_logger.error(message, *args, stack_info=stack_info, exc_info=exc_info)

    @staticmethod
    def exception(message, *args, stack_info=False, exc_info=True):
        _server_action_logger.exception(message, *args, stack_info=stack_info, exc_info=exc_info)


class IrActions(models.Model):
    _name = 'ir.actions.actions'
    _description = 'Actions'
    _table = 'ir_actions'
    _order = 'name'
    _allow_sudo_commands = False

    name = fields.Char(string='Action Name', required=True, translate=True)
    type = fields.Char(string='Action Type', required=True)
    xml_id = fields.Char(compute='_compute_xml_id', string="External ID")
    help = fields.Html(string='Action Description',
                       help='Optional help text for the users with a description of the target view, such as its usage and purpose.',
                       translate=True)
    binding_model_id = fields.Many2one('ir.model', ondelete='cascade',
                                       help="Setting a value makes this action available in the sidebar for the given model.")
    binding_type = fields.Selection([('action', 'Action'),
                                     ('report', 'Report')],
                                    required=True, default='action')
    binding_view_types = fields.Char(default='list,form')

    def _compute_xml_id(self):
        res = self.get_external_id()
        for record in self:
            record.xml_id = res.get(record.id)

    @api.model_create_multi
    def create(self, vals_list):
        res = super(IrActions, self).create(vals_list)
        # self.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return res

    def write(self, vals):
        res = super(IrActions, self).write(vals)
        # self.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return res

    def unlink(self):
        """unlink ir.action.todo/ir.filters which are related to actions which will be deleted.
           NOTE: ondelete cascade will not work on ir.actions.actions so we will need to do it manually."""
        todos = self.env['ir.actions.todo'].search([('action_id', 'in', self.ids)])
        todos.unlink()
        filters = self.env['ir.filters'].search([('action_id', 'in', self.ids)])
        filters.unlink()
        res = super(IrActions, self).unlink()
        # self.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return res

    @api.ondelete(at_uninstall=True)
    def _unlink_check_home_action(self):
        self.env['res.users'].with_context(active_test=False).search([('action_id', 'in', self.ids)]).sudo().write({'action_id': None})

    @api.model
    def _get_eval_context(self, action=None):
        """ evaluation context to pass to safe_eval """
        return {
            'uid': self._uid,
            'user': self.env.user,
            'time': tools.safe_eval.time,
            'datetime': tools.safe_eval.datetime,
            'dateutil': tools.safe_eval.dateutil,
            'timezone': timezone,
            'float_compare': float_compare,
            'b64encode': base64.b64encode,
            'b64decode': base64.b64decode,
            'Command': Command,
        }

    @api.model
    def get_bindings(self, model_name):
        """ Retrieve the list of actions bound to the given model.

           :return: a dict mapping binding types to a list of dict describing
                    actions, where the latter is given by calling the method
                    ``read`` on the action record.
        """
        result = {}
        for action_type, all_actions in self._get_bindings(model_name).items():
            actions = []
            for action in all_actions:
                action = dict(action)
                groups = action.pop('groups_id', None)
                if groups and not self.user_has_groups(groups):
                    # the user may not perform this action
                    continue
                res_model = action.pop('res_model', None)
                if res_model and not self.env['ir.model.access'].check(
                    res_model,
                    mode='read',
                    raise_exception=False
                ):
                    # the user won't be able to read records
                    continue
                actions.append(action)
            if actions:
                result[action_type] = actions
        return result

    @tools.ormcache('model_name', 'self.env.lang')
    def _get_bindings(self, model_name):
        cr = self.env.cr

        # discard unauthorized actions, and read action definitions
        result = defaultdict(list)

        self.env.flush_all()
        cr.execute("""
            SELECT a.id, a.type, a.binding_type
              FROM ir_actions a
              JOIN ir_model m ON a.binding_model_id = m.id
             WHERE m.model = %s
          ORDER BY a.id
        """, [model_name])
        for action_id, action_model, binding_type in cr.fetchall():
            try:
                action = self.env[action_model].sudo().browse(action_id)
                fields = ['name', 'binding_view_types']
                for field in ('groups_id', 'res_model', 'sequence'):
                    if field in action._fields:
                        fields.append(field)
                action = action.read(fields)[0]
                if action.get('groups_id'):
                    groups = self.env['res.groups'].browse(action['groups_id'])
                    action['groups_id'] = ','.join(ext_id for ext_id in groups._ensure_xml_id().values())
                result[binding_type].append(frozendict(action))
            except (MissingError):
                continue

        # sort actions by their sequence if sequence available
        if result.get('action'):
            result['action'] = tuple(sorted(result['action'], key=lambda vals: vals.get('sequence', 0)))
        return frozendict(result)

    @api.model
    def _for_xml_id(self, full_xml_id):
        """ Returns the action content for the provided xml_id

        :param xml_id: the namespace-less id of the action (the @id
                       attribute from the XML file)
        :return: A read() view of the ir.actions.action safe for web use
        """
        record = self.env.ref(full_xml_id)
        assert isinstance(self.env[record._name], self.env.registry[self._name])
        return record._get_action_dict()

    def _get_action_dict(self):
        """ Returns the action content for the provided action record.
        """
        self.ensure_one()
        readable_fields = self._get_readable_fields()
        return {
            field: value
            for field, value in self.sudo().read()[0].items()
            if field in readable_fields
        }

    def _get_readable_fields(self):
        """ return the list of fields that are safe to read

        Fetched via /web/action/load or _for_xml_id method
        Only fields used by the web client should included
        Accessing content useful for the server-side must
        be done manually with superuser
        """
        return {
            "binding_model_id", "binding_type", "binding_view_types",
            "display_name", "help", "id", "name", "type", "xml_id",
        }


class IrActionsActWindow(models.Model):
    _name = 'ir.actions.act_window'
    _description = 'Action Window'
    _table = 'ir_act_window'
    _inherit = 'ir.actions.actions'
    _order = 'name'
    _allow_sudo_commands = False

    @api.constrains('res_model', 'binding_model_id')
    def _check_model(self):
        for action in self:
            if action.res_model not in self.env:
                raise ValidationError(_('Invalid model name %r in action definition.', action.res_model))
            if action.binding_model_id and action.binding_model_id.model not in self.env:
                raise ValidationError(_('Invalid model name %r in action definition.', action.binding_model_id.model))

    @api.depends('view_ids.view_mode', 'view_mode', 'view_id.type')
    def _compute_views(self):
        """ Compute an ordered list of the specific view modes that should be
            enabled when displaying the result of this action, along with the
            ID of the specific view to use for each mode, if any were required.

            This function hides the logic of determining the precedence between
            the view_modes string, the view_ids o2m, and the view_id m2o that
            can be set on the action.
        """
        for act in self:
            act.views = [(view.view_id.id, view.view_mode) for view in act.view_ids]
            got_modes = [view.view_mode for view in act.view_ids]
            all_modes = act.view_mode.split(',')
            missing_modes = [mode for mode in all_modes if mode not in got_modes]
            if missing_modes:
                if act.view_id.type in missing_modes:
                    # reorder missing modes to put view_id first if present
                    missing_modes.remove(act.view_id.type)
                    act.views.append((act.view_id.id, act.view_id.type))
                act.views.extend([(False, mode) for mode in missing_modes])

    @api.constrains('view_mode')
    def _check_view_mode(self):
        for rec in self:
            modes = rec.view_mode.split(',')
            if len(modes) != len(set(modes)):
                raise ValidationError(_('The modes in view_mode must not be duplicated: %s', modes))
            if ' ' in modes:
                raise ValidationError(_('No spaces allowed in view_mode: %r', modes))

    type = fields.Char(default="ir.actions.act_window")
    view_id = fields.Many2one('ir.ui.view', string='View Ref.', ondelete='set null')
    domain = fields.Char(string='Domain Value',
                         help="Optional domain filtering of the destination data, as a Python expression")
    context = fields.Char(string='Context Value', default={}, required=True,
                          help="Context dictionary as Python expression, empty by default (Default: {})")
    res_id = fields.Integer(string='Record ID', help="Database ID of record to open in form view, when ``view_mode`` is set to 'form' only")
    res_model = fields.Char(string='Destination Model', required=True,
                            help="Model name of the object to open in the view window")
    target = fields.Selection([('current', 'Current Window'), ('new', 'New Window'), ('inline', 'Inline Edit'), ('fullscreen', 'Full Screen'), ('main', 'Main action of Current Window')], default="current", string='Target Window')
    view_mode = fields.Char(required=True, default='tree,form',
                            help="Comma-separated list of allowed view modes, such as 'form', 'tree', 'calendar', etc. (Default: tree,form)")
    mobile_view_mode = fields.Char(default="kanban", help="First view mode in mobile and small screen environments (default='kanban'). If it can't be found among available view modes, the same mode as for wider screens is used)")
    usage = fields.Char(string='Action Usage',
                        help="Used to filter menu and home actions from the user form.")
    view_ids = fields.One2many('ir.actions.act_window.view', 'act_window_id', string='No of Views')
    views = fields.Binary(compute='_compute_views',
                          help="This function field computes the ordered list of views that should be enabled " \
                               "when displaying the result of an action, federating view mode, views and " \
                               "reference view. The result is returned as an ordered list of pairs (view_id,view_mode).")
    limit = fields.Integer(default=80, help='Default limit for the list view')
    groups_id = fields.Many2many('res.groups', 'ir_act_window_group_rel',
                                 'act_id', 'gid', string='Groups')
    search_view_id = fields.Many2one('ir.ui.view', string='Search View Ref.')
    filter = fields.Boolean()

    def read(self, fields=None, load='_classic_read'):
        """ call the method get_empty_list_help of the model and set the window action help message
        """
        result = super(IrActionsActWindow, self).read(fields, load=load)
        if not fields or 'help' in fields:
            for values in result:
                model = values.get('res_model')
                if model in self.env:
                    eval_ctx = dict(self.env.context)
                    try:
                        ctx = safe_eval(values.get('context', '{}'), eval_ctx)
                    except:
                        ctx = {}
                    values['help'] = self.with_context(**ctx).env[model].get_empty_list_help(values.get('help', ''))
        return result

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache()
        for vals in vals_list:
            if not vals.get('name') and vals.get('res_model'):
                vals['name'] = self.env[vals['res_model']]._description
        return super(IrActionsActWindow, self).create(vals_list)

    def unlink(self):
        self.env.registry.clear_cache()
        return super(IrActionsActWindow, self).unlink()

    def exists(self):
        ids = self._existing()
        existing = self.filtered(lambda rec: rec.id in ids)
        return existing

    @api.model
    @tools.ormcache()
    def _existing(self):
        self._cr.execute("SELECT id FROM %s" % self._table)
        return set(row[0] for row in self._cr.fetchall())


    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            "context", "mobile_view_mode", "domain", "filter", "groups_id", "limit",
            "res_id", "res_model", "search_view_id", "target", "view_id", "view_mode", "views",
            # `flags` is not a real field of ir.actions.act_window but is used
            # to give the parameters to generate the action
            "flags"
        }


VIEW_TYPES = [
    ('tree', 'Tree'),
    ('form', 'Form'),
    ('graph', 'Graph'),
    ('pivot', 'Pivot'),
    ('calendar', 'Calendar'),
    ('gantt', 'Gantt'),
    ('kanban', 'Kanban'),
]


class IrActionsActWindowView(models.Model):
    _name = 'ir.actions.act_window.view'
    _description = 'Action Window View'
    _table = 'ir_act_window_view'
    _rec_name = 'view_id'
    _order = 'sequence,id'
    _allow_sudo_commands = False

    sequence = fields.Integer()
    view_id = fields.Many2one('ir.ui.view', string='View')
    view_mode = fields.Selection(VIEW_TYPES, string='View Type', required=True)
    act_window_id = fields.Many2one('ir.actions.act_window', string='Action', ondelete='cascade')
    multi = fields.Boolean(string='On Multiple Doc.', help="If set to true, the action will not be displayed on the right toolbar of a form view.")

    def _auto_init(self):
        res = super(IrActionsActWindowView, self)._auto_init()
        tools.create_unique_index(self._cr, 'act_window_view_unique_mode_per_action',
                                  self._table, ['act_window_id', 'view_mode'])
        return res


class IrActionsActWindowclose(models.Model):
    _name = 'ir.actions.act_window_close'
    _description = 'Action Window Close'
    _inherit = 'ir.actions.actions'
    _table = 'ir_actions'
    _allow_sudo_commands = False

    type = fields.Char(default='ir.actions.act_window_close')

    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            # 'effect' and 'infos' are not real fields of `ir.actions.act_window_close` but they are
            # used to display the rainbowman ('effect') and waited by the action_service ('infos').
            "effect", "infos"
        }


class IrActionsActUrl(models.Model):
    _name = 'ir.actions.act_url'
    _description = 'Action URL'
    _table = 'ir_act_url'
    _inherit = 'ir.actions.actions'
    _order = 'name'
    _allow_sudo_commands = False

    type = fields.Char(default='ir.actions.act_url')
    url = fields.Text(string='Action URL', required=True)
    target = fields.Selection([('new', 'New Window'), ('self', 'This Window'), ('download', 'Download')],
                              string='Action Target', default='new', required=True)

    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            "target", "url", "close",
        }

WEBHOOK_SAMPLE_VALUES = {
    "integer": 42,
    "float": 42.42,
    "monetary": 42.42,
    "char": "Hello World",
    "text": "Hello World",
    "html": "<p>Hello World</p>",
    "boolean": True,
    "selection": "option1",
    "date": "2020-01-01",
    "datetime": "2020-01-01 00:00:00",
    "binary": "<base64_data>",
    "many2one": 47,
    "many2many": [42, 47],
    "one2many": [42, 47],
    "reference": "res.partner,42",
    None: "some_data",
}


class IrActionsServer(models.Model):
    """ Server actions model. Server action work on a base model and offer various
    type of actions that can be executed automatically, for example using base
    action rules, of manually, by adding the action in the 'More' contextual
    menu.

    Since Odoo 8.0 a button 'Create Menu Action' button is available on the
    action form view. It creates an entry in the More menu of the base model.
    This allows to create server actions and run them in mass mode easily through
    the interface.

    The available actions are :

    - 'Execute Python Code': a block of python code that will be executed
    - 'Create a new Record': create a new record with new values
    - 'Write on a Record': update the values of a record
    - 'Execute several actions': define an action that triggers several other
      server actions
    """
    _name = 'ir.actions.server'
    _description = 'Server Actions'
    _table = 'ir_act_server'
    _inherit = 'ir.actions.actions'
    _order = 'sequence,name'
    _allow_sudo_commands = False

    DEFAULT_PYTHON_CODE = """# Available variables:
#  - env: environment on which the action is triggered
#  - model: model of the record on which the action is triggered; is a void recordset
#  - record: record on which the action is triggered; may be void
#  - records: recordset of all records on which the action is triggered in multi-mode; may be void
#  - time, datetime, dateutil, timezone: useful Python libraries
#  - float_compare: utility function to compare floats based on specific precision
#  - log: log(message, level='info'): logging function to record debug information in ir.logging table
#  - _logger: _logger.info(message): logger to emit messages in server logs
#  - UserError: exception class for raising user-facing warning messages
#  - Command: x2many commands namespace
# To return an action, assign: action = {...}\n\n\n\n"""

    @api.model
    def _default_update_path(self):
        if not self.env.context.get('default_model_id'):
            return ''
        ir_model = self.env['ir.model'].browse(self.env.context['default_model_id'])
        model = self.env[ir_model.model]
        sensible_default_fields = ['partner_id', 'user_id', 'user_ids', 'stage_id', 'state', 'active']
        for field_name in sensible_default_fields:
            if field_name in model._fields and not model._fields[field_name].readonly:
                return field_name
        return ''

    name = fields.Char(required=True)
    type = fields.Char(default='ir.actions.server')
    usage = fields.Selection([
        ('ir_actions_server', 'Server Action'),
        ('ir_cron', 'Scheduled Action')], string='Usage',
        default='ir_actions_server', required=True)
    state = fields.Selection([
        ('object_write', 'Update Record'),
        ('object_create', 'Create Record'),
        ('code', 'Execute Code'),
        ('webhook', 'Send Webhook Notification'),
        ('multi', 'Execute Existing Actions')], string='Type',
        default='object_write', required=True, copy=True,
        help="Type of server action. The following values are available:\n"
             "- 'Update a Record': update the values of a record\n"
             "- 'Create Activity': create an activity (Discuss)\n"
             "- 'Send Email': post a message, a note or send an email (Discuss)\n"
             "- 'Send SMS': send SMS, log them on documents (SMS)"
             "- 'Add/Remove Followers': add or remove followers to a record (Discuss)\n"
             "- 'Create Record': create a new record with new values\n"
             "- 'Execute Code': a block of Python code that will be executed\n"
             "- 'Send Webhook Notification': send a POST request to an external system, also known as a Webhook\n"
             "- 'Execute Existing Actions': define an action that triggers several other server actions\n")
    # Generic
    sequence = fields.Integer(default=5,
                              help="When dealing with multiple actions, the execution order is "
                                   "based on the sequence. Low number means high priority.")
    model_id = fields.Many2one('ir.model', string='Model', required=True, ondelete='cascade', index=True,
                               help="Model on which the server action runs.")
    available_model_ids = fields.Many2many('ir.model', string='Available Models', compute='_compute_available_model_ids', store=False)
    model_name = fields.Char(related='model_id.model', string='Model Name', readonly=True, store=True)
    # Python code
    code = fields.Text(string='Python Code', groups='base.group_system',
                       default=DEFAULT_PYTHON_CODE,
                       help="Write Python code that the action will execute. Some variables are "
                            "available for use; help about python expression is given in the help tab.")
    # Multi
    child_ids = fields.Many2many('ir.actions.server', 'rel_server_actions', 'server_id', 'action_id',
                                 string='Child Actions', help='Child server actions that will be executed. Note that the last return returned action value will be used as global return value.')
    # Create
    crud_model_id = fields.Many2one(
        'ir.model', string='Record to Create',
        compute='_compute_crud_relations', readonly=False, store=True,
        help="Specify which kind of record should be created. Set this field only to specify a different model than the base model.")
    crud_model_name = fields.Char(related='crud_model_id.model', string='Target Model Name', readonly=True)
    link_field_id = fields.Many2one(
        'ir.model.fields', string='Link Field',
        compute='_compute_link_field_id', readonly=False, store=True,
        help="Specify a field used to link the newly created record on the record used by the server action.")
    groups_id = fields.Many2many('res.groups', 'ir_act_server_group_rel',
                                 'act_id', 'gid', string='Allowed Groups', help='Groups that can execute the server action. Leave empty to allow everybody.')

    update_field_id = fields.Many2one('ir.model.fields', string='Field to Update', ondelete='cascade', compute='_compute_crud_relations', store=True, readonly=False)
    update_path = fields.Char(string='Field to Update Path', help="Path to the field to update, e.g. 'partner_id.name'", default=_default_update_path)
    update_related_model_id = fields.Many2one('ir.model', compute='_compute_crud_relations', store=True)
    update_field_type = fields.Selection(related='update_field_id.ttype', readonly=True)
    update_m2m_operation = fields.Selection([
        ('add', 'Adding'),
        ('remove', 'Removing'),
        ('set', 'Setting it to'),
        ('clear', 'Clearing it')
    ], string='Many2many Operations', default='add')
    update_boolean_value = fields.Selection([('true', 'Yes (True)'), ('false', "No (False)")], string='Boolean Value', default='true')

    value = fields.Text(help="For Python expressions, this field may hold a Python expression "
                             "that can use the same values as for the code field on the server action,"
                             "e.g. `env.user.name` to set the current user's name as the value "
                             "or `record.id` to set the ID of the record on which the action is run.\n\n"
                             "For Static values, the value will be used directly without evaluation, e.g."
                             "`42` or `My custom name` or the selected record.")
    evaluation_type = fields.Selection([
        ('value', 'Update'),
        ('equation', 'Compute')
    ], 'Value Type', default='value', change_default=True)
    resource_ref = fields.Reference(
        string='Record', selection='_selection_target_model', inverse='_set_resource_ref')
    selection_value = fields.Many2one('ir.model.fields.selection', string="Custom Value", ondelete='cascade',
                                      domain='[("field_id", "=", update_field_id)]', inverse='_set_selection_value')

    value_field_to_show = fields.Selection([
        ('value', 'value'),
        ('resource_ref', 'reference'),
        ('update_boolean_value', 'update_boolean_value'),
        ('selection_value', 'selection_value'),
    ], compute='_compute_value_field_to_show')
    # Webhook
    webhook_url = fields.Char(string='Webhook URL', help="URL to send the POST request to.")
    webhook_field_ids = fields.Many2many('ir.model.fields', 'ir_act_server_webhook_field_rel', 'server_id', 'field_id',
                                         string='Webhook Fields',
                                         help="Fields to send in the POST request. "
                                              "The id and model of the record are always sent as '_id' and '_model'. "
                                              "The name of the action that triggered the webhook is always sent as '_name'.")
    webhook_sample_payload = fields.Text(string='Sample Payload', compute='_compute_webhook_sample_payload')

    @api.constrains('webhook_field_ids')
    def _check_webhook_field_ids(self):
        """Check that the selected fields don't have group restrictions"""
        restricted_fields = dict()
        for action in self:
            Model = self.env[action.model_id.model]
            for model_field in action.webhook_field_ids:
                # you might think that the ir.model.field record holds references
                # to the groups, but that's not the case - we need to field object itself
                field = Model._fields[model_field.name]
                if field.groups:
                    restricted_fields.setdefault(action.name, []).append(model_field.field_description)
        if restricted_fields:
            restricted_field_per_action = "\n".join([f"{action}: {', '.join(f for f in fields)}" for action, fields in restricted_fields.items()])
            raise ValidationError(_("Group-restricted fields cannot be included in "
                                    "webhook payloads, as it could allow any user to "
                                    "accidentally leak sensitive information. You will "
                                    "have to remove the following fields from the webhook payload "
                                    "in the following actions:\n %s", restricted_field_per_action))

    @api.depends('state')
    def _compute_available_model_ids(self):
        allowed_models = self.env['ir.model'].search(
            [('model', 'in', list(self.env['ir.model.access']._get_allowed_models()))]
        )
        self.available_model_ids = allowed_models.ids

    @api.depends('model_id', 'update_path', 'state')
    def _compute_crud_relations(self):
        """ Compute the crud_model_id and update_field_id fields.

        The crud_model_id is the model on which the action will create or update
        records. In the case of record creation, it is the same as the main model
        of the action. For record update, it will be the model linked to the last
        field in the update_path.
        This is only used for object_create and object_write actions.
        The update_field_id is the field at the end of the update_path that will
        be updated by the action - only used for object_write actions.
        """
        for action in self:
            if action.model_id and action.state in ('object_write', 'object_create'):
                if action.state == 'object_create':
                    action.crud_model_id = action.model_id
                    action.update_field_id = False
                    action.update_path = False
                elif action.state == 'object_write':
                    if action.update_path:
                        # we need to traverse relations to find the target model and field
                        model, field, _ = action._traverse_path()
                        action.crud_model_id = model
                        action.update_field_id = field
                        need_update_model = action.evaluation_type == 'value' and action.update_field_id and action.update_field_id.relation
                        action.update_related_model_id = action.env["ir.model"]._get_id(field.relation) if need_update_model else False
                    else:
                        action.crud_model_id = action.model_id
                        action.update_field_id = False
            else:
                action.crud_model_id = False
                action.update_field_id = False
                action.update_path = False

    def _traverse_path(self, record=None):
        """ Traverse the update_path to find the target model and field, and optionally
        the target record of an action of type 'object_write'.

        :param record: optional record to use as starting point for the path traversal
        :return: a tuple (model, field, records) where model is the target model and field is the
                 target field; if no record was provided, records is None, otherwise it is the
                    recordset at the end of the path starting from the provided record
        """
        self.ensure_one()
        path = self.update_path.split('.')
        Model = self.env[self.model_id.model]
        # sanity check: we're starting from a record that belongs to the model
        if record and record._name != Model._name:
            raise ValidationError(_("I have no idea how you *did that*, but you're trying to use a gibberish configuration: the model of the record on which the action is triggered is not the same as the model of the action."))
        for field_name in path:
            is_last_field = field_name == path[-1]
            field = Model._fields[field_name]
            if field.relational and not is_last_field:
                Model = self.env[field.comodel_name]
            elif not field.relational:
                # sanity check: this should be the last field in the path
                if not is_last_field:
                    raise ValidationError(_("The path to the field to update contains a non-relational field (%s) that is not the last field in the path. You can't traverse non-relational fields (even in the quantum realm). Make sure only the last field in the path is non-relational.", field_name))
                if isinstance(field, fields.Json):
                    raise ValidationError(_("I'm sorry to say that JSON fields (such as %s) are currently not supported.", field_name))
        target_records = None
        if record is not None:
            target_records = reduce(getitem, path[:-1], record)
        model_id = self.env['ir.model']._get(Model._name)
        field_id = self.env['ir.model.fields']._get(Model._name, field_name)
        return model_id, field_id, target_records

    def _stringify_path(self):
        """ Returns a string representation of the update_path, with the field names
        separated by the `>` symbol."""
        self.ensure_one()
        path = self.update_path
        if not path:
            return ''
        model = self.env[self.model_id.model]
        pretty_path = []
        for field_name in path.split('.'):
            field = model._fields[field_name]
            field_id = self.env['ir.model.fields']._get(model._name, field_name)
            if field.relational:
                model = self.env[field.comodel_name]
            pretty_path.append(field_id.field_description)
        return ' > '.join(pretty_path)

    @api.depends('state', 'model_id', 'webhook_field_ids', 'name')
    def _compute_webhook_sample_payload(self):
        for action in self:
            if action.state != 'webhook':
                action.webhook_sample_payload = False
                continue
            payload = {
                'id': 1,
                '_model': self.model_id.model,
                '_name': action.name,
            }
            if self.model_id:
                sample_record = self.env[self.model_id.model].with_context(active_test=False).search([], limit=1)
                for field in action.webhook_field_ids:
                    if sample_record:
                        payload['id'] = sample_record.id
                        payload.update(sample_record.read(self.webhook_field_ids.mapped('name'), load=None)[0])
                    else:
                        payload[field.name] = WEBHOOK_SAMPLE_VALUES[field.ttype] if field.ttype in WEBHOOK_SAMPLE_VALUES else WEBHOOK_SAMPLE_VALUES[None]
            action.webhook_sample_payload = json.dumps(payload, indent=4, sort_keys=True, default=str)

    @api.depends('model_id')
    def _compute_link_field_id(self):
        invalid = self.filtered(lambda act: act.link_field_id.model_id != act.model_id)
        if invalid:
            invalid.link_field_id = False

    @api.constrains('code')
    def _check_python_code(self):
        for action in self.sudo().filtered('code'):
            msg = test_python_expr(expr=action.code.strip(), mode="exec")
            if msg:
                raise ValidationError(msg)

    @api.constrains('child_ids')
    def _check_recursion(self):
        if not self._check_m2m_recursion('child_ids'):
            raise ValidationError(_('Recursion found in child server actions'))

    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            "groups_id", "model_name",
        }

    def _get_runner(self):
        multi = True
        t = self.env.registry[self._name]
        fn = getattr(t, f'_run_action_{self.state}_multi', None)\
          or getattr(t, f'run_action_{self.state}_multi', None)
        if not fn:
            multi = False
            fn = getattr(t, f'_run_action_{self.state}', None)\
              or getattr(t, f'run_action_{self.state}', None)
        if fn and fn.__name__.startswith('run_action_'):
            fn = partial(fn, self)
        return fn, multi

    def _register_hook(self):
        super()._register_hook()

        for cls in self.env.registry[self._name].mro():
            for symbol in vars(cls).keys():
                if symbol.startswith('run_action_'):
                    _logger.warning(
                        "RPC-public action methods are deprecated, found %r (in class %s.%s)",
                        symbol, cls.__module__, cls.__name__
                    )

    def create_action(self):
        """ Create a contextual action for each server action. """
        for action in self:
            action.write({'binding_model_id': action.model_id.id,
                          'binding_type': 'action'})
        return True

    def unlink_action(self):
        """ Remove the contextual actions created for the server actions. """
        self.check_access_rights('write', raise_exception=True)
        self.filtered('binding_model_id').write({'binding_model_id': False})
        return True

    def _run_action_code_multi(self, eval_context):
        safe_eval(self.code.strip(), eval_context, mode="exec", nocopy=True, filename=str(self))  # nocopy allows to return 'action'
        return eval_context.get('action')

    def _run_action_multi(self, eval_context=None):
        res = False
        for act in self.child_ids.sorted():
            res = act.run() or res
        return res

    def _run_action_object_write(self, eval_context=None):
        """Apply specified write changes to active_id."""
        vals = self._eval_value(eval_context=eval_context)
        res = {action.update_field_id.name: vals[action.id] for action in self}

        if self._context.get('onchange_self'):
            record_cached = self._context['onchange_self']
            for field, new_value in res.items():
                record_cached[field] = new_value
        else:
            starting_record = self.env[self.model_id.model].browse(self._context.get('active_id'))
            _, _, target_records = self._traverse_path(record=starting_record)
            target_records.write(res)

    def _run_action_webhook(self, eval_context=None):
        """Send a post request with a read of the selected field on active_id."""
        record = self.env[self.model_id.model].browse(self._context.get('active_id'))
        url = self.webhook_url
        if not record:
            return
        if not url:
            raise UserError(_("I'll be happy to send a webhook for you, but you really need to give me a URL to reach out to..."))
        vals = {
            '_model': self.model_id.model,
            '_id': record.id,
            '_action': f'{self.name}(#{self.id})',
        }
        if self.webhook_field_ids:
            # you might think we could use the default json serializer of the requests library
            # but it will fail on many fields, e.g. datetime, date or binary
            # so we use the json.dumps serializer instead with the str() function as default
            vals.update(record.read(self.webhook_field_ids.mapped('name'), load=None)[0])
        json_values = json.dumps(vals, sort_keys=True, default=str)
        _logger.info("Webhook call to %s", url)
        _logger.debug("POST JSON data for webhook call: %s", json_values)
        try:
            # 'send and forget' strategy, and avoid locking the user if the webhook
            # is slow or non-functional (we still allow for a 1s timeout so that
            # if we get a proper error response code like 400, 404 or 500 we can log)
            response = requests.post(url, data=json_values, headers={'Content-Type': 'application/json'}, timeout=1)
            response.raise_for_status()
        except requests.exceptions.ReadTimeout:
            _logger.warning("Webhook call timed out after 1s - it may or may not have failed. "
                            "If this happens often, it may be a sign that the system you're "
                            "trying to reach is slow or non-functional.")
        except requests.exceptions.RequestException as e:
            _logger.warning("Webhook call failed: %s", e)
        except Exception as e:  # noqa: BLE001
            raise UserError(_("Wow, your webhook call failed with a really unusual error: %s", e)) from e

    def _run_action_object_create(self, eval_context=None):
        """Create specified model object with specified name contained in value.

        If applicable, link active_id.<self.link_field_id> to the new record.
        """
        res = {'name': self.value}

        res = self.env[self.crud_model_id.model].create(res)

        if self.link_field_id:
            record = self.env[self.model_id.model].browse(self._context.get('active_id'))
            if self.link_field_id.ttype in ['one2many', 'many2many']:
                record.write({self.link_field_id.name: [Command.link(res.id)]})
            else:
                record.write({self.link_field_id.name: res.id})

    def _get_eval_context(self, action=None):
        """ Prepare the context used when evaluating python code, like the
        python formulas or code server actions.

        :param action: the current server action
        :type action: browse record
        :returns: dict -- evaluation context given to (safe_)safe_eval """
        def log(message, level="info"):
            with self.pool.cursor() as cr:
                cr.execute("""
                    INSERT INTO ir_logging(create_date, create_uid, type, dbname, name, level, message, path, line, func)
                    VALUES (NOW() at time zone 'UTC', %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (self.env.uid, 'server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))

        eval_context = super(IrActionsServer, self)._get_eval_context(action=action)
        model_name = action.model_id.sudo().model
        model = self.env[model_name]
        record = None
        records = None
        if self._context.get('active_model') == model_name and self._context.get('active_id'):
            record = model.browse(self._context['active_id'])
        if self._context.get('active_model') == model_name and self._context.get('active_ids'):
            records = model.browse(self._context['active_ids'])
        if self._context.get('onchange_self'):
            record = self._context['onchange_self']
        eval_context.update({
            # orm
            'env': self.env,
            'model': model,
            # Exceptions
            'UserError': odoo.exceptions.UserError,
            # record
            'record': record,
            'records': records,
            # helpers
            'log': log,
            '_logger': LoggerProxy,
        })
        return eval_context

    def run(self):
        """ Runs the server action. For each server action, the
        :samp:`_run_action_{TYPE}[_multi]` method is called. This allows easy
        overriding of the server actions.

        The ``_multi`` suffix means the runner can operate on multiple records,
        otherwise if there are multiple records the runner will be called once
        for each.

        The call context should contain the following keys:

        active_id
            id of the current object (single mode)
        active_model
            current model that should equal the action's model
        active_ids (optional)
           ids of the current records (mass mode). If ``active_ids`` and
           ``active_id`` are present, ``active_ids`` is given precedence.
        :return: an ``action_id`` to be executed, or ``False`` is finished
                 correctly without return action
        """
        res = False
        for action in self.sudo():
            action_groups = action.groups_id
            if action_groups:
                if not (action_groups & self.env.user.groups_id):
                    raise AccessError(_("You don't have enough access rights to run this action."))
            else:
                model_name = action.model_id.model
                try:
                    self.env[model_name].check_access_rights("write")
                except AccessError:
                    _logger.warning("Forbidden server action %r executed while the user %s does not have access to %s.",
                        action.name, self.env.user.login, model_name,
                    )
                    raise

            eval_context = self._get_eval_context(action)
            records = eval_context.get('record') or eval_context['model']
            records |= eval_context.get('records') or eval_context['model']
            if records.ids:
                # check access rules on real records only; base automations of
                # type 'onchange' can run server actions on new records
                try:
                    records.check_access_rule('write')
                except AccessError:
                    _logger.warning("Forbidden server action %r executed while the user %s does not have access to %s.",
                        action.name, self.env.user.login, records,
                    )
                    raise

            runner, multi = action._get_runner()
            if runner and multi:
                # call the multi method
                run_self = action.with_context(eval_context['env'].context)
                res = runner(run_self, eval_context=eval_context)
            elif runner:
                active_id = self._context.get('active_id')
                if not active_id and self._context.get('onchange_self'):
                    active_id = self._context['onchange_self']._origin.id
                    if not active_id:  # onchange on new record
                        res = runner(action, eval_context=eval_context)
                active_ids = self._context.get('active_ids', [active_id] if active_id else [])
                for active_id in active_ids:
                    # run context dedicated to a particular active_id
                    run_self = action.with_context(active_ids=[active_id], active_id=active_id)
                    eval_context["env"].context = run_self._context
                    res = runner(run_self, eval_context=eval_context)
            else:
                _logger.warning(
                    "Found no way to execute server action %r of type %r, ignoring it. "
                    "Verify that the type is correct or add a method called "
                    "`_run_action_<type>` or `_run_action_<type>_multi`.",
                    action.name, action.state
                )
        return res or False

    @api.depends('evaluation_type', 'update_field_id')
    def _compute_value_field_to_show(self):  # check if value_field_to_show can be removed and use ttype in xml view instead
        for action in self:
            if action.update_field_id.ttype in ('many2one', 'many2many'):
                action.value_field_to_show = 'resource_ref'
            elif action.update_field_id.ttype == 'selection':
                action.value_field_to_show = 'selection_value'
            elif action.update_field_id.ttype == 'boolean':
                action.value_field_to_show = 'update_boolean_value'
            else:
                action.value_field_to_show = 'value'

    @api.model
    def _selection_target_model(self):
        return [(model.model, model.name) for model in self.env['ir.model'].sudo().search([])]

    @api.constrains('update_field_id', 'evaluation_type')
    def _raise_many2many_error(self):
        if self.filtered(lambda line: line.update_field_id.ttype == 'many2many' and line.evaluation_type == 'reference'):
            raise ValidationError(_('many2many fields cannot be evaluated by reference'))

    @api.onchange('resource_ref')
    def _set_resource_ref(self):
        for action in self.filtered(lambda action: action.value_field_to_show == 'resource_ref'):
            if action.resource_ref:
                action.value = str(action.resource_ref.id)

    @api.onchange('selection_value')
    def _set_selection_value(self):
        for action in self.filtered(lambda action: action.value_field_to_show == 'selection_value'):
            if action.selection_value:
                action.value = action.selection_value.value

    def _eval_value(self, eval_context=None):
        result = {}
        for action in self:
            expr = action.value
            if action.evaluation_type == 'equation':
                expr = safe_eval(action.value, eval_context)
            elif action.update_field_id.ttype == 'many2many':
                operation = action.update_m2m_operation
                if operation == 'add':
                    expr = [Command.link(int(action.value))]
                elif operation == 'remove':
                    expr = [Command.unlink(int(action.value))]
                elif operation == 'set':
                    expr = [Command.set([int(action.value)])]
                elif operation == 'clear':
                    expr = [Command.clear()]
            elif action.update_field_id.ttype == 'boolean':
                expr = action.update_boolean_value == 'true'
            elif action.update_field_id.ttype in ['many2one', 'integer']:
                try:
                    expr = int(action.value)
                except Exception:
                    pass
            elif action.update_field_id.ttype == 'float':
                with contextlib.suppress(Exception):
                    expr = float(action.value)
            result[action.id] = expr
        return result

class IrActionsTodo(models.Model):
    """
    Configuration Wizards
    """
    _name = 'ir.actions.todo'
    _description = "Configuration Wizards"
    _rec_name = 'action_id'
    _order = "sequence, id"
    _allow_sudo_commands = False

    action_id = fields.Many2one('ir.actions.actions', string='Action', required=True, index=True)
    sequence = fields.Integer(default=10)
    state = fields.Selection([('open', 'To Do'), ('done', 'Done')], string='Status', default='open', required=True)
    name = fields.Char()

    @api.model_create_multi
    def create(self, vals_list):
        todos = super(IrActionsTodo, self).create(vals_list)
        for todo in todos:
            if todo.state == "open":
                self.ensure_one_open_todo()
        return todos

    def write(self, vals):
        res = super(IrActionsTodo, self).write(vals)
        if vals.get('state', '') == 'open':
            self.ensure_one_open_todo()
        return res

    @api.model
    def ensure_one_open_todo(self):
        open_todo = self.search([('state', '=', 'open')], order='sequence asc, id desc', offset=1)
        if open_todo:
            open_todo.write({'state': 'done'})

    def unlink(self):
        if self:
            try:
                todo_open_menu = self.env.ref('base.open_menu')
                # don't remove base.open_menu todo but set its original action
                if todo_open_menu in self:
                    todo_open_menu.action_id = self.env.ref('base.action_client_base_menu').id
                    self -= todo_open_menu
            except ValueError:
                pass
        return super(IrActionsTodo, self).unlink()

    def action_launch(self):
        """ Launch Action of Wizard"""
        self.ensure_one()

        self.write({'state': 'done'})

        # Load action
        action_type = self.action_id.type
        action = self.env[action_type].browse(self.action_id.id)

        result = action.read()[0]
        if action_type != 'ir.actions.act_window':
            return result
        result.setdefault('context', '{}')

        # Open a specific record when res_id is provided in the context
        ctx = safe_eval(result['context'], {'user': self.env.user})
        if ctx.get('res_id'):
            result['res_id'] = ctx.pop('res_id')

        # disable log for automatic wizards
        ctx['disable_log'] = True

        result['context'] = ctx

        return result

    def action_open(self):
        """ Sets configuration wizard in TODO state"""
        return self.write({'state': 'open'})


class IrActionsActClient(models.Model):
    _name = 'ir.actions.client'
    _description = 'Client Action'
    _inherit = 'ir.actions.actions'
    _table = 'ir_act_client'
    _order = 'name'
    _allow_sudo_commands = False

    type = fields.Char(default='ir.actions.client')

    tag = fields.Char(string='Client action tag', required=True,
                      help="An arbitrary string, interpreted by the client"
                           " according to its own needs and wishes. There "
                           "is no central tag repository across clients.")
    target = fields.Selection([('current', 'Current Window'), ('new', 'New Window'), ('fullscreen', 'Full Screen'), ('main', 'Main action of Current Window')], default="current", string='Target Window')
    res_model = fields.Char(string='Destination Model', help="Optional model, mostly used for needactions.")
    context = fields.Char(string='Context Value', default="{}", required=True, help="Context dictionary as Python expression, empty by default (Default: {})")
    params = fields.Binary(compute='_compute_params', inverse='_inverse_params', string='Supplementary arguments',
                           help="Arguments sent to the client along with "
                                "the view tag")
    params_store = fields.Binary(string='Params storage', readonly=True, attachment=False)

    @api.depends('params_store')
    def _compute_params(self):
        self_bin = self.with_context(bin_size=False, bin_size_params_store=False)
        for record, record_bin in zip(self, self_bin):
            record.params = record_bin.params_store and safe_eval(record_bin.params_store, {'uid': self._uid})

    def _inverse_params(self):
        for record in self:
            params = record.params
            record.params_store = repr(params) if isinstance(params, dict) else params

    def _get_default_form_view(self):
        doc = super(IrActionsActClient, self)._get_default_form_view()
        params = doc.find(".//field[@name='params']")
        params.getparent().remove(params)
        params_store = doc.find(".//field[@name='params_store']")
        params_store.getparent().remove(params_store)
        return doc


    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            "context", "params", "res_model", "tag", "target",
        }

```

  File: models/ir_actions_report.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from markupsafe import Markup
from urllib.parse import urlparse

from odoo import api, fields, models, tools, SUPERUSER_ID, _
from odoo.exceptions import UserError, AccessError
from odoo.tools.safe_eval import safe_eval, time
from odoo.tools.misc import find_in_path, ustr
from odoo.tools import check_barcode_encoding, config, is_html_empty, parse_version, split_every
from odoo.http import request
from odoo.osv.expression import NEGATIVE_TERM_OPERATORS, FALSE_DOMAIN

import io
import logging
import os
import lxml.html
import tempfile
import subprocess
import re
import json

from lxml import etree
from contextlib import closing
from reportlab.graphics.barcode import createBarcodeDrawing
from PyPDF2 import PdfFileWriter, PdfFileReader
from collections import OrderedDict
from collections.abc import Iterable
from PIL import Image, ImageFile
from itertools import islice

# Allow truncated images
ImageFile.LOAD_TRUNCATED_IMAGES = True

try:
    from PyPDF2.errors import PdfReadError
except ImportError:
    from PyPDF2.utils import PdfReadError

_logger = logging.getLogger(__name__)

# A lock occurs when the user wants to print a report having multiple barcode while the server is
# started in threaded-mode. The reason is that reportlab has to build a cache of the T1 fonts
# before rendering a barcode (done in a C extension) and this part is not thread safe. We attempt
# here to init the T1 fonts cache at the start-up of Odoo so that rendering of barcode in multiple
# thread does not lock the server.
try:
    createBarcodeDrawing('Code128', value='foo', format='png', width=100, height=100, humanReadable=1).asString('png')
except Exception:
    pass


def _get_wkhtmltopdf_bin():
    return find_in_path('wkhtmltopdf')

def _split_table(tree, max_rows):
    """
    Walks through the etree and splits tables with more than max_rows rows into
    multiple tables with max_rows rows.

    This function is needed because wkhtmltopdf has a exponential processing
    time growth when processing tables with many rows. This function is a
    workaround for this problem.

    :param tree: The etree to process
    :param max_rows: The maximum number of rows per table
    """
    for table in list(tree.iter('table')):
        prev = table
        for rows in islice(split_every(max_rows, table), 1, None):
            sibling = etree.Element('table', attrib=table.attrib)
            sibling.extend(rows)
            prev.addnext(sibling)
            prev = sibling

# Check the presence of Wkhtmltopdf and return its version at Odoo start-up
wkhtmltopdf_state = 'install'
wkhtmltopdf_dpi_zoom_ratio = False
try:
    process = subprocess.Popen(
        [_get_wkhtmltopdf_bin(), '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
except (OSError, IOError):
    _logger.info('You need Wkhtmltopdf to print a pdf version of the reports.')
else:
    _logger.info('Will use the Wkhtmltopdf binary at %s' % _get_wkhtmltopdf_bin())
    out, err = process.communicate()
    match = re.search(b'([0-9.]+)', out)
    if match:
        version = match.group(0).decode('ascii')
        if parse_version(version) < parse_version('0.12.0'):
            _logger.info('Upgrade Wkhtmltopdf to (at least) 0.12.0')
            wkhtmltopdf_state = 'upgrade'
        else:
            wkhtmltopdf_state = 'ok'
        if parse_version(version) >= parse_version('0.12.2'):
            wkhtmltopdf_dpi_zoom_ratio = True

        if config['workers'] == 1:
            _logger.info('You need to start Odoo with at least two workers to print a pdf version of the reports.')
            wkhtmltopdf_state = 'workers'
    else:
        _logger.info('Wkhtmltopdf seems to be broken.')
        wkhtmltopdf_state = 'broken'


class IrActionsReport(models.Model):
    _name = 'ir.actions.report'
    _description = 'Report Action'
    _inherit = 'ir.actions.actions'
    _table = 'ir_act_report_xml'
    _order = 'name, id'
    _allow_sudo_commands = False

    type = fields.Char(default='ir.actions.report')
    binding_type = fields.Selection(default='report')
    model = fields.Char(required=True, string='Model Name')
    model_id = fields.Many2one('ir.model', string='Model', compute='_compute_model_id', search='_search_model_id')

    report_type = fields.Selection([
        ('qweb-html', 'HTML'),
        ('qweb-pdf', 'PDF'),
        ('qweb-text', 'Text'),
    ], required=True, default='qweb-pdf',
    help='The type of the report that will be rendered, each one having its own'
        ' rendering method. HTML means the report will be opened directly in your'
        ' browser PDF means the report will be rendered using Wkhtmltopdf and'
        ' downloaded by the user.')
    report_name = fields.Char(string='Template Name', required=True)
    report_file = fields.Char(string='Report File', required=False, readonly=False, store=True,
                              help="The path to the main report file (depending on Report Type) or empty if the content is in another field")
    groups_id = fields.Many2many('res.groups', 'res_groups_report_rel', 'uid', 'gid', string='Groups')
    multi = fields.Boolean(string='On Multiple Doc.', help="If set to true, the action will not be displayed on the right toolbar of a form view.")

    paperformat_id = fields.Many2one('report.paperformat', 'Paper Format')
    print_report_name = fields.Char('Printed Report Name', translate=True,
                                    help="This is the filename of the report going to download. Keep empty to not change the report filename. You can use a python expression with the 'object' and 'time' variables.")
    attachment_use = fields.Boolean(string='Reload from Attachment',
                                    help='If enabled, then the second time the user prints with same attachment name, it returns the previous report.')
    attachment = fields.Char(string='Save as Attachment Prefix',
                             help='This is the filename of the attachment used to store the printing result. Keep empty to not save the printed reports. You can use a python expression with the object and time variables.')

    @api.depends('model')
    def _compute_model_id(self):
        for action in self:
            action.model_id = self.env['ir.model']._get(action.model).id

    def _search_model_id(self, operator, value):
        ir_model_ids = None
        if isinstance(value, str):
            names = self.env['ir.model'].name_search(value, operator=operator)
            ir_model_ids = [n[0] for n in names]

        elif operator in ('any', 'not any'):
            ir_model_ids = self.env['ir.model']._search(value)

        elif isinstance(value, Iterable):
            ir_model_ids = value

        elif isinstance(value, int) and not isinstance(value, bool):
            ir_model_ids = [value]

        if ir_model_ids:
            operator = 'not in' if operator in NEGATIVE_TERM_OPERATORS else 'in'
            ir_model = self.env['ir.model'].browse(ir_model_ids)
            return [('model', operator, ir_model.mapped('model'))]
        elif isinstance(value, bool) or value is None:
            return [('model', operator, value)]
        else:
            return FALSE_DOMAIN

    def _get_readable_fields(self):
        return super()._get_readable_fields() | {
            "report_name", "report_type", "target",
            # these two are not real fields of ir.actions.report but are
            # expected in the route /report/<converter>/<reportname> and must
            # not be removed by clean_action
            "context", "data",
            # and this one is used by the frontend later on.
            "close_on_report_download",
        }

    def associated_view(self):
        """Used in the ir.actions.report form view in order to search naively after the view(s)
        used in the rendering.
        """
        self.ensure_one()
        action_ref = self.env.ref('base.action_ui_view')
        if not action_ref or len(self.report_name.split('.')) < 2:
            return False
        action_data = action_ref.read()[0]
        action_data['domain'] = [('name', 'ilike', self.report_name.split('.')[1]), ('type', '=', 'qweb')]
        return action_data

    def create_action(self):
        """ Create a contextual action for each report. """
        for report in self:
            model = self.env['ir.model']._get(report.model)
            report.write({'binding_model_id': model.id, 'binding_type': 'report'})
        return True

    def unlink_action(self):
        """ Remove the contextual actions created for the reports. """
        self.check_access_rights('write', raise_exception=True)
        self.filtered('binding_model_id').write({'binding_model_id': False})
        return True

    #--------------------------------------------------------------------------
    # Main report methods
    #--------------------------------------------------------------------------

    def retrieve_attachment(self, record):
        '''Retrieve an attachment for a specific record.

        :param record: The record owning of the attachment.
        :return: A recordset of length <=1 or None
        '''
        attachment_name = safe_eval(self.attachment, {'object': record, 'time': time}) if self.attachment else ''
        if not attachment_name:
            return None
        return self.env['ir.attachment'].search([
                ('name', '=', attachment_name),
                ('res_model', '=', self.model),
                ('res_id', '=', record.id)
        ], limit=1)

    @api.model
    def get_wkhtmltopdf_state(self):
        '''Get the current state of wkhtmltopdf: install, ok, upgrade, workers or broken.
        * install: Starting state.
        * upgrade: The binary is an older version (< 0.12.0).
        * ok: A binary was found with a recent version (>= 0.12.0).
        * workers: Not enough workers found to perform the pdf rendering process (< 2 workers).
        * broken: A binary was found but not responding.

        :return: wkhtmltopdf_state
        '''
        return wkhtmltopdf_state

    def get_paperformat(self):
        return self.paperformat_id or self.env.company.paperformat_id

    def _get_layout(self):
        return self.env.ref('web.minimal_layout', raise_if_not_found=False)

    def _get_report_url(self, layout=None):
        report_url = self.env['ir.config_parameter'].sudo().get_param('report.url')
        return report_url or (layout or self._get_layout() or self).get_base_url()

    @api.model
    def _build_wkhtmltopdf_args(
            self,
            paperformat_id,
            landscape,
            specific_paperformat_args=None,
            set_viewport_size=False):
        '''Build arguments understandable by wkhtmltopdf bin.

        :param paperformat_id: A report.paperformat record.
        :param landscape: Force the report orientation to be landscape.
        :param specific_paperformat_args: A dictionary containing prioritized wkhtmltopdf arguments.
        :param set_viewport_size: Enable a viewport sized '1024x1280' or '1280x1024' depending of landscape arg.
        :return: A list of string representing the wkhtmltopdf process command args.
        '''
        if landscape is None and specific_paperformat_args and specific_paperformat_args.get('data-report-landscape'):
            landscape = specific_paperformat_args.get('data-report-landscape')

        command_args = ['--disable-local-file-access']
        if set_viewport_size:
            command_args.extend(['--viewport-size', landscape and '1024x1280' or '1280x1024'])

        # Less verbose error messages
        command_args.extend(['--quiet'])

        # Build paperformat args
        if paperformat_id:
            if paperformat_id.format and paperformat_id.format != 'custom':
                command_args.extend(['--page-size', paperformat_id.format])

            if paperformat_id.page_height and paperformat_id.page_width and paperformat_id.format == 'custom':
                command_args.extend(['--page-width', str(paperformat_id.page_width) + 'mm'])
                command_args.extend(['--page-height', str(paperformat_id.page_height) + 'mm'])

            if specific_paperformat_args and specific_paperformat_args.get('data-report-margin-top'):
                command_args.extend(['--margin-top', str(specific_paperformat_args['data-report-margin-top'])])
            else:
                command_args.extend(['--margin-top', str(paperformat_id.margin_top)])

            dpi = None
            if specific_paperformat_args and specific_paperformat_args.get('data-report-dpi'):
                dpi = int(specific_paperformat_args['data-report-dpi'])
            elif paperformat_id.dpi:
                if os.name == 'nt' and int(paperformat_id.dpi) <= 95:
                    _logger.info("Generating PDF on Windows platform require DPI >= 96. Using 96 instead.")
                    dpi = 96
                else:
                    dpi = paperformat_id.dpi
            if dpi:
                command_args.extend(['--dpi', str(dpi)])
                if wkhtmltopdf_dpi_zoom_ratio:
                    command_args.extend(['--zoom', str(96.0 / dpi)])

            if specific_paperformat_args and specific_paperformat_args.get('data-report-header-spacing'):
                command_args.extend(['--header-spacing', str(specific_paperformat_args['data-report-header-spacing'])])
            elif paperformat_id.header_spacing:
                command_args.extend(['--header-spacing', str(paperformat_id.header_spacing)])

            command_args.extend(['--margin-left', str(paperformat_id.margin_left)])

            if specific_paperformat_args and specific_paperformat_args.get('data-report-margin-bottom'):
                command_args.extend(['--margin-bottom', str(specific_paperformat_args['data-report-margin-bottom'])])
            else:
                command_args.extend(['--margin-bottom', str(paperformat_id.margin_bottom)])

            command_args.extend(['--margin-right', str(paperformat_id.margin_right)])
            if not landscape and paperformat_id.orientation:
                command_args.extend(['--orientation', str(paperformat_id.orientation)])
            if paperformat_id.header_line:
                command_args.extend(['--header-line'])
            if paperformat_id.disable_shrinking:
                command_args.extend(['--disable-smart-shrinking'])

        # Add extra time to allow the page to render
        delay = self.env['ir.config_parameter'].sudo().get_param('report.print_delay', '1000')
        command_args.extend(['--javascript-delay', delay])

        if landscape:
            command_args.extend(['--orientation', 'landscape'])

        return command_args

    def _prepare_html(self, html, report_model=False):
        '''Divide and recreate the header/footer html by merging all found in html.
        The bodies are extracted and added to a list. Then, extract the specific_paperformat_args.
        The idea is to put all headers/footers together. Then, we will use a javascript trick
        (see minimal_layout template) to set the right header/footer during the processing of wkhtmltopdf.
        This allows the computation of multiple reports in a single call to wkhtmltopdf.

        :param html: The html rendered by render_qweb_html.
        :type: bodies: list of string representing each one a html body.
        :type header: string representing the html header.
        :type footer: string representing the html footer.
        :type specific_paperformat_args: dictionary of prioritized paperformat values.
        :return: bodies, header, footer, specific_paperformat_args
        '''

        # Return empty dictionary if 'web.minimal_layout' not found.
        layout = self._get_layout()
        if not layout:
            return {}
        base_url = self._get_report_url(layout=layout)

        root = lxml.html.fromstring(html, parser=lxml.html.HTMLParser(encoding='utf-8'))
        match_klass = "//div[contains(concat(' ', normalize-space(@class), ' '), ' {} ')]"

        header_node = etree.Element('div', id='minimal_layout_report_headers')
        footer_node = etree.Element('div', id='minimal_layout_report_footers')
        bodies = []
        res_ids = []

        body_parent = root.xpath('//main')[0]
        # Retrieve headers
        for node in root.xpath(match_klass.format('header')):
            body_parent = node.getparent()
            node.getparent().remove(node)
            header_node.append(node)

        # Retrieve footers
        for node in root.xpath(match_klass.format('footer')):
            body_parent = node.getparent()
            node.getparent().remove(node)
            footer_node.append(node)

        # Retrieve bodies
        for node in root.xpath(match_klass.format('article')):
            # set context language to body language
            IrQweb = self.env['ir.qweb']
            if node.get('data-oe-lang'):
                IrQweb = IrQweb.with_context(lang=node.get('data-oe-lang'))
            body = IrQweb._render(layout.id, {
                    'subst': False,
                    'body': Markup(lxml.html.tostring(node, encoding='unicode')),
                    'base_url': base_url,
                    'report_xml_id' : self.xml_id
                }, raise_if_not_found=False)
            bodies.append(body)
            if node.get('data-oe-model') == report_model:
                res_ids.append(int(node.get('data-oe-id', 0)))
            else:
                res_ids.append(None)

        if not bodies:
            body = ''.join(lxml.html.tostring(c, encoding='unicode') for c in body_parent.getchildren())
            bodies.append(body)

        # Get paperformat arguments set in the root html tag. They are prioritized over
        # paperformat-record arguments.
        specific_paperformat_args = {}
        for attribute in root.items():
            if attribute[0].startswith('data-report-'):
                specific_paperformat_args[attribute[0]] = attribute[1]

        header = self.env['ir.qweb']._render(layout.id, {
            'subst': True,
            'body': Markup(lxml.html.tostring(header_node, encoding='unicode')),
            'base_url': base_url
        })
        footer = self.env['ir.qweb']._render(layout.id, {
            'subst': True,
            'body': Markup(lxml.html.tostring(footer_node, encoding='unicode')),
            'base_url': base_url
        })

        return bodies, res_ids, header, footer, specific_paperformat_args

    @api.model
    def _run_wkhtmltopdf(
            self,
            bodies,
            report_ref=False,
            header=None,
            footer=None,
            landscape=False,
            specific_paperformat_args=None,
            set_viewport_size=False):
        '''Execute wkhtmltopdf as a subprocess in order to convert html given in input into a pdf
        document.

        :param list[str] bodies: The html bodies of the report, one per page.
        :param report_ref: report reference that is needed to get report paperformat.
        :param str header: The html header of the report containing all headers.
        :param str footer: The html footer of the report containing all footers.
        :param landscape: Force the pdf to be rendered under a landscape format.
        :param specific_paperformat_args: dict of prioritized paperformat arguments.
        :param set_viewport_size: Enable a viewport sized '1024x1280' or '1280x1024' depending of landscape arg.
        :return: Content of the pdf as bytes
        :rtype: bytes
        '''
        paperformat_id = self._get_report(report_ref).get_paperformat() if report_ref else self.get_paperformat()

        # Build the base command args for wkhtmltopdf bin
        command_args = self._build_wkhtmltopdf_args(
            paperformat_id,
            landscape,
            specific_paperformat_args=specific_paperformat_args,
            set_viewport_size=set_viewport_size)

        files_command_args = []
        temporary_files = []

        # Passing the cookie to wkhtmltopdf in order to resolve internal links.
        if request and request.db:
            base_url = self._get_report_url()
            domain = urlparse(base_url).hostname
            cookie = f'session_id={request.session.sid}; HttpOnly; domain={domain}; path=/;'
            cookie_jar_file_fd, cookie_jar_file_path = tempfile.mkstemp(suffix='.txt', prefix='report.cookie_jar.tmp.')
            temporary_files.append(cookie_jar_file_path)
            with closing(os.fdopen(cookie_jar_file_fd, 'wb')) as cookie_jar_file:
                cookie_jar_file.write(cookie.encode())
            command_args.extend(['--cookie-jar', cookie_jar_file_path])

        if header:
            head_file_fd, head_file_path = tempfile.mkstemp(suffix='.html', prefix='report.header.tmp.')
            with closing(os.fdopen(head_file_fd, 'wb')) as head_file:
                head_file.write(header.encode())
            temporary_files.append(head_file_path)
            files_command_args.extend(['--header-html', head_file_path])
        if footer:
            foot_file_fd, foot_file_path = tempfile.mkstemp(suffix='.html', prefix='report.footer.tmp.')
            with closing(os.fdopen(foot_file_fd, 'wb')) as foot_file:
                foot_file.write(footer.encode())
            temporary_files.append(foot_file_path)
            files_command_args.extend(['--footer-html', foot_file_path])

        paths = []
        for i, body in enumerate(bodies):
            prefix = '%s%d.' % ('report.body.tmp.', i)
            body_file_fd, body_file_path = tempfile.mkstemp(suffix='.html', prefix=prefix)
            with closing(os.fdopen(body_file_fd, 'wb')) as body_file:
                # HACK: wkhtmltopdf doesn't like big table at all and the
                #       processing time become exponential with the number
                #       of rows (like 1H for 250k rows).
                #
                #       So we split the table into multiple tables containing
                #       500 rows each. This reduce the processing time to 1min
                #       for 250k rows. The number 500 was taken from opw-1689673
                if len(body) < 4 * 1024 * 1024: # 4Mib
                    body_file.write(body.encode())
                else:
                    tree = lxml.html.fromstring(body)
                    _split_table(tree, 500)
                    body_file.write(lxml.html.tostring(tree))
            paths.append(body_file_path)
            temporary_files.append(body_file_path)

        pdf_report_fd, pdf_report_path = tempfile.mkstemp(suffix='.pdf', prefix='report.tmp.')
        os.close(pdf_report_fd)
        temporary_files.append(pdf_report_path)

        try:
            wkhtmltopdf = [_get_wkhtmltopdf_bin()] + command_args + files_command_args + paths + [pdf_report_path]
            process = subprocess.Popen(wkhtmltopdf, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = process.communicate()
            err = ustr(err)

            if process.returncode not in [0, 1]:
                if process.returncode == -11:
                    message = _(
                        'Wkhtmltopdf failed (error code: %s). Memory limit too low or maximum file number of subprocess reached. Message : %s',
                        process.returncode,
                        err[-1000:],
                    )
                else:
                    message = _(
                        'Wkhtmltopdf failed (error code: %s). Message: %s',
                        process.returncode,
                        err[-1000:],
                    )
                _logger.warning(message)
                raise UserError(message)
            else:
                if err:
                    _logger.warning('wkhtmltopdf: %s' % err)
        except:
            raise

        with open(pdf_report_path, 'rb') as pdf_document:
            pdf_content = pdf_document.read()

        # Manual cleanup of the temporary files
        for temporary_file in temporary_files:
            try:
                os.unlink(temporary_file)
            except (OSError, IOError):
                _logger.error('Error when trying to remove file %s' % temporary_file)

        return pdf_content

    @api.model
    def _get_report_from_name(self, report_name):
        """Get the first record of ir.actions.report having the ``report_name`` as value for
        the field report_name.
        """
        report_obj = self.env['ir.actions.report']
        conditions = [('report_name', '=', report_name)]
        context = self.env['res.users'].context_get()
        return report_obj.with_context(context).sudo().search(conditions, limit=1)

    @api.model
    def _get_report(self, report_ref):
        """Get the report (with sudo) from a reference
        report_ref: can be one of
            - ir.actions.report id
            - ir.actions.report record
            - ir.model.data reference to ir.actions.report
            - ir.actions.report report_name
        """
        ReportSudo = self.env['ir.actions.report'].sudo()
        if isinstance(report_ref, int):
            return ReportSudo.browse(report_ref)
        if isinstance(report_ref, models.Model):
            if report_ref._name != self._name:
                raise ValueError("Expected report of type %s, got %s" % (self._name, report_ref._name))
            return report_ref.sudo()
        report = ReportSudo.search([('report_name', '=', report_ref)], limit=1)
        if report:
            return report
        report = self.env.ref(report_ref)
        if report:
            if report._name != "ir.actions.report":
                raise ValueError("Fetching report %r: type %s, expected ir.actions.report" % (report_ref, report._name))
            return report.sudo()
        raise ValueError("Fetching report %r: report not found" % report_ref)

    @api.model
    def barcode(self, barcode_type, value, **kwargs):
        defaults = {
            'width': (600, int),
            'height': (100, int),
            'humanreadable': (False, lambda x: bool(int(x))),
            'quiet': (True, lambda x: bool(int(x))),
            'mask': (None, lambda x: x),
            'barBorder': (4, int),
            # The QR code can have different layouts depending on the Error Correction Level
            # See: https://en.wikipedia.org/wiki/QR_code#Error_correction
            # Level 'L' – up to 7% damage   (default)
            # Level 'M' – up to 15% damage  (i.e. required by l10n_ch QR bill)
            # Level 'Q' – up to 25% damage
            # Level 'H' – up to 30% damage
            'barLevel': ('L', lambda x: x in ('L', 'M', 'Q', 'H') and x or 'L'),
        }
        kwargs = {k: validator(kwargs.get(k, v)) for k, (v, validator) in defaults.items()}
        kwargs['humanReadable'] = kwargs.pop('humanreadable')

        if barcode_type == 'UPCA' and len(value) in (11, 12, 13):
            barcode_type = 'EAN13'
            if len(value) in (11, 12):
                value = '0%s' % value
        elif barcode_type == 'auto':
            symbology_guess = {8: 'EAN8', 13: 'EAN13'}
            barcode_type = symbology_guess.get(len(value), 'Code128')
        elif barcode_type == 'QR':
            # for `QR` type, `quiet` is not supported. And is simply ignored.
            # But we can use `barBorder` to get a similar behaviour.
            if kwargs['quiet']:
                kwargs['barBorder'] = 0

        if barcode_type in ('EAN8', 'EAN13') and not check_barcode_encoding(value, barcode_type):
            # If the barcode does not respect the encoding specifications, convert its type into Code128.
            # Otherwise, the report-lab method may return a barcode different from its value. For instance,
            # if the barcode type is EAN-8 and the value 11111111, the report-lab method will take the first
            # seven digits and will compute the check digit, which gives: 11111115 -> the barcode does not
            # match the expected value.
            barcode_type = 'Code128'

        try:
            barcode = createBarcodeDrawing(barcode_type, value=value, format='png', **kwargs)

            # If a mask is asked and it is available, call its function to
            # post-process the generated QR-code image
            if kwargs['mask']:
                available_masks = self.get_available_barcode_masks()
                mask_to_apply = available_masks.get(kwargs['mask'])
                if mask_to_apply:
                    mask_to_apply(kwargs['width'], kwargs['height'], barcode)

            return barcode.asString('png')
        except (ValueError, AttributeError):
            if barcode_type == 'Code128':
                raise ValueError("Cannot convert into barcode.")
            elif barcode_type == 'QR':
                raise ValueError("Cannot convert into QR code.")
            else:
                return self.barcode('Code128', value, **kwargs)

    @api.model
    def get_available_barcode_masks(self):
        """ Hook for extension.
        This function returns the available QR-code masks, in the form of a
        list of (code, mask_function) elements, where code is a string identifying
        the mask uniquely, and mask_function is a function returning a reportlab
        Drawing object with the result of the mask, and taking as parameters:
            - width of the QR-code, in pixels
            - height of the QR-code, in pixels
            - reportlab Drawing object containing the barcode to apply the mask on
        """
        return {}

    def _render_template(self, template, values=None):
        """Allow to render a QWeb template python-side. This function returns the 'ir.ui.view'
        render but embellish it with some variables/methods used in reports.
        :param values: additional methods/variables used in the rendering
        :returns: html representation of the template
        :rtype: bytes
        """
        if values is None:
            values = {}

        # Browse the user instead of using the sudo self.env.user
        user = self.env['res.users'].browse(self.env.uid)
        view_obj = self.env['ir.ui.view'].with_context(inherit_branding=False)
        values.update(
            time=time,
            context_timestamp=lambda t: fields.Datetime.context_timestamp(self.with_context(tz=user.tz), t),
            user=user,
            res_company=self.env.company,
            web_base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url', default=''),
        )
        return view_obj._render_template(template, values).encode()

    @api.model
    def _merge_pdfs(self, streams):
        writer = PdfFileWriter()
        for stream in streams:
            try:
                reader = PdfFileReader(stream)
                writer.appendPagesFromReader(reader)
            except (PdfReadError, TypeError, NotImplementedError, ValueError):
                raise UserError(_("Odoo is unable to merge the generated PDFs."))
        result_stream = io.BytesIO()
        streams.append(result_stream)
        writer.write(result_stream)
        return result_stream

    def _render_qweb_pdf_prepare_streams(self, report_ref, data, res_ids=None):
        if not data:
            data = {}
        data.setdefault('report_type', 'pdf')

        # access the report details with sudo() but evaluation context as current user
        report_sudo = self._get_report(report_ref)
        has_duplicated_ids = res_ids and len(res_ids) != len(set(res_ids))

        collected_streams = OrderedDict()

        # Fetch the existing attachments from the database for later use.
        # Reload the stream from the attachment in case of 'attachment_use'.
        if res_ids:
            records = self.env[report_sudo.model].browse(res_ids)
            for record in records:
                res_id = record.id
                if res_id in collected_streams:
                    continue

                stream = None
                attachment = None
                if not has_duplicated_ids and report_sudo.attachment and not self._context.get("report_pdf_no_attachment"):
                    attachment = report_sudo.retrieve_attachment(record)

                    # Extract the stream from the attachment.
                    if attachment and report_sudo.attachment_use:
                        stream = io.BytesIO(attachment.raw)

                        # Ensure the stream can be saved in Image.
                        if attachment.mimetype.startswith('image'):
                            img = Image.open(stream)
                            new_stream = io.BytesIO()
                            img.convert("RGB").save(new_stream, format="pdf")
                            stream.close()
                            stream = new_stream

                collected_streams[res_id] = {
                    'stream': stream,
                    'attachment': attachment,
                }

        # Call 'wkhtmltopdf' to generate the missing streams.
        res_ids_wo_stream = [res_id for res_id, stream_data in collected_streams.items() if not stream_data['stream']]
        all_res_ids_wo_stream = res_ids if has_duplicated_ids else res_ids_wo_stream
        is_whtmltopdf_needed = not res_ids or res_ids_wo_stream

        if is_whtmltopdf_needed:

            if self.get_wkhtmltopdf_state() == 'install':
                # wkhtmltopdf is not installed
                # the call should be catched before (cf /report/check_wkhtmltopdf) but
                # if get_pdf is called manually (email template), the check could be
                # bypassed
                raise UserError(_("Unable to find Wkhtmltopdf on this system. The PDF can not be created."))

            # Disable the debug mode in the PDF rendering in order to not split the assets bundle
            # into separated files to load. This is done because of an issue in wkhtmltopdf
            # failing to load the CSS/Javascript resources in time.
            # Without this, the header/footer of the reports randomly disappear
            # because the resources files are not loaded in time.
            # https://github.com/wkhtmltopdf/wkhtmltopdf/issues/2083
            additional_context = {'debug': False}

            html = self.with_context(**additional_context)._render_qweb_html(report_ref, all_res_ids_wo_stream, data=data)[0]

            bodies, html_ids, header, footer, specific_paperformat_args = self.with_context(**additional_context)._prepare_html(html, report_model=report_sudo.model)

            if not has_duplicated_ids and report_sudo.attachment and set(res_ids_wo_stream) != set(html_ids):
                raise UserError(_(
                    "The report's template %r is wrong, please contact your administrator. \n\n"
                    "Can not separate file to save as attachment because the report's template does not contains the"
                    " attributes 'data-oe-model' and 'data-oe-id' on the div with 'article' classname.",
                    report_sudo.name,
                ))

            pdf_content = self._run_wkhtmltopdf(
                bodies,
                report_ref=report_ref,
                header=header,
                footer=footer,
                landscape=self._context.get('landscape'),
                specific_paperformat_args=specific_paperformat_args,
                set_viewport_size=self._context.get('set_viewport_size'),
            )
            pdf_content_stream = io.BytesIO(pdf_content)

            # Printing a PDF report without any records. The content could be returned directly.
            if has_duplicated_ids or not res_ids:
                return {
                    False: {
                        'stream': pdf_content_stream,
                        'attachment': None,
                    }
                }

            # Split the pdf for each record using the PDF outlines.

            # Only one record: append the whole PDF.
            if len(res_ids_wo_stream) == 1:
                collected_streams[res_ids_wo_stream[0]]['stream'] = pdf_content_stream
                return collected_streams

            # In case of multiple docs, we need to split the pdf according the records.
            # In the simplest case of 1 res_id == 1 page, we use the PDFReader to print the
            # pages one by one.
            html_ids_wo_none = [x for x in html_ids if x]
            reader = PdfFileReader(pdf_content_stream)
            if reader.numPages == len(res_ids_wo_stream):
                for i in range(reader.numPages):
                    attachment_writer = PdfFileWriter()
                    attachment_writer.addPage(reader.getPage(i))
                    stream = io.BytesIO()
                    attachment_writer.write(stream)
                    collected_streams[res_ids_wo_stream[i]]['stream'] = stream
                return collected_streams

            # In cases where the number of res_ids != the number of pages,
            # we split the pdf based on top outlines computed by wkhtmltopdf.
            # An outline is a <h?> html tag found on the document. To retrieve this table,
            # we look on the pdf structure using pypdf to compute the outlines_pages from
            # the top level heading in /Outlines.
            if len(res_ids_wo_stream) > 1 and set(res_ids_wo_stream) == set(html_ids_wo_none):
                root = reader.trailer['/Root']
                has_valid_outlines = '/Outlines' in root and '/First' in root['/Outlines']
                if not has_valid_outlines:
                    return {False: {
                        'report_action': self,
                        'stream': pdf_content_stream,
                        'attachment': None,
                    }}

                outlines_pages = []
                node = root['/Outlines']['/First']
                while True:
                    outlines_pages.append(root['/Dests'][node['/Dest']][0])
                    if '/Next' not in node:
                        break
                    node = node['/Next']
                outlines_pages = sorted(set(outlines_pages))

                # The number of outlines must be equal to the number of records to be able to split the document.
                has_same_number_of_outlines = len(outlines_pages) == len(res_ids_wo_stream)

                # There should be a top-level heading on first page
                has_top_level_heading = outlines_pages[0] == 0

                if has_same_number_of_outlines and has_top_level_heading:
                    # Split the PDF according to outlines.
                    for i, num in enumerate(outlines_pages):
                        to = outlines_pages[i + 1] if i + 1 < len(outlines_pages) else reader.numPages
                        attachment_writer = PdfFileWriter()
                        for j in range(num, to):
                            attachment_writer.addPage(reader.getPage(j))
                        stream = io.BytesIO()
                        attachment_writer.write(stream)
                        collected_streams[res_ids_wo_stream[i]]['stream'] = stream

                    return collected_streams

            collected_streams[False] = {'stream': pdf_content_stream, 'attachment': None}

        return collected_streams

    def _prepare_pdf_report_attachment_vals_list(self, report, streams):
        """Hook to prepare attachment values needed for attachments creation
        during the pdf report generation.

        :param report: The report (with sudo) from a reference report_ref.
        :param streams: Dict of streams for each report containing the pdf content and existing attachments.
        :return: attachment values list needed for attachments creation.
        """
        attachment_vals_list = []
        for res_id, stream_data in streams.items():
            # An attachment already exists.
            if stream_data['attachment']:
                continue

            # if res_id is false
            # we are unable to fetch the record, it won't be saved as we can't split the documents unambiguously
            if not res_id:
                _logger.warning(
                    "These documents were not saved as an attachment because the template of %s doesn't "
                    "have any headers seperating different instances of it. If you want it saved,"
                    "please print the documents separately", report.report_name)
                continue
            record = self.env[report.model].browse(res_id)
            attachment_name = safe_eval(report.attachment, {'object': record, 'time': time})

            # Unable to compute a name for the attachment.
            if not attachment_name:
                continue

            attachment_vals_list.append({
                'name': attachment_name,
                'raw': stream_data['stream'].getvalue(),
                'res_model': report.model,
                'res_id': record.id,
                'type': 'binary',
            })
        return attachment_vals_list

    def _render_qweb_pdf(self, report_ref, res_ids=None, data=None):
        if not data:
            data = {}
        if isinstance(res_ids, int):
            res_ids = [res_ids]
        data.setdefault('report_type', 'pdf')
        # In case of test environment without enough workers to perform calls to wkhtmltopdf,
        # fallback to render_html.
        if (tools.config['test_enable'] or tools.config['test_file']) and not self.env.context.get('force_report_rendering'):
            return self._render_qweb_html(report_ref, res_ids, data=data)

        self = self.with_context(webp_as_jpg=True)
        collected_streams = self._render_qweb_pdf_prepare_streams(report_ref, data, res_ids=res_ids)
        has_duplicated_ids = res_ids and len(res_ids) != len(set(res_ids))

        # access the report details with sudo() but keep evaluation context as current user
        report_sudo = self._get_report(report_ref)

        # Generate the ir.attachment if needed.
        if not has_duplicated_ids and report_sudo.attachment and not self._context.get("report_pdf_no_attachment"):
            attachment_vals_list = self._prepare_pdf_report_attachment_vals_list(report_sudo, collected_streams)
            if attachment_vals_list:
                attachment_names = ', '.join(x['name'] for x in attachment_vals_list)
                try:
                    self.env['ir.attachment'].create(attachment_vals_list)
                except AccessError:
                    _logger.info("Cannot save PDF report %r attachments for user %r", attachment_names, self.env.user.display_name)
                else:
                    _logger.info("The PDF documents %r are now saved in the database", attachment_names)

        # Merge all streams together for a single record.
        streams_to_merge = [x['stream'] for x in collected_streams.values() if x['stream']]
        if len(streams_to_merge) == 1:
            pdf_content = streams_to_merge[0].getvalue()
        else:
            with self._merge_pdfs(streams_to_merge) as pdf_merged_stream:
                pdf_content = pdf_merged_stream.getvalue()

        for stream in streams_to_merge:
            stream.close()

        if res_ids:
            _logger.info("The PDF report has been generated for model: %s, records %s.", report_sudo.model, str(res_ids))

        return pdf_content, 'pdf'

    @api.model
    def _render_qweb_text(self, report_ref, docids, data=None):
        if not data:
            data = {}
        data.setdefault('report_type', 'text')
        report = self._get_report(report_ref)
        data = self._get_rendering_context(report, docids, data)
        return self._render_template(report.report_name, data), 'text'

    @api.model
    def _render_qweb_html(self, report_ref, docids, data=None):
        if not data:
            data = {}
        data.setdefault('report_type', 'html')
        report = self._get_report(report_ref)
        data = self._get_rendering_context(report, docids, data)
        return self._render_template(report.report_name, data), 'html'

    def _get_rendering_context_model(self, report):
        report_model_name = 'report.%s' % report.report_name
        return self.env.get(report_model_name)

    def _get_rendering_context(self, report, docids, data):
        # If the report is using a custom model to render its html, we must use it.
        # Otherwise, fallback on the generic html rendering.
        report_model = self._get_rendering_context_model(report)

        data = data and dict(data) or {}

        if report_model is not None:
            data.update(report_model._get_report_values(docids, data=data))
        else:
            docs = self.env[report.model].browse(docids)
            data.update({
                'doc_ids': docids,
                'doc_model': report.model,
                'docs': docs,
            })
        data['is_html_empty'] = is_html_empty
        return data

    @api.model
    def _render(self, report_ref, res_ids, data=None):
        report = self._get_report(report_ref)
        report_type = report.report_type.lower().replace('-', '_')
        render_func = getattr(self, '_render_' + report_type, None)
        if not render_func:
            return None
        return render_func(report_ref, res_ids, data=data)

    def report_action(self, docids, data=None, config=True):
        """Return an action of type ir.actions.report.

        :param docids: id/ids/browse record of the records to print (if not used, pass an empty list)
        :param data:
        :param bool config:
        :rtype: bytes
        """
        context = self.env.context
        if docids:
            if isinstance(docids, models.Model):
                active_ids = docids.ids
            elif isinstance(docids, int):
                active_ids = [docids]
            elif isinstance(docids, list):
                active_ids = docids
            context = dict(self.env.context, active_ids=active_ids)

        report_action = {
            'context': context,
            'data': data,
            'type': 'ir.actions.report',
            'report_name': self.report_name,
            'report_type': self.report_type,
            'report_file': self.report_file,
            'name': self.name,
        }

        discard_logo_check = self.env.context.get('discard_logo_check')
        if self.env.is_admin() and not self.env.company.external_report_layout_id and config and not discard_logo_check:
            return self._action_configure_external_report_layout(report_action)

        return report_action

    def _action_configure_external_report_layout(self, report_action):
        action = self.env["ir.actions.actions"]._for_xml_id("web.action_base_document_layout_configurator")
        py_ctx = json.loads(action.get('context', {}))
        report_action['close_on_report_download'] = True
        py_ctx['report_action'] = report_action
        py_ctx['dialog_size'] = 'large'
        action['context'] = py_ctx
        return action

```

  File: models/ir_asset.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import os
from glob import glob
from logging import getLogger
from werkzeug import urls

import odoo
import odoo.modules.module  # get_manifest, don't from-import it
from odoo import api, fields, models, tools
from odoo.tools import misc
from odoo.tools.constants import ASSET_EXTENSIONS, EXTERNAL_ASSET

_logger = getLogger(__name__)

DEFAULT_SEQUENCE = 16

# Directives are stored in variables for ease of use and syntax checks.
APPEND_DIRECTIVE = 'append'
PREPEND_DIRECTIVE = 'prepend'
AFTER_DIRECTIVE = 'after'
BEFORE_DIRECTIVE = 'before'
REMOVE_DIRECTIVE = 'remove'
REPLACE_DIRECTIVE = 'replace'
INCLUDE_DIRECTIVE = 'include'
# Those are the directives used with a 'target' argument/field.
DIRECTIVES_WITH_TARGET = [AFTER_DIRECTIVE, BEFORE_DIRECTIVE, REPLACE_DIRECTIVE]


def fs2web(path):
    """Converts a file system path to a web path"""
    if os.path.sep == '/':
        return path
    return '/'.join(path.split(os.path.sep))


def can_aggregate(url):
    parsed = urls.url_parse(url)
    return not parsed.scheme and not parsed.netloc and not url.startswith('/web/content')


def is_wildcard_glob(path):
    """Determine whether a path is a wildcarded glob eg: "/web/file[14].*"
    or a genuine single file path "/web/myfile.scss"""
    return '*' in path or '[' in path or ']' in path or '?' in path


def _glob_static_file(pattern):
    files = glob(pattern, recursive=True)
    return sorted((file, os.path.getmtime(file)) for file in files if file.rsplit('.', 1)[-1] in ASSET_EXTENSIONS)


class IrAsset(models.Model):
    """This model contributes to two things:

        1. It provides a function returning a list of all file paths declared
        in a given list of addons (see _get_addon_paths);

        2. It allows to create 'ir.asset' records to add additional directives
        to certain bundles.
    """
    _name = 'ir.asset'
    _description = 'Asset'
    _order = 'sequence, id'
    _allow_sudo_commands = False

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache('assets')
        return super().create(vals_list)

    def write(self, values):
        if self:
            self.env.registry.clear_cache('assets')
        return super().write(values)

    def unlink(self):
        self.env.registry.clear_cache('assets')
        return super().unlink()

    name = fields.Char(string='Name', required=True)
    bundle = fields.Char(string='Bundle name', required=True)
    directive = fields.Selection(string='Directive', selection=[
        (APPEND_DIRECTIVE, 'Append'),
        (PREPEND_DIRECTIVE, 'Prepend'),
        (AFTER_DIRECTIVE, 'After'),
        (BEFORE_DIRECTIVE, 'Before'),
        (REMOVE_DIRECTIVE, 'Remove'),
        (REPLACE_DIRECTIVE, 'Replace'),
        (INCLUDE_DIRECTIVE, 'Include')], default=APPEND_DIRECTIVE)
    path = fields.Char(string='Path (or glob pattern)', required=True)
    target = fields.Char(string='Target')
    active = fields.Boolean(string='active', default=True)
    sequence = fields.Integer(string="Sequence", default=DEFAULT_SEQUENCE, required=True)

    def _get_asset_params(self):
        """
        This method can be overriden to add param _get_asset_paths call.
        Those params will be part of the orm cache key
        """
        return {}

    def _get_asset_bundle_url(self, filename, unique, assets_params, ignore_params=False):
        return f'/web/assets/{unique}/{filename}'

    def _parse_bundle_name(self, bundle_name, debug_assets):
        bundle_name, asset_type = bundle_name.rsplit('.', 1)
        rtl = False
        if not debug_assets:
            bundle_name, min_ = bundle_name.rsplit('.', 1)
            if min_ != 'min':
                raise ValueError("'min' expected in extension in non debug mode")
        if asset_type == 'css':
            if bundle_name.endswith('.rtl'):
                bundle_name = bundle_name[:-4]
                rtl = True
        elif asset_type != 'js':
            raise ValueError('Only js and css assets bundle are supported for now')
        if len(bundle_name.split('.')) != 2:
            raise ValueError(f'{bundle_name} is not a valid bundle name, should have two parts')
        return bundle_name, rtl, asset_type

    @tools.conditional(
        'xml' not in tools.config['dev_mode'],
        tools.ormcache('bundle', 'tuple(sorted(assets_params.items()))', cache='assets'),
    )
    def _get_asset_paths(self, bundle, assets_params):
        """
        Fetches all asset file paths from a given list of addons matching a
        certain bundle. The returned list is composed of tuples containing the
        file path [1], the first addon calling it [0] and the bundle name.
        Asset loading is performed as follows:

        1. All 'ir.asset' records matching the given bundle and with a sequence
        strictly less than 16 are applied.

        3. The manifests of the given addons are checked for assets declaration
        for the given bundle. If any, they are read sequentially and their
        operations are applied to the current list.

        4. After all manifests have been parsed, the remaining 'ir.asset'
        records matching the bundle are also applied to the current list.

        :param bundle: name of the bundle from which to fetch the file paths
        :param assets_params: parameters needed by overrides, mainly website_id
            see _get_asset_params
        :returns: the list of tuples (path, addon, bundle)
        """
        installed = self._get_installed_addons_list()
        addons = self._get_active_addons_list(**assets_params)

        asset_paths = AssetPaths()

        addons = self._topological_sort(tuple(addons))

        self._fill_asset_paths(bundle, asset_paths, [], addons, installed, **assets_params)
        return asset_paths.list

    def _fill_asset_paths(self, bundle, asset_paths, seen, addons, installed, **assets_params):
        """
        Fills the given AssetPaths instance by applying the operations found in
        the matching bundle of the given addons manifests.
        See `_get_asset_paths` for more information.

        :param bundle: name of the bundle from which to fetch the file paths
        :param addons: list of addon names as strings
        :param css: boolean: whether or not to include style files
        :param js: boolean: whether or not to include script files
        :param xml: boolean: whether or not to include template files
        :param asset_paths: the AssetPath object to fill
        :param seen: a list of bundles already checked to avoid circularity
        """
        if bundle in seen:
            raise Exception("Circular assets bundle declaration: %s" % " > ".join(seen + [bundle]))

        # this index is used for prepending: files are inserted at the beginning
        # of the CURRENT bundle.
        bundle_start_index = len(asset_paths.list)

        assets = self._get_related_assets([('bundle', '=', bundle)], **assets_params).filtered('active')
        # 1. Process the first sequence of 'ir.asset' records
        for asset in assets.filtered(lambda a: a.sequence < DEFAULT_SEQUENCE):
            self._process_path(bundle, asset.directive, asset.target, asset.path, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)

        # 2. Process all addons' manifests.
        for addon in addons:
            for command in odoo.modules.module._get_manifest_cached(addon)['assets'].get(bundle, ()):
                directive, target, path_def = self._process_command(command)
                self._process_path(bundle, directive, target, path_def, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)

        # 3. Process the rest of 'ir.asset' records
        for asset in assets.filtered(lambda a: a.sequence >= DEFAULT_SEQUENCE):
            self._process_path(bundle, asset.directive, asset.target, asset.path, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)

    def _process_path(self, bundle, directive, target, path_def, asset_paths, seen, addons, installed, bundle_start_index, **assets_params):
        """
        This sub function is meant to take a directive and a set of
        arguments and apply them to the current asset_paths list
        accordingly.

        It is nested inside `_get_asset_paths` since we need the current
        list of addons, extensions and asset_paths.

        :param directive: string
        :param target: string or None or False
        :param path_def: string
        """
        if directive == INCLUDE_DIRECTIVE:
            # recursively call this function for each INCLUDE_DIRECTIVE directive.
            self._fill_asset_paths(path_def, asset_paths, seen + [bundle], addons, installed, **assets_params)
            return
        if can_aggregate(path_def):
            paths = self._get_paths(path_def, installed)
        else:
            paths = [(path_def, EXTERNAL_ASSET, -1)]  # external urls

        # retrieve target index when it applies
        if directive in DIRECTIVES_WITH_TARGET:
            target_paths = self._get_paths(target, installed)
            if not target_paths and target.rpartition('.')[2] not in ASSET_EXTENSIONS:
                # nothing to do: the extension of the target is wrong
                return
            if target_paths:
                target = target_paths[0][0]
            target_index = asset_paths.index(target, bundle)

        if directive == APPEND_DIRECTIVE:
            asset_paths.append(paths, bundle)
        elif directive == PREPEND_DIRECTIVE:
            asset_paths.insert(paths, bundle, bundle_start_index)
        elif directive == AFTER_DIRECTIVE:
            asset_paths.insert(paths, bundle, target_index + 1)
        elif directive == BEFORE_DIRECTIVE:
            asset_paths.insert(paths, bundle, target_index)
        elif directive == REMOVE_DIRECTIVE:
            asset_paths.remove(paths, bundle)
        elif directive == REPLACE_DIRECTIVE:
            asset_paths.insert(paths, bundle, target_index)
            asset_paths.remove(target_paths, bundle)
        else:
            # this should never happen
            raise ValueError("Unexpected directive")

    def _get_related_assets(self, domain):
        """
        Returns a set of assets matching the domain, regardless of their
        active state. This method can be overridden to filter the results.
        :param domain: search domain
        :returns: ir.asset recordset
        """
        # active_test is needed to disable some assets through filter_duplicate for website
        # they will be filtered on active afterward
        return self.with_context(active_test=False).sudo().search(domain, order='sequence, id')

    def _get_related_bundle(self, target_path_def, root_bundle):
        """
        Returns the first bundle directly defining a glob matching the target
        path. This is useful when generating an 'ir.asset' record to override
        a specific asset and target the right bundle, i.e. the first one
        defining the target path.

        :param target_path_def: string: path to match.
        :root_bundle: string: bundle from which to initiate the search.
        :returns: the first matching bundle or None
        """
        installed = self._get_installed_addons_list()
        target_path, _full_path, _modified = self._get_paths(target_path_def, installed)[0]
        assets_params = self._get_asset_params()
        asset_paths = self._get_asset_paths(root_bundle, assets_params)

        for path, _full_path, bundle, _modified in asset_paths:
            if path == target_path:
                return bundle

        return root_bundle

    def _get_active_addons_list(self):
        """Can be overridden to filter the returned list of active modules."""
        return self._get_installed_addons_list()

    @api.model
    @tools.ormcache('addons_tuple')
    def _topological_sort(self, addons_tuple):
        """Returns a list of sorted modules name accord to the spec in ir.module.module
        that is, application desc, sequence, name then topologically sorted"""
        IrModule = self.env['ir.module.module']

        def mapper(addon):
            manif = odoo.modules.module._get_manifest_cached(addon)
            from_terp = IrModule.get_values_from_terp(manif)
            from_terp['name'] = addon
            from_terp['depends'] = manif.get('depends', ['base'])
            return from_terp

        manifs = map(mapper, addons_tuple)

        def sort_key(manif):
            return (not manif['application'], int(manif['sequence']), manif['name'])

        manifs = sorted(manifs, key=sort_key)

        return misc.topological_sort({manif['name']: tuple(manif['depends']) for manif in manifs})

    @api.model
    @tools.ormcache()
    def _get_installed_addons_list(self):
        """
        Returns the list of all installed addons.
        :returns: string[]: list of module names
        """
        # Main source: the current registry list
        # Second source of modules: server wide modules
        return self.env.registry._init_modules.union(odoo.conf.server_wide_modules or [])

    def _get_paths(self, path_def, installed):
        """
        Returns a list of tuple (path, full_path, modified) matching a given glob (path_def).
        The glob can only occur in the static direcory of an installed addon.

        If the path_def matches a (list of) file, the result will contain the full_path
        and the modified time.
        Ex: ('/base/static/file.js', '/home/user/source/odoo/odoo/addons/base/static/file.js', 643636800)

        If the path_def looks like a non aggregable path (http://, /web/assets), only return the path
        Ex: ('http://example.com/lib.js', None, -1)
        The timestamp -1 is given to be thruthy while carrying no information.

        If the path_def is not a wildward, but may still be a valid addons path, return a False path
        with No timetamp
        Ex: ('/_custom/web.asset_frontend', False, None)

        :param path_def: the definition (glob) of file paths to match
        :param installed: the list of installed addons
        :param extensions: a list of extensions that found files must match
        :returns: a list of tuple: (path, full_path, modified)
        """
        paths = None
        path_def = fs2web(path_def)  # we expect to have all path definition unix style or url style, this is a safety
        path_parts = [part for part in path_def.split('/') if part]
        addon = path_parts[0]
        addon_manifest = odoo.modules.module._get_manifest_cached(addon)

        safe_path = True
        if addon_manifest:
            if addon not in installed:
                # Assert that the path is in the installed addons
                raise Exception(f"Unallowed to fetch files from addon {addon} for file {path_def}")
            addons_path = addon_manifest['addons_path']
            full_path = os.path.normpath(os.sep.join([addons_path, *path_parts]))
            # forbid escape from the current addon
            # "/mymodule/../myothermodule" is forbidden
            static_prefix = os.sep.join([addons_path, addon, 'static', ''])
            if full_path.startswith(static_prefix):
                paths_with_timestamps = _glob_static_file(full_path)
                paths = [
                    (fs2web(absolute_path[len(addons_path):]), absolute_path, timestamp)
                    for absolute_path, timestamp in paths_with_timestamps
                ]
            else:
                safe_path = False
        else:
            safe_path = False

        if not paths and not can_aggregate(path_def):  # http:// or /web/content
            paths = [(path_def, EXTERNAL_ASSET, -1)]

        if not paths and not is_wildcard_glob(path_def):  # an attachment url most likely
            paths = [(path_def, None, None)]

        if not paths:
            msg = f'IrAsset: the path "{path_def}" did not resolve to anything.'
            if not safe_path:
                msg += " It may be due to security reasons."
            _logger.warning(msg)
        # Paths are filtered on the extensions (if any).
        return paths

    def _process_command(self, command):
        """Parses a given command to return its directive, target and path definition."""
        if isinstance(command, str):
            # Default directive: append
            directive, target, path_def = APPEND_DIRECTIVE, None, command
        elif command[0] in DIRECTIVES_WITH_TARGET:
            directive, target, path_def = command
        else:
            directive, path_def = command
            target = None
        return directive, target, path_def


class AssetPaths:
    """ A list of asset paths (path, addon, bundle) with efficient operations. """
    def __init__(self):
        self.list = []
        self.memo = set()

    def index(self, path, bundle):
        """Returns the index of the given path in the current assets list."""
        if path not in self.memo:
            self._raise_not_found(path, bundle)
        for index, asset in enumerate(self.list):
            if asset[0] == path:
                return index

    def append(self, paths, bundle):
        """Appends the given paths to the current list."""
        for path, full_path, last_modified in paths:
            if path not in self.memo:
                self.list.append((path, full_path, bundle, last_modified))
                self.memo.add(path)

    def insert(self, paths, bundle, index):
        """Inserts the given paths to the current list at the given position."""
        to_insert = []
        for path, full_path, last_modified in paths:
            if path not in self.memo:
                to_insert.append((path, full_path, bundle, last_modified))
                self.memo.add(path)
        self.list[index:index] = to_insert

    def remove(self, paths_to_remove, bundle):
        """Removes the given paths from the current list."""
        paths = {path for path, _full_path, _last_modified in paths_to_remove if path in self.memo}
        if paths:
            self.list[:] = [asset for asset in self.list if asset[0] not in paths]
            self.memo.difference_update(paths)
            return

        if paths_to_remove:
            self._raise_not_found([path for path, _full_path, _last_modified in paths_to_remove], bundle)

    def _raise_not_found(self, path, bundle):
        raise ValueError("File(s) %s not found in bundle %s" % (path, bundle))

```

  File: models/ir_attachment.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import binascii
import contextlib
import hashlib
import io
import itertools
import logging
import mimetypes
import os
import psycopg2
import re
import uuid

from collections import defaultdict
from PIL import Image

from odoo import api, fields, models, SUPERUSER_ID, tools, _
from odoo.exceptions import AccessError, ValidationError, UserError
from odoo.tools import config, human_size, ImageProcess, str2bool, consteq
from odoo.tools.mimetypes import guess_mimetype
from odoo.osv import expression

_logger = logging.getLogger(__name__)


class IrAttachment(models.Model):
    """Attachments are used to link binary files or url to any openerp document.

    External attachment storage
    ---------------------------

    The computed field ``datas`` is implemented using ``_file_read``,
    ``_file_write`` and ``_file_delete``, which can be overridden to implement
    other storage engines. Such methods should check for other location pseudo
    uri (example: hdfs://hadoopserver).

    The default implementation is the file:dirname location that stores files
    on the local filesystem using name based on their sha1 hash
    """
    _name = 'ir.attachment'
    _description = 'Attachment'
    _order = 'id desc'

    def _compute_res_name(self):
        for attachment in self:
            if attachment.res_model and attachment.res_id:
                record = self.env[attachment.res_model].browse(attachment.res_id)
                attachment.res_name = record.display_name
            else:
                attachment.res_name = False

    @api.model
    def _storage(self):
        return self.env['ir.config_parameter'].sudo().get_param('ir_attachment.location', 'file')

    @api.model
    def _filestore(self):
        return config.filestore(self._cr.dbname)

    @api.model
    def _get_storage_domain(self):
        # domain to retrieve the attachments to migrate
        return {
            'db': [('store_fname', '!=', False)],
            'file': [('db_datas', '!=', False)],
        }[self._storage()]

    @api.model
    def force_storage(self):
        """Force all attachments to be stored in the currently configured storage"""
        if not self.env.is_admin():
            raise AccessError(_('Only administrators can execute this action.'))

        # Migrate only binary attachments and bypass the res_field automatic
        # filter added in _search override
        self.search(expression.AND([
            self._get_storage_domain(),
            ['&', ('type', '=', 'binary'), '|', ('res_field', '=', False), ('res_field', '!=', False)]
        ]))._migrate()

    def _migrate(self):
        record_count = len(self)
        storage = self._storage().upper()
        for index, attach in enumerate(self):
            _logger.debug("Migrate attachment %s/%s to %s", index + 1, record_count, storage)
            # pass mimetype, to avoid recomputation
            attach.write({'raw': attach.raw, 'mimetype': attach.mimetype})

    @api.model
    def _full_path(self, path):
        # sanitize path
        path = re.sub('[.]', '', path)
        path = path.strip('/\\')
        return os.path.join(self._filestore(), path)

    @api.model
    def _get_path(self, bin_data, sha):
        # retro compatibility
        fname = sha[:3] + '/' + sha
        full_path = self._full_path(fname)
        if os.path.isfile(full_path):
            return fname, full_path        # keep existing path

        # scatter files across 256 dirs
        # we use '/' in the db (even on windows)
        fname = sha[:2] + '/' + sha
        full_path = self._full_path(fname)
        dirname = os.path.dirname(full_path)
        if not os.path.isdir(dirname):
            os.makedirs(dirname, exist_ok=True)
        # prevent sha-1 collision
        if os.path.isfile(full_path) and not self._same_content(bin_data, full_path):
            raise UserError(_("The attachment collides with an existing file."))
        return fname, full_path

    @api.model
    def _file_read(self, fname):
        assert isinstance(self, IrAttachment)
        full_path = self._full_path(fname)
        try:
            with open(full_path, 'rb') as f:
                return f.read()
        except (IOError, OSError):
            _logger.info("_read_file reading %s", full_path, exc_info=True)
        return b''

    @api.model
    def _file_write(self, bin_value, checksum):
        assert isinstance(self, IrAttachment)
        fname, full_path = self._get_path(bin_value, checksum)
        if not os.path.exists(full_path):
            try:
                with open(full_path, 'wb') as fp:
                    fp.write(bin_value)
                # add fname to checklist, in case the transaction aborts
                self._mark_for_gc(fname)
            except IOError:
                _logger.info("_file_write writing %s", full_path, exc_info=True)
        return fname

    @api.model
    def _file_delete(self, fname):
        # simply add fname to checklist, it will be garbage-collected later
        self._mark_for_gc(fname)

    def _mark_for_gc(self, fname):
        """ Add ``fname`` in a checklist for the filestore garbage collection. """
        assert isinstance(self, IrAttachment)
        fname = re.sub('[.]', '', fname).strip('/\\')
        # we use a spooldir: add an empty file in the subdirectory 'checklist'
        full_path = os.path.join(self._full_path('checklist'), fname)
        if not os.path.exists(full_path):
            dirname = os.path.dirname(full_path)
            if not os.path.isdir(dirname):
                with contextlib.suppress(OSError):
                    os.makedirs(dirname)
            open(full_path, 'ab').close()

    @api.autovacuum
    def _gc_file_store(self):
        """ Perform the garbage collection of the filestore. """
        assert isinstance(self, IrAttachment)
        if self._storage() != 'file':
            return

        # Continue in a new transaction. The LOCK statement below must be the
        # first one in the current transaction, otherwise the database snapshot
        # used by it may not contain the most recent changes made to the table
        # ir_attachment! Indeed, if concurrent transactions create attachments,
        # the LOCK statement will wait until those concurrent transactions end.
        # But this transaction will not see the new attachements if it has done
        # other requests before the LOCK (like the method _storage() above).
        cr = self._cr
        cr.commit()

        # prevent all concurrent updates on ir_attachment while collecting,
        # but only attempt to grab the lock for a little bit, otherwise it'd
        # start blocking other transactions. (will be retried later anyway)
        cr.execute("SET LOCAL lock_timeout TO '10s'")
        try:
            cr.execute("LOCK ir_attachment IN SHARE MODE")
        except psycopg2.errors.LockNotAvailable:
            cr.rollback()
            return False

        self._gc_file_store_unsafe()

        # commit to release the lock
        cr.commit()

    def _gc_file_store_unsafe(self):
        # retrieve the file names from the checklist
        checklist = {}
        for dirpath, _, filenames in os.walk(self._full_path('checklist')):
            dirname = os.path.basename(dirpath)
            for filename in filenames:
                fname = "%s/%s" % (dirname, filename)
                checklist[fname] = os.path.join(dirpath, filename)

        # Clean up the checklist. The checklist is split in chunks and files are garbage-collected
        # for each chunk.
        removed = 0
        for names in self.env.cr.split_for_in_conditions(checklist):
            # determine which files to keep among the checklist
            self.env.cr.execute("SELECT store_fname FROM ir_attachment WHERE store_fname IN %s", [names])
            whitelist = set(row[0] for row in self.env.cr.fetchall())

            # remove garbage files, and clean up checklist
            for fname in names:
                filepath = checklist[fname]
                if fname not in whitelist:
                    try:
                        os.unlink(self._full_path(fname))
                        _logger.debug("_file_gc unlinked %s", self._full_path(fname))
                        removed += 1
                    except (OSError, IOError):
                        _logger.info("_file_gc could not unlink %s", self._full_path(fname), exc_info=True)
                with contextlib.suppress(OSError):
                    os.unlink(filepath)

        _logger.info("filestore gc %d checked, %d removed", len(checklist), removed)

    @api.depends('store_fname', 'db_datas', 'file_size')
    @api.depends_context('bin_size')
    def _compute_datas(self):
        if self._context.get('bin_size'):
            for attach in self:
                attach.datas = human_size(attach.file_size)
            return

        for attach in self:
            attach.datas = base64.b64encode(attach.raw or b'')

    @api.depends('store_fname', 'db_datas')
    def _compute_raw(self):
        for attach in self:
            if attach.store_fname:
                attach.raw = attach._file_read(attach.store_fname)
            else:
                attach.raw = attach.db_datas

    def _inverse_raw(self):
        self._set_attachment_data(lambda a: a.raw or b'')

    def _inverse_datas(self):
        self._set_attachment_data(lambda attach: base64.b64decode(attach.datas or b''))

    def _set_attachment_data(self, asbytes):
        for attach in self:
            # compute the fields that depend on datas
            bin_data = asbytes(attach)
            vals = self._get_datas_related_values(bin_data, attach.mimetype)

            # take current location in filestore to possibly garbage-collect it
            fname = attach.store_fname
            # write as superuser, as user probably does not have write access
            super(IrAttachment, attach.sudo()).write(vals)
            if fname:
                self._file_delete(fname)

    def _get_datas_related_values(self, data, mimetype):
        checksum = self._compute_checksum(data)
        try:
            index_content = self._index(data, mimetype, checksum=checksum)
        except TypeError:
            index_content = self._index(data, mimetype)
        values = {
            'file_size': len(data),
            'checksum': checksum,
            'index_content': index_content,
            'store_fname': False,
            'db_datas': data,
        }
        if data and self._storage() != 'db':
            values['store_fname'] = self._file_write(data, values['checksum'])
            values['db_datas'] = False
        return values

    def _compute_checksum(self, bin_data):
        """ compute the checksum for the given datas
            :param bin_data : datas in its binary form
        """
        # an empty file has a checksum too (for caching)
        return hashlib.sha1(bin_data or b'').hexdigest()

    @api.model
    def _same_content(self, bin_data, filepath):
        BLOCK_SIZE = 1024
        with open(filepath, 'rb') as fd:
            i = 0
            while True:
                data = fd.read(BLOCK_SIZE)
                if data != bin_data[i * BLOCK_SIZE:(i + 1) * BLOCK_SIZE]:
                    return False
                if not data:
                    break
                i += 1
        return True

    def _compute_mimetype(self, values):
        """ compute the mimetype of the given values
            :param values : dict of values to create or write an ir_attachment
            :return mime : string indicating the mimetype, or application/octet-stream by default
        """
        mimetype = None
        if values.get('mimetype'):
            mimetype = values['mimetype']
        if not mimetype and values.get('name'):
            mimetype = mimetypes.guess_type(values['name'])[0]
        if not mimetype and values.get('url'):
            mimetype = mimetypes.guess_type(values['url'].split('?')[0])[0]
        if not mimetype or mimetype == 'application/octet-stream':
            raw = None
            if values.get('raw'):
                raw = values['raw']
            elif values.get('datas'):
                raw = base64.b64decode(values['datas'])
            if raw:
                mimetype = guess_mimetype(raw)
        return mimetype and mimetype.lower() or 'application/octet-stream'

    def _postprocess_contents(self, values):
        ICP = self.env['ir.config_parameter'].sudo().get_param
        supported_subtype = ICP('base.image_autoresize_extensions', 'png,jpeg,bmp,tiff').split(',')

        mimetype = values['mimetype'] = self._compute_mimetype(values)
        _type, _match, _subtype = mimetype.partition('/')
        is_image_resizable = _type == 'image' and _subtype in supported_subtype
        if is_image_resizable and (values.get('datas') or values.get('raw')):
            is_raw = values.get('raw')

            # Can be set to 0 to skip the resize
            max_resolution = ICP('base.image_autoresize_max_px', '1920x1920')
            if str2bool(max_resolution, True):
                try:
                    img = False
                    if is_raw:
                        img = ImageProcess(values['raw'], verify_resolution=False)
                    else:  # datas
                        img = ImageProcess(base64.b64decode(values['datas']), verify_resolution=False)

                    if not img.image:
                        _logger.info('Post processing ignored : Empty source, SVG, or WEBP')
                        return values

                    w, h = img.image.size
                    nw, nh = map(int, max_resolution.split('x'))
                    if w > nw or h > nh:
                        img = img.resize(nw, nh)
                        quality = int(ICP('base.image_autoresize_quality', 80))
                        image_data = img.image_quality(quality=quality)
                        if is_raw:
                            values['raw'] = image_data
                        else:
                            values['datas'] = base64.b64encode(image_data)
                except UserError as e:
                    # Catch error during test where we provide fake image
                    # raise UserError(_("This file could not be decoded as an image file. Please try with a different file."))
                    _logger.info('Post processing ignored : %s', e)
        return values

    def _check_contents(self, values):
        mimetype = values['mimetype'] = self._compute_mimetype(values)
        xml_like = 'ht' in mimetype or ( # hta, html, xhtml, etc.
                'xml' in mimetype and    # other xml (svg, text/xml, etc)
                not mimetype.startswith('application/vnd.openxmlformats'))  # exception for Office formats
        force_text = xml_like and (
            self.env.context.get('attachments_mime_plainxml') or
            not self.env['ir.ui.view'].sudo(False).check_access_rights('write', False))
        if force_text:
            values['mimetype'] = 'text/plain'
        if not self.env.context.get('image_no_postprocess'):
            values = self._postprocess_contents(values)
        return values

    @api.model
    def _index(self, bin_data, file_type, checksum=None):
        """ compute the index content of the given binary data.
            This is a python implementation of the unix command 'strings'.
            :param bin_data : datas in binary form
            :return index_content : string containing all the printable character of the binary data
        """
        index_content = False
        if file_type:
            index_content = file_type.split('/')[0]
            if index_content == 'text': # compute index_content only for text type
                words = re.findall(b"[\x20-\x7E]{4,}", bin_data)
                index_content = b"\n".join(words).decode('ascii')
        return index_content

    @api.model
    def get_serving_groups(self):
        """ An ir.attachment record may be used as a fallback in the
        http dispatch if its type field is set to "binary" and its url
        field is set as the request's url. Only the groups returned by
        this method are allowed to create and write on such records.
        """
        return ['base.group_system']

    name = fields.Char('Name', required=True)
    description = fields.Text('Description')
    res_name = fields.Char('Resource Name', compute='_compute_res_name')
    res_model = fields.Char('Resource Model', readonly=True)
    res_field = fields.Char('Resource Field', readonly=True)
    res_id = fields.Many2oneReference('Resource ID', model_field='res_model',
                                      readonly=True)
    company_id = fields.Many2one('res.company', string='Company', change_default=True,
                                 default=lambda self: self.env.company)
    type = fields.Selection([('url', 'URL'), ('binary', 'File')],
                            string='Type', required=True, default='binary', change_default=True,
                            help="You can either upload a file from your computer or copy/paste an internet link to your file.")
    url = fields.Char('Url', index='btree_not_null', size=1024)
    public = fields.Boolean('Is public document')

    # for external access
    access_token = fields.Char('Access Token', groups="base.group_user")

    # the field 'datas' is computed and may use the other fields below
    raw = fields.Binary(string="File Content (raw)", compute='_compute_raw', inverse='_inverse_raw')
    datas = fields.Binary(string='File Content (base64)', compute='_compute_datas', inverse='_inverse_datas')
    db_datas = fields.Binary('Database Data', attachment=False)
    store_fname = fields.Char('Stored Filename', index=True, unaccent=False)
    file_size = fields.Integer('File Size', readonly=True)
    checksum = fields.Char("Checksum/SHA1", size=40, readonly=True)
    mimetype = fields.Char('Mime Type', readonly=True)
    index_content = fields.Text('Indexed Content', readonly=True, prefetch=False)

    def _auto_init(self):
        res = super(IrAttachment, self)._auto_init()
        tools.create_index(self._cr, 'ir_attachment_res_idx',
                           self._table, ['res_model', 'res_id'])
        return res

    @api.constrains('type', 'url')
    def _check_serving_attachments(self):
        if self.env.is_admin():
            return
        for attachment in self:
            # restrict writing on attachments that could be served by the
            # ir.http's dispatch exception handling
            # XDO note: this should be done in check(write), constraints for access rights?
            # XDO note: if read on sudo, read twice, one for constraints, one for _inverse_datas as user
            if attachment.type == 'binary' and attachment.url:
                has_group = self.env.user.has_group
                if not any(has_group(g) for g in attachment.get_serving_groups()):
                    raise ValidationError(_("Sorry, you are not allowed to write on this document"))

    @api.model
    def check(self, mode, values=None):
        """ Restricts the access to an ir.attachment, according to referred mode """
        if self.env.is_superuser():
            return True
        # Always require an internal user (aka, employee) to access to a attachment
        if not (self.env.is_admin() or self.env.user._is_internal()):
            raise AccessError(_("Sorry, you are not allowed to access this document."))
        # collect the records to check (by model)
        model_ids = defaultdict(set)            # {model_name: set(ids)}
        if self:
            # DLE P173: `test_01_portal_attachment`
            self.env['ir.attachment'].flush_model(['res_model', 'res_id', 'create_uid', 'public', 'res_field'])
            self._cr.execute('SELECT res_model, res_id, create_uid, public, res_field FROM ir_attachment WHERE id IN %s', [tuple(self.ids)])
            for res_model, res_id, create_uid, public, res_field in self._cr.fetchall():
                if public and mode == 'read':
                    continue
                if not self.env.is_system():
                    if not res_id and create_uid != self.env.uid:
                        raise AccessError(_("Sorry, you are not allowed to access this document."))
                    if res_field:
                        field = self.env[res_model]._fields[res_field]
                        if field.groups:
                            if not self.env.user.user_has_groups(field.groups):
                                raise AccessError(_("Sorry, you are not allowed to access this document."))
                if not (res_model and res_id):
                    continue
                model_ids[res_model].add(res_id)
        if values and values.get('res_model') and values.get('res_id'):
            model_ids[values['res_model']].add(values['res_id'])

        # check access rights on the records
        for res_model, res_ids in model_ids.items():
            # ignore attachments that are not attached to a resource anymore
            # when checking access rights (resource was deleted but attachment
            # was not)
            if res_model not in self.env:
                continue
            if res_model == 'res.users' and len(res_ids) == 1 and self.env.uid == list(res_ids)[0]:
                # by default a user cannot write on itself, despite the list of writeable fields
                # e.g. in the case of a user inserting an image into his image signature
                # we need to bypass this check which would needlessly throw us away
                continue
            records = self.env[res_model].browse(res_ids).exists()
            # For related models, check if we can write to the model, as unlinking
            # and creating attachments can be seen as an update to the model
            access_mode = 'write' if mode in ('create', 'unlink') else mode
            records.check_access_rights(access_mode)
            records.check_access_rule(access_mode)

    @api.model
    def _filter_attachment_access(self, attachment_ids):
        """Filter the given attachment to return only the records the current user have access to.

        :param attachment_ids: List of attachment ids we want to filter
        :return: <ir.attachment> the current user have access to
        """
        ret_attachments = self.env['ir.attachment']
        attachments = self.browse(attachment_ids)
        if not attachments.check_access_rights('read', raise_exception=False):
            return ret_attachments

        for attachment in attachments.sudo():
            # Use SUDO here to not raise an error during the prefetch
            # And then drop SUDO right to check if we can access it
            try:
                attachment.sudo(False).check('read')
                ret_attachments |= attachment
            except AccessError:
                continue
        return ret_attachments

    @api.model
    def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):
        # add res_field=False in domain if not present; the arg[0] trick below
        # works for domain items and '&'/'|'/'!' operators too
        disable_binary_fields_attachments = False
        if not self.env.context.get('skip_res_field_check') and not any(arg[0] in ('id', 'res_field') for arg in domain):
            disable_binary_fields_attachments = True
            domain = [('res_field', '=', False)] + domain

        if self.env.is_superuser():
            # rules do not apply for the superuser
            return super()._search(domain, offset, limit, order, access_rights_uid)

        # For attachments, the permissions of the document they are attached to
        # apply, so we must remove attachments for which the user cannot access
        # the linked document. For the sake of performance, fetch the fields to
        # determine those permissions within the same SQL query.
        self.flush_model(['res_model', 'res_id', 'res_field', 'public', 'create_uid'])
        query = super()._search(domain, offset, limit, order, access_rights_uid)
        query_str, params = query.select(
            f'"{self._table}"."id"',
            f'"{self._table}"."res_model"',
            f'"{self._table}"."res_id"',
            f'"{self._table}"."res_field"',
            f'"{self._table}"."public"',
            f'"{self._table}"."create_uid"',
        )
        self.env.cr.execute(query_str, params)
        rows = self.env.cr.fetchall()

        # determine permissions based on linked records
        all_ids = []
        allowed_ids = set()
        model_attachments = defaultdict(lambda: defaultdict(set))   # {res_model: {res_id: set(ids)}}
        for id_, res_model, res_id, res_field, public, create_uid in rows:
            all_ids.append(id_)
            if public:
                allowed_ids.add(id_)
                continue
            if not res_id and (self.env.is_system() or create_uid == self.env.uid):
                allowed_ids.add(id_)
                continue
            if not (res_field and disable_binary_fields_attachments) and res_model and res_id:
                model_attachments[res_model][res_id].add(id_)

        # check permissions on records model by model
        for res_model, targets in model_attachments.items():
            if res_model not in self.env:
                allowed_ids.update(id_ for ids in targets.values() for id_ in ids)
                continue
            if not self.env[res_model].check_access_rights('read', False):
                continue
            # filter ids according to what access rules permit
            ResModel = self.env[res_model].with_context(active_test=False)
            for res_id in ResModel.search([('id', 'in', list(targets))])._ids:
                allowed_ids.update(targets[res_id])

        # filter out all_ids by keeping allowed_ids only
        result = [id_ for id_ in all_ids if id_ in allowed_ids]

        # If the original search reached the limit, it is important the
        # filtered record set does so too. When a JS view receive a
        # record set whose length is below the limit, it thinks it
        # reached the last page. To avoid an infinite recursion due to the
        # permission checks the sub-call need to be aware of the number of
        # expected records to retrieve
        if len(all_ids) == limit and len(result) < self._context.get('need', limit):
            need = self._context.get('need', limit) - len(result)
            more_ids = self.with_context(need=need)._search(
                domain, offset + len(all_ids), limit, order, access_rights_uid,
            )
            result.extend(list(more_ids)[:limit - len(result)])

        return self.browse(result)._as_query(order)

    def write(self, vals):
        self.check('write', values=vals)
        # remove computed field depending of datas
        for field in ('file_size', 'checksum', 'store_fname'):
            vals.pop(field, False)
        if 'mimetype' in vals or 'datas' in vals or 'raw' in vals:
            vals = self._check_contents(vals)
        return super(IrAttachment, self).write(vals)

    def copy(self, default=None):
        if not (default or {}).keys() & {'datas', 'db_datas', 'raw'}:
            # ensure the content is kept and recomputes checksum/store_fname
            default = dict(default or {}, raw=self.raw)
        return super(IrAttachment, self).copy(default)

    def unlink(self):
        if not self:
            return True
        self.check('unlink')

        # First delete in the database, *then* in the filesystem if the
        # database allowed it. Helps avoid errors when concurrent transactions
        # are deleting the same file, and some of the transactions are
        # rolled back by PostgreSQL (due to concurrent updates detection).
        to_delete = set(attach.store_fname for attach in self if attach.store_fname)
        res = super(IrAttachment, self).unlink()
        for file_path in to_delete:
            self._file_delete(file_path)

        return res

    @api.model_create_multi
    def create(self, vals_list):
        record_tuple_set = set()

        # remove computed field depending of datas
        vals_list = [{
            key: value
            for key, value
            in vals.items()
            if key not in ('file_size', 'checksum', 'store_fname')
        } for vals in vals_list]

        for values in vals_list:
            values = self._check_contents(values)
            raw, datas = values.pop('raw', None), values.pop('datas', None)
            if raw or datas:
                if isinstance(raw, str):
                    # b64decode handles str input but raw needs explicit encoding
                    raw = raw.encode()
                values.update(self._get_datas_related_values(
                    raw or base64.b64decode(datas or b''),
                    values['mimetype']
                ))

            # 'check()' only uses res_model and res_id from values, and make an exists.
            # We can group the values by model, res_id to make only one query when
            # creating multiple attachments on a single record.
            record_tuple = (values.get('res_model'), values.get('res_id'))
            record_tuple_set.add(record_tuple)

        # don't use possible contextual recordset for check, see commit for details
        Attachments = self.browse()
        for res_model, res_id in record_tuple_set:
            Attachments.check('create', values={'res_model':res_model, 'res_id':res_id})
        return super().create(vals_list)

    def _post_add_create(self):
        pass

    def generate_access_token(self):
        tokens = []
        for attachment in self:
            if attachment.access_token:
                tokens.append(attachment.access_token)
                continue
            access_token = self._generate_access_token()
            attachment.write({'access_token': access_token})
            tokens.append(access_token)
        return tokens

    @api.model
    def create_unique(self, values_list):
        ids = []
        for values in values_list:
            # Create only if record does not already exist for checksum and size.
            try:
                bin_data = base64.b64decode(values.get('datas', '')) or False
            except binascii.Error:
                raise UserError(_("Attachment is not encoded in base64."))
            checksum = self._compute_checksum(bin_data)
            existing_domain = [
                ['id', '!=', False],  # No implicit condition on res_field.
                ['checksum', '=', checksum],
                ['file_size', '=', len(bin_data)],
                ['mimetype', '=', values['mimetype']],
            ]
            existing = self.sudo().search(existing_domain)
            if existing:
                for attachment in existing:
                    ids.append(attachment.id)
            else:
                attachment = self.create(values)
                ids.append(attachment.id)
        return ids

    def _generate_access_token(self):
        return str(uuid.uuid4())

    def validate_access(self, access_token):
        self.ensure_one()
        record_sudo = self.sudo()

        if access_token:
            tok = record_sudo.with_context(prefetch_fields=False).access_token
            valid_token = consteq(tok or '', access_token)
            if not valid_token:
                raise AccessError("Invalid access token")
            return record_sudo

        if record_sudo.with_context(prefetch_fields=False).public:
            return record_sudo

        if self.env.user.has_group('base.group_portal'):
            # Check the read access on the record linked to the attachment
            # eg: Allow to download an attachment on a task from /my/tasks/task_id
            self.check('read')
            return record_sudo

        return self

    @api.model
    def action_get(self):
        return self.env['ir.actions.act_window']._for_xml_id('base.action_attachment')

    @api.model
    def _get_serve_attachment(self, url, extra_domain=None, order=None):
        domain = [('type', '=', 'binary'), ('url', '=', url)] + (extra_domain or [])
        return self.search(domain, order=order, limit=1)

    @api.model
    def regenerate_assets_bundles(self):
        self.search([
            ('public', '=', True),
            ("url", "=like", "/web/assets/%"),
            ('res_model', '=', 'ir.ui.view'),
            ('res_id', '=', 0),
            ('create_uid', '=', SUPERUSER_ID),
        ]).unlink()
        self.env.registry.clear_cache('assets')

```

  File: models/ir_autovacuum.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import inspect
import logging
import warnings
import traceback

from odoo import api, models
from odoo.exceptions import AccessDenied

_logger = logging.getLogger(__name__)


def is_autovacuum(func):
    """ Return whether ``func`` is an autovacuum method. """
    return callable(func) and getattr(func, '_autovacuum', False)


class AutoVacuum(models.AbstractModel):
    """ Helper model to the ``@api.autovacuum`` method decorator. """
    _name = 'ir.autovacuum'
    _description = 'Automatic Vacuum'

    def _run_vacuum_cleaner(self):
        """
        Perform a complete database cleanup by safely calling every
        ``@api.autovacuum`` decorated method.
        """
        if not self.env.is_admin():
            raise AccessDenied()

        for model in self.env.values():
            cls = self.env.registry[model._name]
            for attr, func in inspect.getmembers(cls, is_autovacuum):
                _logger.debug('Calling %s.%s()', model, attr)
                try:
                    func(model)
                    self.env.cr.commit()
                except Exception:
                    _logger.exception("Failed %s.%s()", model, attr)
                    self.env.cr.rollback()

```

  File: models/ir_binary.py
  Content:
```
import logging
import werkzeug.http
from datetime import datetime
from mimetypes import guess_extension

from odoo import models
from odoo.exceptions import MissingError, UserError
from odoo.http import Stream, request
from odoo.tools import file_open, replace_exceptions
from odoo.tools.image import image_process, image_guess_size_from_field_name
from odoo.tools.mimetypes import guess_mimetype, get_extension


DEFAULT_PLACEHOLDER_PATH = 'web/static/img/placeholder.png'
_logger = logging.getLogger(__name__)


class IrBinary(models.AbstractModel):
    _name = 'ir.binary'
    _description = "File streaming helper model for controllers"

    def _find_record(
            self, xmlid=None, res_model='ir.attachment', res_id=None,
            access_token=None,
    ):
        """
        Find and return a record either using an xmlid either a model+id
        pair. This method is an helper for the ``/web/content`` and
        ``/web/image`` controllers and should not be used in other
        contextes.

        :param Optional[str] xmlid: xmlid of the record
        :param Optional[str] res_model: model of the record,
            ir.attachment by default.
        :param Optional[id] res_id: id of the record
        :param Optional[str] access_token: access token to use instead
            of the access rights and access rules.
        :returns: single record
        :raises MissingError: when no record was found.
        """
        record = None
        if xmlid:
            record = self.env.ref(xmlid, False)
        elif res_id is not None and res_model in self.env:
            record = self.env[res_model].browse(res_id).exists()
        if not record:
            raise MissingError(f"No record found for xmlid={xmlid}, res_model={res_model}, id={res_id}")

        record = self._find_record_check_access(record, access_token)
        return record

    def _find_record_check_access(self, record, access_token):
        if record._name == 'ir.attachment':
            return record.validate_access(access_token)

        record.check_access_rights('read')
        record.check_access_rule('read')
        return record

    def _record_to_stream(self, record, field_name):
        """
        Low level method responsible for the actual conversion from a
        model record to a stream. This method is an extensible hook for
        other modules. It is not meant to be directly called from
        outside or the ir.binary model.

        :param record: the record where to load the data from.
        :param str field_name: the binary field where to load the data
            from.
        :rtype: odoo.http.Stream
        """
        if record._name == 'ir.attachment' and field_name in ('raw', 'datas', 'db_datas'):
            return Stream.from_attachment(record)

        record.check_field_access_rights('read', [field_name])
        field_def = record._fields[field_name]

        # fields.Binary(attachment=False) or compute/related
        if not field_def.attachment or field_def.compute or field_def.related:
            return Stream.from_binary_field(record, field_name)

        # fields.Binary(attachment=True)
        field_attachment = self.env['ir.attachment'].sudo().search(
            domain=[('res_model', '=', record._name),
                    ('res_id', '=', record.id),
                    ('res_field', '=', field_name)],
            limit=1)
        if not field_attachment:
            raise MissingError("The related attachment does not exist.")
        return Stream.from_attachment(field_attachment)

    def _get_stream_from(
        self, record, field_name='raw', filename=None, filename_field='name',
        mimetype=None, default_mimetype='application/octet-stream',
    ):
        """
        Create a :class:odoo.http.Stream: from a record's binary field.

        :param record: the record where to load the data from.
        :param str field_name: the binary field where to load the data
            from.
        :param Optional[str] filename: when the stream is downloaded by
            a browser, what filename it should have on disk. By default
            it is ``{model}-{id}-{field}.{extension}``, the extension is
            determined thanks to mimetype.
        :param Optional[str] filename_field: like ``filename`` but use
            one of the record's char field as filename.
        :param Optional[str] mimetype: the data mimetype to use instead
            of the stored one (attachment) or the one determined by
            magic.
        :param str default_mimetype: the mimetype to use when the
            mimetype couldn't be determined. By default it is
            ``application/octet-stream``.
        :rtype: odoo.http.Stream
        """
        with replace_exceptions(ValueError, by=UserError(f'Expected singleton: {record}')):
            record.ensure_one()

        try:
            field_def = record._fields[field_name]
        except KeyError:
            raise UserError(f"Record has no field {field_name!r}.")
        if field_def.type != 'binary':
            raise UserError(
                f"Field {field_def!r} is type {field_def.type!r} but "
                f"it is only possible to stream Binary or Image fields."
            )

        stream = self._record_to_stream(record, field_name)

        if stream.type in ('data', 'path'):
            if mimetype:
                stream.mimetype = mimetype
            elif not stream.mimetype:
                if stream.type == 'data':
                    head = stream.data[:1024]
                else:
                    with open(stream.path, 'rb') as file:
                        head = file.read(1024)
                stream.mimetype = guess_mimetype(head, default=default_mimetype)

            if filename:
                stream.download_name = filename
            elif filename_field in record:
                stream.download_name = record[filename_field]
            if not stream.download_name:
                stream.download_name = f'{record._table}-{record.id}-{field_name}'

            stream.download_name = stream.download_name.replace('\n', '_').replace('\r', '_')
            if (not get_extension(stream.download_name)
                and stream.mimetype != 'application/octet-stream'):
                stream.download_name += guess_extension(stream.mimetype) or ''

        return stream

    def _get_image_stream_from(
        self, record, field_name='raw', filename=None, filename_field='name',
        mimetype=None, default_mimetype='image/png', placeholder=None,
        width=0, height=0, crop=False, quality=0,
    ):
        """
        Create a :class:odoo.http.Stream: from a record's binary field,
        equivalent of :meth:`~get_stream_from` but for images.

        In case the record does not exist or is not accessible, the
        alternative ``placeholder`` path is used instead. If not set,
        a path is determined via
        :meth:`~odoo.models.BaseModel._get_placeholder_filename` which
        ultimately fallbacks on ``web/static/img/placeholder.png``.

        In case the arguments ``width``, ``height``, ``crop`` or
        ``quality`` are given, the image will be post-processed and the
        ETags (the unique cache http header) will be updated
        accordingly. See also :func:`odoo.tools.image.image_process`.

        :param record: the record where to load the data from.
        :param str field_name: the binary field where to load the data
            from.
        :param Optional[str] filename: when the stream is downloaded by
            a browser, what filename it should have on disk. By default
            it is ``{table}-{id}-{field}.{extension}``, the extension is
            determined thanks to mimetype.
        :param Optional[str] filename_field: like ``filename`` but use
            one of the record's char field as filename.
        :param Optional[str] mimetype: the data mimetype to use instead
            of the stored one (attachment) or the one determined by
            magic.
        :param str default_mimetype: the mimetype to use when the
            mimetype couldn't be determined. By default it is
            ``image/png``.
        :param Optional[pathlike] placeholder: in case the image is not
            found or unaccessible, the path of an image to use instead.
            By default the record ``_get_placeholder_filename`` on the
            requested field or ``web/static/img/placeholder.png``.
        :param int width: if not zero, the width of the resized image.
        :param int height: if not zero, the height of the resized image.
        :param bool crop: if true, crop the image instead of rezising
            it.
        :param int quality: if not zero, the quality of the resized
            image.

        """
        stream = None
        try:
            stream = self._get_stream_from(
                record, field_name, filename, filename_field, mimetype,
                default_mimetype
            )
        except UserError:
            if request.params.get('download'):
                raise

        if not stream or stream.size == 0:
            if not placeholder:
                placeholder = record._get_placeholder_filename(field_name)
            stream = self._get_placeholder_stream(placeholder)

        if stream.type == 'url':
            return stream  # Rezising an external URL is not supported

        if (width, height) == (0, 0):
            width, height = image_guess_size_from_field_name(field_name)

        if isinstance(stream.etag, str):
            stream.etag += f'-{width}x{height}-crop={crop}-quality={quality}'
        if isinstance(stream.last_modified, (int, float)):
            stream.last_modified = datetime.fromtimestamp(stream.last_modified, tz=None)
        modified = werkzeug.http.is_resource_modified(
            request.httprequest.environ,
            etag=stream.etag if isinstance(stream.etag, str) else None,
            last_modified=stream.last_modified
        )

        if modified and (width or height or crop):
            if stream.type == 'path':
                with open(stream.path, 'rb') as file:
                    stream.type = 'data'
                    stream.path = None
                    stream.data = file.read()
            stream.data = image_process(
                stream.data,
                size=(width, height),
                crop=crop,
                quality=quality,
            )
            stream.size = len(stream.data)

        return stream

    def _get_placeholder_stream(self, path=None):
        if not path:
            path = DEFAULT_PLACEHOLDER_PATH
        return Stream.from_path(path, filter_ext=('.png', '.jpg'))

    def _placeholder(self, path=False):
        if not path:
            path = DEFAULT_PLACEHOLDER_PATH
        with file_open(path, 'rb', filter_ext=('.png', '.jpg')) as file:
            return file.read()

```

  File: models/ir_config_parameter.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
"""
Store database-specific configuration parameters
"""

import uuid
import logging

from odoo import api, fields, models, _
from odoo.exceptions import ValidationError
from odoo.tools import config, ormcache, mute_logger

_logger = logging.getLogger(__name__)

"""
A dictionary holding some configuration parameters to be initialized when the database is created.
"""
_default_parameters = {
    "database.secret": lambda: str(uuid.uuid4()),
    "database.uuid": lambda: str(uuid.uuid1()),
    "database.create_date": fields.Datetime.now,
    "web.base.url": lambda: "http://localhost:%s" % config.get('http_port'),
    "base.login_cooldown_after": lambda: 10,
    "base.login_cooldown_duration": lambda: 60,
}


class IrConfigParameter(models.Model):
    """Per-database storage of configuration key-value pairs."""
    _name = 'ir.config_parameter'
    _description = 'System Parameter'
    _rec_name = 'key'
    _order = 'key'
    _allow_sudo_commands = False

    key = fields.Char(required=True)
    value = fields.Text(required=True)

    _sql_constraints = [
        ('key_uniq', 'unique (key)', 'Key must be unique.')
    ]

    @mute_logger('odoo.addons.base.models.ir_config_parameter')
    def init(self, force=False):
        """
        Initializes the parameters listed in _default_parameters.
        It overrides existing parameters if force is ``True``.
        """
        # avoid prefetching during module installation, as the res_users table
        # may not have all prescribed columns
        self = self.with_context(prefetch_fields=False)
        for key, func in _default_parameters.items():
            # force=True skips search and always performs the 'if' body (because ids=False)
            params = self.sudo().search([('key', '=', key)])
            if force or not params:
                params.set_param(key, func())

    @api.model
    def get_param(self, key, default=False):
        """Retrieve the value for a given key.

        :param string key: The key of the parameter value to retrieve.
        :param string default: default value if parameter is missing.
        :return: The value of the parameter, or ``default`` if it does not exist.
        :rtype: string
        """
        self.check_access_rights('read')
        return self._get_param(key) or default

    @api.model
    @ormcache('key')
    def _get_param(self, key):
        # we bypass the ORM because get_param() is used in some field's depends,
        # and must therefore work even when the ORM is not ready to work
        self.flush_model(['key', 'value'])
        self.env.cr.execute("SELECT value FROM ir_config_parameter WHERE key = %s", [key])
        result = self.env.cr.fetchone()
        return result and result[0]

    @api.model
    def set_param(self, key, value):
        """Sets the value of a parameter.

        :param string key: The key of the parameter value to set.
        :param string value: The value to set.
        :return: the previous value of the parameter or False if it did
                 not exist.
        :rtype: string
        """
        param = self.search([('key', '=', key)])
        if param:
            old = param.value
            if value is not False and value is not None:
                if str(value) != old:
                    param.write({'value': value})
            else:
                param.unlink()
            return old
        else:
            if value is not False and value is not None:
                self.create({'key': key, 'value': value})
            return False

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache()
        return super(IrConfigParameter, self).create(vals_list)

    def write(self, vals):
        if 'key' in vals:
            illegal = _default_parameters.keys() & self.mapped('key')
            if illegal:
                raise ValidationError(_("You cannot rename config parameters with keys %s", ', '.join(illegal)))
        self.env.registry.clear_cache()
        return super(IrConfigParameter, self).write(vals)

    def unlink(self):
        self.env.registry.clear_cache()
        return super(IrConfigParameter, self).unlink()

    @api.ondelete(at_uninstall=False)
    def unlink_default_parameters(self):
        for record in self.filtered(lambda p: p.key in _default_parameters.keys()):
            raise ValidationError(_("You cannot delete the %s record.", record.key))

```

  File: models/ir_cron.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import logging
import threading
import time
import os
import psycopg2
import pytz
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from psycopg2 import sql

import odoo
from odoo import api, fields, models, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)

BASE_VERSION = odoo.modules.get_manifest('base')['version']
MAX_FAIL_TIME = timedelta(hours=5)  # chosen with a fair roll of the dice

# custom function to call instead of default PostgreSQL's `pg_notify`
ODOO_NOTIFY_FUNCTION = os.getenv('ODOO_NOTIFY_FUNCTION', 'pg_notify')


class BadVersion(Exception):
    pass

class BadModuleState(Exception):
    pass


_intervalTypes = {
    'days': lambda interval: relativedelta(days=interval),
    'hours': lambda interval: relativedelta(hours=interval),
    'weeks': lambda interval: relativedelta(days=7*interval),
    'months': lambda interval: relativedelta(months=interval),
    'minutes': lambda interval: relativedelta(minutes=interval),
}


class ir_cron(models.Model):
    """ Model describing cron jobs (also called actions or tasks).
    """

    # TODO: perhaps in the future we could consider a flag on ir.cron jobs
    # that would cause database wake-up even if the database has not been
    # loaded yet or was already unloaded (e.g. 'force_db_wakeup' or something)
    # See also odoo.cron

    _name = "ir.cron"
    _order = 'cron_name'
    _description = 'Scheduled Actions'
    _allow_sudo_commands = False

    ir_actions_server_id = fields.Many2one(
        'ir.actions.server', 'Server action',
        delegate=True, ondelete='restrict', required=True)
    cron_name = fields.Char('Name', compute='_compute_cron_name', store=True)
    user_id = fields.Many2one('res.users', string='Scheduler User', default=lambda self: self.env.user, required=True)
    active = fields.Boolean(default=True)
    interval_number = fields.Integer(default=1, help="Repeat every x.")
    interval_type = fields.Selection([('minutes', 'Minutes'),
                                      ('hours', 'Hours'),
                                      ('days', 'Days'),
                                      ('weeks', 'Weeks'),
                                      ('months', 'Months')], string='Interval Unit', default='months')
    numbercall = fields.Integer(string='Number of Calls', default=1, help='How many times the method is called,\na negative number indicates no limit.')
    doall = fields.Boolean(string='Repeat Missed', help="Specify if missed occurrences should be executed when the server restarts.")
    nextcall = fields.Datetime(string='Next Execution Date', required=True, default=fields.Datetime.now, help="Next planned execution date for this job.")
    lastcall = fields.Datetime(string='Last Execution Date', help="Previous time the cron ran successfully, provided to the job through the context on the `lastcall` key")
    priority = fields.Integer(default=5, help='The priority of the job, as an integer: 0 means higher priority, 10 means lower priority.')

    @api.depends('ir_actions_server_id.name')
    def _compute_cron_name(self):
        for cron in self.with_context(lang='en_US'):
            cron.cron_name = cron.ir_actions_server_id.name

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            vals['usage'] = 'ir_cron'
        if os.getenv('ODOO_NOTIFY_CRON_CHANGES'):
            self._cr.postcommit.add(self._notifydb)
        return super().create(vals_list)

    @api.model
    def default_get(self, fields_list):
        # only 'code' state is supported for cron job so set it as default
        if not self._context.get('default_state'):
            self = self.with_context(default_state='code')
        return super(ir_cron, self).default_get(fields_list)

    @api.onchange('active', 'interval_number')
    def _onchange_interval_number(self):
        if self.active and self.interval_number <= 0:
            self.active = False
            return {'warning': {
                'title': _("Scheduled action disabled"),
                'message': _("This scheduled action has been disabled because its interval number is not a strictly positive value.")}
            }

    def method_direct_trigger(self):
        self.check_access_rights('write')
        for cron in self:
            cron._try_lock()
            _logger.info('Manually starting job `%s`.', cron.name)
            cron.with_user(cron.user_id).with_context({'lastcall': cron.lastcall}).ir_actions_server_id.run()
            self.env.flush_all()
            _logger.info('Job `%s` done.', cron.name)
            cron.lastcall = fields.Datetime.now()
        return True

    @classmethod
    def _process_jobs(cls, db_name):
        """ Execute every job ready to be run on this database. """
        try:
            db = odoo.sql_db.db_connect(db_name)
            threading.current_thread().dbname = db_name
            with db.cursor() as cron_cr:
                cls._check_version(cron_cr)
                jobs = cls._get_all_ready_jobs(cron_cr)
                if not jobs:
                    return
                cls._check_modules_state(cron_cr, jobs)

                for job_id in (job['id'] for job in jobs):
                    try:
                        job = cls._acquire_one_job(cron_cr, (job_id,))
                    except psycopg2.extensions.TransactionRollbackError:
                        cron_cr.rollback()
                        _logger.debug("job %s has been processed by another worker, skip", job_id)
                        continue
                    if not job:
                        _logger.debug("another worker is processing job %s, skip", job_id)
                        continue
                    _logger.debug("job %s acquired", job_id)
                    # take into account overridings of _process_job() on that database
                    registry = odoo.registry(db_name)
                    registry[cls._name]._process_job(db, cron_cr, job)
                    cron_cr.commit()
                    _logger.debug("job %s updated and released", job_id)

        except BadVersion:
            _logger.warning('Skipping database %s as its base version is not %s.', db_name, BASE_VERSION)
        except BadModuleState:
            _logger.warning('Skipping database %s because of modules to install/upgrade/remove.', db_name)
        except psycopg2.ProgrammingError as e:
            if e.pgcode == '42P01':
                # Class 42 — Syntax Error or Access Rule Violation; 42P01: undefined_table
                # The table ir_cron does not exist; this is probably not an OpenERP database.
                _logger.warning('Tried to poll an undefined table on database %s.', db_name)
            else:
                raise
        except Exception:
            _logger.warning('Exception in cron:', exc_info=True)
        finally:
            if hasattr(threading.current_thread(), 'dbname'):
                del threading.current_thread().dbname

    @classmethod
    def _check_version(cls, cron_cr):
        """ Ensure the code version matches the database version """
        cron_cr.execute("""
            SELECT latest_version
            FROM ir_module_module
             WHERE name='base'
        """)
        (version,) = cron_cr.fetchone()
        if version is None:
            raise BadModuleState()
        if version != BASE_VERSION:
            raise BadVersion()

    @classmethod
    def _check_modules_state(cls, cr, jobs):
        """ Ensure no module is installing or upgrading """
        cr.execute("""
            SELECT COUNT(*)
            FROM ir_module_module
            WHERE state LIKE %s
        """, ['to %'])
        (changes,) = cr.fetchone()
        if not changes:
            return

        if not jobs:
            raise BadModuleState()

        oldest = min([
            fields.Datetime.from_string(job['nextcall'])
            for job in jobs
        ])
        if datetime.now() - oldest < MAX_FAIL_TIME:
            raise BadModuleState()

        # the cron execution failed around MAX_FAIL_TIME * 60 times (1 failure
        # per minute for 5h) in which case we assume that the crons are stuck
        # because the db has zombie states and we force a call to
        # reset_module_states.
        odoo.modules.reset_modules_state(cr.dbname)

    @classmethod
    def _get_all_ready_jobs(cls, cr):
        """ Return a list of all jobs that are ready to be executed """
        cr.execute("""
            SELECT *
            FROM ir_cron
            WHERE active = true
              AND numbercall != 0
              AND (nextcall <= (now() at time zone 'UTC')
                OR id in (
                    SELECT cron_id
                    FROM ir_cron_trigger
                    WHERE call_at <= (now() at time zone 'UTC')
                )
              )
            ORDER BY priority
        """)
        return cr.dictfetchall()

    @classmethod
    def _acquire_one_job(cls, cr, job_ids):
        """
        Acquire for update one job that is ready from the job_ids tuple.

        The jobs that have already been processed in this worker should
        be excluded from the tuple.

        This function raises a ``psycopg2.errors.SerializationFailure``
        when the ``nextcall`` of one of the job_ids is modified in
        another transaction. You should rollback the transaction and try
        again later.
        """

        # We have to make sure ALL jobs are executed ONLY ONCE no matter
        # how many cron workers may process them. The exlusion mechanism
        # is twofold: (i) prevent parallel processing of the same job,
        # and (ii) prevent re-processing jobs that have been processed
        # already.
        #
        # (i) is implemented via `LIMIT 1 FOR UPDATE SKIP LOCKED`, each
        # worker just acquire one available job at a time and lock it so
        # the other workers don't select it too.
        # (ii) is implemented via the `WHERE` statement, when a job has
        # been processed, its nextcall is updated to a date in the
        # future and the optional triggers are removed.
        #
        # Note about (ii): it is possible that a job becomes available
        # again quickly (e.g. high frequency or self-triggering cron).
        # This function doesn't prevent from acquiring that job multiple
        # times at different moments. This can block a worker on
        # executing a same job in loop. To prevent this problem, the
        # callee is responsible of providing a `job_ids` tuple without
        # the jobs it has executed already.
        #
        # An `UPDATE` lock type is the strongest row lock, it conflicts
        # with ALL other lock types. Among them the `KEY SHARE` row lock
        # which is implicitely aquired by foreign keys to prevent the
        # referenced record from being removed while in use. Because we
        # never delete acquired cron jobs, foreign keys are safe to
        # concurrently reference cron jobs. Hence, the `NO KEY UPDATE`
        # row lock is used, it is a weaker lock that does conflict with
        # everything BUT `KEY SHARE`.
        #
        # Learn more: https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS

        query = """
            SELECT *
            FROM ir_cron
            WHERE active = true
              AND numbercall != 0
              AND (nextcall <= (now() at time zone 'UTC')
                OR EXISTS (
                    SELECT cron_id
                    FROM ir_cron_trigger
                    WHERE call_at <= (now() at time zone 'UTC')
                      AND cron_id = ir_cron.id
                )
              )
              AND id in %s
            ORDER BY priority
            LIMIT 1 FOR NO KEY UPDATE SKIP LOCKED
        """
        try:
            cr.execute(query, [job_ids], log_exceptions=False)
        except psycopg2.extensions.TransactionRollbackError:
            # A serialization error can occur when another cron worker
            # commits the new `nextcall` value of a cron it just ran and
            # that commit occured just before this query. The error is
            # genuine and the job should be skipped in this cron worker.
            raise
        except Exception as exc:
            _logger.error("bad query: %s\nERROR: %s", query, exc)
            raise
        return cr.dictfetchone()

    @classmethod
    def _process_job(cls, db, cron_cr, job):
        """ Execute a cron job and re-schedule a call for later. """

        # Compute how many calls were missed and at what time we should
        # recall the cron next. In the example bellow, we fake a cron
        # with an interval of 30 (starting at 0) that was last executed
        # at 15 and that is executed again at 135.
        #
        #    0          60          120         180
        #  --|-----|-----|-----|-----|-----|-----|----> time
        #    1     2*    *     *     *  3  4
        #
        # 1: lastcall, the last time the cron was executed
        # 2: past_nextcall, the cron nextcall as seen from lastcall
        # *: missed_call, a total of 4 calls are missing
        # 3: now
        # 4: future_nextcall, the cron nextcall as seen from now

        if job['interval_number'] <= 0:
            _logger.error("Job %s %r has been disabled because its interval number is null or negative.", job['id'], job['cron_name'])
            cron_cr.execute("UPDATE ir_cron SET active=false WHERE id=%s", [job['id']])
            return

        with cls.pool.cursor() as job_cr:
            lastcall = fields.Datetime.to_datetime(job['lastcall'])
            interval = _intervalTypes[job['interval_type']](job['interval_number'])
            env = api.Environment(job_cr, job['user_id'], {'lastcall': lastcall})
            ir_cron = env[cls._name]

            # Use the user's timezone to compare and compute datetimes,
            # otherwise unexpected results may appear. For instance, adding
            # 1 month in UTC to July 1st at midnight in GMT+2 gives July 30
            # instead of August 1st!
            now = fields.Datetime.context_timestamp(ir_cron, datetime.utcnow())
            past_nextcall = fields.Datetime.context_timestamp(
                ir_cron, fields.Datetime.to_datetime(job['nextcall']))

            # Compute how many call were missed
            missed_call = past_nextcall
            missed_call_count = 0
            while missed_call <= now:
                missed_call += interval
                missed_call_count += 1
            future_nextcall = missed_call

            # Compute how many time we should run the cron
            effective_call_count = (
                     1 if not missed_call_count                    # run at least once
                else 1 if not job['doall']                         # run once for all
                else missed_call_count if job['numbercall'] == -1  # run them all
                else min(missed_call_count, job['numbercall'])     # run maximum numbercall times
            )
            call_count_left = max(job['numbercall'] - effective_call_count, -1)

            # The actual cron execution
            for call in range(effective_call_count):
                ir_cron._callback(job['cron_name'], job['ir_actions_server_id'], job['id'])

        # Update the cron with the information computed above
        cron_cr.execute("""
            UPDATE ir_cron
            SET nextcall=%s,
                numbercall=%s,
                lastcall=%s,
                active=%s
            WHERE id=%s
        """, [
            fields.Datetime.to_string(future_nextcall.astimezone(pytz.UTC)),
            call_count_left,
            fields.Datetime.to_string(now.astimezone(pytz.UTC)),
            job['active'] and bool(call_count_left),
            job['id'],
        ])

        cron_cr.execute("""
            DELETE FROM ir_cron_trigger
            WHERE cron_id = %s
              AND call_at < (now() at time zone 'UTC')
        """, [job['id']])

    @api.model
    def _callback(self, cron_name, server_action_id, job_id):
        """ Run the method associated to a given job. It takes care of logging
        and exception handling. Note that the user running the server action
        is the user calling this method. """
        try:
            if self.pool != self.pool.check_signaling():
                # the registry has changed, reload self in the new registry
                self.env.reset()
                self = self.env()[self._name]

            log_depth = (None if _logger.isEnabledFor(logging.DEBUG) else 1)
            odoo.netsvc.log(_logger, logging.DEBUG, 'cron.object.execute', (self._cr.dbname, self._uid, '*', cron_name, server_action_id), depth=log_depth)
            _logger.info('Starting job `%s`.', cron_name)
            start_time = time.time()
            self.env['ir.actions.server'].browse(server_action_id).run()
            self.env.flush_all()
            end_time = time.time()
            _logger.info('Job done: `%s` (%.3fs).', cron_name, end_time - start_time)
            if start_time and _logger.isEnabledFor(logging.DEBUG):
                _logger.debug('%.3fs (cron %s, server action %d with uid %d)', end_time - start_time, cron_name, server_action_id, self.env.uid)
            self.pool.signal_changes()
        except Exception as e:
            self.pool.reset_changes()
            _logger.exception("Call from cron %s for server action #%s failed in Job #%s",
                              cron_name, server_action_id, job_id)
            self._handle_callback_exception(cron_name, server_action_id, job_id, e)

    @api.model
    def _handle_callback_exception(self, cron_name, server_action_id, job_id, job_exception):
        """ Method called when an exception is raised by a job.

        Simply logs the exception and rollback the transaction. """
        self._cr.rollback()

    def _try_lock(self, lockfk=False):
        """Try to grab a dummy exclusive write-lock to the rows with the given ids,
           to make sure a following write() or unlink() will not block due
           to a process currently executing those cron tasks.

           :param lockfk: acquire a strong row lock which conflicts with
                          the lock aquired by foreign keys when they
                          reference this row.
        """
        if not self:
            return
        row_level_lock = "UPDATE" if lockfk else "NO KEY UPDATE"
        try:
            self._cr.execute(f"""
                SELECT id
                FROM "{self._table}"
                WHERE id IN %s
                FOR {row_level_lock} NOWAIT
            """, [tuple(self.ids)], log_exceptions=False)
        except psycopg2.OperationalError:
            self._cr.rollback()  # early rollback to allow translations to work for the user feedback
            raise UserError(_("Record cannot be modified right now: "
                              "This cron task is currently being executed and may not be modified "
                              "Please try again in a few minutes"))

    def write(self, vals):
        self._try_lock()
        if ('nextcall' in vals or vals.get('active')) and os.getenv('ODOO_NOTIFY_CRON_CHANGES'):
            self._cr.postcommit.add(self._notifydb)
        return super(ir_cron, self).write(vals)

    def unlink(self):
        self._try_lock(lockfk=True)
        return super(ir_cron, self).unlink()

    def try_write(self, values):
        try:
            with self._cr.savepoint():
                self._cr.execute(f"""
                    SELECT id
                    FROM "{self._table}"
                    WHERE id IN %s
                    FOR NO KEY UPDATE NOWAIT
                """, [tuple(self.ids)], log_exceptions=False)
        except psycopg2.OperationalError:
            pass
        else:
            return super(ir_cron, self).write(values)
        return False

    @api.model
    def toggle(self, model, domain):
        # Prevent deactivated cron jobs from being re-enabled through side effects on
        # neutralized databases.
        if self.env['ir.config_parameter'].sudo().get_param('database.is_neutralized'):
            return True

        active = bool(self.env[model].search_count(domain))
        return self.try_write({'active': active})

    def _trigger(self, at=None):
        """
        Schedule a cron job to be executed soon independently of its
        ``nextcall`` field value.

        By default the cron is scheduled to be executed in the next batch but
        the optional `at` argument may be given to delay the execution later
        with a precision down to 1 minute.

        The method may be called with a datetime or an iterable of datetime.
        The actual implementation is in :meth:`~._trigger_list`, which is the
        recommended method for overrides.

        :param Optional[Union[datetime.datetime, list[datetime.datetime]]] at:
            When to execute the cron, at one or several moments in time instead
            of as soon as possible.
        :return: the created triggers records
        :rtype: recordset
        """
        if at is None:
            at_list = [fields.Datetime.now()]
        elif isinstance(at, datetime):
            at_list = [at]
        else:
            at_list = list(at)
            assert all(isinstance(at, datetime) for at in at_list)

        return self._trigger_list(at_list)

    def _trigger_list(self, at_list):
        """
        Implementation of :meth:`~._trigger`.

        :param list[datetime.datetime] at_list:
            Execute the cron later, at precise moments in time.
        :return: the created triggers records
        :rtype: recordset
        """
        self.ensure_one()
        now = fields.Datetime.now()

        if not self.sudo().active:
            # skip triggers that would be ignored
            at_list = [at for at in at_list if at > now]

        if not at_list:
            return self.env['ir.cron.trigger']

        triggers = self.env['ir.cron.trigger'].sudo().create([
            {'cron_id': self.id, 'call_at': at}
            for at in at_list
        ])
        if _logger.isEnabledFor(logging.DEBUG):
            ats = ', '.join(map(str, at_list))
            _logger.debug("will execute '%s' at %s", self.sudo().name, ats)

        if min(at_list) <= now or os.getenv('ODOO_NOTIFY_CRON_CHANGES'):
            self._cr.postcommit.add(self._notifydb)
        return triggers

    def _notifydb(self):
        """ Wake up the cron workers
        The ODOO_NOTIFY_CRON_CHANGES environment variable allows to force the notifydb on both
        ir_cron modification and on trigger creation (regardless of call_at)
        """
        with odoo.sql_db.db_connect('postgres').cursor() as cr:
            query = sql.SQL("SELECT {}('cron_trigger', %s)").format(sql.Identifier(ODOO_NOTIFY_FUNCTION))
            cr.execute(query, [self.env.cr.dbname])
        _logger.debug("cron workers notified")


class ir_cron_trigger(models.Model):
    _name = 'ir.cron.trigger'
    _description = 'Triggered actions'
    _rec_name = 'cron_id'
    _allow_sudo_commands = False

    cron_id = fields.Many2one("ir.cron", index=True)
    call_at = fields.Datetime(index=True)

    @api.autovacuum
    def _gc_cron_triggers(self):
        self.search([('call_at', '<', datetime.now() + relativedelta(weeks=-1))]).unlink()

```

  File: models/ir_default.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import json

from odoo import api, fields, models, tools, _
from odoo.exceptions import ValidationError


class IrDefault(models.Model):
    """ User-defined default values for fields. """
    _name = 'ir.default'
    _description = 'Default Values'
    _rec_name = 'field_id'
    _allow_sudo_commands = False

    field_id = fields.Many2one('ir.model.fields', string="Field", required=True,
                               ondelete='cascade', index=True)
    user_id = fields.Many2one('res.users', string='User', ondelete='cascade', index=True,
                              help="If set, action binding only applies for this user.")
    company_id = fields.Many2one('res.company', string='Company', ondelete='cascade', index=True,
                                 help="If set, action binding only applies for this company")
    condition = fields.Char('Condition', help="If set, applies the default upon condition.")
    json_value = fields.Char('Default Value (JSON format)', required=True)

    @api.constrains('json_value')
    def _check_json_format(self):
        for record in self:
            try:
                json.loads(record.json_value)
            except json.JSONDecodeError:
                raise ValidationError(_('Invalid JSON format in Default Value field.'))

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache()
        return super(IrDefault, self).create(vals_list)

    def write(self, vals):
        if self:
            self.env.registry.clear_cache()
        return super(IrDefault, self).write(vals)

    def unlink(self):
        if self:
            self.env.registry.clear_cache()
        return super(IrDefault, self).unlink()

    @api.model
    def set(self, model_name, field_name, value, user_id=False, company_id=False, condition=False):
        """ Defines a default value for the given field. Any entry for the same
            scope (field, user, company) will be replaced. The value is encoded
            in JSON to be stored to the database.

            :param model_name:
            :param field_name:
            :param value:
            :param user_id: may be ``False`` for all users, ``True`` for the
                            current user, or any user id
            :param company_id: may be ``False`` for all companies, ``True`` for
                               the current user's company, or any company id
            :param condition: optional condition that restricts the
                              applicability of the default value; this is an
                              opaque string, but the client typically uses
                              single-field conditions in the form ``'key=val'``.
        """
        if user_id is True:
            user_id = self.env.uid
        if company_id is True:
            company_id = self.env.company.id

        # check consistency of model_name, field_name, and value
        try:
            model = self.env[model_name]
            field = model._fields[field_name]
            parsed = field.convert_to_cache(value, model)
            json_value = json.dumps(value, ensure_ascii=False)
        except KeyError:
            raise ValidationError(_("Invalid field %s.%s", model_name, field_name))
        except Exception:
            raise ValidationError(_("Invalid value for %s.%s: %s", model_name, field_name, value))
        if field.type == 'integer' and not (-2**31 < parsed < 2**31-1):
            raise ValidationError(_("Invalid value for %s.%s: %s is out of bounds (integers should be between -2,147,483,648 and 2,147,483,647)", model_name, field_name, value))

        # update existing default for the same scope, or create one
        field = self.env['ir.model.fields']._get(model_name, field_name)
        default = self.search([
            ('field_id', '=', field.id),
            ('user_id', '=', user_id),
            ('company_id', '=', company_id),
            ('condition', '=', condition),
        ])
        if default:
            # Avoid clearing the cache if nothing changes
            if default.json_value != json_value:
                default.write({'json_value': json_value})
        else:
            self.create({
                'field_id': field.id,
                'user_id': user_id,
                'company_id': company_id,
                'condition': condition,
                'json_value': json_value,
            })
        return True

    @api.model
    def _get(self, model_name, field_name, user_id=False, company_id=False, condition=False):
        """ Return the default value for the given field, user and company, or
            ``None`` if no default is available.

            :param model_name:
            :param field_name:
            :param user_id: may be ``False`` for all users, ``True`` for the
                            current user, or any user id
            :param company_id: may be ``False`` for all companies, ``True`` for
                               the current user's company, or any company id
            :param condition: optional condition that restricts the
                              applicability of the default value; this is an
                              opaque string, but the client typically uses
                              single-field conditions in the form ``'key=val'``.
        """
        if user_id is True:
            user_id = self.env.uid
        if company_id is True:
            company_id = self.env.company.id

        field = self.env['ir.model.fields']._get(model_name, field_name)
        default = self.search([
            ('field_id', '=', field.id),
            ('user_id', '=', user_id),
            ('company_id', '=', company_id),
            ('condition', '=', condition),
        ], limit=1)
        return json.loads(default.json_value) if default else None

    @api.model
    @tools.ormcache('self.env.uid', 'self.env.company.id', 'model_name', 'condition')
    # Note about ormcache invalidation: it is not needed when deleting a field,
    # a user, or a company, as the corresponding defaults will no longer be
    # requested. It must only be done when a user's company is modified.
    def _get_model_defaults(self, model_name, condition=False):
        """ Return the available default values for the given model (for the
            current user), as a dict mapping field names to values.
        """
        cr = self.env.cr
        query = """ SELECT f.name, d.json_value
                    FROM ir_default d
                    JOIN ir_model_fields f ON d.field_id=f.id
                    WHERE f.model=%s
                        AND (d.user_id IS NULL OR d.user_id=%s)
                        AND (d.company_id IS NULL OR d.company_id=%s)
                        AND {}
                    ORDER BY d.user_id, d.company_id, d.id
                """
        # self.env.company is empty when there is no user (controllers with auth=None)
        params = [model_name, self.env.uid, self.env.company.id or None]
        if condition:
            query = query.format("d.condition=%s")
            params.append(condition)
        else:
            query = query.format("d.condition IS NULL")
        cr.execute(query, params)
        result = {}
        for row in cr.fetchall():
            # keep the highest priority default for each field
            if row[0] not in result:
                result[row[0]] = json.loads(row[1])
        return result

    @api.model
    def discard_records(self, records):
        """ Discard all the defaults of many2one fields using any of the given
            records.
        """
        json_vals = [json.dumps(id) for id in records.ids]
        domain = [('field_id.ttype', '=', 'many2one'),
                  ('field_id.relation', '=', records._name),
                  ('json_value', 'in', json_vals)]
        return self.search(domain).unlink()

    @api.model
    def discard_values(self, model_name, field_name, values):
        """ Discard all the defaults for any of the given values. """
        field = self.env['ir.model.fields']._get(model_name, field_name)
        json_vals = [json.dumps(value, ensure_ascii=False) for value in values]
        domain = [('field_id', '=', field.id), ('json_value', 'in', json_vals)]
        return self.search(domain).unlink()

```

  File: models/ir_demo.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models
from odoo.modules.loading import force_demo
from odoo.addons.base.models.ir_module import assert_log_admin_access


class IrDemo(models.TransientModel):

    _name = 'ir.demo'
    _description = 'Demo'

    @assert_log_admin_access
    def install_demo(self):
        force_demo(self.env)
        return {
            'type': 'ir.actions.act_url',
            'target': 'self',
            'url': '/web',
        }

```

  File: models/ir_demo_failure.py
  Content:
```
from odoo import api, fields, models


class DemoFailure(models.TransientModel):
    """ Stores modules for which we could not install demo data
    """
    _name = 'ir.demo_failure'
    _description = 'Demo failure'

    module_id = fields.Many2one('ir.module.module', required=True, string="Module")
    error = fields.Char(string="Error")
    wizard_id = fields.Many2one('ir.demo_failure.wizard')

class DemoFailureWizard(models.TransientModel):
    _name = 'ir.demo_failure.wizard'
    _description = 'Demo Failure wizard'

    failure_ids = fields.One2many(
        'ir.demo_failure', 'wizard_id', readonly=True,
        string="Demo Installation Failures"
    )
    failures_count = fields.Integer(compute='_compute_failures_count')

    @api.depends('failure_ids')
    def _compute_failures_count(self):
        for r in self:
            r.failures_count = len(r.failure_ids)

    def done(self):
        # pylint: disable=next-method-called
        return self.env['ir.module.module'].next()

```

  File: models/ir_exports.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import fields, models


class IrExports(models.Model):
    _name = "ir.exports"
    _description = 'Exports'
    _order = 'name'

    name = fields.Char(string='Export Name')
    resource = fields.Char(index=True)
    export_fields = fields.One2many('ir.exports.line', 'export_id', string='Export ID', copy=True)


class IrExportsLine(models.Model):
    _name = 'ir.exports.line'
    _description = 'Exports Line'
    _order = 'id'

    name = fields.Char(string='Field Name')
    export_id = fields.Many2one('ir.exports', string='Export', index=True, ondelete='cascade')

```

  File: models/ir_fields.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import json
import functools
import itertools

import psycopg2
import pytz

from odoo import api, Command, fields, models, _
from odoo.tools import ustr, OrderedSet
from odoo.tools.translate import code_translations, _lt

REFERENCING_FIELDS = {None, 'id', '.id'}
def only_ref_fields(record):
    return {k: v for k, v in record.items() if k in REFERENCING_FIELDS}
def exclude_ref_fields(record):
    return {k: v for k, v in record.items() if k not in REFERENCING_FIELDS}

# these lazy translations promise translations for ['yes', 'no', 'true', 'false']
BOOLEAN_TRANSLATIONS = (
    _lt('yes'),
    _lt('no'),
    _lt('true'),
    _lt('false')
)

class ImportWarning(Warning):
    """ Used to send warnings upwards the stack during the import process """
    pass

class ConversionNotFound(ValueError):
    pass

class IrFieldsConverter(models.AbstractModel):
    _name = 'ir.fields.converter'
    _description = 'Fields Converter'

    @api.model
    def _format_import_error(self, error_type, error_msg, error_params=(), error_args=None):
        # sanitize error params for later formatting by the import system
        sanitize = lambda p: p.replace('%', '%%') if isinstance(p, str) else p
        if error_params:
            if isinstance(error_params, str):
                error_params = sanitize(error_params)
            elif isinstance(error_params, dict):
                error_params = {k: sanitize(v) for k, v in error_params.items()}
            elif isinstance(error_params, tuple):
                error_params = tuple(sanitize(v) for v in error_params)
        return error_type(error_msg % error_params, error_args)

    def _get_import_field_path(self, field, value):
        """ Rebuild field path for import error attribution to the right field.
        This method uses the 'parent_fields_hierarchy' context key built during treatment of one2many fields
        (_str_to_one2many). As the field to import is the last of the chain (child_id/child_id2/field_to_import),
        we need to retrieve the complete hierarchy in case of error in order to assign the error to the correct
        column in the import UI.

        :param (str) field: field in which the value will be imported.
        :param (str or list) value:
            - str: in most of the case the value we want to import into a field is a string (or a number).
            - list: when importing into a one2may field, all the records to import are regrouped into a list of dict.
                E.g.: creating multiple partners: [{None: 'ChildA_1', 'type': 'Private address'}, {None: 'ChildA_2', 'type': 'Private address'}]
                where 'None' is the name. (because we can find a partner by his name, we don't need to specify the field.)

        The field_path value is computed based on the last field in the chain.
        for example,
            - path_field for 'Private address' at childA_1 is ['partner_id', 'type']
            - path_field for 'childA_1' is ['partner_id']

        So, by retrieving the correct field_path for each value to import, if errors are raised for those fields,
        we can the link the errors to the correct header-field couple in the import UI.
        """
        field_path = [field]
        parent_fields_hierarchy = self._context.get('parent_fields_hierarchy')
        if parent_fields_hierarchy:
            field_path = parent_fields_hierarchy + field_path

        field_path_value = value
        while isinstance(field_path_value, list):
            key = list(field_path_value[0].keys())[0]
            if key:
                field_path.append(key)
            field_path_value = field_path_value[0][key]
        return field_path

    @api.model
    def for_model(self, model, fromtype=str):
        """ Returns a converter object for the model. A converter is a
        callable taking a record-ish (a dictionary representing an odoo
        record with values of typetag ``fromtype``) and returning a converted
        records matching what :meth:`odoo.osv.orm.Model.write` expects.

        :param model: :class:`odoo.osv.orm.Model` for the conversion base
        :param fromtype:
        :returns: a converter callable
        :rtype: (record: dict, logger: (field, error) -> None) -> dict
        """
        # make sure model is new api
        model = self.env[model._name]

        converters = {
            name: self.to_field(model, field, fromtype)
            for name, field in model._fields.items()
        }

        def fn(record, log):
            converted = {}
            import_file_context = self.env.context.get('import_file')
            for field, value in record.items():
                if field in REFERENCING_FIELDS:
                    continue
                if not value:
                    converted[field] = False
                    continue
                try:
                    converted[field], ws = converters[field](value)
                    for w in ws:
                        if isinstance(w, str):
                            # wrap warning string in an ImportWarning for
                            # uniform handling
                            w = ImportWarning(w)
                        log(field, w)
                except (UnicodeEncodeError, UnicodeDecodeError) as e:
                    log(field, ValueError(str(e)))
                except ValueError as e:
                    if import_file_context:
                        # if the error is linked to a matching error, the error is a tuple
                        # E.g.:("Value X cannot be found for field Y at row 1", {
                        #   'more_info': {},
                        #   'value': 'X',
                        #   'field': 'Y',
                        #   'field_path': child_id/Y,
                        # })
                        # In order to link the error to the correct header-field couple in the import UI, we need to add
                        # the field path to the additional error info.
                        # As we raise the deepest child in error, we need to add the field path only for the deepest
                        # error in the import recursion. (if field_path is given, don't overwrite it)
                        error_info = len(e.args) > 1 and e.args[1]
                        if error_info and not error_info.get('field_path'):  # only raise the deepest child in error
                            error_info['field_path'] = self._get_import_field_path(field, value)
                    log(field, e)
            return converted

        return fn

    @api.model
    def to_field(self, model, field, fromtype=str):
        """ Fetches a converter for the provided field object, from the
        specified type.

        A converter is simply a callable taking a value of type ``fromtype``
        (or a composite of ``fromtype``, e.g. list or dict) and returning a
        value acceptable for a write() on the field ``field``.

        By default, tries to get a method on itself with a name matching the
        pattern ``_$fromtype_to_$field.type`` and returns it.

        Converter callables can either return a value and a list of warnings
        to their caller or raise ``ValueError``, which will be interpreted as a
        validation & conversion failure.

        ValueError can have either one or two parameters. The first parameter
        is mandatory, **must** be a unicode string and will be used as the
        user-visible message for the error (it should be translatable and
        translated). It can contain a ``field`` named format placeholder so the
        caller can inject the field's translated, user-facing name (@string).

        The second parameter is optional and, if provided, must be a mapping.
        This mapping will be merged into the error dictionary returned to the
        client.

        If a converter can perform its function but has to make assumptions
        about the data, it can send a warning to the user through adding an
        instance of :class:`~.ImportWarning` to the second value
        it returns. The handling of a warning at the upper levels is the same
        as ``ValueError`` above.

        :param model:
        :param field: field object to generate a value for
        :type field: :class:`odoo.fields.Field`
        :param fromtype: type to convert to something fitting for ``field``
        :type fromtype: type | str
        :return: a function (fromtype -> field.write_type), if a converter is found
        :rtype: Callable | None
        """
        assert isinstance(fromtype, (type, str))
        # FIXME: return None
        typename = fromtype.__name__ if isinstance(fromtype, type) else fromtype
        converter = getattr(self, '_%s_to_%s' % (typename, field.type), None)
        if not converter:
            return None
        return functools.partial(converter, model, field)

    def _str_to_json(self, model, field, value):
        try:
            return json.loads(value), []
        except ValueError:
            msg = _("'%s' does not seem to be a valid JSON for field '%%(field)s'")
            raise self._format_import_error(ValueError, msg, value)

    def _str_to_properties(self, model, field, value):
        msg = _("Unable to import field type '%s'  ", field.type)
        raise self._format_import_error(ValueError, msg)

    @api.model
    def _str_to_boolean(self, model, field, value):
        # all translatables used for booleans
        # potentially broken casefolding? What about locales?
        trues = set(word.lower() for word in itertools.chain(
            [u'1', u"true", u"yes"], # don't use potentially translated values
            self._get_boolean_translations(u"true"),
            self._get_boolean_translations(u"yes"),
        ))
        if value.lower() in trues:
            return True, []

        # potentially broken casefolding? What about locales?
        falses = set(word.lower() for word in itertools.chain(
            [u'', u"0", u"false", u"no"],
            self._get_boolean_translations(u"false"),
            self._get_boolean_translations(u"no"),
        ))
        if value.lower() in falses:
            return False, []

        if field.name in self._context.get('import_skip_records', []):
            return None, []

        return True, [self._format_import_error(
            ValueError,
            _(u"Unknown value '%s' for boolean field '%%(field)s'"),
            value,
            {'moreinfo': _(u"Use '1' for yes and '0' for no")}
        )]

    @api.model
    def _str_to_integer(self, model, field, value):
        try:
            return int(value), []
        except ValueError:
            raise self._format_import_error(
                ValueError,
                _(u"'%s' does not seem to be an integer for field '%%(field)s'"),
                value
            )

    @api.model
    def _str_to_float(self, model, field, value):
        try:
            return float(value), []
        except ValueError:
            raise self._format_import_error(
                ValueError,
                _(u"'%s' does not seem to be a number for field '%%(field)s'"),
                value
            )

    _str_to_monetary = _str_to_float

    @api.model
    def _str_id(self, model, field, value):
        return value, []

    _str_to_reference = _str_to_char = _str_to_text = _str_to_binary = _str_to_html = _str_id

    @api.model
    def _str_to_date(self, model, field, value):
        try:
            parsed_value = fields.Date.from_string(value)
            return fields.Date.to_string(parsed_value), []
        except ValueError:
            raise self._format_import_error(
                ValueError,
                _(u"'%s' does not seem to be a valid date for field '%%(field)s'"),
                value,
                {'moreinfo': _(u"Use the format '%s'", u"2012-12-31")}
            )

    @api.model
    def _input_tz(self):
        # if there's a tz in context, try to use that
        if self._context.get('tz'):
            try:
                return pytz.timezone(self._context['tz'])
            except pytz.UnknownTimeZoneError:
                pass

        # if the current user has a tz set, try to use that
        user = self.env.user
        if user.tz:
            try:
                return pytz.timezone(user.tz)
            except pytz.UnknownTimeZoneError:
                pass

        # fallback if no tz in context or on user: UTC
        return pytz.UTC

    @api.model
    def _str_to_datetime(self, model, field, value):
        try:
            parsed_value = fields.Datetime.from_string(value)
        except ValueError:
            raise self._format_import_error(
                ValueError,
                _(u"'%s' does not seem to be a valid datetime for field '%%(field)s'"),
                value,
                {'moreinfo': _(u"Use the format '%s'", u"2012-12-31 23:59:59")}
            )

        input_tz = self._input_tz()# Apply input tz to the parsed naive datetime
        dt = input_tz.localize(parsed_value, is_dst=False)
        # And convert to UTC before reformatting for writing
        return fields.Datetime.to_string(dt.astimezone(pytz.UTC)), []

    @api.model
    def _get_boolean_translations(self, src):
        # Cache translations so they don't have to be reloaded from scratch on
        # every row of the file
        tnx_cache = self._cr.cache.setdefault(self._name, {})
        if src in tnx_cache:
            return tnx_cache[src]

        values = OrderedSet()
        for lang, __ in self.env['res.lang'].get_installed():
            translations = code_translations.get_python_translations('base', lang)
            if src in translations:
                values.add(translations[src])

        result = tnx_cache[src] = list(values)
        return result

    @api.model
    def _get_selection_translations(self, field, src):
        if not src:
            return []
        # Cache translations so they don't have to be reloaded from scratch on
        # every row of the file
        tnx_cache = self._cr.cache.setdefault(self._name, {})
        if src in tnx_cache:
            return tnx_cache[src]

        values = OrderedSet()
        self.env['ir.model.fields.selection'].flush_model()
        query = """
            SELECT s.name
            FROM ir_model_fields_selection s
            JOIN ir_model_fields f ON s.field_id = f.id
            WHERE f.model = %s AND f.name = %s AND s.name->>'en_US' = %s
        """
        self.env.cr.execute(query, [field.model_name, field.name, src])
        for (name,) in self.env.cr.fetchall():
            name.pop('en_US')
            values.update(name.values())

        result = tnx_cache[src] = list(values)
        return result

    @api.model
    def _str_to_selection(self, model, field, value):
        # get untranslated values
        env = self.with_context(lang=None).env
        selection = field.get_description(env)['selection']

        for item, label in selection:
            label = ustr(label)
            if callable(field.selection):
                labels = [label]
                for item2, label2 in field._description_selection(self.env):
                    if item2 == item:
                        labels.append(label2)
                        break
            else:
                labels = [label] + self._get_selection_translations(field, label)
            # case insensitive comparaison of string to allow to set the value even if the given 'value' param is not
            # exactly (case sensitive) the same as one of the selection item.
            if value.lower() == str(item).lower() or any(value.lower() == label.lower() for label in labels):
                return item, []

        if field.name in self._context.get('import_skip_records', []):
            return None, []
        elif field.name in self._context.get('import_set_empty_fields', []):
            return False, []
        raise self._format_import_error(
            ValueError,
            _(u"Value '%s' not found in selection field '%%(field)s'"),
            value,
            {'moreinfo': [_label or str(item) for item, _label in selection if _label or item]}
        )

    @api.model
    def db_id_for(self, model, field, subfield, value):
        """ Finds a database id for the reference ``value`` in the referencing
        subfield ``subfield`` of the provided field of the provided model.

        :param model: model to which the field belongs
        :param field: relational field for which references are provided
        :param subfield: a relational subfield allowing building of refs to
                         existing records: ``None`` for a name_search,
                         ``id`` for an external id and ``.id`` for a database
                         id
        :param value: value of the reference to match to an actual record
        :return: a pair of the matched database identifier (if any), the
                 translated user-readable name for the field and the list of
                 warnings
        :rtype: (ID|None, unicode, list)
        """
        # the function 'flush' comes from BaseModel.load(), and forces the
        # creation/update of former records (batch creation)
        flush = self._context.get('import_flush', lambda **kw: None)

        id = None
        warnings = []
        error_msg = ''
        action = {
            'name': 'Possible Values',
            'type': 'ir.actions.act_window', 'target': 'new',
            'view_mode': 'tree,form',
            'views': [(False, 'list'), (False, 'form')],
            'context': {'create': False},
            'help': _(u"See all possible values")}
        if subfield is None:
            action['res_model'] = field.comodel_name
        elif subfield in ('id', '.id'):
            action['res_model'] = 'ir.model.data'
            action['domain'] = [('model', '=', field.comodel_name)]

        RelatedModel = self.env[field.comodel_name]
        if subfield == '.id':
            field_type = _(u"database id")
            if isinstance(value, str) and not self._str_to_boolean(model, field, value)[0]:
                return False, field_type, warnings
            try:
                tentative_id = int(value)
            except ValueError:
                raise self._format_import_error(
                    ValueError,
                    _(u"Invalid database id '%s' for the field '%%(field)s'"),
                    value,
                    {'moreinfo': action})
            if RelatedModel.browse(tentative_id).exists():
                id = tentative_id
        elif subfield == 'id':
            field_type = _(u"external id")
            if not self._str_to_boolean(model, field, value)[0]:
                return False, field_type, warnings
            if '.' in value:
                xmlid = value
            else:
                xmlid = "%s.%s" % (self._context.get('_import_current_module', ''), value)
            flush(xml_id=xmlid)
            id = self._xmlid_to_record_id(xmlid, RelatedModel)
        elif subfield is None:
            field_type = _(u"name")
            if value == '':
                return False, field_type, warnings
            flush(model=field.comodel_name)
            ids = RelatedModel.name_search(name=value, operator='=')
            if ids:
                if len(ids) > 1:
                    warnings.append(ImportWarning(_(
                        "Found multiple matches for value %r in field %%(field)r (%d matches)",
                        str(value).replace('%', '%%'),
                        len(ids),
                    )))
                id, _name = ids[0]
            else:
                name_create_enabled_fields = self.env.context.get('name_create_enabled_fields') or {}
                if name_create_enabled_fields.get(field.name):
                    try:
                        with self.env.cr.savepoint():
                            id, _name = RelatedModel.name_create(name=value)
                    except (Exception, psycopg2.IntegrityError):
                        error_msg = _("Cannot create new '%s' records from their name alone. Please create those records manually and try importing again.", RelatedModel._description)
        else:
            raise self._format_import_error(
                Exception,
                _("Unknown sub-field %r", subfield)
            )

        set_empty = False
        skip_record = False
        if self.env.context.get('import_file'):
            import_set_empty_fields = self.env.context.get('import_set_empty_fields') or []
            field_path = "/".join((self.env.context.get('parent_fields_hierarchy', []) + [field.name]))
            set_empty = field_path in import_set_empty_fields
            skip_record = field_path in self.env.context.get('import_skip_records', [])
        if id is None and not set_empty and not skip_record:
            if error_msg:
                message = _("No matching record found for %(field_type)s '%(value)s' in field '%%(field)s' and the following error was encountered when we attempted to create one: %(error_message)s")
            else:
                message = _("No matching record found for %(field_type)s '%(value)s' in field '%%(field)s'")

            error_info_dict = {'moreinfo': action}
            if self.env.context.get('import_file'):
                # limit to 50 char to avoid too long error messages.
                value = value[:50] if isinstance(value, str) else value
                error_info_dict.update({'value': value, 'field_type': field_type})
                if error_msg:
                    error_info_dict['error_message'] = error_msg
            raise self._format_import_error(
                ValueError,
                message,
                {'field_type': field_type, 'value': value, 'error_message': error_msg},
                error_info_dict)
        return id, field_type, warnings

    def _xmlid_to_record_id(self, xmlid, model):
        """ Return the record id corresponding to the given external id,
        provided that the record actually exists; otherwise return ``None``.
        """
        import_cache = self.env.context.get('import_cache', {})
        result = import_cache.get(xmlid)

        if not result:
            module, name = xmlid.split('.', 1)
            query = """
                SELECT d.model, d.res_id
                FROM ir_model_data d
                JOIN "{}" r ON d.res_id = r.id
                WHERE d.module = %s AND d.name = %s
            """.format(model._table)
            self.env.cr.execute(query, [module, name])
            result = self.env.cr.fetchone()

        if result:
            res_model, res_id = import_cache[xmlid] = result
            if res_model != model._name:
                MSG = "Invalid external ID %s: expected model %r, found %r"
                raise ValueError(MSG % (xmlid, model._name, res_model))
            return res_id

    def _referencing_subfield(self, record):
        """ Checks the record for the subfields allowing referencing (an
        existing record in an other table), errors out if it finds potential
        conflicts (multiple referencing subfields) or non-referencing subfields
        returns the name of the correct subfield.

        :param record:
        :return: the record subfield to use for referencing and a list of warnings
        :rtype: str, list
        """
        # Can import by display_name, external id or database id
        fieldset = set(record)
        if fieldset - REFERENCING_FIELDS:
            raise ValueError(
                _(u"Can not create Many-To-One records indirectly, import the field separately"))
        if len(fieldset) > 1:
            raise ValueError(
                _(u"Ambiguous specification for field '%(field)s', only provide one of name, external id or database id"))

        # only one field left possible, unpack
        [subfield] = fieldset
        return subfield, []

    @api.model
    def _str_to_many2one(self, model, field, values):
        # Should only be one record, unpack
        [record] = values

        subfield, w1 = self._referencing_subfield(record)

        id, _, w2 = self.db_id_for(model, field, subfield, record[subfield])
        return id, w1 + w2

    @api.model
    def _str_to_many2one_reference(self, model, field, value):
        return self._str_to_integer(model, field, value)

    @api.model
    def _str_to_many2many(self, model, field, value):
        [record] = value

        subfield, warnings = self._referencing_subfield(record)

        ids = []
        for reference in record[subfield].split(','):
            id, _, ws = self.db_id_for(model, field, subfield, reference)
            ids.append(id)
            warnings.extend(ws)

        if field.name in self._context.get('import_set_empty_fields', []) and any([id is None for id in ids]):
            ids = [id for id in ids if id]
        elif field.name in self._context.get('import_skip_records', []) and any([id is None for id in ids]):
            return None, warnings

        if self._context.get('update_many2many'):
            return [Command.link(id) for id in ids], warnings
        else:
            return [Command.set(ids)], warnings

    @api.model
    def _str_to_one2many(self, model, field, records):
        name_create_enabled_fields = self._context.get('name_create_enabled_fields') or {}
        prefix = field.name + '/'
        relative_name_create_enabled_fields = {
            k[len(prefix):]: v
            for k, v in name_create_enabled_fields.items()
            if k.startswith(prefix)
        }
        commands = []
        warnings = []

        if len(records) == 1 and exclude_ref_fields(records[0]) == {}:
            # only one row with only ref field, field=ref1,ref2,ref3 as in
            # m2o/m2m
            record = records[0]
            subfield, ws = self._referencing_subfield(record)
            warnings.extend(ws)
            # transform [{subfield:ref1,ref2,ref3}] into
            # [{subfield:ref1},{subfield:ref2},{subfield:ref3}]
            records = ({subfield:item} for item in record[subfield].split(','))

        def log(f, exception):
            if not isinstance(exception, Warning):
                current_field_name = self.env[field.comodel_name]._fields[f].string
                arg0 = exception.args[0].replace('%(field)s', '%(field)s/' + current_field_name)
                exception.args = (arg0, *exception.args[1:])
                raise exception
            warnings.append(exception)

        # Complete the field hierarchy path
        # E.g. For "parent/child/subchild", field hierarchy path for "subchild" is ['parent', 'child']
        parent_fields_hierarchy = self._context.get('parent_fields_hierarchy', []) + [field.name]

        convert = self.with_context(
            name_create_enabled_fields=relative_name_create_enabled_fields,
            parent_fields_hierarchy=parent_fields_hierarchy
        ).for_model(self.env[field.comodel_name])

        for record in records:
            id = None
            refs = only_ref_fields(record)
            writable = convert(exclude_ref_fields(record), log)
            if refs:
                subfield, w1 = self._referencing_subfield(refs)
                warnings.extend(w1)
                try:
                    id, _, w2 = self.db_id_for(model, field, subfield, record[subfield])
                    warnings.extend(w2)
                except ValueError:
                    if subfield != 'id':
                        raise
                    writable['id'] = record['id']

            if id:
                commands.append(Command.link(id))
                commands.append(Command.update(id, writable))
            else:
                commands.append(Command.create(writable))

        return commands, warnings

```

  File: models/ir_filters.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, tools, _
from odoo.exceptions import UserError
from odoo.tools.safe_eval import safe_eval, datetime


class IrFilters(models.Model):
    _name = 'ir.filters'
    _description = 'Filters'
    _order = 'model_id, name, id desc'

    name = fields.Char(string='Filter Name', required=True)
    user_id = fields.Many2one('res.users', string='User', ondelete='cascade',
                              help="The user this filter is private to. When left empty the filter is public "
                                   "and available to all users.")
    domain = fields.Text(default='[]', required=True)
    context = fields.Text(default='{}', required=True)
    sort = fields.Text(default='[]', required=True)
    model_id = fields.Selection(selection='_list_all_models', string='Model', required=True)
    is_default = fields.Boolean(string='Default Filter')
    action_id = fields.Many2one('ir.actions.actions', string='Action', ondelete='cascade',
                                help="The menu action this filter applies to. "
                                     "When left empty the filter applies to all menus "
                                     "for this model.")
    active = fields.Boolean(default=True)

    @api.model
    def _list_all_models(self):
        lang = self.env.lang or 'en_US'
        self._cr.execute(
            "SELECT model, COALESCE(name->>%s, name->>'en_US') FROM ir_model ORDER BY 2",
            [lang],
        )
        return self._cr.fetchall()

    def copy(self, default=None):
        self.ensure_one()
        default = dict(default or {}, name=_('%s (copy)', self.name))
        return super(IrFilters, self).copy(default)

    def _get_eval_domain(self):
        self.ensure_one()
        return safe_eval(self.domain, {
            'datetime': datetime,
            'context_today': datetime.datetime.now,
        })

    @api.model
    def _get_action_domain(self, action_id=None):
        """Return a domain component for matching filters that are visible in the
           same context (menu/view) as the given action."""
        if action_id:
            # filters specific to this menu + global ones
            return [('action_id', 'in', [action_id, False])]
        # only global ones
        return [('action_id', '=', False)]

    @api.model
    def get_filters(self, model, action_id=None):
        """Obtain the list of filters available for the user on the given model.

        :param int model: id of model to find filters for
        :param action_id: optional ID of action to restrict filters to this action
            plus global filters. If missing only global filters are returned.
            The action does not have to correspond to the model, it may only be
            a contextual action.
        :return: list of :meth:`~osv.read`-like dicts containing the
            ``name``, ``is_default``, ``domain``, ``user_id`` (m2o tuple),
            ``action_id`` (m2o tuple) and ``context`` of the matching ``ir.filters``.
        """
        # available filters: private filters (user_id=uid) and public filters (uid=NULL),
        # and filters for the action (action_id=action_id) or global (action_id=NULL)
        user_context = self.env['res.users'].context_get()
        action_domain = self._get_action_domain(action_id)
        return self.with_context(user_context).search_read(
            action_domain + [('model_id', '=', model), ('user_id', 'in', [self._uid, False])],
            ['name', 'is_default', 'domain', 'context', 'user_id', 'sort'],
        )

    @api.model
    def _check_global_default(self, vals, matching_filters):
        """ _check_global_default(dict, list(dict), dict) -> None

        Checks if there is a global default for the model_id requested.

        If there is, and the default is different than the record being written
        (-> we're not updating the current global default), raise an error
        to avoid users unknowingly overwriting existing global defaults (they
        have to explicitly remove the current default before setting a new one)

        This method should only be called if ``vals`` is trying to set
        ``is_default``

        :raises odoo.exceptions.UserError: if there is an existing default and
                                            we're not updating it
        """
        domain = self._get_action_domain(vals.get('action_id'))
        defaults = self.search(domain + [
            ('model_id', '=', vals['model_id']),
            ('user_id', '=', False),
            ('is_default', '=', True),
        ])

        if not defaults:
            return
        if matching_filters and (matching_filters[0]['id'] == defaults.id):
            return

        raise UserError(_("There is already a shared filter set as default for %(model)s, delete or change it before setting a new default", model=vals.get('model_id')))

    @api.model
    @api.returns('self', lambda value: value.id)
    def create_or_replace(self, vals):
        action_id = vals.get('action_id')
        current_filters = self.get_filters(vals['model_id'], action_id)
        matching_filters = [f for f in current_filters
                            if f['name'].lower() == vals['name'].lower()
                            # next line looks for matching user_ids (specific or global), i.e.
                            # f.user_id is False and vals.user_id is False or missing,
                            # or f.user_id.id == vals.user_id
                            if (f['user_id'] and f['user_id'][0]) == vals.get('user_id')]

        if vals.get('is_default'):
            if vals.get('user_id'):
                # Setting new default: any other default that belongs to the user
                # should be turned off
                domain = self._get_action_domain(action_id)
                defaults = self.search(domain + [
                    ('model_id', '=', vals['model_id']),
                    ('user_id', '=', vals['user_id']),
                    ('is_default', '=', True),
                ])
                if defaults:
                    defaults.write({'is_default': False})
            else:
                self._check_global_default(vals, matching_filters)

        # When a filter exists for the same (name, model, user) triple, we simply
        # replace its definition (considering action_id irrelevant here)
        if matching_filters:
            matching_filter = self.browse(matching_filters[0]['id'])
            matching_filter.write(vals)
            return matching_filter

        return self.create(vals)

    _sql_constraints = [
        # Partial constraint, complemented by unique index (see below). Still
        # useful to keep because it provides a proper error message when a
        # violation occurs, as it shares the same prefix as the unique index.
        ('name_model_uid_unique', 'unique (model_id, user_id, action_id, name)', 'Filter names must be unique'),
    ]

    def _auto_init(self):
        result = super(IrFilters, self)._auto_init()
        # Use unique index to implement unique constraint on the lowercase name (not possible using a constraint)
        tools.create_unique_index(self._cr, 'ir_filters_name_model_uid_unique_action_index',
            self._table, ['model_id', 'COALESCE(user_id,-1)', 'COALESCE(action_id,-1)', 'lower(name)'])
        return result

```

  File: models/ir_http.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
#----------------------------------------------------------
# ir_http modular http routing
#----------------------------------------------------------
import base64
import hashlib
import json
import logging
import mimetypes
import os
import re
import sys
import traceback
import threading

import werkzeug
import werkzeug.exceptions
import werkzeug.routing
import werkzeug.utils

try:
    from werkzeug.routing import NumberConverter
except ImportError:
    from werkzeug.routing.converters import NumberConverter  # moved in werkzeug 2.2.2

import odoo
from odoo import api, http, models, tools, SUPERUSER_ID
from odoo.exceptions import AccessDenied, AccessError, MissingError
from odoo.http import request, Response, ROUTING_KEYS, Stream
from odoo.modules.registry import Registry
from odoo.service import security
from odoo.tools import get_lang, submap
from odoo.tools.translate import code_translations

_logger = logging.getLogger(__name__)


class RequestUID(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)


class ModelConverter(werkzeug.routing.BaseConverter):

    def __init__(self, url_map, model=False):
        super(ModelConverter, self).__init__(url_map)
        self.model = model
        self.regex = r'([0-9]+)'

    def to_python(self, value):
        _uid = RequestUID(value=value, converter=self)
        env = api.Environment(request.cr, _uid, request.context)
        return env[self.model].browse(int(value))

    def to_url(self, value):
        return value.id


class ModelsConverter(werkzeug.routing.BaseConverter):

    def __init__(self, url_map, model=False):
        super(ModelsConverter, self).__init__(url_map)
        self.model = model
        # TODO add support for slug in the form [A-Za-z0-9-] bla-bla-89 -> id 89
        self.regex = r'([0-9,]+)'

    def to_python(self, value):
        _uid = RequestUID(value=value, converter=self)
        env = api.Environment(request.cr, _uid, request.context)
        return env[self.model].browse(int(v) for v in value.split(','))

    def to_url(self, value):
        return ",".join(value.ids)


class SignedIntConverter(NumberConverter):
    regex = r'-?\d+'
    num_convert = int


class LazyCompiledBuilder:
    def __init__(self, rule, _compile_builder, append_unknown):
        self.rule = rule
        self._callable = None
        self._compile_builder = _compile_builder
        self._append_unknown = append_unknown

    def __get__(self, *args):
        # Rule.compile will actually call
        #
        #   self._build = self._compile_builder(False).__get__(self, None)
        #   self._build_unknown = self._compile_builder(True).__get__(self, None)
        #
        # meaning the _build and _build unkown will contain _compile_builder().__get__(self, None).
        # This is why this override of __get__ is needed.
        return self

    def __call__(self, *args, **kwargs):
        if self._callable is None:
            self._callable = self._compile_builder(self._append_unknown).__get__(self.rule, None)
            del self.rule
            del self._compile_builder
            del self._append_unknown
        return self._callable(*args, **kwargs)


class FasterRule(werkzeug.routing.Rule):
    """
    _compile_builder is a major part of the routing map generation and rules
    are actually not build so often.
    This classe makes calls to _compile_builder lazy
    """
    def _compile_builder(self, append_unknown=True):
        return LazyCompiledBuilder(self, super()._compile_builder, append_unknown)


class IrHttp(models.AbstractModel):
    _name = 'ir.http'
    _description = "HTTP Routing"

    #------------------------------------------------------
    # Routing map
    #------------------------------------------------------

    @classmethod
    def _get_converters(cls):
        return {'model': ModelConverter, 'models': ModelsConverter, 'int': SignedIntConverter}

    @classmethod
    def _match(cls, path_info):
        rule, args = request.env['ir.http'].routing_map().bind_to_environ(request.httprequest.environ).match(path_info=path_info, return_rule=True)
        return rule, args

    @classmethod
    def _get_public_users(cls):
        return [request.env['ir.model.data']._xmlid_to_res_model_res_id('base.public_user')[1]]

    @classmethod
    def _auth_method_user(cls):
        if request.env.uid in [None] + cls._get_public_users():
            raise http.SessionExpiredException("Session expired")

    @classmethod
    def _auth_method_none(cls):
        request.env = api.Environment(request.env.cr, None, request.env.context)

    @classmethod
    def _auth_method_public(cls):
        if request.env.uid is None:
            public_user = request.env.ref('base.public_user')
            request.update_env(user=public_user.id)

    @classmethod
    def _authenticate(cls, endpoint):
        auth = 'none' if http.is_cors_preflight(request, endpoint) else endpoint.routing['auth']

        try:
            if request.session.uid is not None:
                if not security.check_session(request.session, request.env):
                    request.session.logout(keep_db=True)
                    request.env = api.Environment(request.env.cr, None, request.session.context)
            getattr(cls, f'_auth_method_{auth}')()
        except (AccessDenied, http.SessionExpiredException, werkzeug.exceptions.HTTPException):
            raise
        except Exception:
            _logger.info("Exception during request Authentication.", exc_info=True)
            raise AccessDenied()

    @classmethod
    def _geoip_resolve(cls):
        return request._geoip_resolve()

    @classmethod
    def _pre_dispatch(cls, rule, args):
        ICP = request.env['ir.config_parameter'].with_user(SUPERUSER_ID)

        # Change the default database-wide 128MiB upload limit on the
        # ICP value. Do it before calling http's generic pre_dispatch
        # so that the per-route limit @route(..., max_content_length=x)
        # takes over.
        try:
            key = 'web.max_file_upload_size'
            if (value := ICP.get_param(key, None)) is not None:
                request.httprequest.max_content_length = int(value)
        except ValueError:  # better not crash on ALL requests
            _logger.error("invalid %s: %r, using %s instead",
                key, value, request.httprequest.max_content_length,
            )

        request.dispatcher.pre_dispatch(rule, args)

        # Replace uid placeholder by the current request.env.uid
        for key, val in list(args.items()):
            if isinstance(val, models.BaseModel) and isinstance(val._uid, RequestUID):
                args[key] = val.with_user(request.env.uid)

        # verify the default language set in the context is valid,
        # otherwise fallback on the company lang, english or the first
        # lang installed
        env = request.env if request.env.uid else request.env['base'].with_user(SUPERUSER_ID).env
        request.update_context(lang=get_lang(env)._get_cached('code'))

        for key, val in list(args.items()):
            if not isinstance(val, models.BaseModel):
                continue

            try:
                # explicitly crash now, instead of crashing later
                args[key].check_access_rights('read')
                args[key].check_access_rule('read')
            except (odoo.exceptions.AccessError, odoo.exceptions.MissingError) as e:
                # custom behavior in case a record is not accessible / has been removed
                if handle_error := rule.endpoint.routing.get('handle_params_access_error'):
                    if response := handle_error(e):
                        werkzeug.exceptions.abort(response)
                if isinstance(e, odoo.exceptions.MissingError):
                    raise werkzeug.exceptions.NotFound() from e
                raise

    @classmethod
    def _dispatch(cls, endpoint):
        result = endpoint(**request.params)
        if isinstance(result, Response) and result.is_qweb:
            result.flatten()
        return result

    @classmethod
    def _post_dispatch(cls, response):
        request.dispatcher.post_dispatch(response)

    @classmethod
    def _post_logout(cls):
        pass

    @classmethod
    def _handle_error(cls, exception):
        return request.dispatcher.handle_error(exception)

    @classmethod
    def _serve_fallback(cls):
        model = request.env['ir.attachment']
        attach = model.sudo()._get_serve_attachment(request.httprequest.path)
        if attach and (attach.store_fname or attach.db_datas):
            return Stream.from_attachment(attach).get_response()

    @classmethod
    def _redirect(cls, location, code=303):
        return werkzeug.utils.redirect(location, code=code, Response=Response)

    def _generate_routing_rules(self, modules, converters):
        return http._generate_routing_rules(modules, False, converters)

    @tools.ormcache('key', cache='routing')
    def routing_map(self, key=None):
        _logger.info("Generating routing map for key %s", str(key))
        registry = Registry(threading.current_thread().dbname)
        installed = registry._init_modules.union(odoo.conf.server_wide_modules)
        if tools.config['test_enable'] and odoo.modules.module.current_test:
            installed.add(odoo.modules.module.current_test)
        mods = sorted(installed)
        # Note : when routing map is generated, we put it on the class `cls`
        # to make it available for all instance. Since `env` create an new instance
        # of the model, each instance will regenared its own routing map and thus
        # regenerate its EndPoint. The routing map should be static.
        routing_map = werkzeug.routing.Map(strict_slashes=False, converters=self._get_converters())
        for url, endpoint in self._generate_routing_rules(mods, converters=self._get_converters()):
            routing = submap(endpoint.routing, ROUTING_KEYS)
            if routing['methods'] is not None and 'OPTIONS' not in routing['methods']:
                routing['methods'] = routing['methods'] + ['OPTIONS']
            rule = FasterRule(url, endpoint=endpoint, **routing)
            rule.merge_slashes = False
            routing_map.add(rule)
        return routing_map

    @api.autovacuum
    def _gc_sessions(self):
        if os.getenv("ODOO_SKIP_GC_SESSIONS"):
            return
        ICP = self.env["ir.config_parameter"]
        max_lifetime = int(ICP.get_param('sessions.max_inactivity_seconds', http.SESSION_LIFETIME))
        http.root.session_store.vacuum(max_lifetime=max_lifetime)

    @api.model
    def get_translations_for_webclient(self, modules, lang):
        if not modules:
            modules = self.pool._init_modules
        if not lang:
            lang = self._context.get("lang")
        langs = self.env['res.lang']._lang_get(lang)
        lang_params = None
        if langs:
            lang_params = {
                "name": langs.name,
                "direction": langs.direction,
                "date_format": langs.date_format,
                "time_format": langs.time_format,
                "grouping": langs.grouping,
                "decimal_point": langs.decimal_point,
                "thousands_sep": langs.thousands_sep,
                "week_start": langs.week_start,
            }
            lang_params['week_start'] = int(lang_params['week_start'])
            lang_params['code'] = lang

        # Regional languages (ll_CC) must inherit/override their parent lang (ll), but this is
        # done server-side when the language is loaded, so we only need to load the user's lang.
        translations_per_module = {}
        for module in modules:
            translations_per_module[module] = code_translations.get_web_translations(module, lang)

        return translations_per_module, lang_params

    @api.model
    @tools.ormcache('frozenset(modules)', 'lang')
    def get_web_translations_hash(self, modules, lang):
        translations, lang_params = self.get_translations_for_webclient(modules, lang)
        translation_cache = {
            'lang_parameters': lang_params,
            'modules': translations,
            'lang': lang,
            'multi_lang': len(self.env['res.lang'].sudo().get_installed()) > 1,
        }
        return hashlib.sha1(json.dumps(translation_cache, sort_keys=True).encode()).hexdigest()

    @classmethod
    def _is_allowed_cookie(cls, cookie_type):
        return True

```

  File: models/ir_logging.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo import api, fields, models


class IrLogging(models.Model):
    _name = 'ir.logging'
    _description = 'Logging'
    _order = 'id DESC'
    _allow_sudo_commands = False

    # The _log_access fields are defined manually for the following reasons:
    #
    # - The entries in ir_logging are filled in with sql queries bypassing the orm. As the --log-db
    #   cli option allows to insert ir_logging entries into a remote database, the one2many *_uid
    #   fields make no sense in the first place but we will keep it for backward compatibility.
    #
    # - Also, when an ir_logging entry is triggered by the orm (when using --log-db) at the moment
    #   it is making changes to the res.users model, the ALTER TABLE will aquire an exclusive lock
    #   on res_users, preventing the ir_logging INSERT to be processed, hence the ongoing module
    #   install/update will hang forever as the orm is blocked by the ir_logging query that will
    #   never occur.
    create_uid = fields.Integer(string='Created by', readonly=True)
    create_date = fields.Datetime(string='Created on', readonly=True)
    write_uid = fields.Integer(string='Last Updated by', readonly=True)
    write_date = fields.Datetime(string='Last Updated on', readonly=True)

    name = fields.Char(required=True)
    type = fields.Selection([('client', 'Client'), ('server', 'Server')], required=True, index=True)
    dbname = fields.Char(string='Database Name', index=True)
    level = fields.Char(index=True)
    message = fields.Text(required=True)
    path = fields.Char(required=True)
    func = fields.Char(string='Function', required=True)
    line = fields.Char(required=True)

    def init(self):
        super(IrLogging, self).init()
        self._cr.execute("select 1 from information_schema.constraint_column_usage where table_name = 'ir_logging' and constraint_name = 'ir_logging_write_uid_fkey'")
        if self._cr.rowcount:
            # DROP CONSTRAINT unconditionally takes an ACCESS EXCLUSIVE lock
            # on the table, even "IF EXISTS" is set and not matching; disabling
            # the relevant trigger instead acquires SHARE ROW EXCLUSIVE, which
            # still conflicts with the ROW EXCLUSIVE needed for an insert
            self._cr.execute("ALTER TABLE ir_logging DROP CONSTRAINT ir_logging_write_uid_fkey")

```

  File: models/ir_mail_server.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from email.message import EmailMessage
from email.utils import make_msgid
import base64
import datetime
import email
import email.policy
import idna
import logging
import re
import smtplib
import ssl
import sys
import threading

from socket import gaierror, timeout
from OpenSSL import crypto as SSLCrypto
from OpenSSL.crypto import Error as SSLCryptoError, FILETYPE_PEM
from OpenSSL.SSL import Error as SSLError
from urllib3.contrib.pyopenssl import PyOpenSSLContext

from odoo import api, fields, models, tools, _
from odoo.exceptions import UserError
from odoo.tools import ustr, pycompat, formataddr, email_normalize, encapsulate_email, email_domain_extract, email_domain_normalize


_logger = logging.getLogger(__name__)
_test_logger = logging.getLogger('odoo.tests')

SMTP_TIMEOUT = 60


class MailDeliveryException(Exception):
    """Specific exception subclass for mail delivery errors"""


def make_wrap_property(name):
    return property(
        lambda self: getattr(self.__obj__, name),
        lambda self, value: setattr(self.__obj__, name, value),
    )


class SMTPConnection:
    """Wrapper around smtplib.SMTP and smtplib.SMTP_SSL"""
    def __init__(self, server, port, encryption, context=None):
        if encryption == 'ssl':
            self.__obj__ = smtplib.SMTP_SSL(server, port, timeout=SMTP_TIMEOUT, context=context)
        else:
            self.__obj__ = smtplib.SMTP(server, port, timeout=SMTP_TIMEOUT)


SMTP_ATTRIBUTES = [
    'auth', 'auth_cram_md5', 'auth_login', 'auth_plain', 'close', 'data', 'docmd', 'ehlo', 'ehlo_or_helo_if_needed',
    'expn', 'from_filter', 'getreply', 'has_extn', 'login', 'mail', 'noop', 'putcmd', 'quit', 'rcpt', 'rset',
    'send_message', 'sendmail', 'set_debuglevel', 'smtp_from', 'starttls', 'user', 'verify', '_host',
]
for name in SMTP_ATTRIBUTES:
    setattr(SMTPConnection, name, make_wrap_property(name))


# Python 3: patch SMTP's internal printer/debugger
def _print_debug(self, *args):
    _logger.debug(' '.join(str(a) for a in args))
smtplib.SMTP._print_debug = _print_debug

# Python 3: workaround for bpo-35805, only partially fixed in Python 3.8.
RFC5322_IDENTIFICATION_HEADERS = {'message-id', 'in-reply-to', 'references', 'resent-msg-id'}
_noFoldPolicy = email.policy.SMTP.clone(max_line_length=None)
class IdentificationFieldsNoFoldPolicy(email.policy.EmailPolicy):
    # Override _fold() to avoid folding identification fields, excluded by RFC2047 section 5
    # These are particularly important to preserve, as MTAs will often rewrite non-conformant
    # Message-ID headers, causing a loss of thread information (replies are lost)
    def _fold(self, name, value, *args, **kwargs):
        if name.lower() in RFC5322_IDENTIFICATION_HEADERS:
            return _noFoldPolicy._fold(name, value, *args, **kwargs)
        return super()._fold(name, value, *args, **kwargs)

# Global monkey-patch for our preferred SMTP policy, preserving the non-default linesep
email.policy.SMTP = IdentificationFieldsNoFoldPolicy(linesep=email.policy.SMTP.linesep)

# Python 2: replace smtplib's stderr
class WriteToLogger(object):
    def write(self, s):
        _logger.debug(s)
smtplib.stderr = WriteToLogger()

def is_ascii(s):
    return all(ord(cp) < 128 for cp in s)

address_pattern = re.compile(r'([^" ,<@]+@[^>" ,]+)')

def extract_rfc2822_addresses(text):
    """Returns a list of valid RFC2822 addresses
       that can be found in ``source``, ignoring
       malformed ones and non-ASCII ones.
    """
    if not text:
        return []
    candidates = address_pattern.findall(ustr(text))
    valid_addresses = []
    for c in candidates:
        try:
            valid_addresses.append(formataddr(('', c), charset='ascii'))
        except idna.IDNAError:
            pass
    return valid_addresses


class IrMailServer(models.Model):
    """Represents an SMTP server, able to send outgoing emails, with SSL and TLS capabilities."""
    _name = "ir.mail_server"
    _description = 'Mail Server'
    _order = 'sequence, id'
    _allow_sudo_commands = False

    NO_VALID_RECIPIENT = ("At least one valid recipient address should be "
                          "specified for outgoing emails (To/Cc/Bcc)")
    NO_FOUND_FROM = ("You must either provide a sender address explicitly or configure "
          "using the combination of `mail.catchall.domain` and `mail.default.from` "
          "ICPs, in the server configuration file or with the --email-from startup "
          "parameter.")
    NO_FOUND_SMTP_FROM = "The Return-Path or From header is required for any outbound email"
    NO_VALID_FROM = "Malformed 'Return-Path' or 'From' address. It should contain one valid plain ASCII email"

    name = fields.Char(string='Name', required=True, index=True)
    from_filter = fields.Char(
        "FROM Filtering",
        help='Comma-separated list of addresses or domains for which this server can be used.\n'
             'e.g.: "notification@odoo.com" or "odoo.com"')
    smtp_host = fields.Char(string='SMTP Server', help="Hostname or IP of SMTP server")
    smtp_port = fields.Integer(string='SMTP Port', default=25, help="SMTP Port. Usually 465 for SSL, and 25 or 587 for other cases.")
    smtp_authentication = fields.Selection([
        ('login', 'Username'),
        ('certificate', 'SSL Certificate'),
        ('cli', 'Command Line Interface')
    ], string='Authenticate with', required=True, default='login')
    smtp_authentication_info = fields.Text('Authentication Info', compute='_compute_smtp_authentication_info')
    smtp_user = fields.Char(string='Username', help="Optional username for SMTP authentication", groups='base.group_system')
    smtp_pass = fields.Char(string='Password', help="Optional password for SMTP authentication", groups='base.group_system')
    smtp_encryption = fields.Selection([('none', 'None'),
                                        ('starttls', 'TLS (STARTTLS)'),
                                        ('ssl', 'SSL/TLS')],
                                       string='Connection Encryption', required=True, default='none',
                                       help="Choose the connection encryption scheme:\n"
                                            "- None: SMTP sessions are done in cleartext.\n"
                                            "- TLS (STARTTLS): TLS encryption is requested at start of SMTP session (Recommended)\n"
                                            "- SSL/TLS: SMTP sessions are encrypted with SSL/TLS through a dedicated port (default: 465)")
    smtp_ssl_certificate = fields.Binary(
        'SSL Certificate', groups='base.group_system', attachment=False,
        help='SSL certificate used for authentication')
    smtp_ssl_private_key = fields.Binary(
        'SSL Private Key', groups='base.group_system', attachment=False,
        help='SSL private key used for authentication')
    smtp_debug = fields.Boolean(string='Debugging', help="If enabled, the full output of SMTP sessions will "
                                                         "be written to the server log at DEBUG level "
                                                         "(this is very verbose and may include confidential info!)")
    sequence = fields.Integer(string='Priority', default=10, help="When no specific mail server is requested for a mail, the highest priority one "
                                                                  "is used. Default priority is 10 (smaller number = higher priority)")
    active = fields.Boolean(default=True)

    @api.depends('smtp_authentication')
    def _compute_smtp_authentication_info(self):
        for server in self:
            if server.smtp_authentication == 'login':
                server.smtp_authentication_info = _(
                    'Connect to your server through your usual username and password. \n'
                    'This is the most basic SMTP authentication process and '
                    'may not be accepted by all providers. \n')
            elif server.smtp_authentication == 'certificate':
                server.smtp_authentication_info = _(
                    'Authenticate by using SSL certificates, belonging to your domain name. \n'
                    'SSL certificates allow you to authenticate your mail server for the entire domain name.')
            elif server.smtp_authentication == 'cli':
                server.smtp_authentication_info = _(
                    'Use the SMTP configuration set in the "Command Line Interface" arguments.')
            else:
                server.smtp_authentication = False

    @api.constrains('smtp_authentication', 'smtp_ssl_certificate', 'smtp_ssl_private_key')
    def _check_smtp_ssl_files(self):
        for mail_server in self:
            if mail_server.smtp_authentication == 'certificate':
                if not mail_server.smtp_ssl_private_key:
                    raise UserError(_('SSL private key is missing for %s.', mail_server.name))
                if not mail_server.smtp_ssl_certificate:
                    raise UserError(_('SSL certificate is missing for %s.', mail_server.name))

    def write(self, vals):
        """Ensure we cannot archive a server in-use"""
        usages_per_server = {}
        if not vals.get('active', True):
            usages_per_server = self._active_usages_compute()

        if not usages_per_server:
            return super().write(vals)

        # Write cannot be performed as some server are used, build detailed usage per server
        usage_details_per_server = {}
        is_multiple_server_usage = len(usages_per_server) > 1
        for server in self:
            if server.id not in usages_per_server:
                continue
            usage_details = []
            if is_multiple_server_usage:
                usage_details.append(_('%s (Dedicated Outgoing Mail Server):', server.display_name))
            usage_details.extend(map(lambda u: f'- {u}', usages_per_server[server.id]))
            usage_details_per_server[server] = usage_details

        # Raise the error with the ordered list of servers and concatenated detailed usages
        servers_ordered_by_name = sorted(usage_details_per_server.keys(), key=lambda r: r.display_name)
        error_server_usage = ', '.join(server.display_name for server in servers_ordered_by_name)
        error_usage_details = '\n'.join(line
                                        for server in servers_ordered_by_name
                                        for line in usage_details_per_server[server])
        if is_multiple_server_usage:
            raise UserError(
                _('You cannot archive these Outgoing Mail Servers (%s) because they are still used in the following case(s):\n%s',
                  error_server_usage, error_usage_details))
        raise UserError(
            _('You cannot archive this Outgoing Mail Server (%s) because it is still used in the following case(s):\n%s',
              error_server_usage, error_usage_details))

    def _active_usages_compute(self):
        """Compute a dict server id to list of user-friendly outgoing mail servers usage of this record set.

        This method must be overridden by all modules that uses this class in order to complete the list with
        user-friendly string describing the active elements that could send mail through the instance of this class.
        :return dict: { ir_mail_server.id: usage_str_list }.
        """
        return dict()

    def _get_test_email_from(self):
        self.ensure_one()
        email_from = False
        if from_filter_parts := [part.strip() for part in (self.from_filter or '').split(",") if part.strip()]:
            # find first found complete email in filter parts
            email_from = next((email for email in from_filter_parts if "@" in email), False)
            # no complete email -> consider noreply
            if not email_from:
                email_from = f"noreply@{from_filter_parts[0]}"
        if not email_from:
            # Fallback to current user email if there's no from filter
            email_from = self.env.user.email
        if not email_from or "@" not in email_from:
            raise UserError(_('Please configure an email on the current user to simulate '
                              'sending an email message via this outgoing server'))
        return email_from

    def _get_test_email_to(self):
        return "noreply@odoo.com"

    def test_smtp_connection(self):
        for server in self:
            smtp = False
            try:
                smtp = self.connect(mail_server_id=server.id, allow_archived=True)
                # simulate sending an email from current user's address - without sending it!
                email_from = server._get_test_email_from()
                email_to = server._get_test_email_to()
                # Testing the MAIL FROM step should detect sender filter problems
                (code, repl) = smtp.mail(email_from)
                if code != 250:
                    raise UserError(_('The server refused the sender address (%(email_from)s) with error %(repl)s', email_from=email_from, repl=repl))  # noqa: TRY301
                # Testing the RCPT TO step should detect most relaying problems
                (code, repl) = smtp.rcpt(email_to)
                if code not in (250, 251):
                    raise UserError(_('The server refused the test recipient (%(email_to)s) with error %(repl)s', email_to=email_to, repl=repl))  # noqa: TRY301
                # Beginning the DATA step should detect some deferred rejections
                # Can't use self.data() as it would actually send the mail!
                smtp.putcmd("data")
                (code, repl) = smtp.getreply()
                if code != 354:
                    raise UserError(_('The server refused the test connection with error %(repl)s', repl=repl))  # noqa: TRY301
            except (UnicodeError, idna.core.InvalidCodepoint) as e:
                raise UserError(_("Invalid server name!\n %s", e)) from e
            except (gaierror, timeout) as e:
                raise UserError(_("No response received. Check server address and port number.\n %s", e)) from e
            except smtplib.SMTPServerDisconnected as e:
                raise UserError(_("The server has closed the connection unexpectedly. Check configuration served on this port number.\n %s", e)) from e
            except smtplib.SMTPResponseException as e:
                raise UserError(_("Server replied with following exception:\n %s", e)) from e
            except smtplib.SMTPNotSupportedError as e:
                raise UserError(_("An option is not supported by the server:\n %s", e)) from e
            except smtplib.SMTPException as e:
                raise UserError(_("An SMTP exception occurred. Check port number and connection security type.\n %s", e)) from e
            except (ssl.SSLError, SSLError) as e:
                raise UserError(_("An SSL exception occurred. Check connection security type.\n %s", e)) from e
            except UserError:
                raise
            except Exception as e:
                _logger.warning("Connection test on %s failed with a generic error.", server, exc_info=True)
                raise UserError(_("Connection Test Failed! Here is what we got instead:\n %s", e)) from e
            finally:
                try:
                    if smtp:
                        smtp.close()
                except Exception:
                    # ignored, just a consequence of the previous exception
                    pass

        message = _("Connection Test Successful!")
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'message': message,
                'type': 'success',
                'sticky': False,
            }
        }

    def connect(self, host=None, port=None, user=None, password=None, encryption=None,
                smtp_from=None, ssl_certificate=None, ssl_private_key=None, smtp_debug=False, mail_server_id=None,
                allow_archived=False):
        """Returns a new SMTP connection to the given SMTP server.
           When running in test mode, this method does nothing and returns `None`.

           :param host: host or IP of SMTP server to connect to, if mail_server_id not passed
           :param int port: SMTP port to connect to
           :param user: optional username to authenticate with
           :param password: optional password to authenticate with
           :param string encryption: optional, ``'ssl'`` | ``'starttls'``
           :param smtp_from: FROM SMTP envelop, used to find the best mail server
           :param ssl_certificate: filename of the SSL certificate used for authentication
               Used when no mail server is given and overwrite  the odoo-bin argument "smtp_ssl_certificate"
           :param ssl_private_key: filename of the SSL private key used for authentication
               Used when no mail server is given and overwrite  the odoo-bin argument "smtp_ssl_private_key"
           :param bool smtp_debug: toggle debugging of SMTP sessions (all i/o
                              will be output in logs)
           :param mail_server_id: ID of specific mail server to use (overrides other parameters)
           :param bool allow_archived: by default (False), an exception is raised when calling this method on an
           archived record (using mail_server_id param). It can be set to True for testing so that the exception is no
           longer raised.
        """
        # Do not actually connect while running in test mode
        if self._is_test_mode():
            return

        mail_server = smtp_encryption = None
        if mail_server_id:
            mail_server = self.sudo().browse(mail_server_id)
            if not allow_archived and not mail_server.active:
                raise UserError(_('The server "%s" cannot be used because it is archived.', mail_server.display_name))
        elif not host:
            mail_server, smtp_from = self.sudo()._find_mail_server(smtp_from)

        if not mail_server:
            mail_server = self.env['ir.mail_server']
        ssl_context = None

        if mail_server and mail_server.smtp_authentication != "cli":
            smtp_server = mail_server.smtp_host
            smtp_port = mail_server.smtp_port
            if mail_server.smtp_authentication == "certificate":
                smtp_user = None
                smtp_password = None
            else:
                smtp_user = mail_server.smtp_user
                smtp_password = mail_server.smtp_pass
            smtp_encryption = mail_server.smtp_encryption
            smtp_debug = smtp_debug or mail_server.smtp_debug
            from_filter = mail_server.from_filter
            if mail_server.smtp_authentication == "certificate":
                try:
                    ssl_context = PyOpenSSLContext(ssl.PROTOCOL_TLS)
                    smtp_ssl_certificate = base64.b64decode(mail_server.smtp_ssl_certificate)
                    certificate = SSLCrypto.load_certificate(FILETYPE_PEM, smtp_ssl_certificate)
                    smtp_ssl_private_key = base64.b64decode(mail_server.smtp_ssl_private_key)
                    private_key = SSLCrypto.load_privatekey(FILETYPE_PEM, smtp_ssl_private_key)
                    ssl_context._ctx.use_certificate(certificate)
                    ssl_context._ctx.use_privatekey(private_key)
                    # Check that the private key match the certificate
                    ssl_context._ctx.check_privatekey()
                except SSLCryptoError as e:
                    raise UserError(_('The private key or the certificate is not a valid file. \n%s', str(e)))
                except SSLError as e:
                    raise UserError(_('Could not load your certificate / private key. \n%s', str(e)))

        else:
            # we were passed individual smtp parameters or nothing and there is no default server
            smtp_server = host or tools.config.get('smtp_server')
            smtp_port = tools.config.get('smtp_port', 25) if port is None else port
            smtp_user = user or tools.config.get('smtp_user')
            smtp_password = password or tools.config.get('smtp_password')
            if mail_server:
                from_filter = mail_server.from_filter
            else:
                from_filter = self.env['ir.mail_server']._get_default_from_filter()

            smtp_encryption = encryption
            if smtp_encryption is None and tools.config.get('smtp_ssl'):
                smtp_encryption = 'starttls' # smtp_ssl => STARTTLS as of v7
            smtp_ssl_certificate_filename = ssl_certificate or tools.config.get('smtp_ssl_certificate_filename')
            smtp_ssl_private_key_filename = ssl_private_key or tools.config.get('smtp_ssl_private_key_filename')

            if smtp_ssl_certificate_filename and smtp_ssl_private_key_filename:
                try:
                    ssl_context = PyOpenSSLContext(ssl.PROTOCOL_TLS)
                    ssl_context.load_cert_chain(smtp_ssl_certificate_filename, keyfile=smtp_ssl_private_key_filename)
                    # Check that the private key match the certificate
                    ssl_context._ctx.check_privatekey()
                except SSLCryptoError as e:
                    raise UserError(_('The private key or the certificate is not a valid file. \n%s', str(e)))
                except SSLError as e:
                    raise UserError(_('Could not load your certificate / private key. \n%s', str(e)))

        if not smtp_server:
            raise UserError(
                (_("Missing SMTP Server") + "\n" +
                 _("Please define at least one SMTP server, "
                   "or provide the SMTP parameters explicitly.")))

        if smtp_encryption == 'ssl':
            if 'SMTP_SSL' not in smtplib.__all__:
                raise UserError(
                    _("Your Odoo Server does not support SMTP-over-SSL. "
                      "You could use STARTTLS instead. "
                       "If SSL is needed, an upgrade to Python 2.6 on the server-side "
                       "should do the trick."))
        connection = SMTPConnection(smtp_server, smtp_port, smtp_encryption, context=ssl_context)
        connection.set_debuglevel(smtp_debug)
        if smtp_encryption == 'starttls':
            # starttls() will perform ehlo() if needed first
            # and will discard the previous list of services
            # after successfully performing STARTTLS command,
            # (as per RFC 3207) so for example any AUTH
            # capability that appears only on encrypted channels
            # will be correctly detected for next step
            connection.starttls(context=ssl_context)

        if smtp_user:
            # Attempt authentication - will raise if AUTH service not supported
            local, at, domain = smtp_user.rpartition('@')
            if at:
                smtp_user = local + at + idna.encode(domain).decode('ascii')
            mail_server._smtp_login(connection, smtp_user, smtp_password or '')

        # Some methods of SMTP don't check whether EHLO/HELO was sent.
        # Anyway, as it may have been sent by login(), all subsequent usages should consider this command as sent.
        connection.ehlo_or_helo_if_needed()

        # Store the "from_filter" of the mail server / odoo-bin argument to  know if we
        # need to change the FROM headers or not when we will prepare the mail message
        connection.from_filter = from_filter
        connection.smtp_from = smtp_from

        return connection

    def _smtp_login(self, connection, smtp_user, smtp_password):
        """Authenticate the SMTP connection.

        Can be overridden in other module for different authentication methods.Can be
        called on the model itself or on a singleton.

        :param connection: The SMTP connection to authenticate
        :param smtp_user: The user to used for the authentication
        :param smtp_password: The password to used for the authentication
        """
        connection.login(smtp_user, smtp_password)

    def build_email(self, email_from, email_to, subject, body, email_cc=None, email_bcc=None, reply_to=False,
                    attachments=None, message_id=None, references=None, object_id=False, subtype='plain', headers=None,
                    body_alternative=None, subtype_alternative='plain'):
        """Constructs an RFC2822 email.message.Message object based on the keyword arguments passed, and returns it.

           :param string email_from: sender email address
           :param list email_to: list of recipient addresses (to be joined with commas)
           :param string subject: email subject (no pre-encoding/quoting necessary)
           :param string body: email body, of the type ``subtype`` (by default, plaintext).
                               If html subtype is used, the message will be automatically converted
                               to plaintext and wrapped in multipart/alternative, unless an explicit
                               ``body_alternative`` version is passed.
           :param string body_alternative: optional alternative body, of the type specified in ``subtype_alternative``
           :param string reply_to: optional value of Reply-To header
           :param string object_id: optional tracking identifier, to be included in the message-id for
                                    recognizing replies. Suggested format for object-id is "res_id-model",
                                    e.g. "12345-crm.lead".
           :param string subtype: optional mime subtype for the text body (usually 'plain' or 'html'),
                                  must match the format of the ``body`` parameter. Default is 'plain',
                                  making the content part of the mail "text/plain".
           :param string subtype_alternative: optional mime subtype of ``body_alternative`` (usually 'plain'
                                              or 'html'). Default is 'plain'.
           :param list attachments: list of (filename, filecontents) pairs, where filecontents is a string
                                    containing the bytes of the attachment
           :param message_id:
           :param references:
           :param list email_cc: optional list of string values for CC header (to be joined with commas)
           :param list email_bcc: optional list of string values for BCC header (to be joined with commas)
           :param dict headers: optional map of headers to set on the outgoing mail (may override the
                                other headers, including Subject, Reply-To, Message-Id, etc.)
           :rtype: email.message.EmailMessage
           :return: the new RFC2822 email message
        """
        email_from = email_from or self.env.context.get('domain_notifications_email') or self._get_default_from_address()
        assert email_from, self.NO_FOUND_FROM

        headers = headers or {}         # need valid dict later
        email_cc = email_cc or []
        email_bcc = email_bcc or []
        body = body or u''

        msg = EmailMessage(policy=email.policy.SMTP)
        if not message_id:
            if object_id:
                message_id = tools.generate_tracking_message_id(object_id)
            else:
                message_id = make_msgid()
        msg['Message-Id'] = message_id
        if references:
            msg['references'] = references
        msg['Subject'] = subject
        msg['From'] = email_from
        del msg['Reply-To']
        msg['Reply-To'] = reply_to or email_from
        msg['To'] = email_to
        if email_cc:
            msg['Cc'] = email_cc
        if email_bcc:
            msg['Bcc'] = email_bcc
        msg['Date'] = datetime.datetime.utcnow()
        for key, value in headers.items():
            msg[pycompat.to_text(ustr(key))] = value

        email_body = ustr(body)
        if subtype == 'html' and not body_alternative:
            msg['MIME-Version'] = '1.0'
            msg.add_alternative(tools.html2plaintext(email_body), subtype='plain', charset='utf-8')
            msg.add_alternative(email_body, subtype=subtype, charset='utf-8')
        elif body_alternative:
            msg['MIME-Version'] = '1.0'
            msg.add_alternative(ustr(body_alternative), subtype=subtype_alternative, charset='utf-8')
            msg.add_alternative(email_body, subtype=subtype, charset='utf-8')
        else:
            msg.set_content(email_body, subtype=subtype, charset='utf-8')

        if attachments:
            for (fname, fcontent, mime) in attachments:
                maintype, subtype = mime.split('/') if mime and '/' in mime else ('application', 'octet-stream')
                msg.add_attachment(fcontent, maintype, subtype, filename=fname)
        return msg

    @api.model
    def _get_default_bounce_address(self):
        """ Computes the default bounce address. It is used to set the envelop
        address if no envelop address is provided in the message.

        :return str/None: defaults to the ``--email-from`` CLI/config parameter.
        """
        return tools.config.get("email_from")

    @api.model
    def _get_default_from_address(self):
        """ Computes the default from address. It is used for the "header from"
        address when no other has been received.

        :return str/None: defaults to the ``--email-from`` CLI/config parameter.
        """
        return tools.config.get("email_from")

    @api.model
    def _get_default_from_filter(self):
        """ Computes the default from_filter. It is used when no specific
        ir.mail_server is used when sending emails, hence having no value for
        from_filter.

        :return str/None: defaults to 'mail.default.from_filter', then
          ``--from-filter`` CLI/config parameter.
        """
        return self.env['ir.config_parameter'].sudo().get_param(
            'mail.default.from_filter', tools.config.get('from_filter')
        )

    def _prepare_email_message(self, message, smtp_session):
        """Prepare the SMTP information (from, to, message) before sending.

        :param message: the email.message.Message to send, information like the
            Return-Path, the From, etc... will be used to find the smtp_from and to smtp_to
        :param smtp_session: the opened SMTP session to use to authenticate the sender
        :return: smtp_from, smtp_to_list, message
            smtp_from: email to used during the authentication to the mail server
            smtp_to_list: list of email address which will receive the email
            message: the email.message.Message to send
        """
        # Use the default bounce address **only if** no Return-Path was
        # provided by caller.  Caller may be using Variable Envelope Return
        # Path (VERP) to detect no-longer valid email addresses.
        # context may force a value, e.g. mail.alias.domain usage
        bounce_address = self.env.context.get('domain_bounce_address') or message['Return-Path'] or self._get_default_bounce_address() or message['From']

        smtp_from = message['From'] or bounce_address
        assert smtp_from, self.NO_FOUND_SMTP_FROM

        email_to = message['To']
        email_cc = message['Cc']
        email_bcc = message['Bcc']
        del message['Bcc']

        # All recipient addresses must only contain ASCII characters
        smtp_to_list = [
            address
            for base in [email_to, email_cc, email_bcc]
            for address in extract_rfc2822_addresses(base)
            if address
        ]
        assert smtp_to_list, self.NO_VALID_RECIPIENT

        x_forge_to = message['X-Forge-To']
        if x_forge_to:
            # `To:` header forged, e.g. for posting on discuss.channels, to avoid confusion
            del message['X-Forge-To']
            del message['To']           # avoid multiple To: headers!
            message['To'] = x_forge_to

        # Try to not spoof the mail from headers; fetch session-based or contextualized
        # values for encapsulation computation
        from_filter = getattr(smtp_session, 'from_filter', False)
        smtp_from = getattr(smtp_session, 'smtp_from', False) or smtp_from
        notifications_email = email_normalize(
            self.env.context.get('domain_notifications_email') or self._get_default_from_address()
        )
        if notifications_email and smtp_from == notifications_email and message['From'] != notifications_email:
            smtp_from = encapsulate_email(message['From'], notifications_email)

        if message['From'] != smtp_from:
            del message['From']
            message['From'] = smtp_from

        # Check if it's still possible to put the bounce address as smtp_from
        if self._match_from_filter(bounce_address, from_filter):
            # Mail headers FROM will be spoofed to be able to receive bounce notifications
            # Because the mail server support the domain of the bounce address
            smtp_from = bounce_address

        # The email's "Envelope From" (Return-Path) must only contain ASCII characters.
        smtp_from_rfc2822 = extract_rfc2822_addresses(smtp_from)
        if not smtp_from_rfc2822:
            raise AssertionError(
                self.NO_VALID_FROM,
                f"Malformed 'Return-Path' or 'From' address: {smtp_from} - "
                "It should contain one valid plain ASCII email"
            )
        smtp_from = smtp_from_rfc2822[-1]

        return smtp_from, smtp_to_list, message

    @api.model
    def send_email(self, message, mail_server_id=None, smtp_server=None, smtp_port=None,
                   smtp_user=None, smtp_password=None, smtp_encryption=None,
                   smtp_ssl_certificate=None, smtp_ssl_private_key=None,
                   smtp_debug=False, smtp_session=None):
        """Sends an email directly (no queuing).

        No retries are done, the caller should handle MailDeliveryException in order to ensure that
        the mail is never lost.

        If the mail_server_id is provided, sends using this mail server, ignoring other smtp_* arguments.
        If mail_server_id is None and smtp_server is None, use the default mail server (highest priority).
        If mail_server_id is None and smtp_server is not None, use the provided smtp_* arguments.
        If both mail_server_id and smtp_server are None, look for an 'smtp_server' value in server config,
        and fails if not found.

        :param message: the email.message.Message to send. The envelope sender will be extracted from the
                        ``Return-Path`` (if present), or will be set to the default bounce address.
                        The envelope recipients will be extracted from the combined list of ``To``,
                        ``CC`` and ``BCC`` headers.
        :param smtp_session: optional pre-established SMTP session. When provided,
                             overrides `mail_server_id` and all the `smtp_*` parameters.
                             Passing the matching `mail_server_id` may yield better debugging/log
                             messages. The caller is in charge of disconnecting the session.
        :param mail_server_id: optional id of ir.mail_server to use for sending. overrides other smtp_* arguments.
        :param smtp_server: optional hostname of SMTP server to use
        :param smtp_encryption: optional TLS mode, one of 'none', 'starttls' or 'ssl' (see ir.mail_server fields for explanation)
        :param smtp_port: optional SMTP port, if mail_server_id is not passed
        :param smtp_user: optional SMTP user, if mail_server_id is not passed
        :param smtp_password: optional SMTP password to use, if mail_server_id is not passed
        :param smtp_ssl_certificate: filename of the SSL certificate used for authentication
        :param smtp_ssl_private_key: filename of the SSL private key used for authentication
        :param smtp_debug: optional SMTP debug flag, if mail_server_id is not passed
        :return: the Message-ID of the message that was just sent, if successfully sent, otherwise raises
                 MailDeliveryException and logs root cause.
        """
        smtp = smtp_session
        if not smtp:
            smtp = self.connect(
                smtp_server, smtp_port, smtp_user, smtp_password, smtp_encryption,
                smtp_from=message['From'], ssl_certificate=smtp_ssl_certificate, ssl_private_key=smtp_ssl_private_key,
                smtp_debug=smtp_debug, mail_server_id=mail_server_id,)

        smtp_from, smtp_to_list, message = self._prepare_email_message(message, smtp)

        # Do not actually send emails in testing mode!
        if self._is_test_mode():
            _test_logger.info("skip sending email in test mode")
            return message['Message-Id']

        try:
            message_id = message['Message-Id']

            if sys.version_info < (3, 7, 4):
                # header folding code is buggy and adds redundant carriage
                # returns, it got fixed in 3.7.4 thanks to bpo-34424
                message_str = message.as_string()
                message_str = re.sub('\r+(?!\n)', '', message_str)

                mail_options = []
                if any((not is_ascii(addr) for addr in smtp_to_list + [smtp_from])):
                    # non ascii email found, require SMTPUTF8 extension,
                    # the relay may reject it
                    mail_options.append("SMTPUTF8")
                smtp.sendmail(smtp_from, smtp_to_list, message_str, mail_options=mail_options)
            else:
                smtp.send_message(message, smtp_from, smtp_to_list)

            # do not quit() a pre-established smtp_session
            if not smtp_session:
                smtp.quit()
        except smtplib.SMTPServerDisconnected:
            raise
        except Exception as e:
            params = (ustr(smtp_server), e.__class__.__name__, ustr(e))
            msg = _("Mail delivery failed via SMTP server '%s'.\n%s: %s", *params)
            _logger.info(msg)
            raise MailDeliveryException(_("Mail Delivery Failed"), msg)
        return message_id

    def _find_mail_server(self, email_from, mail_servers=None):
        """Find the appropriate mail server for the given email address.

        Returns: Record<ir.mail_server>, email_from
        - Mail server to use to send the email (None if we use the odoo-bin arguments)
        - Email FROM to use to send the email (in some case, it might be impossible
          to use the given email address directly if no mail server is configured for)
        """
        email_from_normalized = email_normalize(email_from)
        email_from_domain = email_domain_extract(email_from_normalized)
        notifications_email = self.env.context.get('domain_notifications_email') or email_normalize(self._get_default_from_address())
        notifications_domain = email_domain_extract(notifications_email)

        if mail_servers is None:
            mail_servers = self.sudo().search([], order='sequence')
        # 0. Archived mail server should never be used
        mail_servers = mail_servers.filtered('active')

        def first_match(target, normalize_method):
            for mail_server in mail_servers:
                if mail_server.from_filter and any(
                    normalize_method(email.strip()) == target
                    for email in mail_server.from_filter.split(',')
                ):
                    return mail_server

        # 1. Try to find a mail server for the right mail from
        if mail_server := first_match(email_from_normalized, email_normalize):
            return mail_server, email_from

        if mail_server := first_match(email_from_domain, email_domain_normalize):
            return mail_server, email_from

        # 2. Try to find a mail server for <notifications@domain.com>
        if notifications_email:
            if mail_server := first_match(notifications_email, email_normalize):
                return mail_server, notifications_email

            if mail_server := first_match(notifications_domain, email_domain_normalize):
                return mail_server, notifications_email

        # 3. Take the first mail server without "from_filter" because
        # nothing else has been found... Will spoof the FROM because
        # we have no other choices (will use the notification email if available
        # otherwise we will use the user email)
        if mail_server := mail_servers.filtered(lambda m: not m.from_filter):
            return mail_server[0], notifications_email or email_from

        # 4. Return the first mail server even if it was configured for another domain
        if mail_servers:
            _logger.warning(
                "No mail server matches the from_filter, using %s as fallback",
                notifications_email or email_from)
            return mail_servers[0], notifications_email or email_from

        # 5: SMTP config in odoo-bin arguments
        from_filter = self.env['ir.mail_server']._get_default_from_filter()

        if self._match_from_filter(email_from, from_filter):
            return None, email_from

        if notifications_email and self._match_from_filter(notifications_email, from_filter):
            return None, notifications_email

        _logger.warning(
            "The from filter of the CLI configuration does not match the notification email "
            "or the user email, using %s as fallback",
            notifications_email or email_from)
        return None, notifications_email or email_from

    @api.model
    def _match_from_filter(self, email_from, from_filter):
        """Return True is the given email address match the "from_filter" field.

        The from filter can be Falsy (always match),
        a domain name or an full email address.
        """
        if not from_filter:
            return True

        normalized_mail_from = email_normalize(email_from)
        normalized_domain = email_domain_extract(normalized_mail_from)

        for email_filter in [part.strip() for part in (from_filter or '').split(',') if part.strip()]:
            if '@' in email_filter and email_normalize(email_filter) == normalized_mail_from:
                return True
            if '@' not in email_filter and email_domain_normalize(email_filter) == normalized_domain:
                return True
        return False

    @api.onchange('smtp_encryption')
    def _onchange_encryption(self):
        result = {}
        if self.smtp_encryption == 'ssl':
            self.smtp_port = 465
            if not 'SMTP_SSL' in smtplib.__all__:
                result['warning'] = {
                    'title': _('Warning'),
                    'message': _('Your server does not seem to support SSL, you may want to try STARTTLS instead'),
                }
        else:
            self.smtp_port = 25
        return result

    def _is_test_mode(self):
        """Return True if we are running the tests, so we do not send real emails.

        Can be overridden in tests after mocking the SMTP lib to test in depth the
        outgoing mail server.
        """
        return getattr(threading.current_thread(), 'testing', False) or self.env.registry.in_test_mode()

```

  File: models/ir_model.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import itertools
import logging
import random
import re
import psycopg2
from ast import literal_eval
from collections import defaultdict
from collections.abc import Mapping
from operator import itemgetter

from psycopg2 import sql
from psycopg2.extras import Json
from psycopg2.sql import Identifier, SQL, Placeholder

from odoo import api, fields, models, tools, _, _lt, Command
from odoo.exceptions import AccessError, UserError, ValidationError
from odoo.osv import expression
from odoo.tools import pycompat, unique, OrderedSet
from odoo.tools.safe_eval import safe_eval, datetime, dateutil, time

_logger = logging.getLogger(__name__)

MODULE_UNINSTALL_FLAG = '_force_unlink'
RE_ORDER_FIELDS = re.compile(r'"?(\w+)"?\s*(?:asc|desc)?', flags=re.I)

# base environment for doing a safe_eval
SAFE_EVAL_BASE = {
    'datetime': datetime,
    'dateutil': dateutil,
    'time': time,
}


def make_compute(text, deps):
    """ Return a compute function from its code body and dependencies. """
    func = lambda self: safe_eval(text, SAFE_EVAL_BASE, {'self': self}, mode="exec")
    deps = [arg.strip() for arg in deps.split(",")] if deps else []
    return api.depends(*deps)(func)


def mark_modified(records, fnames):
    """ Mark the given fields as modified on records. """
    # protect all modified fields, to avoid them being recomputed
    fields = [records._fields[fname] for fname in fnames]
    with records.env.protecting(fields, records):
        records.modified(fnames)


def model_xmlid(module, model_name):
    """ Return the XML id of the given model. """
    return '%s.model_%s' % (module, model_name.replace('.', '_'))


def field_xmlid(module, model_name, field_name):
    """ Return the XML id of the given field. """
    return '%s.field_%s__%s' % (module, model_name.replace('.', '_'), field_name)


def selection_xmlid(module, model_name, field_name, value):
    """ Return the XML id of the given selection. """
    xmodel = model_name.replace('.', '_')
    xvalue = value.replace('.', '_').replace(' ', '_').lower()
    return '%s.selection__%s__%s__%s' % (module, xmodel, field_name, xvalue)


# generic INSERT and UPDATE queries
INSERT_QUERY = SQL("INSERT INTO {table} ({cols}) VALUES %s RETURNING id")
UPDATE_QUERY = SQL("UPDATE {table} SET {assignment} WHERE {condition} RETURNING id")

quote = '"{}"'.format


def query_insert(cr, table, rows):
    """ Insert rows in a table. ``rows`` is a list of dicts, all with the same
        set of keys. Return the ids of the new rows.
    """
    if isinstance(rows, Mapping):
        rows = [rows]
    cols = list(rows[0])
    query = INSERT_QUERY.format(
        table=Identifier(table),
        cols=SQL(",").join(map(Identifier, cols)),
    )
    params = [tuple(row[col] for col in cols) for row in rows]
    cr.execute_values(query, params)
    return [row[0] for row in cr.fetchall()]


def query_update(cr, table, values, selectors):
    """ Update the table with the given values (dict), and use the columns in
        ``selectors`` to select the rows to update.
    """
    setters = set(values) - set(selectors)
    query = UPDATE_QUERY.format(
        table=Identifier(table),
        assignment=SQL(",").join(
            SQL("{} = {}").format(Identifier(s), Placeholder(s))
            for s in setters
        ),
        condition=SQL(" AND ").join(
            SQL("{} = {}").format(Identifier(s), Placeholder(s))
            for s in selectors
        ),
    )
    cr.execute(query, values)
    return [row[0] for row in cr.fetchall()]


def select_en(model, fnames, where, params):
    """ Select the given columns from the given model's table, with the given WHERE clause.
    Translated fields are returned in 'en_US'.
    """
    table = quote(model._table)
    cols = ", ".join(
        f"{quote(fname)}->>'en_US'" if model._fields[fname].translate else quote(fname)
        for fname in fnames
    )
    query = f"SELECT {cols} FROM {table} WHERE {where}"
    model.env.cr.execute(query, params)
    return model.env.cr.fetchall()


def upsert_en(model, fnames, rows, conflict):
    """ Insert or update the table with the given rows.

    :param model: recordset of the model to query
    :param fnames: list of column names
    :param rows: list of tuples, where each tuple value corresponds to a column name
    :param conflict: list of column names to put into the ON CONFLICT clause
    :return: the ids of the inserted or updated rows
    """
    table = quote(model._table)
    cols = ", ".join(quote(fname) for fname in fnames)
    values = ", ".join("%s" for row in rows)
    conf = ", ".join(conflict)
    excluded = ", ".join(f"EXCLUDED.{quote(fname)}" for fname in fnames)
    query = f"""
        INSERT INTO {table} ({cols}) VALUES {values}
        ON CONFLICT ({conf}) DO UPDATE SET ({cols}) = ({excluded})
        RETURNING id
    """

    # for translated fields, we can actually erase the json value, as
    # translations will be reloaded after this
    def identity(val):
        return val

    def jsonify(val):
        return Json({'en_US': val}) if val is not None else val

    wrappers = [(jsonify if model._fields[fname].translate else identity) for fname in fnames]
    params = [
        tuple(func(val) for func, val in zip(wrappers, row))
        for row in rows
    ]
    model.env.cr.execute(query, params)
    return [row[0] for row in model.env.cr.fetchall()]


#
# IMPORTANT: this must be the first model declared in the module
#
class Base(models.AbstractModel):
    """ The base model, which is implicitly inherited by all models. """
    _name = 'base'
    _description = 'Base'


class Unknown(models.AbstractModel):
    """
    Abstract model used as a substitute for relational fields with an unknown
    comodel.
    """
    _name = '_unknown'
    _description = 'Unknown'


class IrModel(models.Model):
    _name = 'ir.model'
    _description = "Models"
    _order = 'model'
    _rec_names_search = ['name', 'model']
    _allow_sudo_commands = False

    def _default_field_id(self):
        if self.env.context.get('install_mode'):
            return []                   # no default field when importing
        return [Command.create({'name': 'x_name', 'field_description': 'Name', 'ttype': 'char', 'copied': True})]

    name = fields.Char(string='Model Description', translate=True, required=True)
    model = fields.Char(default='x_', required=True)
    order = fields.Char(string='Order', default='id', required=True,
                        help='SQL expression for ordering records in the model; e.g. "x_sequence asc, id desc"')
    info = fields.Text(string='Information')
    field_id = fields.One2many('ir.model.fields', 'model_id', string='Fields', required=True, copy=True,
                               default=_default_field_id)
    inherited_model_ids = fields.Many2many('ir.model', compute='_inherited_models', string="Inherited models",
                                           help="The list of models that extends the current model.")
    state = fields.Selection([('manual', 'Custom Object'), ('base', 'Base Object')], string='Type', default='manual', readonly=True)
    access_ids = fields.One2many('ir.model.access', 'model_id', string='Access')
    rule_ids = fields.One2many('ir.rule', 'model_id', string='Record Rules')
    transient = fields.Boolean(string="Transient Model")
    modules = fields.Char(compute='_in_modules', string='In Apps', help='List of modules in which the object is defined or inherited')
    view_ids = fields.One2many('ir.ui.view', compute='_view_ids', string='Views')
    count = fields.Integer(compute='_compute_count', string="Count (Incl. Archived)",
                           help="Total number of records in this model")

    @api.depends()
    def _inherited_models(self):
        self.inherited_model_ids = False
        for model in self:
            parent_names = list(self.env[model.model]._inherits)
            if parent_names:
                model.inherited_model_ids = self.search([('model', 'in', parent_names)])
            else:
                model.inherited_model_ids = False

    @api.depends()
    def _in_modules(self):
        installed_modules = self.env['ir.module.module'].search([('state', '=', 'installed')])
        installed_names = set(installed_modules.mapped('name'))
        xml_ids = models.Model._get_external_ids(self)
        for model in self:
            module_names = set(xml_id.split('.')[0] for xml_id in xml_ids[model.id])
            model.modules = ", ".join(sorted(installed_names & module_names))

    @api.depends()
    def _view_ids(self):
        for model in self:
            model.view_ids = self.env['ir.ui.view'].search([('model', '=', model.model)])

    @api.depends()
    def _compute_count(self):
        cr = self.env.cr
        self.count = 0
        for model in self:
            records = self.env[model.model]
            if not records._abstract and records._auto:
                cr.execute(sql.SQL('SELECT COUNT(*) FROM {}').format(sql.Identifier(records._table)))
                model.count = cr.fetchone()[0]

    @api.constrains('model')
    def _check_model_name(self):
        for model in self:
            if model.state == 'manual':
                self._check_manual_name(model.model)
            if not models.check_object_name(model.model):
                raise ValidationError(_("The model name can only contain lowercase characters, digits, underscores and dots."))

    @api.constrains('order', 'field_id')
    def _check_order(self):
        for model in self:
            try:
                model._check_qorder(model.order)  # regex check for the whole clause ('is it valid sql?')
            except UserError as e:
                raise ValidationError(str(e))
            # add MAGIC_COLUMNS to 'stored_fields' in case 'model' has not been
            # initialized yet, or 'field_id' is not up-to-date in cache
            stored_fields = set(
                model.field_id.filtered('store').mapped('name') + models.MAGIC_COLUMNS
            )
            order_fields = RE_ORDER_FIELDS.findall(model.order)
            for field in order_fields:
                if field not in stored_fields:
                    raise ValidationError(_("Unable to order by %s: fields used for ordering must be present on the model and stored.", field))

    _sql_constraints = [
        ('obj_name_uniq', 'unique (model)', 'Each model must have a unique name.'),
    ]

    def _get(self, name):
        """ Return the (sudoed) `ir.model` record with the given name.
        The result may be an empty recordset if the model is not found.
        """
        model_id = self._get_id(name) if name else False
        return self.sudo().browse(model_id)

    @tools.ormcache('name')
    def _get_id(self, name):
        self.env.cr.execute("SELECT id FROM ir_model WHERE model=%s", (name,))
        result = self.env.cr.fetchone()
        return result and result[0]

    def _drop_table(self):
        for model in self:
            current_model = self.env.get(model.model)
            if current_model is not None:
                if current_model._abstract:
                    continue

                table = current_model._table
                kind = tools.table_kind(self._cr, table)
                if kind == tools.TableKind.View:
                    self._cr.execute(sql.SQL('DROP VIEW {}').format(sql.Identifier(table)))
                elif kind == tools.TableKind.Regular:
                    self._cr.execute(sql.SQL('DROP TABLE {} CASCADE').format(sql.Identifier(table)))
                elif kind is not None:
                    _logger.warning(
                        "Unable to drop table %r of model %r: unmanaged or unknown tabe type %r",
                        table, model.model, kind
                    )
            else:
                _logger.runbot('The model %s could not be dropped because it did not exist in the registry.', model.model)
        return True

    @api.ondelete(at_uninstall=False)
    def _unlink_if_manual(self):
        # Prevent manual deletion of module tables
        for model in self:
            if model.state != 'manual':
                raise UserError(_("Model %r contains module data and cannot be removed.", model.name))

    def unlink(self):
        # prevent screwing up fields that depend on these models' fields
        manual_models = self.filtered(lambda model: model.state == 'manual')
        manual_models.field_id.filtered(lambda f: f.state == 'manual')._prepare_update()
        (self - manual_models).field_id._prepare_update()

        # delete fields whose comodel is being removed
        self.env['ir.model.fields'].search([('relation', 'in', self.mapped('model'))]).unlink()

        # delete ir_crons created by user
        crons = self.env['ir.cron'].with_context(active_test=False).search([('model_id', 'in', self.ids)])
        if crons:
            crons.unlink()

        self._drop_table()
        res = super(IrModel, self).unlink()

        # Reload registry for normal unlink only. For module uninstall, the
        # reload is done independently in odoo.modules.loading.
        if not self._context.get(MODULE_UNINSTALL_FLAG):
            # setup models; this automatically removes model from registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)

        return res

    def write(self, vals):
        if 'model' in vals and any(rec.model != vals['model'] for rec in self):
            raise UserError(_('Field "Model" cannot be modified on models.'))
        if 'state' in vals and any(rec.state != vals['state'] for rec in self):
            raise UserError(_('Field "Type" cannot be modified on models.'))
        if 'transient' in vals and any(rec.transient != vals['transient'] for rec in self):
            raise UserError(_('Field "Transient Model" cannot be modified on models.'))
        # Filter out operations 4 from field id, because the web client always
        # writes (4,id,False) even for non dirty items.
        if 'field_id' in vals:
            vals['field_id'] = [op for op in vals['field_id'] if op[0] != 4]
        res = super(IrModel, self).write(vals)
        # ordering has been changed, reload registry to reflect update + signaling
        if 'order' in vals:
            self.env.flush_all()  # setup_models need to fetch the updated values from the db
            self.pool.setup_models(self._cr)
        return res

    @api.model_create_multi
    def create(self, vals_list):
        res = super(IrModel, self).create(vals_list)
        manual_models = [
            vals['model'] for vals in vals_list if vals.get('state', 'manual') == 'manual'
        ]
        if manual_models:
            # setup models; this automatically adds model in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)
            # update database schema
            self.pool.init_models(self._cr, manual_models, dict(self._context, update_custom_fields=True))
        return res

    @api.model
    def name_create(self, name):
        """ Infer the model from the name. E.g.: 'My New Model' should become 'x_my_new_model'. """
        ir_model = self.create({
            'name': name,
            'model': 'x_' + '_'.join(name.lower().split(' ')),
        })
        return ir_model.id, ir_model.display_name

    def _reflect_model_params(self, model):
        """ Return the values to write to the database for the given model. """
        return {
            'model': model._name,
            'name': model._description,
            'order': model._order,
            'info': next(cls.__doc__ for cls in self.env.registry[model._name].mro() if cls.__doc__),
            'state': 'manual' if model._custom else 'base',
            'transient': model._transient,
        }

    def _reflect_models(self, model_names):
        """ Reflect the given models. """
        # determine expected and existing rows
        rows = [
            self._reflect_model_params(self.env[model_name])
            for model_name in model_names
        ]
        cols = list(unique(['model'] + list(rows[0])))
        expected = [tuple(row[col] for col in cols) for row in rows]

        model_ids = {}
        existing = {}
        for row in select_en(self, ['id'] + cols, "model IN %s", [tuple(model_names)]):
            model_ids[row[1]] = row[0]
            existing[row[1]] = row[1:]

        # create or update rows
        rows = [row for row in expected if existing.get(row[0]) != row]
        if rows:
            ids = upsert_en(self, cols, rows, ['model'])
            for row, id_ in zip(rows, ids):
                model_ids[row[0]] = id_
            self.pool.post_init(mark_modified, self.browse(ids), cols[1:])

        # update their XML id
        module = self._context.get('module')
        if not module:
            return

        data_list = []
        for model_name, model_id in model_ids.items():
            model = self.env[model_name]
            if model._module == module:
                # model._module is the name of the module that last extended model
                xml_id = model_xmlid(module, model_name)
                record = self.browse(model_id)
                data_list.append({'xml_id': xml_id, 'record': record})
        self.env['ir.model.data']._update_xmlids(data_list)

    @api.model
    def _instanciate(self, model_data):
        """ Return a class for the custom model given by parameters ``model_data``. """
        class CustomModel(models.Model):
            _name = pycompat.to_text(model_data['model'])
            _description = model_data['name']
            _module = False
            _custom = True
            _transient = bool(model_data['transient'])
            _order = model_data['order']
            __doc__ = model_data['info']

        return CustomModel

    @api.model
    def _is_manual_name(self, name):
        return name.startswith('x_')

    @api.model
    def _check_manual_name(self, name):
        if not self._is_manual_name(name):
            raise ValidationError(_("The model name must start with 'x_'."))

    def _add_manual_models(self):
        """ Add extra models to the registry. """
        # clean up registry first
        for name, Model in list(self.pool.items()):
            if Model._custom:
                del self.pool.models[name]
                # remove the model's name from its parents' _inherit_children
                for Parent in Model.__bases__:
                    if hasattr(Parent, 'pool'):
                        Parent._inherit_children.discard(name)
        # add manual models
        cr = self.env.cr
        # we cannot use self._fields to determine translated fields, as it has not been set up yet
        cr.execute("SELECT *, name->>'en_US' AS name FROM ir_model WHERE state = 'manual'")
        for model_data in cr.dictfetchall():
            model_class = self._instanciate(model_data)
            Model = model_class._build_model(self.pool, cr)
            kind = tools.table_kind(cr, Model._table)
            if kind not in (tools.TableKind.Regular, None):
                _logger.info(
                    "Model %r is backed by table %r which is not a regular table (%r), disabling automatic schema management",
                    Model._name, Model._table, kind,
                )
                Model._auto = False
                cr.execute(
                    '''
                    SELECT a.attname
                      FROM pg_attribute a
                      JOIN pg_class t
                        ON a.attrelid = t.oid
                       AND t.relname = %s
                     WHERE a.attnum > 0 -- skip system columns
                    ''',
                    [Model._table]
                )
                columns = {colinfo[0] for colinfo in cr.fetchall()}
                Model._log_access = set(models.LOG_ACCESS_COLUMNS) <= columns


# retrieve field types defined by the framework only (not extensions)
FIELD_TYPES = [(key, key) for key in sorted(fields.Field.by_type)]


class IrModelFields(models.Model):
    _name = 'ir.model.fields'
    _description = "Fields"
    _order = "name"
    _rec_name = 'field_description'
    _allow_sudo_commands = False

    name = fields.Char(string='Field Name', default='x_', required=True, index=True)
    complete_name = fields.Char(index=True)
    model = fields.Char(string='Model Name', required=True, index=True,
                        help="The technical name of the model this field belongs to")
    relation = fields.Char(string='Related Model',
                           help="For relationship fields, the technical name of the target model")
    relation_field = fields.Char(help="For one2many fields, the field on the target model that implement the opposite many2one relationship")
    relation_field_id = fields.Many2one('ir.model.fields', compute='_compute_relation_field_id',
                                        store=True, ondelete='cascade', string='Relation field')
    model_id = fields.Many2one('ir.model', string='Model', required=True, index=True, ondelete='cascade',
                               help="The model this field belongs to")
    field_description = fields.Char(string='Field Label', default='', required=True, translate=True)
    help = fields.Text(string='Field Help', translate=True)
    ttype = fields.Selection(selection=FIELD_TYPES, string='Field Type', required=True)
    selection = fields.Char(string="Selection Options (Deprecated)",
                            compute='_compute_selection', inverse='_inverse_selection')
    selection_ids = fields.One2many("ir.model.fields.selection", "field_id",
                                    string="Selection Options", copy=True)
    copied = fields.Boolean(string='Copied',
                            compute='_compute_copied', store=True, readonly=False,
                            help="Whether the value is copied when duplicating a record.")
    related = fields.Char(string='Related Field', help="The corresponding related field, if any. This must be a dot-separated list of field names.")
    related_field_id = fields.Many2one('ir.model.fields', compute='_compute_related_field_id',
                                       store=True, string="Related field", ondelete='cascade')
    required = fields.Boolean()
    readonly = fields.Boolean()
    index = fields.Boolean(string='Indexed')
    translate = fields.Boolean(string='Translatable', help="Whether values for this field can be translated (enables the translation mechanism for that field)")
    size = fields.Integer()
    state = fields.Selection([('manual', 'Custom Field'), ('base', 'Base Field')], string='Type', default='manual', required=True, readonly=True, index=True)
    on_delete = fields.Selection([('cascade', 'Cascade'), ('set null', 'Set NULL'), ('restrict', 'Restrict')],
                                 string='On Delete', default='set null', help='On delete property for many2one fields')
    domain = fields.Char(default="[]", help="The optional domain to restrict possible values for relationship fields, "
                                            "specified as a Python expression defining a list of triplets. "
                                            "For example: [('color','=','red')]")
    groups = fields.Many2many('res.groups', 'ir_model_fields_group_rel', 'field_id', 'group_id') # CLEANME unimplemented field (empty table)
    group_expand = fields.Boolean(string="Expand Groups",
                                  help="If checked, all the records of the target model will be included\n"
                                        "in a grouped result (e.g. 'Group By' filters, Kanban columns, etc.).\n"
                                        "Note that it can significantly reduce performance if the target model\n"
                                        "of the field contains a lot of records; usually used on models with\n"
                                        "few records (e.g. Stages, Job Positions, Event Types, etc.).")
    selectable = fields.Boolean(default=True)
    modules = fields.Char(compute='_in_modules', string='In Apps', help='List of modules in which the field is defined')
    relation_table = fields.Char(help="Used for custom many2many fields to define a custom relation table name")
    column1 = fields.Char(string='Column 1', help="Column referring to the record in the model table")
    column2 = fields.Char(string="Column 2", help="Column referring to the record in the comodel table")
    compute = fields.Text(help="Code to compute the value of the field.\n"
                               "Iterate on the recordset 'self' and assign the field's value:\n\n"
                               "    for record in self:\n"
                               "        record['size'] = len(record.name)\n\n"
                               "Modules time, datetime, dateutil are available.")
    depends = fields.Char(string='Dependencies', help="Dependencies of compute method; "
                                                      "a list of comma-separated field names, like\n\n"
                                                      "    name, partner_id.name")
    store = fields.Boolean(string='Stored', default=True, help="Whether the value is stored in the database.")
    currency_field = fields.Char(string="Currency field", help="Name of the Many2one field holding the res.currency")
    # HTML sanitization reflection, useless for other kinds of fields
    sanitize = fields.Boolean(string='Sanitize HTML', default=True)
    sanitize_overridable = fields.Boolean(string='Sanitize HTML overridable', default=False)
    sanitize_tags = fields.Boolean(string='Sanitize HTML Tags', default=True)
    sanitize_attributes = fields.Boolean(string='Sanitize HTML Attributes', default=True)
    sanitize_style = fields.Boolean(string='Sanitize HTML Style', default=False)
    sanitize_form = fields.Boolean(string='Sanitize HTML Form', default=True)
    strip_style = fields.Boolean(string='Strip Style Attribute', default=False)
    strip_classes = fields.Boolean(string='Strip Class Attribute', default=False)


    @api.depends('relation', 'relation_field')
    def _compute_relation_field_id(self):
        for rec in self:
            if rec.state == 'manual' and rec.relation_field:
                rec.relation_field_id = self._get(rec.relation, rec.relation_field)
            else:
                rec.relation_field_id = False

    @api.depends('related')
    def _compute_related_field_id(self):
        for rec in self:
            if rec.state == 'manual' and rec.related:
                rec.related_field_id = rec._related_field()
            else:
                rec.related_field_id = False

    @api.depends('selection_ids')
    def _compute_selection(self):
        for rec in self:
            if rec.ttype in ('selection', 'reference'):
                rec.selection = str(self.env['ir.model.fields.selection']._get_selection(rec.id))
            else:
                rec.selection = False

    def _inverse_selection(self):
        for rec in self:
            selection = literal_eval(rec.selection or "[]")
            self.env['ir.model.fields.selection']._update_selection(rec.model, rec.name, selection)

    @api.depends('ttype', 'related', 'compute')
    def _compute_copied(self):
        for rec in self:
            rec.copied = (rec.ttype != 'one2many') and not (rec.related or rec.compute)

    @api.depends()
    def _in_modules(self):
        installed_modules = self.env['ir.module.module'].search([('state', '=', 'installed')])
        installed_names = set(installed_modules.mapped('name'))
        xml_ids = models.Model._get_external_ids(self)
        for field in self:
            module_names = set(xml_id.split('.')[0] for xml_id in xml_ids[field.id])
            field.modules = ", ".join(sorted(installed_names & module_names))

    @api.constrains('domain')
    def _check_domain(self):
        for field in self:
            safe_eval(field.domain or '[]')

    @api.constrains('name')
    def _check_name(self):
        for field in self:
            try:
                models.check_pg_name(field.name)
            except ValidationError:
                msg = _("Field names can only contain characters, digits and underscores (up to 63).")
                raise ValidationError(msg)

    _sql_constraints = [
        ('name_unique', 'UNIQUE(model, name)', "Field names must be unique per model."),
        ('size_gt_zero', 'CHECK (size>=0)', 'Size of the field cannot be negative.'),
        (
            "name_manual_field",
            "CHECK (state != 'manual' OR name LIKE 'x\\_%')",
            "Custom fields must have a name that starts with 'x_'!"
        ),
    ]

    def _related_field(self):
        """ Return the ``ir.model.fields`` record corresponding to ``self.related``. """
        names = self.related.split(".")
        last = len(names) - 1
        model_name = self.model or self.model_id.model
        for index, name in enumerate(names):
            field = self._get(model_name, name)
            if not field:
                raise UserError(_("Unknown field name %r in related field %r", name, self.related))
            model_name = field.relation
            if index < last and not field.relation:
                raise UserError(_("Non-relational field name %r in related field %r", name, self.related))
        return field

    @api.constrains('related')
    def _check_related(self):
        for rec in self:
            if rec.state == 'manual' and rec.related:
                field = rec._related_field()
                if field.ttype != rec.ttype:
                    raise ValidationError(_("Related field %r does not have type %r", rec.related, rec.ttype))
                if field.relation != rec.relation:
                    raise ValidationError(_("Related field %r does not have comodel %r", rec.related, rec.relation))

    @api.onchange('related')
    def _onchange_related(self):
        if self.related:
            try:
                field = self._related_field()
            except UserError as e:
                return {'warning': {'title': _("Warning"), 'message': e}}
            self.ttype = field.ttype
            self.relation = field.relation
            self.readonly = True

    @api.onchange('relation')
    def _onchange_relation(self):
        try:
            self._check_relation()
        except ValidationError as e:
            return {'warning': {'title': _("Model %s does not exist", self.relation), 'message': e}}

    @api.constrains('relation')
    def _check_relation(self):
        for rec in self:
            if rec.state == 'manual' and rec.relation and not rec.env['ir.model']._get_id(rec.relation):
                raise ValidationError(_("Unknown model name '%s' in Related Model", rec.relation))

    @api.constrains('depends')
    def _check_depends(self):
        """ Check whether all fields in dependencies are valid. """
        for record in self:
            if not record.depends:
                continue
            for seq in record.depends.split(","):
                if not seq.strip():
                    raise UserError(_("Empty dependency in %r", record.depends))
                model = self.env[record.model]
                names = seq.strip().split(".")
                last = len(names) - 1
                for index, name in enumerate(names):
                    if name == 'id':
                        raise UserError(_("Compute method cannot depend on field 'id'"))
                    field = model._fields.get(name)
                    if field is None:
                        raise UserError(_("Unknown field %r in dependency %r", name, seq.strip()))
                    if index < last and not field.relational:
                        raise UserError(_("Non-relational field %r in dependency %r", name, seq.strip()))
                    model = model[name]

    @api.onchange('compute')
    def _onchange_compute(self):
        if self.compute:
            self.readonly = True

    @api.constrains('relation_table')
    def _check_relation_table(self):
        for rec in self:
            if rec.relation_table:
                models.check_pg_name(rec.relation_table)

    @api.constrains('currency_field')
    def _check_currency_field(self):
        for rec in self:
            if rec.state == 'manual' and rec.ttype == 'monetary':
                if not rec.currency_field:
                    currency_field = self._get(rec.model, 'currency_id') or self._get(rec.model, 'x_currency_id')
                    if not currency_field:
                        raise ValidationError(_("Currency field is empty and there is no fallback field in the model"))
                else:
                    currency_field = self._get(rec.model, rec.currency_field)
                    if not currency_field:
                        raise ValidationError(_("Unknown field name %r in currency_field", rec.currency_field))

                if currency_field.ttype != 'many2one':
                    raise ValidationError(_("Currency field does not have type many2one"))
                if currency_field.relation != 'res.currency':
                    raise ValidationError(_("Currency field should have a res.currency relation"))

    @api.model
    def _custom_many2many_names(self, model_name, comodel_name):
        """ Return default names for the table and columns of a custom many2many field. """
        rel1 = self.env[model_name]._table
        rel2 = self.env[comodel_name]._table
        table = 'x_%s_%s_rel' % tuple(sorted([rel1, rel2]))
        if rel1 == rel2:
            return (table, 'id1', 'id2')
        else:
            return (table, '%s_id' % rel1, '%s_id' % rel2)

    @api.onchange('ttype', 'model_id', 'relation')
    def _onchange_ttype(self):
        if self.ttype == 'many2many' and self.model_id and self.relation:
            if self.relation not in self.env:
                return
            names = self._custom_many2many_names(self.model_id.model, self.relation)
            self.relation_table, self.column1, self.column2 = names
        else:
            self.relation_table = False
            self.column1 = False
            self.column2 = False

    @api.onchange('relation_table')
    def _onchange_relation_table(self):
        if self.relation_table:
            # check whether other fields use the same table
            others = self.search([('ttype', '=', 'many2many'),
                                  ('relation_table', '=', self.relation_table),
                                  ('id', 'not in', self.ids)])
            if others:
                for other in others:
                    if (other.model, other.relation) == (self.relation, self.model):
                        # other is a candidate inverse field
                        self.column1 = other.column2
                        self.column2 = other.column1
                        return
                return {'warning': {
                    'title': _("Warning"),
                    'message': _("The table %r if used for other, possibly incompatible fields.", self.relation_table),
                }}

    @api.constrains('required', 'ttype', 'on_delete')
    def _check_on_delete_required_m2o(self):
        for rec in self:
            if rec.ttype == 'many2one' and rec.required and rec.on_delete == 'set null':
                raise ValidationError(_(
                    "The m2o field %s is required but declares its ondelete policy "
                    "as being 'set null'. Only 'restrict' and 'cascade' make sense.", rec.name,
                ))

    def _get(self, model_name, name):
        """ Return the (sudoed) `ir.model.fields` record with the given model and name.
        The result may be an empty recordset if the model is not found.
        """
        field_id = model_name and name and self._get_ids(model_name).get(name)
        return self.sudo().browse(field_id)

    @tools.ormcache('model_name')
    def _get_ids(self, model_name):
        cr = self.env.cr
        cr.execute("SELECT name, id FROM ir_model_fields WHERE model=%s", [model_name])
        return dict(cr.fetchall())

    def _drop_column(self):
        tables_to_drop = set()

        for field in self:
            if field.name in models.MAGIC_COLUMNS:
                continue
            model = self.env.get(field.model)
            is_model = model is not None
            if field.store:
                # TODO: Refactor this brol in master
                if is_model and tools.column_exists(self._cr, model._table, field.name) and \
                        tools.table_kind(self._cr, model._table) == tools.TableKind.Regular:
                    self._cr.execute(sql.SQL('ALTER TABLE {} DROP COLUMN {} CASCADE').format(
                        sql.Identifier(model._table), sql.Identifier(field.name),
                    ))
                if field.state == 'manual' and field.ttype == 'many2many':
                    rel_name = field.relation_table or (is_model and model._fields[field.name].relation)
                    tables_to_drop.add(rel_name)
            if field.state == 'manual' and is_model:
                model._pop_field(field.name)

        if tables_to_drop:
            # drop the relation tables that are not used by other fields
            self._cr.execute("""SELECT relation_table FROM ir_model_fields
                                WHERE relation_table IN %s AND id NOT IN %s""",
                             (tuple(tables_to_drop), tuple(self.ids)))
            tables_to_keep = set(row[0] for row in self._cr.fetchall())
            for rel_name in tables_to_drop - tables_to_keep:
                self._cr.execute(sql.SQL('DROP TABLE {}').format(sql.Identifier(rel_name)))

        return True

    def _prepare_update(self):
        """ Check whether the fields in ``self`` may be modified or removed.
            This method prevents the modification/deletion of many2one fields
            that have an inverse one2many, for instance.
        """
        uninstalling = self._context.get(MODULE_UNINSTALL_FLAG)
        if not uninstalling and any(record.state != 'manual' for record in self):
            raise UserError(_("This column contains module data and cannot be removed!"))

        records = self              # all the records to delete
        fields_ = OrderedSet()      # all the fields corresponding to 'records'
        failed_dependencies = []    # list of broken (field, dependent_field)

        for record in self:
            model = self.env.get(record.model)
            if model is None:
                continue
            field = model._fields.get(record.name)
            if field is None:
                continue
            fields_.add(field)
            for dep in self.pool.get_dependent_fields(field):
                if dep.manual:
                    failed_dependencies.append((field, dep))
                elif dep.inherited:
                    fields_.add(dep)
                    records |= self._get(dep.model_name, dep.name)

        for field in fields_:
            for inverse in model.pool.field_inverses[field]:
                if inverse.manual and inverse.type == 'one2many':
                    failed_dependencies.append((field, inverse))

        self = records

        if failed_dependencies:
            if not uninstalling:
                field, dep = failed_dependencies[0]
                raise UserError(_(
                    "The field '%s' cannot be removed because the field '%s' depends on it.",
                    field, dep,
                ))
            else:
                self = self.union(*[
                    self._get(dep.model_name, dep.name)
                    for field, dep in failed_dependencies
                ])

        records = self.filtered(lambda record: record.state == 'manual')
        if not records:
            return self

        # remove pending write of this field
        # DLE P16: if there are pending updates of the field we currently try to unlink, pop them out from the cache
        # test `test_unlink_with_dependant`
        for record in records:
            model = self.env.get(record.model)
            field = model and model._fields.get(record.name)
            if field:
                self.env.cache.clear_dirty_field(field)
        # remove fields from registry, and check that views are not broken
        fields = [self.env[record.model]._pop_field(record.name) for record in records]
        domain = expression.OR([('arch_db', 'like', record.name)] for record in records)
        views = self.env['ir.ui.view'].search(domain)
        try:
            for view in views:
                view._check_xml()
        except Exception:
            if not uninstalling:
                raise UserError(_(
                    "Cannot rename/delete fields that are still present in views:\nFields: %s\nView: %s",
                    ", ".join(str(f) for f in fields),
                    view.name,
                ))
            else:
                # uninstall mode
                _logger.warning(
                    "The following fields were force-deleted to prevent a registry crash %s the following view might be broken %s",
                    ", ".join(str(f) for f in fields),
                    view.name)
        finally:
            if not uninstalling:
                # the registry has been modified, restore it
                self.pool.setup_models(self._cr)

        return self

    def unlink(self):
        if not self:
            return True

        # prevent screwing up fields that depend on these fields
        self = self._prepare_update()

        # determine registry fields corresponding to self
        fields = OrderedSet()
        for record in self:
            try:
                fields.add(self.pool[record.model]._fields[record.name])
            except KeyError:
                pass

        # clean the registry from the fields to remove
        self.pool.registry_invalidated = True
        self.pool._discard_fields(fields)

        # discard the removed fields from fields to compute
        for field in fields:
            self.env.all.tocompute.pop(field, None)

        model_names = self.mapped('model')
        self._drop_column()
        res = super(IrModelFields, self).unlink()

        # The field we just deleted might be inherited, and the registry is
        # inconsistent in this case; therefore we reload the registry.
        if not self._context.get(MODULE_UNINSTALL_FLAG):
            # setup models; this re-initializes models in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)
            # update database schema of model and its descendant models
            models = self.pool.descendants(model_names, '_inherits')
            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))

        return res

    @api.model_create_multi
    def create(self, vals_list):
        IrModel = self.env['ir.model']
        models = set()
        for vals in vals_list:
            if 'model_id' in vals:
                vals['model'] = IrModel.browse(vals['model_id']).model
            assert vals.get('model'), f"missing model name for {vals}"
            models.add(vals['model'])

        # for self._get_ids() in _update_selection()
        self.env.registry.clear_cache()

        res = super(IrModelFields, self).create(vals_list)

        for vals in vals_list:
            if vals.get('state', 'manual') == 'manual':
                relation = vals.get('relation')
                if relation and not IrModel._get_id(relation):
                    raise UserError(_("Model %s does not exist!", vals['relation']))

                if vals.get('ttype') == 'one2many' and not self.search_count([
                    ('ttype', '=', 'many2one'),
                    ('model', '=', vals['relation']),
                    ('name', '=', vals['relation_field']),
                ]):
                    raise UserError(_("Many2one %s on model %s does not exist!", vals['relation_field'], vals['relation']))

        if any(model in self.pool for model in models):
            # setup models; this re-initializes model in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)
            # update database schema of models and their descendants
            models = self.pool.descendants(models, '_inherits')
            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))

        return res

    def write(self, vals):
        if not self:
            return True

        # if set, *one* column can be renamed here
        column_rename = None

        # names of the models to patch
        patched_models = set()
        translate_only = all(self._fields[field_name].translate for field_name in vals)
        if vals and self and not translate_only:
            for item in self:
                if item.state != 'manual':
                    raise UserError(_('Properties of base fields cannot be altered in this manner! '
                                      'Please modify them through Python code, '
                                      'preferably through a custom addon!'))

                if vals.get('model_id', item.model_id.id) != item.model_id.id:
                    raise UserError(_("Changing the model of a field is forbidden!"))

                if vals.get('ttype', item.ttype) != item.ttype:
                    raise UserError(_("Changing the type of a field is not yet supported. "
                                      "Please drop it and create it again!"))

                obj = self.pool.get(item.model)
                field = getattr(obj, '_fields', {}).get(item.name)

                if vals.get('name', item.name) != item.name:
                    # We need to rename the field
                    item._prepare_update()
                    if item.ttype in ('one2many', 'many2many', 'binary'):
                        # those field names are not explicit in the database!
                        pass
                    else:
                        if column_rename:
                            raise UserError(_('Can only rename one field at a time!'))
                        column_rename = (obj._table, item.name, vals['name'], item.index, item.store)

                # We don't check the 'state', because it might come from the context
                # (thus be set for multiple fields) and will be ignored anyway.
                if obj is not None and field is not None:
                    patched_models.add(obj._name)

        # These shall never be written (modified)
        for column_name in ('model_id', 'model', 'state'):
            if column_name in vals:
                del vals[column_name]

        res = super(IrModelFields, self).write(vals)

        self.env.flush_all()

        if column_rename:
            # rename column in database, and its corresponding index if present
            table, oldname, newname, index, stored = column_rename
            if stored:
                self._cr.execute(
                    sql.SQL('ALTER TABLE {} RENAME COLUMN {} TO {}').format(
                        sql.Identifier(table),
                        sql.Identifier(oldname),
                        sql.Identifier(newname)
                    ))
                if index:
                    self._cr.execute(
                        sql.SQL('ALTER INDEX {} RENAME TO {}').format(
                            sql.Identifier(f'{table}_{oldname}_index'),
                            sql.Identifier(f'{table}_{newname}_index'),
                        ))

        if column_rename or patched_models or translate_only:
            # setup models, this will reload all manual fields in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)

        if patched_models:
            # update the database schema of the models to patch
            models = self.pool.descendants(patched_models, '_inherits')
            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))

        return res

    @api.depends('field_description', 'model')
    def _compute_display_name(self):
        IrModel = self.env["ir.model"]
        for field in self:
            if self.env.context.get('hide_model'):
                field.display_name = field.field_description
                continue
            model_string = IrModel._get(field.model).name
            field.display_name = f'{field.field_description} ({model_string})'

    def _reflect_field_params(self, field, model_id):
        """ Return the values to write to the database for the given field. """
        return {
            'model_id': model_id,
            'model': field.model_name,
            'name': field.name,
            'field_description': field.string,
            'help': field.help or None,
            'ttype': field.type,
            'state': 'manual' if field.manual else 'base',
            'relation': field.comodel_name or None,
            'index': bool(field.index),
            'store': bool(field.store),
            'copied': bool(field.copy),
            'on_delete': field.ondelete if field.type == 'many2one' else None,
            'related': field.related or None,
            'readonly': bool(field.readonly),
            'required': bool(field.required),
            'selectable': bool(field.search or field.store),
            'size': getattr(field, 'size', None),
            'translate': bool(field.translate),
            'relation_field': field.inverse_name if field.type == 'one2many' else None,
            'relation_table': field.relation if field.type == 'many2many' else None,
            'column1': field.column1 if field.type == 'many2many' else None,
            'column2': field.column2 if field.type == 'many2many' else None,
            'currency_field': field.currency_field if field.type == 'monetary' else None,
            # html sanitization attributes (useless for other fields)
            'sanitize': field.sanitize if field.type == 'html' else None,
            'sanitize_overridable': field.sanitize_overridable if field.type == 'html' else None,
            'sanitize_tags': field.sanitize_tags if field.type == 'html' else None,
            'sanitize_attributes': field.sanitize_attributes if field.type == 'html' else None,
            'sanitize_style': field.sanitize_style if field.type == 'html' else None,
            'sanitize_form': field.sanitize_form if field.type == 'html' else None,
            'strip_style': field.strip_style if field.type == 'html' else None,
            'strip_classes': field.strip_classes if field.type == 'html' else None,
        }

    def _reflect_fields(self, model_names):
        """ Reflect the fields of the given models. """
        cr = self.env.cr

        for model_name in model_names:
            model = self.env[model_name]
            by_label = {}
            for field in model._fields.values():
                if field.string in by_label:
                    other = by_label[field.string]
                    _logger.warning('Two fields (%s, %s) of %s have the same label: %s. [Modules: %s and %s]',
                                    field.name, other.name, model, field.string, field._module, other._module)
                else:
                    by_label[field.string] = field

        # determine expected and existing rows
        rows = []
        for model_name in model_names:
            model_id = self.env['ir.model']._get_id(model_name)
            for field in self.env[model_name]._fields.values():
                rows.append(self._reflect_field_params(field, model_id))
        if not rows:
            return
        cols = list(unique(['model', 'name'] + list(rows[0])))
        expected = [tuple(row[col] for col in cols) for row in rows]

        field_ids = {}
        existing = {}
        for row in select_en(self, ['id'] + cols, "model IN %s", [tuple(model_names)]):
            field_ids[row[1:3]] = row[0]
            existing[row[1:3]] = row[1:]

        # create or update rows
        rows = [row for row in expected if existing.get(row[:2]) != row]
        if rows:
            ids = upsert_en(self, cols, rows, ['model', 'name'])
            for row, id_ in zip(rows, ids):
                field_ids[row[:2]] = id_
            self.pool.post_init(mark_modified, self.browse(ids), cols[2:])

        # update their XML id
        module = self._context.get('module')
        if not module:
            return

        data_list = []
        for (field_model, field_name), field_id in field_ids.items():
            model = self.env[field_model]
            field = model._fields.get(field_name)
            if field and (
                module == model._original_module
                or module in field._modules
                or any(
                    # module introduced field on model by inheritance
                    field_name in self.env[parent]._fields
                    for parent, parent_module in model._inherit_module.items()
                    if module == parent_module
                )
            ):
                xml_id = field_xmlid(module, field_model, field_name)
                record = self.browse(field_id)
                data_list.append({'xml_id': xml_id, 'record': record})
        self.env['ir.model.data']._update_xmlids(data_list)

    @tools.ormcache()
    def _all_manual_field_data(self):
        cr = self._cr
        # we cannot use self._fields to determine translated fields, as it has not been set up yet
        cr.execute("""
            SELECT *, field_description->>'en_US' AS field_description, help->>'en_US' AS help
            FROM ir_model_fields
            WHERE state = 'manual'
        """)
        result = defaultdict(dict)
        for row in cr.dictfetchall():
            result[row['model']][row['name']] = row
        return result

    def _get_manual_field_data(self, model_name):
        """ Return the given model's manual field data. """
        return self._all_manual_field_data().get(model_name, {})

    def _instanciate_attrs(self, field_data):
        """ Return the parameters for a field instance for ``field_data``. """
        attrs = {
            'manual': True,
            'string': field_data['field_description'],
            'help': field_data['help'],
            'index': bool(field_data['index']),
            'copy': bool(field_data['copied']),
            'related': field_data['related'],
            'required': bool(field_data['required']),
            'readonly': bool(field_data['readonly']),
            'store': bool(field_data['store']),
        }
        if field_data['ttype'] in ('char', 'text', 'html'):
            attrs['translate'] = bool(field_data['translate'])
            if field_data['ttype'] == 'char':
                attrs['size'] = field_data['size'] or None
            elif field_data['ttype'] == 'html':
                attrs['sanitize'] = field_data['sanitize']
                attrs['sanitize_overridable'] = field_data['sanitize_overridable']
                attrs['sanitize_tags'] = field_data['sanitize_tags']
                attrs['sanitize_attributes'] = field_data['sanitize_attributes']
                attrs['sanitize_style'] = field_data['sanitize_style']
                attrs['sanitize_form'] = field_data['sanitize_form']
                attrs['strip_style'] = field_data['strip_style']
                attrs['strip_classes'] = field_data['strip_classes']
        elif field_data['ttype'] in ('selection', 'reference'):
            attrs['selection'] = self.env['ir.model.fields.selection']._get_selection_data(field_data['id'])
            if field_data['ttype'] == 'selection':
                attrs['group_expand'] = field_data['group_expand']
        elif field_data['ttype'] == 'many2one':
            if not self.pool.loaded and field_data['relation'] not in self.env:
                return
            attrs['comodel_name'] = field_data['relation']
            attrs['ondelete'] = field_data['on_delete']
            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
            attrs['group_expand'] = '_read_group_expand_full' if field_data['group_expand'] else None
        elif field_data['ttype'] == 'one2many':
            if not self.pool.loaded and not (
                field_data['relation'] in self.env and (
                    field_data['relation_field'] in self.env[field_data['relation']]._fields or
                    field_data['relation_field'] in self._get_manual_field_data(field_data['relation'])
            )):
                return
            attrs['comodel_name'] = field_data['relation']
            attrs['inverse_name'] = field_data['relation_field']
            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
        elif field_data['ttype'] == 'many2many':
            if not self.pool.loaded and field_data['relation'] not in self.env:
                return
            attrs['comodel_name'] = field_data['relation']
            rel, col1, col2 = self._custom_many2many_names(field_data['model'], field_data['relation'])
            attrs['relation'] = field_data['relation_table'] or rel
            attrs['column1'] = field_data['column1'] or col1
            attrs['column2'] = field_data['column2'] or col2
            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
        elif field_data['ttype'] == 'monetary':
            # be sure that custom monetary field are always instanciated
            if not self.pool.loaded and \
                not (field_data['currency_field'] and self._is_manual_name(field_data['currency_field'])):
                return
            attrs['currency_field'] = field_data['currency_field']
        # add compute function if given
        if field_data['compute']:
            attrs['compute'] = make_compute(field_data['compute'], field_data['depends'])
        return attrs

    def _instanciate(self, field_data):
        """ Return a field instance corresponding to parameters ``field_data``. """
        attrs = self._instanciate_attrs(field_data)
        if attrs:
            return fields.Field.by_type[field_data['ttype']](**attrs)

    @api.model
    def _is_manual_name(self, name):
        return name.startswith('x_')

    def _add_manual_fields(self, model):
        """ Add extra fields on model. """
        fields_data = self._get_manual_field_data(model._name)
        for name, field_data in fields_data.items():
            if name not in model._fields and field_data['state'] == 'manual':
                try:
                    field = self._instanciate(field_data)
                    if field:
                        model._add_field(name, field)
                except Exception:
                    _logger.exception("Failed to load field %s.%s: skipped", model._name, field_data['name'])

    @api.model
    @tools.ormcache_context('model_name', keys=('lang',))
    def get_field_string(self, model_name):
        """ Return the translation of fields strings in the context's language.
        Note that the result contains the available translations only.

        :param model_name: the name of a model
        :return: the model's fields' strings as a dictionary `{field_name: field_string}`
        """
        fields = self.sudo().search([('model', '=', model_name)])
        return {field.name: field.field_description for field in fields}

    @api.model
    @tools.ormcache_context('model_name', keys=('lang',))
    def get_field_help(self, model_name):
        """ Return the translation of fields help in the context's language.
        Note that the result contains the available translations only.

        :param model_name: the name of a model
        :return: the model's fields' help as a dictionary `{field_name: field_help}`
        """
        fields = self.sudo().search([('model', '=', model_name)])
        return {field.name: field.help for field in fields}

    @api.model
    @tools.ormcache_context('model_name', 'field_name', keys=('lang',))
    def get_field_selection(self, model_name, field_name):
        """ Return the translation of a field's selection in the context's language.
        Note that the result contains the available translations only.

        :param model_name: the name of the field's model
        :param field_name: the name of the field
        :return: the fields' selection as a list
        """
        field = self._get(model_name, field_name)
        return [(sel.value, sel.name) for sel in field.selection_ids]


class ModelInherit(models.Model):
    _name = "ir.model.inherit"
    _description = "Model Inheritance Tree"
    _log_access = False

    model_id = fields.Many2one("ir.model", required=True, ondelete="cascade")
    parent_id = fields.Many2one("ir.model", required=True, ondelete="cascade")
    parent_field_id = fields.Many2one("ir.model.fields", ondelete="cascade")  # in case of inherits

    _sql_constraints = [
        ("uniq", "UNIQUE(model_id, parent_id)", "Models inherits from another only once")
    ]

    def _reflect_inherits(self, model_names):
        """ Reflect the given models' inherits (_inherit and _inherits). """
        IrModel = self.env["ir.model"]
        get_model_id = IrModel._get_id

        module_mapping = defaultdict(list)
        for model_name in model_names:
            get_field_id = self.env["ir.model.fields"]._get_ids(model_name).get
            model_id = get_model_id(model_name)
            model = self.env[model_name]

            for cls in reversed(type(model).mro()):
                if not models.is_definition_class(cls):
                    continue

                items = [
                    (model_id, get_model_id(parent_name), None)
                    for parent_name in cls._inherit
                    if parent_name not in ("base", model_name)
                ] + [
                    (model_id, get_model_id(parent_name), get_field_id(field))
                    for parent_name, field in cls._inherits.items()
                ]

                for item in items:
                    module_mapping[item].append(cls._module)

        if not module_mapping:
            return

        cr = self.env.cr
        cr.execute(
            """
                SELECT i.id, i.model_id, i.parent_id, i.parent_field_id
                  FROM ir_model_inherit i
                  JOIN ir_model m
                    ON m.id = i.model_id
                 WHERE m.model IN %s
            """,
            [tuple(model_names)]
        )
        existing = {}
        inh_ids = {}
        for iid, model_id, parent_id, parent_field_id in cr.fetchall():
            inh_ids[(model_id, parent_id, parent_field_id)] = iid
            existing[(model_id, parent_id)] = parent_field_id

        sentinel = object()
        cols = ["model_id", "parent_id", "parent_field_id"]
        rows = [item for item in module_mapping if existing.get(item[:2], sentinel) != item[2]]
        if rows:
            ids = upsert_en(self, cols, rows, ["model_id", "parent_id"])
            for row, id_ in zip(rows, ids):
                inh_ids[row] = id_
            self.pool.post_init(mark_modified, self.browse(ids), cols[1:])

        # update their XML id
        IrModel.browse(id_ for item in module_mapping for id_ in item[:2]).fetch(['model'])
        data_list = []
        for (model_id, parent_id, parent_field_id), modules in module_mapping.items():
            model_name = IrModel.browse(model_id).model.replace(".", "_")
            parent_name = IrModel.browse(parent_id).model.replace(".", "_")
            record_id = inh_ids[(model_id, parent_id, parent_field_id)]
            data_list += [
                {
                    "xml_id": f"{module}.model_inherit__{model_name}__{parent_name}",
                    "record": self.browse(record_id),
                }
                for module in modules
            ]

        self.env["ir.model.data"]._update_xmlids(data_list)


class IrModelSelection(models.Model):
    _name = 'ir.model.fields.selection'
    _order = 'sequence, id'
    _description = "Fields Selection"
    _allow_sudo_commands = False

    field_id = fields.Many2one("ir.model.fields",
        required=True, ondelete="cascade", index=True,
        domain=[('ttype', 'in', ['selection', 'reference'])])
    value = fields.Char(required=True)
    name = fields.Char(translate=True, required=True)
    sequence = fields.Integer(default=1000)

    _sql_constraints = [
        ('selection_field_uniq', 'unique(field_id, value)',
         'Selections values must be unique per field'),
    ]

    def _get_selection(self, field_id):
        """ Return the given field's selection as a list of pairs (value, string). """
        self.flush_model(['value', 'name', 'field_id', 'sequence'])
        return self._get_selection_data(field_id)

    def _get_selection_data(self, field_id):
        # return selection as expected on registry (no translations)
        self._cr.execute("""
            SELECT value, name->>'en_US'
            FROM ir_model_fields_selection
            WHERE field_id=%s
            ORDER BY sequence, id
        """, (field_id,))
        return self._cr.fetchall()

    def _reflect_selections(self, model_names):
        """ Reflect the selections of the fields of the given models. """
        fields = [
            field
            for model_name in model_names
            for field_name, field in self.env[model_name]._fields.items()
            if field.type in ('selection', 'reference')
            if isinstance(field.selection, list)
        ]
        if not fields:
            return

        # determine expected and existing rows
        IMF = self.env['ir.model.fields']
        expected = {
            (field_id, value): (label, index)
            for field in fields
            for field_id in [IMF._get_ids(field.model_name)[field.name]]
            for index, (value, label) in enumerate(field.selection)
        }

        cr = self.env.cr
        query = """
            SELECT s.field_id, s.value, s.name->>'en_US', s.sequence
            FROM ir_model_fields_selection s, ir_model_fields f
            WHERE s.field_id = f.id AND f.model IN %s
        """
        cr.execute(query, [tuple(model_names)])
        existing = {row[:2]: row[2:] for row in cr.fetchall()}

        # create or update rows
        cols = ['field_id', 'value', 'name', 'sequence']
        rows = [key + val for key, val in expected.items() if existing.get(key) != val]
        if rows:
            ids = upsert_en(self, cols, rows, ['field_id', 'value'])
            self.pool.post_init(mark_modified, self.browse(ids), cols[2:])

        # update their XML ids
        module = self._context.get('module')
        if not module:
            return

        query = """
            SELECT f.model, f.name, s.value, s.id
            FROM ir_model_fields_selection s, ir_model_fields f
            WHERE s.field_id = f.id AND f.model IN %s
        """
        cr.execute(query, [tuple(model_names)])
        selection_ids = {row[:3]: row[3] for row in cr.fetchall()}

        data_list = []
        for field in fields:
            model = self.env[field.model_name]
            for value, modules in field._selection_modules(model).items():
                for m in modules:
                    xml_id = selection_xmlid(m, field.model_name, field.name, value)
                    record = self.browse(selection_ids[field.model_name, field.name, value])
                    data_list.append({'xml_id': xml_id, 'record': record})
        self.env['ir.model.data']._update_xmlids(data_list)

    def _update_selection(self, model_name, field_name, selection):
        """ Set the selection of a field to the given list, and return the row
            values of the given selection records.
        """
        field_id = self.env['ir.model.fields']._get_ids(model_name)[field_name]

        # selection rows {value: row}
        cur_rows = self._existing_selection_data(model_name, field_name)
        new_rows = {
            value: dict(value=value, name=label, sequence=index)
            for index, (value, label) in enumerate(selection)
        }

        rows_to_insert = []
        rows_to_update = []
        rows_to_remove = []
        for value in new_rows.keys() | cur_rows.keys():
            new_row, cur_row = new_rows.get(value), cur_rows.get(value)
            if new_row is None:
                if self.pool.ready:
                    # removing a selection in the new list, at your own risks
                    _logger.warning("Removing selection value %s on %s.%s",
                                    cur_row['value'], model_name, field_name)
                    rows_to_remove.append(cur_row['id'])
            elif cur_row is None:
                new_row['name'] = Json({'en_US': new_row['name']})
                rows_to_insert.append(dict(new_row, field_id=field_id))
            elif any(new_row[key] != cur_row[key] for key in new_row):
                new_row['name'] = Json({'en_US': new_row['name']})
                rows_to_update.append(dict(new_row, id=cur_row['id']))

        if rows_to_insert:
            row_ids = query_insert(self.env.cr, self._table, rows_to_insert)
            # update cur_rows for output
            for row, row_id in zip(rows_to_insert, row_ids):
                cur_rows[row['value']] = dict(row, id=row_id)

        for row in rows_to_update:
            query_update(self.env.cr, self._table, row, ['id'])

        if rows_to_remove:
            self.browse(rows_to_remove).unlink()

        return cur_rows

    def _existing_selection_data(self, model_name, field_name):
        """ Return the selection data of the given model, by field and value, as
            a dict {field_name: {value: row_values}}.
        """
        query = """
            SELECT s.*, s.name->>'en_US' AS name
            FROM ir_model_fields_selection s
            JOIN ir_model_fields f ON s.field_id=f.id
            WHERE f.model=%s and f.name=%s
        """
        self._cr.execute(query, [model_name, field_name])
        return {row['value']: row for row in self._cr.dictfetchall()}

    @api.model_create_multi
    def create(self, vals_list):
        field_ids = {vals['field_id'] for vals in vals_list}
        field_names = set()
        for field in self.env['ir.model.fields'].browse(field_ids):
            field_names.add((field.model, field.name))
            if field.state != 'manual':
                raise UserError(_('Properties of base fields cannot be altered in this manner! '
                                  'Please modify them through Python code, '
                                  'preferably through a custom addon!'))
        recs = super().create(vals_list)

        if any(
            model in self.pool and name in self.pool[model]._fields
            for model, name in field_names
        ):
            # setup models; this re-initializes model in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)

        return recs

    def write(self, vals):
        if not self:
            return True

        if (
            not self.env.user._is_admin() and
            any(record.field_id.state != 'manual' for record in self)
        ):
            raise UserError(_('Properties of base fields cannot be altered in this manner! '
                              'Please modify them through Python code, '
                              'preferably through a custom addon!'))

        if 'value' in vals:
            for selection in self:
                if selection.value == vals['value']:
                    continue
                if selection.field_id.store:
                    # in order to keep the cache consistent, flush the
                    # corresponding field, and invalidate it from cache
                    model = self.env[selection.field_id.model]
                    fname = selection.field_id.name
                    model.invalidate_model([fname])
                    # replace the value by the new one in the field's corresponding column
                    query = f'UPDATE "{model._table}" SET "{fname}"=%s WHERE "{fname}"=%s'
                    self.env.cr.execute(query, [vals['value'], selection.value])

        result = super().write(vals)

        # setup models; this re-initializes model in registry
        self.env.flush_all()
        self.pool.setup_models(self._cr)

        return result

    @api.ondelete(at_uninstall=False)
    def _unlink_if_manual(self):
        # Prevent manual deletion of module columns
        if (
            self.pool.ready
            and any(selection.field_id.state != 'manual' for selection in self)
        ):
            raise UserError(_('Properties of base fields cannot be altered in this manner! '
                              'Please modify them through Python code, '
                              'preferably through a custom addon!'))

    def unlink(self):
        self._process_ondelete()
        result = super().unlink()

        # Reload registry for normal unlink only. For module uninstall, the
        # reload is done independently in odoo.modules.loading.
        if not self._context.get(MODULE_UNINSTALL_FLAG):
            # setup models; this re-initializes model in registry
            self.env.flush_all()
            self.pool.setup_models(self._cr)

        return result

    def _process_ondelete(self):
        """ Process the 'ondelete' of the given selection values. """
        def safe_write(records, fname, value):
            if not records:
                return
            try:
                with self.env.cr.savepoint():
                    records.write({fname: value})
            except Exception:
                # going through the ORM failed, probably because of an exception
                # in an override or possibly a constraint.
                _logger.runbot(
                    "Could not fulfill ondelete action for field %s.%s, "
                    "attempting ORM bypass...", records._name, fname,
                )
                query = sql.SQL("UPDATE {} SET {}=%s WHERE id IN %s").format(
                    sql.Identifier(records._table),
                    sql.Identifier(fname),
                )
                # if this fails then we're shit out of luck and there's nothing
                # we can do except fix on a case-by-case basis
                value = field.convert_to_column(value, records)
                self.env.cr.execute(query, [value, records._ids])
                records.invalidate_recordset([fname])

        for selection in self:
            Model = self.env[selection.field_id.model]
            # The field may exist in database but not in registry. In this case
            # we allow the field to be skipped, but for production this should
            # be handled through a migration script. The ORM will take care of
            # the orphaned 'ir.model.fields' down the stack, and will log a
            # warning prompting the developer to write a migration script.
            field = Model._fields.get(selection.field_id.name)
            if not field or not field.store or not Model._auto:
                continue

            ondelete = (field.ondelete or {}).get(selection.value)
            # special case for custom fields
            if ondelete is None and field.manual and not field.required:
                ondelete = 'set null'

            if ondelete is None:
                # nothing to do, the selection does not come from a field extension
                continue
            elif callable(ondelete):
                ondelete(selection._get_records())
            elif ondelete == 'set null':
                safe_write(selection._get_records(), field.name, False)
            elif ondelete == 'set default':
                value = field.convert_to_write(field.default(Model), Model)
                safe_write(selection._get_records(), field.name, value)
            elif ondelete.startswith('set '):
                safe_write(selection._get_records(), field.name, ondelete[4:])
            elif ondelete == 'cascade':
                selection._get_records().unlink()
            else:
                # this shouldn't happen... simply a sanity check
                raise ValueError(_(
                    "The ondelete policy %r is not valid for field %r",
                    ondelete, selection
                ))

    def _get_records(self):
        """ Return the records having 'self' as a value. """
        self.ensure_one()
        Model = self.env[self.field_id.model]
        Model.flush_model([self.field_id.name])
        query = 'SELECT id FROM "{table}" WHERE "{field}"=%s'.format(
            table=Model._table, field=self.field_id.name,
        )
        self.env.cr.execute(query, [self.value])
        return Model.browse(r[0] for r in self.env.cr.fetchall())


class IrModelConstraint(models.Model):
    """
    This model tracks PostgreSQL foreign keys and constraints used by Odoo
    models.
    """
    _name = 'ir.model.constraint'
    _description = 'Model Constraint'
    _allow_sudo_commands = False

    name = fields.Char(string='Constraint', required=True, index=True,
                       help="PostgreSQL constraint or foreign key name.")
    definition = fields.Char(help="PostgreSQL constraint definition")
    message = fields.Char(help="Error message returned when the constraint is violated.", translate=True)
    model = fields.Many2one('ir.model', required=True, ondelete="cascade", index=True)
    module = fields.Many2one('ir.module.module', required=True, index=True, ondelete='cascade')
    type = fields.Char(string='Constraint Type', required=True, size=1, index=True,
                       help="Type of the constraint: `f` for a foreign key, "
                            "`u` for other constraints.")
    write_date = fields.Datetime()
    create_date = fields.Datetime()

    _sql_constraints = [
        ('module_name_uniq', 'unique(name, module)',
         'Constraints with the same name are unique per module.'),
    ]

    def unlink(self):
        self.check_access_rights('unlink')
        self.check_access_rule('unlink')
        ids_set = set(self.ids)
        for data in self.sorted(key='id', reverse=True):
            name = tools.ustr(data.name)
            if data.model.model in self.env:
                table = self.env[data.model.model]._table
            else:
                table = data.model.model.replace('.', '_')
            typ = data.type

            # double-check we are really going to delete all the owners of this schema element
            self._cr.execute("""SELECT id from ir_model_constraint where name=%s""", (data.name,))
            external_ids = set(x[0] for x in self._cr.fetchall())
            if external_ids - ids_set:
                # as installed modules have defined this element we must not delete it!
                continue

            if typ == 'f':
                # test if FK exists on this table (it could be on a related m2m table, in which case we ignore it)
                self._cr.execute("""SELECT 1 from pg_constraint cs JOIN pg_class cl ON (cs.conrelid = cl.oid)
                                    WHERE cs.contype=%s and cs.conname=%s and cl.relname=%s""",
                                 ('f', name, table))
                if self._cr.fetchone():
                    self._cr.execute(
                        sql.SQL('ALTER TABLE {} DROP CONSTRAINT {}').format(
                            sql.Identifier(table),
                            sql.Identifier(name[:63])
                        ))
                    _logger.info('Dropped FK CONSTRAINT %s@%s', name, data.model.model)

            if typ == 'u':
                hname = tools.make_identifier(name)
                # test if constraint exists
                # Since type='u' means any "other" constraint, to avoid issues we limit to
                # 'c' -> check, 'u' -> unique, 'x' -> exclude constraints, effective leaving
                # out 'p' -> primary key and 'f' -> foreign key, constraints.
                # See: https://www.postgresql.org/docs/9.5/catalog-pg-constraint.html
                self._cr.execute("""SELECT 1 from pg_constraint cs JOIN pg_class cl ON (cs.conrelid = cl.oid)
                                    WHERE cs.contype in ('c', 'u', 'x') and cs.conname=%s and cl.relname=%s""",
                                 (hname, table))
                if self._cr.fetchone():
                    self._cr.execute(sql.SQL('ALTER TABLE {} DROP CONSTRAINT {}').format(
                        sql.Identifier(table), sql.Identifier(hname)))
                    _logger.info('Dropped CONSTRAINT %s@%s', name, data.model.model)

        return super().unlink()

    def copy(self, default=None):
        default = dict(default or {})
        default['name'] = self.name + '_copy'
        return super(IrModelConstraint, self).copy(default)

    def _reflect_constraint(self, model, conname, type, definition, module, message=None):
        """ Reflect the given constraint, and return its corresponding record
            if a record is created or modified; returns ``None`` otherwise.
            The reflection makes it possible to remove a constraint when its
            corresponding module is uninstalled. ``type`` is either 'f' or 'u'
            depending on the constraint being a foreign key or not.
        """
        if not module:
            # no need to save constraints for custom models as they're not part
            # of any module
            return
        assert type in ('f', 'u')
        cr = self._cr
        query = """ SELECT c.id, type, definition, message->>'en_US' as message
                    FROM ir_model_constraint c, ir_module_module m
                    WHERE c.module=m.id AND c.name=%s AND m.name=%s """
        cr.execute(query, (conname, module))
        cons = cr.dictfetchone()
        if not cons:
            query = """ INSERT INTO ir_model_constraint
                            (name, create_date, write_date, create_uid, write_uid, module, model, type, definition, message)
                        VALUES (%s,
                                now() AT TIME ZONE 'UTC',
                                now() AT TIME ZONE 'UTC',
                                %s, %s,
                                (SELECT id FROM ir_module_module WHERE name=%s),
                                (SELECT id FROM ir_model WHERE model=%s),
                                %s, %s, %s)
                        RETURNING id"""
            cr.execute(query, (conname, self.env.uid, self.env.uid, module, model._name, type, definition, Json({'en_US': message})))
            return self.browse(cr.fetchone()[0])

        cons_id = cons.pop('id')
        if cons != dict(type=type, definition=definition, message=message):
            query = """ UPDATE ir_model_constraint
                        SET write_date=now() AT TIME ZONE 'UTC',
                            write_uid=%s, type=%s, definition=%s, message=%s
                        WHERE id=%s"""
            cr.execute(query, (self.env.uid, type, definition, Json({'en_US': message}), cons_id))
            return self.browse(cons_id)

    def _reflect_constraints(self, model_names):
        """ Reflect the SQL constraints of the given models. """
        for model_name in model_names:
            self._reflect_model(self.env[model_name])

    def _reflect_model(self, model):
        """ Reflect the _sql_constraints of the given model. """
        def cons_text(txt):
            return txt.lower().replace(', ',',').replace(' (','(')

        # map each constraint on the name of the module where it is defined
        constraint_module = {
            constraint[0]: cls._module
            for cls in reversed(self.env.registry[model._name].mro())
            if models.is_definition_class(cls)
            for constraint in getattr(cls, '_local_sql_constraints', ())
        }

        data_list = []
        for (key, definition, message) in model._sql_constraints:
            conname = '%s_%s' % (model._table, key)
            module = constraint_module.get(key)
            record = self._reflect_constraint(model, conname, 'u', cons_text(definition), module, message)
            xml_id = '%s.constraint_%s' % (module, conname)
            if record:
                data_list.append(dict(xml_id=xml_id, record=record))
            else:
                self.env['ir.model.data']._load_xmlid(xml_id)
        if data_list:
            self.env['ir.model.data']._update_xmlids(data_list)


class IrModelRelation(models.Model):
    """
    This model tracks PostgreSQL tables used to implement Odoo many2many
    relations.
    """
    _name = 'ir.model.relation'
    _description = 'Relation Model'
    _allow_sudo_commands = False

    name = fields.Char(string='Relation Name', required=True, index=True,
                       help="PostgreSQL table name implementing a many2many relation.")
    model = fields.Many2one('ir.model', required=True, index=True, ondelete='cascade')
    module = fields.Many2one('ir.module.module', required=True, index=True, ondelete='cascade')
    write_date = fields.Datetime()
    create_date = fields.Datetime()

    def _module_data_uninstall(self):
        """
        Delete PostgreSQL many2many relations tracked by this model.
        """
        if not self.env.is_system():
            raise AccessError(_('Administrator access is required to uninstall a module'))

        ids_set = set(self.ids)
        to_drop = tools.OrderedSet()
        for data in self.sorted(key='id', reverse=True):
            name = tools.ustr(data.name)

            # double-check we are really going to delete all the owners of this schema element
            self._cr.execute("""SELECT id from ir_model_relation where name = %s""", (data.name,))
            external_ids = set(x[0] for x in self._cr.fetchall())
            if external_ids - ids_set:
                # as installed modules have defined this element we must not delete it!
                continue

            if tools.table_exists(self._cr, name):
                to_drop.add(name)

        self.unlink()

        # drop m2m relation tables
        for table in to_drop:
            self._cr.execute(sql.SQL('DROP TABLE {} CASCADE').format(sql.Identifier(table)))
            _logger.info('Dropped table %s', table)

    def _reflect_relation(self, model, table, module):
        """ Reflect the table of a many2many field for the given model, to make
            it possible to delete it later when the module is uninstalled.
        """
        self.env.invalidate_all()
        cr = self._cr
        query = """ SELECT 1 FROM ir_model_relation r, ir_module_module m
                    WHERE r.module=m.id AND r.name=%s AND m.name=%s """
        cr.execute(query, (table, module))
        if not cr.rowcount:
            query = """ INSERT INTO ir_model_relation
                            (name, create_date, write_date, create_uid, write_uid, module, model)
                        VALUES (%s,
                                now() AT TIME ZONE 'UTC',
                                now() AT TIME ZONE 'UTC',
                                %s, %s,
                                (SELECT id FROM ir_module_module WHERE name=%s),
                                (SELECT id FROM ir_model WHERE model=%s)) """
            cr.execute(query, (table, self.env.uid, self.env.uid, module, model._name))


class IrModelAccess(models.Model):
    _name = 'ir.model.access'
    _description = 'Model Access'
    _order = 'model_id,group_id,name,id'
    _allow_sudo_commands = False

    name = fields.Char(required=True, index=True)
    active = fields.Boolean(default=True, help='If you uncheck the active field, it will disable the ACL without deleting it (if you delete a native ACL, it will be re-created when you reload the module).')
    model_id = fields.Many2one('ir.model', string='Model', required=True, index=True, ondelete='cascade')
    group_id = fields.Many2one('res.groups', string='Group', ondelete='restrict', index=True)
    perm_read = fields.Boolean(string='Read Access')
    perm_write = fields.Boolean(string='Write Access')
    perm_create = fields.Boolean(string='Create Access')
    perm_unlink = fields.Boolean(string='Delete Access')

    @api.model
    def group_names_with_access(self, model_name, access_mode):
        """ Return the names of visible groups which have been granted
            ``access_mode`` on the model ``model_name``.
           :rtype: list
        """
        assert access_mode in ('read', 'write', 'create', 'unlink'), 'Invalid access mode'
        lang = self.env.lang or 'en_US'
        self._cr.execute(f"""
            SELECT COALESCE(c.name->>%s, c.name->>'en_US'), COALESCE(g.name->>%s, g.name->>'en_US')
              FROM ir_model_access a
              JOIN ir_model m ON (a.model_id = m.id)
              JOIN res_groups g ON (a.group_id = g.id)
         LEFT JOIN ir_module_category c ON (c.id = g.category_id)
             WHERE m.model = %s
               AND a.active = TRUE
               AND a.perm_{access_mode} = TRUE
          ORDER BY c.name, g.name NULLS LAST
        """, [lang, lang, model_name])
        return [('%s/%s' % x) if x[0] else x[1] for x in self._cr.fetchall()]

    # The context parameter is useful when the method translates error messages.
    # But as the method raises an exception in that case,  the key 'lang' might
    # not be really necessary as a cache key, unless the `ormcache_context`
    # decorator catches the exception (it does not at the moment.)

    @tools.ormcache('self.env.uid', 'mode')
    def _get_allowed_models(self, mode='read'):
        assert mode in ('read', 'write', 'create', 'unlink'), 'Invalid access mode'

        self.flush_model()
        self.env.cr.execute(f"""
            SELECT m.model
              FROM ir_model_access a
              JOIN ir_model m ON (m.id = a.model_id)
             WHERE a.perm_{mode}
               AND a.active
               AND (
                    a.group_id IS NULL OR
                    -- use subselect fo force a better query plan. See #99695 --
                    a.group_id IN (
                        SELECT gu.gid
                            FROM res_groups_users_rel gu
                            WHERE gu.uid = %s
                    )
                )
            GROUP BY m.model
        """, (self.env.uid,))

        return frozenset(v[0] for v in self.env.cr.fetchall())

    @api.model
    def check(self, model, mode='read', raise_exception=True):
        if self.env.su:
            # User root have all accesses
            return True

        assert isinstance(model, str), 'Not a model name: %s' % (model,)

        # TransientModel records have no access rights, only an implicit access rule
        if model not in self.env:
            _logger.error('Missing model %s', model)

        has_access = model in self._get_allowed_models(mode)

        if not has_access and raise_exception:
            groups = '\n'.join('\t- %s' % g for g in self.group_names_with_access(model, mode))
            document_kind = self.env['ir.model']._get(model).name or model
            msg_heads = {
                # Messages are declared in extenso so they are properly exported in translation terms
                'read': _lt(
                    "You are not allowed to access '%(document_kind)s' (%(document_model)s) records.",
                    document_kind=document_kind,
                    document_model=model,
                ),
                'write':  _lt(
                    "You are not allowed to modify '%(document_kind)s' (%(document_model)s) records.",
                    document_kind=document_kind,
                    document_model=model,
                ),
                'create': _lt(
                    "You are not allowed to create '%(document_kind)s' (%(document_model)s) records.",
                    document_kind=document_kind,
                    document_model=model,
                ),
                'unlink': _lt(
                    "You are not allowed to delete '%(document_kind)s' (%(document_model)s) records.",
                    document_kind=document_kind,
                    document_model=model,
                ),
            }
            operation_error = msg_heads[mode]

            if groups:
                group_info = _("This operation is allowed for the following groups:\n%(groups_list)s", groups_list=groups)
            else:
                group_info = _("No group currently allows this operation.")

            resolution_info = _("Contact your administrator to request access if necessary.")

            _logger.info('Access Denied by ACLs for operation: %s, uid: %s, model: %s', mode, self._uid, model)
            msg = """{operation_error}

{group_info}

{resolution_info}""".format(
                operation_error=operation_error,
                group_info=group_info,
                resolution_info=resolution_info)

            raise AccessError(msg) from None

        return has_access


    @api.model
    def call_cache_clearing_methods(self):
        self.env.invalidate_all()
        self.env.registry.clear_cache()  # mainly _get_allowed_models

    #
    # Check rights on actions
    #
    @api.model_create_multi
    def create(self, vals_list):
        self.call_cache_clearing_methods()
        for ima in vals_list:
            if "group_id" in ima and not ima["group_id"] and any([
                    ima.get("perm_read"),
                    ima.get("perm_write"),
                    ima.get("perm_create"),
                    ima.get("perm_unlink")]):
                _logger.warning("Rule %s has no group, this is a deprecated feature. Every access-granting rule should specify a group.", ima['name'])
        return super(IrModelAccess, self).create(vals_list)

    def write(self, values):
        self.call_cache_clearing_methods()
        return super(IrModelAccess, self).write(values)

    def unlink(self):
        self.call_cache_clearing_methods()
        return super(IrModelAccess, self).unlink()


class IrModelData(models.Model):
    """Holds external identifier keys for records in the database.
       This has two main uses:

           * allows easy data integration with third-party systems,
             making import/export/sync of data possible, as records
             can be uniquely identified across multiple systems
           * allows tracking the origin of data installed by Odoo
             modules themselves, thus making it possible to later
             update them seamlessly.
    """
    _name = 'ir.model.data'
    _description = 'Model Data'
    _order = 'module, model, name'
    _allow_sudo_commands = False

    name = fields.Char(string='External Identifier', required=True,
                       help="External Key/Identifier that can be used for "
                            "data integration with third-party systems")
    complete_name = fields.Char(compute='_compute_complete_name', string='Complete ID')
    model = fields.Char(string='Model Name', required=True)
    module = fields.Char(default='', required=True)
    res_id = fields.Many2oneReference(string='Record ID', help="ID of the target record in the database", model_field='model')
    noupdate = fields.Boolean(string='Non Updatable', default=False)
    reference = fields.Char(string='Reference', compute='_compute_reference', readonly=True, store=False)

    _sql_constraints = [
        ('name_nospaces', "CHECK(name NOT LIKE '% %')",
         "External IDs cannot contain spaces"),
    ]

    @api.depends('module', 'name')
    def _compute_complete_name(self):
        for res in self:
            res.complete_name = ".".join(n for n in [res.module, res.name] if n)

    @api.depends('model', 'res_id')
    def _compute_reference(self):
        for res in self:
            res.reference = "%s,%s" % (res.model, res.res_id)

    def _auto_init(self):
        res = super(IrModelData, self)._auto_init()
        tools.create_unique_index(self._cr, 'ir_model_data_module_name_uniq_index',
                                  self._table, ['module', 'name'])
        tools.create_index(self._cr, 'ir_model_data_model_res_id_index',
                           self._table, ['model', 'res_id'])
        return res

    @api.depends('res_id', 'model', 'complete_name')
    def _compute_display_name(self):
        invalid_records = self.filtered(lambda r: not r.res_id or r.model not in self.env)
        for invalid_record in invalid_records:
            invalid_record.display_name = invalid_record.complete_name
        for model, model_data_records in (self - invalid_records).grouped('model').items():
            records = self.env[model].browse(model_data_records.mapped('res_id'))
            for xid, target_record in zip(model_data_records, records):
                try:
                    xid.display_name = target_record.display_name or xid.complete_name
                except Exception:  # pylint: disable=broad-except
                    xid.display_name = xid.complete_name

    # NEW V8 API
    @api.model
    @tools.ormcache('xmlid')
    def _xmlid_lookup(self, xmlid: str) -> tuple:
        """Low level xmlid lookup
        Return (id, res_model, res_id) or raise ValueError if not found
        """
        module, name = xmlid.split('.', 1)
        query = "SELECT model, res_id FROM ir_model_data WHERE module=%s AND name=%s"
        self.env.cr.execute(query, [module, name])
        result = self.env.cr.fetchone()
        if not (result and result[1]):
            raise ValueError('External ID not found in the system: %s' % xmlid)
        return result

    @api.model
    def _xmlid_to_res_model_res_id(self, xmlid, raise_if_not_found=False):
        """ Return (res_model, res_id)"""
        try:
            return self._xmlid_lookup(xmlid)
        except ValueError:
            if raise_if_not_found:
                raise
            return (False, False)

    @api.model
    def _xmlid_to_res_id(self, xmlid, raise_if_not_found=False):
        """ Returns res_id """
        return self._xmlid_to_res_model_res_id(xmlid, raise_if_not_found)[1]

    @api.model
    def check_object_reference(self, module, xml_id, raise_on_access_error=False):
        """Returns (model, res_id) corresponding to a given module and xml_id (cached), if and only if the user has the necessary access rights
        to see that object, otherwise raise a ValueError if raise_on_access_error is True or returns a tuple (model found, False)"""
        model, res_id = self._xmlid_lookup("%s.%s" % (module, xml_id))
        #search on id found in result to check if current user has read access right
        if self.env[model].search([('id', '=', res_id)]):
            return model, res_id
        if raise_on_access_error:
            raise AccessError(_('Not enough access rights on the external ID %r', '%s.%s', (module, xml_id)))
        return model, False

    @api.returns('self', lambda value: value.id)
    def copy(self, default=None):
        self.ensure_one()
        rand = "%04x" % random.getrandbits(16)
        default = dict(default or {}, name="%s_%s" % (self.name, rand))
        return super().copy(default)

    def write(self, values):
        self.env.registry.clear_cache()  # _xmlid_lookup
        return super().write(values)

    def unlink(self):
        """ Regular unlink method, but make sure to clear the caches. """
        self.env.registry.clear_cache()  # _xmlid_lookup
        return super(IrModelData, self).unlink()

    def _lookup_xmlids(self, xml_ids, model):
        """ Look up the given XML ids of the given model. """
        if not xml_ids:
            return []

        # group xml_ids by prefix
        bymodule = defaultdict(set)
        for xml_id in xml_ids:
            prefix, suffix = xml_id.split('.', 1)
            bymodule[prefix].add(suffix)

        # query xml_ids by prefix
        result = []
        cr = self.env.cr
        for prefix, suffixes in bymodule.items():
            query = """
                SELECT d.id, d.module, d.name, d.model, d.res_id, d.noupdate, r.id
                FROM ir_model_data d LEFT JOIN "{}" r on d.res_id=r.id
                WHERE d.module=%s AND d.name IN %s
            """.format(model._table)
            for subsuffixes in cr.split_for_in_conditions(suffixes):
                cr.execute(query, (prefix, subsuffixes))
                result.extend(cr.fetchall())

        return result

    @api.model
    def _update_xmlids(self, data_list, update=False):
        """ Create or update the given XML ids.

            :param data_list: list of dicts with keys `xml_id` (XMLID to
                assign), `noupdate` (flag on XMLID), `record` (target record).
            :param update: should be ``True`` when upgrading a module
        """
        if not data_list:
            return

        rows = tools.OrderedSet()
        for data in data_list:
            prefix, suffix = data['xml_id'].split('.', 1)
            record = data['record']
            noupdate = bool(data.get('noupdate'))
            rows.add((prefix, suffix, record._name, record.id, noupdate))

        for sub_rows in self.env.cr.split_for_in_conditions(rows):
            # insert rows or update them
            query = self._build_update_xmlids_query(sub_rows, update)
            try:
                self.env.cr.execute(query, [arg for row in sub_rows for arg in row])
                result = self.env.cr.fetchall()
                if result:
                    for module, name, model, res_id, create_date, write_date in result:
                        # small optimisation: during install a lot of xmlid are created/updated.
                        # Instead of clearing the cache, set the correct value in the cache to avoid a bunch of query
                        self._xmlid_lookup.__cache__.add_value(self, f"{module}.{name}", cache_value=(model, res_id))
                        if create_date != write_date:
                            # something was updated, notify other workers
                            # it is possible that create_date and write_date
                            # have the same value after an update if it was
                            # created in the same transaction, no need to invalidate other worker cache
                            # cache in this case.
                            self.env.registry.cache_invalidated.add('default')

            except Exception:
                _logger.error("Failed to insert ir_model_data\n%s", "\n".join(str(row) for row in sub_rows))
                raise

        # update loaded_xmlids
        self.pool.loaded_xmlids.update("%s.%s" % row[:2] for row in rows)

    # NOTE: this method is overriden in web_studio; if you need to make another
    #  override, make sure it is compatible with the one that is there.
    def _build_insert_xmlids_values(self):
        return {
            'module': '%s',
            'name': '%s',
            'model': '%s',
            'res_id': '%s',
            'noupdate': '%s',
        }

    def _build_update_xmlids_query(self, sub_rows, update):
        rows = self._build_insert_xmlids_values()
        row_names = f"({','.join(rows.keys())})"
        row_placeholders = f"({','.join(rows.values())})"
        row_placeholders = ", ".join([row_placeholders] * len(sub_rows))
        return """
            INSERT INTO ir_model_data {row_names}
            VALUES {row_placeholder}
            ON CONFLICT (module, name)
            DO UPDATE SET (model, res_id, write_date) =
                (EXCLUDED.model, EXCLUDED.res_id, now() at time zone 'UTC')
                WHERE (ir_model_data.res_id != EXCLUDED.res_id OR ir_model_data.model != EXCLUDED.model) {and_where}
            RETURNING module, name, model, res_id, create_date, write_date
        """.format(
            row_names=row_names,
            row_placeholder=row_placeholders,
            and_where="AND NOT ir_model_data.noupdate" if update else "",
        )

    @api.model
    def _load_xmlid(self, xml_id):
        """ Simply mark the given XML id as being loaded, and return the
            corresponding record.
        """
        record = self.env.ref(xml_id, raise_if_not_found=False)
        if record:
            self.pool.loaded_xmlids.add(xml_id)
        return record

    @api.model
    def _module_data_uninstall(self, modules_to_remove):
        """Deletes all the records referenced by the ir.model.data entries
        ``ids`` along with their corresponding database backed (including
        dropping tables, columns, FKs, etc, as long as there is no other
        ir.model.data entry holding a reference to them (which indicates that
        they are still owned by another module).
        Attempts to perform the deletion in an appropriate order to maximize
        the chance of gracefully deleting all records.
        This step is performed as part of the full uninstallation of a module.
        """
        if not self.env.is_system():
            raise AccessError(_('Administrator access is required to uninstall a module'))

        # enable model/field deletion
        # we deactivate prefetching to not try to read a column that has been deleted
        self = self.with_context(**{MODULE_UNINSTALL_FLAG: True, 'prefetch_fields': False})

        # determine records to unlink
        records_items = []              # [(model, id)]
        model_ids = []
        field_ids = []
        selection_ids = []
        constraint_ids = []

        module_data = self.search([('module', 'in', modules_to_remove)], order='id DESC')
        for data in module_data:
            if data.model == 'ir.model':
                model_ids.append(data.res_id)
            elif data.model == 'ir.model.fields':
                field_ids.append(data.res_id)
            elif data.model == 'ir.model.fields.selection':
                selection_ids.append(data.res_id)
            elif data.model == 'ir.model.constraint':
                constraint_ids.append(data.res_id)
            else:
                records_items.append((data.model, data.res_id))

        # avoid prefetching fields that are going to be deleted: during uninstall, it is
        # possible to perform a recompute (via flush) after the database columns have been
        # deleted but before the new registry has been created, meaning the recompute will
        # be executed on a stale registry, and if some of the data for executing the compute
        # methods is not in cache it will be fetched, and fields that exist in the registry but not
        # in the database will be prefetched, this will of course fail and prevent the uninstall.
        for ir_field in self.env['ir.model.fields'].browse(field_ids):
            model = self.pool.get(ir_field.model)
            if model is not None:
                field = model._fields.get(ir_field.name)
                if field is not None:
                    field.prefetch = False

        # to collect external ids of records that cannot be deleted
        undeletable_ids = []

        def delete(records):
            # do not delete records that have other external ids (and thus do
            # not belong to the modules being installed)
            ref_data = self.search([
                ('model', '=', records._name),
                ('res_id', 'in', records.ids),
            ])
            records -= records.browse((ref_data - module_data).mapped('res_id'))
            if not records:
                return

            # special case for ir.model.fields
            if records._name == 'ir.model.fields':
                missing = records - records.exists()
                if missing:
                    # delete orphan external ids right now;
                    # an orphan ir.model.data can happen if the ir.model.field is deleted via
                    # an ONDELETE CASCADE, in which case we must verify that the records we're
                    # processing exist in the database otherwise a MissingError will be raised
                    orphans = ref_data.filtered(lambda r: r.res_id in missing._ids)
                    _logger.info('Deleting orphan ir_model_data %s', orphans)
                    orphans.unlink()
                    # /!\ this must go before any field accesses on `records`
                    records -= missing
                # do not remove LOG_ACCESS_COLUMNS unless _log_access is False
                # on the model
                records -= records.filtered(lambda f: f.name == 'id' or (
                    f.name in models.LOG_ACCESS_COLUMNS and
                    f.model in self.env and self.env[f.model]._log_access
                ))

            # now delete the records
            _logger.info('Deleting %s', records)
            try:
                with self._cr.savepoint():
                    records.unlink()
            except Exception:
                if len(records) <= 1:
                    undeletable_ids.extend(ref_data._ids)
                else:
                    # divide the batch in two, and recursively delete them
                    half_size = len(records) // 2
                    delete(records[:half_size])
                    delete(records[half_size:])

        # remove non-model records first, grouped by batches of the same model
        for model, items in itertools.groupby(unique(records_items), itemgetter(0)):
            delete(self.env[model].browse(item[1] for item in items))

        # Remove copied views. This must happen after removing all records from
        # the modules to remove, otherwise ondelete='restrict' may prevent the
        # deletion of some view. This must also happen before cleaning up the
        # database schema, otherwise some dependent fields may no longer exist
        # in database.
        modules = self.env['ir.module.module'].search([('name', 'in', modules_to_remove)])
        modules._remove_copied_views()

        # remove constraints
        delete(self.env['ir.model.constraint'].browse(unique(constraint_ids)))

        # If we delete a selection field, and some of its values have ondelete='cascade',
        # we expect the records with that value to be deleted. If we delete the field first,
        # the column is dropped and the selection is gone, and thus the records above will not
        # be deleted.
        delete(self.env['ir.model.fields.selection'].browse(unique(selection_ids)).exists())
        delete(self.env['ir.model.fields'].browse(unique(field_ids)))
        relations = self.env['ir.model.relation'].search([('module', 'in', modules.ids)])
        relations._module_data_uninstall()

        # remove models
        delete(self.env['ir.model'].browse(unique(model_ids)))

        # log undeletable ids
        _logger.info("ir.model.data could not be deleted (%s)", undeletable_ids)

        # sort out which undeletable model data may have become deletable again because
        # of records being cascade-deleted or tables being dropped just above
        for data in self.browse(undeletable_ids).exists():
            record = self.env[data.model].browse(data.res_id)
            try:
                with self.env.cr.savepoint():
                    if record.exists():
                        # record exists therefore the data is still undeletable,
                        # remove it from module_data
                        module_data -= data
                        continue
            except psycopg2.ProgrammingError:
                # This most likely means that the record does not exist, since record.exists()
                # is rougly equivalent to `SELECT id FROM table WHERE id=record.id` and it may raise
                # a ProgrammingError because the table no longer exists (and so does the
                # record), also applies to ir.model.fields, constraints, etc.
                pass
        # remove remaining module data records
        module_data.unlink()

    @api.model
    def _process_end_unlink_record(self, record):
        record.unlink()

    @api.model
    def _process_end(self, modules):
        """ Clear records removed from updated module data.
        This method is called at the end of the module loading process.
        It is meant to removed records that are no longer present in the
        updated data. Such records are recognised as the one with an xml id
        and a module in ir_model_data and noupdate set to false, but not
        present in self.pool.loaded_xmlids.
        """
        if not modules or tools.config.get('import_partial'):
            return True

        bad_imd_ids = []
        self = self.with_context({MODULE_UNINSTALL_FLAG: True})
        loaded_xmlids = self.pool.loaded_xmlids

        query = """ SELECT id, module || '.' || name, model, res_id FROM ir_model_data
                    WHERE module IN %s AND res_id IS NOT NULL AND COALESCE(noupdate, false) != %s ORDER BY id DESC
                """
        self._cr.execute(query, (tuple(modules), True))
        for (id, xmlid, model, res_id) in self._cr.fetchall():
            if xmlid in loaded_xmlids:
                continue

            Model = self.env.get(model)
            if Model is None:
                continue

            # when _inherits parents are implicitly created we give them an
            # external id (if their descendant has one) in order to e.g.
            # properly remove them when the module is deleted, however this
            # generated id is *not* provided during update yet we don't want to
            # try and remove either the xid or the record, so check if the
            # record has a child we've just updated
            keep = False
            for inheriting in (self.env[m] for m in Model._inherits_children):
                # ignore mixins
                if inheriting._abstract:
                    continue

                parent_field = inheriting._inherits[model]
                children = inheriting.with_context(active_test=False).search([(parent_field, '=', res_id)])
                children_xids = {
                    xid
                    for xids in (children and children._get_external_ids().values())
                    for xid in xids
                }
                if children_xids & loaded_xmlids:
                    # at least one child was loaded
                    keep = True
                    break
            if keep:
                continue

            # if the record has other associated xids, only remove the xid
            if self.search_count([
                ("model", "=", model),
                ("res_id", "=", res_id),
                ("id", "!=", id),
                ("id", "not in", bad_imd_ids),
            ]):
                bad_imd_ids.append(id)
                continue

            _logger.info('Deleting %s@%s (%s)', res_id, model, xmlid)
            record = Model.browse(res_id)
            if record.exists():
                module = xmlid.split('.', 1)[0]
                record = record.with_context(module=module)
                self._process_end_unlink_record(record)
            else:
                bad_imd_ids.append(id)
        if bad_imd_ids:
            self.browse(bad_imd_ids).unlink()

        # Once all views are created create specific ones
        self.env['ir.ui.view']._create_all_specific_views(modules)

        loaded_xmlids.clear()

    @api.model
    def toggle_noupdate(self, model, res_id):
        """ Toggle the noupdate flag on the external id of the record """
        record = self.env[model].browse(res_id)
        if record.check_access_rights('write'):
            for xid in self.search([('model', '=', model), ('res_id', '=', res_id)]):
                xid.noupdate = not xid.noupdate


class WizardModelMenu(models.TransientModel):
    _name = 'wizard.ir.model.menu.create'
    _description = 'Create Menu Wizard'

    menu_id = fields.Many2one('ir.ui.menu', string='Parent Menu', required=True, ondelete='cascade')
    name = fields.Char(string='Menu Name', required=True)

    def menu_create(self):
        for menu in self:
            model = self.env['ir.model'].browse(self._context.get('model_id'))
            vals = {
                'name': menu.name,
                'res_model': model.model,
                'view_mode': 'tree,form',
            }
            action_id = self.env['ir.actions.act_window'].create(vals)
            self.env['ir.ui.menu'].create({
                'name': menu.name,
                'parent_id': menu.menu_id.id,
                'action': 'ir.actions.act_window,%d' % (action_id,)
            })
        return {'type': 'ir.actions.act_window_close'}

```

  File: models/ir_module.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import base64
import warnings
from collections import defaultdict, OrderedDict
from decorator import decorator
from operator import attrgetter
from textwrap import dedent
import io
import logging
import os
import shutil
import threading
import zipfile

import requests
import werkzeug.urls

from docutils import nodes
from docutils.core import publish_string
from docutils.transforms import Transform, writer_aux
from docutils.writers.html4css1 import Writer
import lxml.html
import psycopg2

import odoo
from odoo import api, fields, models, modules, tools, _
from odoo.addons.base.models.ir_model import MODULE_UNINSTALL_FLAG
from odoo.exceptions import AccessDenied, UserError, ValidationError
from odoo.osv import expression
from odoo.tools.parse_version import parse_version
from odoo.tools.misc import topological_sort, get_flag
from odoo.tools.translate import TranslationImporter, get_po_paths
from odoo.http import request
from odoo.modules import get_module_path

_logger = logging.getLogger(__name__)

ACTION_DICT = {
    'view_mode': 'form',
    'res_model': 'base.module.upgrade',
    'target': 'new',
    'type': 'ir.actions.act_window',
}

def backup(path, raise_exception=True):
    path = os.path.normpath(path)
    if not os.path.exists(path):
        if not raise_exception:
            return None
        raise OSError('path does not exists')
    cnt = 1
    while True:
        bck = '%s~%d' % (path, cnt)
        if not os.path.exists(bck):
            shutil.move(path, bck)
            return bck
        cnt += 1


def assert_log_admin_access(method):
    """Decorator checking that the calling user is an administrator, and logging the call.

    Raises an AccessDenied error if the user does not have administrator privileges, according
    to `user._is_admin()`.
    """
    def check_and_log(method, self, *args, **kwargs):
        user = self.env.user
        origin = request.httprequest.remote_addr if request else 'n/a'
        log_data = (method.__name__, self.sudo().mapped('display_name'), user.login, user.id, origin)
        if not self.env.is_admin():
            _logger.warning('DENY access to module.%s on %s to user %s ID #%s via %s', *log_data)
            raise AccessDenied()
        _logger.info('ALLOW access to module.%s on %s to user %s #%s via %s', *log_data)
        return method(self, *args, **kwargs)
    return decorator(check_and_log, method)

class ModuleCategory(models.Model):
    _name = "ir.module.category"
    _description = "Application"
    _order = 'name'
    _allow_sudo_commands = False

    name = fields.Char(string='Name', required=True, translate=True, index=True)
    parent_id = fields.Many2one('ir.module.category', string='Parent Application', index=True)
    child_ids = fields.One2many('ir.module.category', 'parent_id', string='Child Applications')
    module_ids = fields.One2many('ir.module.module', 'category_id', string='Modules')
    description = fields.Text(string='Description', translate=True)
    sequence = fields.Integer(string='Sequence')
    visible = fields.Boolean(string='Visible', default=True)
    exclusive = fields.Boolean(string='Exclusive')
    xml_id = fields.Char(string='External ID', compute='_compute_xml_id')

    def _compute_xml_id(self):
        xml_ids = defaultdict(list)
        domain = [('model', '=', self._name), ('res_id', 'in', self.ids)]
        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):
            xml_ids[data['res_id']].append("%s.%s" % (data['module'], data['name']))
        for cat in self:
            cat.xml_id = xml_ids.get(cat.id, [''])[0]

    @api.constrains('parent_id')
    def _check_parent_not_circular(self):
        if not self._check_recursion():
            raise ValidationError(_("Error ! You cannot create recursive categories."))


class MyFilterMessages(Transform):
    """
    Custom docutils transform to remove `system message` for a document and
    generate warnings.

    (The standard filter removes them based on some `report_level` passed in
    the `settings_override` dictionary, but if we use it, we can't see them
    and generate warnings.)
    """
    default_priority = 870

    def apply(self):
        for node in self.document.traverse(nodes.system_message):
            _logger.warning("docutils' system message present: %s", str(node))
            node.parent.remove(node)


class MyWriter(Writer):
    """
    Custom docutils html4ccs1 writer that doesn't add the warnings to the
    output document.
    """
    def get_transforms(self):
        return [MyFilterMessages, writer_aux.Admonitions]


STATES = [
    ('uninstallable', 'Uninstallable'),
    ('uninstalled', 'Not Installed'),
    ('installed', 'Installed'),
    ('to upgrade', 'To be upgraded'),
    ('to remove', 'To be removed'),
    ('to install', 'To be installed'),
]


XML_DECLARATION = (
    '<?xml version='.encode('utf-8'),
    '<?xml version='.encode('utf-16-be'),
    '<?xml version='.encode('utf-16-le'),
)


class Module(models.Model):
    _name = "ir.module.module"
    _rec_name = "shortdesc"
    _rec_names_search = ['name', 'shortdesc', 'summary']
    _description = "Module"
    _order = 'application desc,sequence,name'
    _allow_sudo_commands = False

    @classmethod
    def get_module_info(cls, name):
        try:
            return modules.get_manifest(name)
        except Exception:
            _logger.debug('Error when trying to fetch information for module %s', name, exc_info=True)
            return {}

    @api.depends('name', 'description')
    def _get_desc(self):
        for module in self:
            if not module.name:
                module.description_html = False
                continue
            path = os.path.join(module.name, 'static/description/index.html')
            try:
                with tools.file_open(path, 'rb') as desc_file:
                    doc = desc_file.read()
                    if doc.startswith(XML_DECLARATION):
                        warnings.warn(
                            f"XML declarations in HTML module descriptions are "
                            f"deprecated since Odoo 17, {module.name} can just "
                            f"have a UTF8 description with not need for a "
                            f"declaration.",
                            category=DeprecationWarning,
                        )
                    else:
                        try:
                            doc = doc.decode()
                        except UnicodeDecodeError:
                            warnings.warn(
                                f"Non-UTF8 module descriptions are deprecated "
                                f"since Odoo 17 ({module.name}'s description "
                                f"is not utf-8)",
                                category=DeprecationWarning,
                            )
                    html = lxml.html.document_fromstring(doc)
                    for element, attribute, link, pos in html.iterlinks():
                        if element.get('src') and not '//' in element.get('src') and not 'static/' in element.get('src'):
                            element.set('src', "/%s/static/description/%s" % (module.name, element.get('src')))
                    module.description_html = tools.html_sanitize(lxml.html.tostring(html))
            except FileNotFoundError:
                overrides = {
                    'embed_stylesheet': False,
                    'doctitle_xform': False,
                    'output_encoding': 'unicode',
                    'xml_declaration': False,
                    'file_insertion_enabled': False,
                }
                output = publish_string(source=module.description if not module.application and module.description else '', settings_overrides=overrides, writer=MyWriter())
                module.description_html = tools.html_sanitize(output)

    @api.depends('name')
    def _get_latest_version(self):
        default_version = modules.adapt_version('1.0')
        for module in self:
            module.installed_version = self.get_module_info(module.name).get('version', default_version)

    @api.depends('name', 'state')
    def _get_views(self):
        IrModelData = self.env['ir.model.data'].with_context(active_test=True)
        dmodels = ['ir.ui.view', 'ir.actions.report', 'ir.ui.menu']

        for module in self:
            # Skip uninstalled modules below, no data to find anyway.
            if module.state not in ('installed', 'to upgrade', 'to remove'):
                module.views_by_module = ""
                module.reports_by_module = ""
                module.menus_by_module = ""
                continue

            # then, search and group ir.model.data records
            imd_models = defaultdict(list)
            imd_domain = [('module', '=', module.name), ('model', 'in', tuple(dmodels))]
            for data in IrModelData.sudo().search(imd_domain):
                imd_models[data.model].append(data.res_id)

            def browse(model):
                # as this method is called before the module update, some xmlid
                # may be invalid at this stage; explictly filter records before
                # reading them
                return self.env[model].browse(imd_models[model]).exists()

            def format_view(v):
                return '%s%s (%s)' % (v.inherit_id and '* INHERIT ' or '', v.name, v.type)

            module.views_by_module = "\n".join(sorted(format_view(v) for v in browse('ir.ui.view')))
            module.reports_by_module = "\n".join(sorted(r.name for r in browse('ir.actions.report')))
            module.menus_by_module = "\n".join(sorted(m.complete_name for m in browse('ir.ui.menu')))

    @api.depends('icon')
    def _get_icon_image(self):
        self.icon_image = ''
        for module in self:
            if not module.id:
                continue
            if module.icon:
                path = os.path.join(module.icon.lstrip("/"))
            else:
                path = modules.module.get_module_icon_path(module)
            if path:
                try:
                    with tools.file_open(path, 'rb', filter_ext=('.png', '.svg', '.gif', '.jpeg', '.jpg')) as image_file:
                        module.icon_image = base64.b64encode(image_file.read())
                except FileNotFoundError:
                    module.icon_image = ''
            countries = self.get_module_info(module.name).get('countries', [])
            country_code = len(countries) == 1 and countries[0]
            module.icon_flag = get_flag(country_code.upper()) if country_code else ''

    name = fields.Char('Technical Name', readonly=True, required=True)
    category_id = fields.Many2one('ir.module.category', string='Category', readonly=True, index=True)
    shortdesc = fields.Char('Module Name', readonly=True, translate=True)
    summary = fields.Char('Summary', readonly=True, translate=True)
    description = fields.Text('Description', readonly=True, translate=True)
    description_html = fields.Html('Description HTML', compute='_get_desc')
    author = fields.Char("Author", readonly=True)
    maintainer = fields.Char('Maintainer', readonly=True)
    contributors = fields.Text('Contributors', readonly=True)
    website = fields.Char("Website", readonly=True)

    # attention: Incorrect field names !!
    #   installed_version refers the latest version (the one on disk)
    #   latest_version refers the installed version (the one in database)
    #   published_version refers the version available on the repository
    installed_version = fields.Char('Latest Version', compute='_get_latest_version')
    latest_version = fields.Char('Installed Version', readonly=True)
    published_version = fields.Char('Published Version', readonly=True)

    url = fields.Char('URL', readonly=True)
    sequence = fields.Integer('Sequence', default=100)
    dependencies_id = fields.One2many('ir.module.module.dependency', 'module_id',
                                       string='Dependencies', readonly=True)
    exclusion_ids = fields.One2many('ir.module.module.exclusion', 'module_id',
                                    string='Exclusions', readonly=True)
    auto_install = fields.Boolean('Automatic Installation',
                                   help='An auto-installable module is automatically installed by the '
                                        'system when all its dependencies are satisfied. '
                                        'If the module has no dependency, it is always installed.')
    state = fields.Selection(STATES, string='Status', default='uninstallable', readonly=True, index=True)
    demo = fields.Boolean('Demo Data', default=False, readonly=True)
    license = fields.Selection([
        ('GPL-2', 'GPL Version 2'),
        ('GPL-2 or any later version', 'GPL-2 or later version'),
        ('GPL-3', 'GPL Version 3'),
        ('GPL-3 or any later version', 'GPL-3 or later version'),
        ('AGPL-3', 'Affero GPL-3'),
        ('LGPL-3', 'LGPL Version 3'),
        ('Other OSI approved licence', 'Other OSI Approved License'),
        ('OEEL-1', 'Odoo Enterprise Edition License v1.0'),
        ('OPL-1', 'Odoo Proprietary License v1.0'),
        ('Other proprietary', 'Other Proprietary')
    ], string='License', default='LGPL-3', readonly=True)
    menus_by_module = fields.Text(string='Menus', compute='_get_views', store=True)
    reports_by_module = fields.Text(string='Reports', compute='_get_views', store=True)
    views_by_module = fields.Text(string='Views', compute='_get_views', store=True)
    application = fields.Boolean('Application', readonly=True)
    icon = fields.Char('Icon URL')
    icon_image = fields.Binary(string='Icon', compute='_get_icon_image')
    icon_flag = fields.Char(string='Flag', compute='_get_icon_image')
    to_buy = fields.Boolean('Odoo Enterprise Module', default=False)
    has_iap = fields.Boolean(compute='_compute_has_iap')

    _sql_constraints = [
        ('name_uniq', 'UNIQUE (name)', 'The name of the module must be unique!'),
    ]

    def _compute_has_iap(self):
        for module in self:
            module.has_iap = bool(module.id) and 'iap' in module.upstream_dependencies(exclude_states=('',)).mapped('name')

    @api.ondelete(at_uninstall=False)
    def _unlink_except_installed(self):
        for module in self:
            if module.state in ('installed', 'to upgrade', 'to remove', 'to install'):
                raise UserError(_('You are trying to remove a module that is installed or will be installed.'))

    def unlink(self):
        self.env.registry.clear_cache()
        return super(Module, self).unlink()

    def _get_modules_to_load_domain(self):
        """ Domain to retrieve the modules that should be loaded by the registry. """
        return [('state', '=', 'installed')]

    @classmethod
    def check_external_dependencies(cls, module_name, newstate='to install'):
        terp = cls.get_module_info(module_name)
        try:
            modules.check_manifest_dependencies(terp)
        except Exception as e:
            if newstate == 'to install':
                msg = _('Unable to install module "%s" because an external dependency is not met: %s', module_name, e.args[0])
            elif newstate == 'to upgrade':
                msg = _('Unable to upgrade module "%s" because an external dependency is not met: %s', module_name, e.args[0])
            else:
                msg = _('Unable to process module "%s" because an external dependency is not met: %s', module_name, e.args[0])
            raise UserError(msg)

    def _state_update(self, newstate, states_to_update, level=100):
        if level < 1:
            raise UserError(_('Recursion error in modules dependencies!'))

        # whether some modules are installed with demo data
        demo = False

        for module in self:
            if module.state not in states_to_update:
                demo = demo or module.demo
                continue

            # determine dependency modules to update/others
            update_mods, ready_mods = self.browse(), self.browse()
            for dep in module.dependencies_id:
                if dep.state == 'unknown':
                    raise UserError(_("You try to install module %r that depends on module %r.\nBut the latter module is not available in your system.", module.name, dep.name))
                if dep.depend_id.state == newstate:
                    ready_mods += dep.depend_id
                else:
                    update_mods += dep.depend_id

            # update dependency modules that require it, and determine demo for module
            update_demo = update_mods._state_update(newstate, states_to_update, level=level-1)
            module_demo = module.demo or update_demo or any(mod.demo for mod in ready_mods)
            demo = demo or module_demo

            if module.state in states_to_update:
                # check dependencies and update module itself
                self.check_external_dependencies(module.name, newstate)
                module.write({'state': newstate, 'demo': module_demo})

        return demo

    @assert_log_admin_access
    def button_install(self):
        # domain to select auto-installable (but not yet installed) modules
        auto_domain = [('state', '=', 'uninstalled'), ('auto_install', '=', True)]

        # determine whether an auto-install module must be installed:
        #  - all its dependencies are installed or to be installed,
        #  - at least one dependency is 'to install'
        install_states = frozenset(('installed', 'to install', 'to upgrade'))
        def must_install(module):
            states = {dep.state for dep in module.dependencies_id if dep.auto_install_required}
            return states <= install_states and 'to install' in states

        modules = self
        while modules:
            # Mark the given modules and their dependencies to be installed.
            modules._state_update('to install', ['uninstalled'])

            # Determine which auto-installable modules must be installed.
            modules = self.search(auto_domain).filtered(must_install)

        # the modules that are installed/to install/to upgrade
        install_mods = self.search([('state', 'in', list(install_states))])

        # check individual exclusions
        install_names = {module.name for module in install_mods}
        for module in install_mods:
            for exclusion in module.exclusion_ids:
                if exclusion.name in install_names:
                    raise UserError(_('Modules %r and %r are incompatible.', module.shortdesc, exclusion.exclusion_id.shortdesc))

        # check category exclusions
        def closure(module):
            todo = result = module
            while todo:
                result |= todo
                todo = todo.dependencies_id.depend_id
            return result

        exclusives = self.env['ir.module.category'].search([('exclusive', '=', True)])
        for category in exclusives:
            # retrieve installed modules in category and sub-categories
            categories = category.search([('id', 'child_of', category.ids)])
            modules = install_mods.filtered(lambda mod: mod.category_id in categories)
            # the installation is valid if all installed modules in categories
            # belong to the transitive dependencies of one of them
            if modules and not any(modules <= closure(module) for module in modules):
                labels = dict(self.fields_get(['state'])['state']['selection'])
                raise UserError(
                    _('You are trying to install incompatible modules in category %r:%s', category.name, ''.join(
                        f"\n- {module.shortdesc} ({labels[module.state]})"
                        for module in modules
                    ))
                )

        return dict(ACTION_DICT, name=_('Install'))

    @assert_log_admin_access
    def button_immediate_install(self):
        """ Installs the selected module(s) immediately and fully,
        returns the next res.config action to execute

        :returns: next res.config item to execute
        :rtype: dict[str, object]
        """
        _logger.info('User #%d triggered module installation', self.env.uid)
        # We use here the request object (which is thread-local) as a kind of
        # "global" env because the env is not usable in the following use case.
        # When installing a Chart of Account, I would like to send the
        # allowed companies to configure it on the correct company.
        # Otherwise, the SUPERUSER won't be aware of that and will try to
        # configure the CoA on his own company, which makes no sense.
        if request:
            request.allowed_company_ids = self.env.companies.ids
        return self._button_immediate_function(self.env.registry[self._name].button_install)

    @assert_log_admin_access
    def button_install_cancel(self):
        self.write({'state': 'uninstalled', 'demo': False})
        return True

    @assert_log_admin_access
    def module_uninstall(self):
        """ Perform the various steps required to uninstall a module completely
        including the deletion of all database structures created by the module:
        tables, columns, constraints, etc.
        """
        modules_to_remove = self.mapped('name')
        self.env['ir.model.data']._module_data_uninstall(modules_to_remove)
        # we deactivate prefetching to not try to read a column that has been deleted
        self.with_context(prefetch_fields=False).write({'state': 'uninstalled', 'latest_version': False})
        return True

    def _remove_copied_views(self):
        """ Remove the copies of the views installed by the modules in `self`.

        Those copies do not have an external id so they will not be cleaned by
        `_module_data_uninstall`. This is why we rely on `key` instead.

        It is important to remove these copies because using them will crash if
        they rely on data that don't exist anymore if the module is removed.
        """
        domain = expression.OR([[('key', '=like', m.name + '.%')] for m in self])
        orphans = self.env['ir.ui.view'].with_context(**{'active_test': False, MODULE_UNINSTALL_FLAG: True}).search(domain)
        orphans.unlink()

    @api.returns('self')
    def downstream_dependencies(self, known_deps=None,
                                exclude_states=('uninstalled', 'uninstallable', 'to remove')):
        """ Return the modules that directly or indirectly depend on the modules
        in `self`, and that satisfy the `exclude_states` filter.
        """
        if not self:
            return self
        self.flush_model(['name', 'state'])
        self.env['ir.module.module.dependency'].flush_model(['module_id', 'name'])
        known_deps = known_deps or self.browse()
        query = """ SELECT DISTINCT m.id
                    FROM ir_module_module_dependency d
                    JOIN ir_module_module m ON (d.module_id=m.id)
                    WHERE
                        d.name IN (SELECT name from ir_module_module where id in %s) AND
                        m.state NOT IN %s AND
                        m.id NOT IN %s """
        self._cr.execute(query, (tuple(self.ids), tuple(exclude_states), tuple(known_deps.ids or self.ids)))
        new_deps = self.browse([row[0] for row in self._cr.fetchall()])
        missing_mods = new_deps - known_deps
        known_deps |= new_deps
        if missing_mods:
            known_deps |= missing_mods.downstream_dependencies(known_deps, exclude_states)
        return known_deps

    @api.returns('self')
    def upstream_dependencies(self, known_deps=None,
                              exclude_states=('installed', 'uninstallable', 'to remove')):
        """ Return the dependency tree of modules of the modules in `self`, and
        that satisfy the `exclude_states` filter.
        """
        if not self:
            return self
        self.flush_model(['name', 'state'])
        self.env['ir.module.module.dependency'].flush_model(['module_id', 'name'])
        known_deps = known_deps or self.browse()
        query = """ SELECT DISTINCT m.id
                    FROM ir_module_module_dependency d
                    JOIN ir_module_module m ON (d.module_id=m.id)
                    WHERE
                        m.name IN (SELECT name from ir_module_module_dependency where module_id in %s) AND
                        m.state NOT IN %s AND
                        m.id NOT IN %s """
        self._cr.execute(query, (tuple(self.ids), tuple(exclude_states), tuple(known_deps.ids or self.ids)))
        new_deps = self.browse([row[0] for row in self._cr.fetchall()])
        missing_mods = new_deps - known_deps
        known_deps |= new_deps
        if missing_mods:
            known_deps |= missing_mods.upstream_dependencies(known_deps, exclude_states)
        return known_deps

    def next(self):
        """
        Return the action linked to an ir.actions.todo is there exists one that
        should be executed. Otherwise, redirect to /web
        """
        Todos = self.env['ir.actions.todo']
        _logger.info('getting next %s', Todos)
        active_todo = Todos.search([('state', '=', 'open')], limit=1)
        if active_todo:
            _logger.info('next action is "%s"', active_todo.name)
            return active_todo.action_launch()
        return {
            'type': 'ir.actions.act_url',
            'target': 'self',
            'url': '/web',
        }

    def _button_immediate_function(self, function):
        if not self.env.registry.ready or self.env.registry._init:
            raise UserError(_('The method _button_immediate_install cannot be called on init or non loaded registries. Please use button_install instead.'))

        if getattr(threading.current_thread(), 'testing', False):
            raise RuntimeError(
                "Module operations inside tests are not transactional and thus forbidden.\n"
                "If you really need to perform module operations to test a specific behavior, it "
                "is best to write it as a standalone script, and ask the runbot/metastorm team "
                "for help."
            )
        try:
            # This is done because the installation/uninstallation/upgrade can modify a currently
            # running cron job and prevent it from finishing, and since the ir_cron table is locked
            # during execution, the lock won't be released until timeout.
            self._cr.execute("SELECT * FROM ir_cron FOR UPDATE NOWAIT")
        except psycopg2.OperationalError:
            raise UserError(_("Odoo is currently processing a scheduled action.\n"
                              "Module operations are not possible at this time, "
                              "please try again later or contact your system administrator."))
        function(self)

        self._cr.commit()
        registry = modules.registry.Registry.new(self._cr.dbname, update_module=True)
        self._cr.commit()
        if request and request.registry is self.env.registry:
            request.env.cr.reset()
            request.registry = request.env.registry
            assert request.env.registry is registry
        self._cr.reset()
        assert self.env.registry is registry

        # pylint: disable=next-method-called
        config = self.env['ir.module.module'].next() or {}
        if config.get('type') not in ('ir.actions.act_window_close',):
            return config

        # reload the client; open the first available root menu
        menu = self.env['ir.ui.menu'].search([('parent_id', '=', False)])[:1]
        return {
            'type': 'ir.actions.client',
            'tag': 'reload',
            'params': {'menu_id': menu.id},
        }

    @assert_log_admin_access
    def button_immediate_uninstall(self):
        """
        Uninstall the selected module(s) immediately and fully,
        returns the next res.config action to execute
        """
        _logger.info('User #%d triggered module uninstallation', self.env.uid)
        return self._button_immediate_function(self.env.registry[self._name].button_uninstall)

    @assert_log_admin_access
    def button_uninstall(self):
        un_installable_modules = set(odoo.conf.server_wide_modules) & set(self.mapped('name'))
        if un_installable_modules:
            raise UserError(_("Those modules cannot be uninstalled: %s", ', '.join(un_installable_modules)))
        if any(state not in ('installed', 'to upgrade') for state in self.mapped('state')):
            raise UserError(_(
                "One or more of the selected modules have already been uninstalled, if you "
                "believe this to be an error, you may try again later or contact support."
            ))
        deps = self.downstream_dependencies()
        (self + deps).write({'state': 'to remove'})
        return dict(ACTION_DICT, name=_('Uninstall'))

    @assert_log_admin_access
    def button_uninstall_wizard(self):
        """ Launch the wizard to uninstall the given module. """
        return {
            'type': 'ir.actions.act_window',
            'target': 'new',
            'name': _('Uninstall module'),
            'view_mode': 'form',
            'res_model': 'base.module.uninstall',
            'context': {'default_module_id': self.id},
        }

    def button_uninstall_cancel(self):
        self.write({'state': 'installed'})
        return True

    @assert_log_admin_access
    def button_immediate_upgrade(self):
        """
        Upgrade the selected module(s) immediately and fully,
        return the next res.config action to execute
        """
        return self._button_immediate_function(self.env.registry[self._name].button_upgrade)

    @assert_log_admin_access
    def button_upgrade(self):
        if not self:
            return
        Dependency = self.env['ir.module.module.dependency']
        self.update_list()

        todo = list(self)
        if 'base' in self.mapped('name'):
            # If an installed module is only present in the dependency graph through
            # a new, uninstalled dependency, it will not have been selected yet.
            # An update of 'base' should also update these modules, and as a consequence,
            # install the new dependency.
            todo.extend(self.search([
                ('state', '=', 'installed'),
                ('name', '!=', 'studio_customization'),
                ('id', 'not in', self.ids),
            ]))
        i = 0
        while i < len(todo):
            module = todo[i]
            i += 1
            if module.state not in ('installed', 'to upgrade'):
                raise UserError(_("Can not upgrade module %r. It is not installed.", module.name))
            if self.get_module_info(module.name).get("installable", True):
                self.check_external_dependencies(module.name, 'to upgrade')
            for dep in Dependency.search([('name', '=', module.name)]):
                if (
                    dep.module_id.state == 'installed'
                    and dep.module_id not in todo
                    and dep.module_id.name != 'studio_customization'
                ):
                    todo.append(dep.module_id)

        self.browse(module.id for module in todo).write({'state': 'to upgrade'})

        to_install = []
        for module in todo:
            if not self.get_module_info(module.name).get("installable", True):
                continue
            for dep in module.dependencies_id:
                if dep.state == 'unknown':
                    raise UserError(_('You try to upgrade the module %s that depends on the module: %s.\nBut this module is not available in your system.', module.name, dep.name))
                if dep.state == 'uninstalled':
                    to_install += self.search([('name', '=', dep.name)]).ids

        self.browse(to_install).button_install()
        return dict(ACTION_DICT, name=_('Apply Schedule Upgrade'))

    @assert_log_admin_access
    def button_upgrade_cancel(self):
        self.write({'state': 'installed'})
        return True

    @staticmethod
    def get_values_from_terp(terp):
        return {
            'description': dedent(terp.get('description', '')),
            'shortdesc': terp.get('name', ''),
            'author': terp.get('author', 'Unknown'),
            'maintainer': terp.get('maintainer', False),
            'contributors': ', '.join(terp.get('contributors', [])) or False,
            'website': terp.get('website', ''),
            'license': terp.get('license', 'LGPL-3'),
            'sequence': terp.get('sequence', 100),
            'application': terp.get('application', False),
            'auto_install': terp.get('auto_install', False) is not False,
            'icon': terp.get('icon', False),
            'summary': terp.get('summary', ''),
            'url': terp.get('url') or terp.get('live_test_url', ''),
            'to_buy': False
        }

    @api.model_create_multi
    def create(self, vals_list):
        modules = super().create(vals_list)
        module_metadata_list = [{
            'name': 'module_%s' % module.name,
            'model': 'ir.module.module',
            'module': 'base',
            'res_id': module.id,
            'noupdate': True,
        } for module in modules]
        self.env['ir.model.data'].create(module_metadata_list)
        return modules

    # update the list of available packages
    @assert_log_admin_access
    @api.model
    def update_list(self):
        res = [0, 0]    # [update, add]

        default_version = modules.adapt_version('1.0')
        known_mods = self.with_context(lang=None).search([])
        known_mods_names = {mod.name: mod for mod in known_mods}

        # iterate through detected modules and update/create them in db
        for mod_name in modules.get_modules():
            mod = known_mods_names.get(mod_name)
            terp = self.get_module_info(mod_name)
            values = self.get_values_from_terp(terp)

            if mod:
                updated_values = {}
                for key in values:
                    old = getattr(mod, key)
                    if (old or values[key]) and values[key] != old:
                        updated_values[key] = values[key]
                if terp.get('installable', True) and mod.state == 'uninstallable':
                    updated_values['state'] = 'uninstalled'
                if parse_version(terp.get('version', default_version)) > parse_version(mod.latest_version or default_version):
                    res[0] += 1
                if updated_values:
                    mod.write(updated_values)
            else:
                mod_path = modules.get_module_path(mod_name)
                if not mod_path or not terp:
                    continue
                state = "uninstalled" if terp.get('installable', True) else "uninstallable"
                mod = self.create(dict(name=mod_name, state=state, **values))
                res[1] += 1

            mod._update_from_terp(terp)

        return res

    def _update_from_terp(self, terp):
        self._update_dependencies(terp.get('depends', []), terp.get('auto_install'))
        self._update_exclusions(terp.get('excludes', []))
        self._update_category(terp.get('category', 'Uncategorized'))

    def _update_dependencies(self, depends=None, auto_install_requirements=()):
        self.env['ir.module.module.dependency'].flush_model()
        existing = set(dep.name for dep in self.dependencies_id)
        needed = set(depends or [])
        for dep in (needed - existing):
            self._cr.execute('INSERT INTO ir_module_module_dependency (module_id, name) values (%s, %s)', (self.id, dep))
        for dep in (existing - needed):
            self._cr.execute('DELETE FROM ir_module_module_dependency WHERE module_id = %s and name = %s', (self.id, dep))
        self._cr.execute('UPDATE ir_module_module_dependency SET auto_install_required = (name = any(%s)) WHERE module_id = %s',
                         (list(auto_install_requirements or ()), self.id))
        self.env['ir.module.module.dependency'].invalidate_model(['auto_install_required'])
        self.invalidate_recordset(['dependencies_id'])

    def _update_exclusions(self, excludes=None):
        self.env['ir.module.module.exclusion'].flush_model()
        existing = set(excl.name for excl in self.exclusion_ids)
        needed = set(excludes or [])
        for name in (needed - existing):
            self._cr.execute('INSERT INTO ir_module_module_exclusion (module_id, name) VALUES (%s, %s)', (self.id, name))
        for name in (existing - needed):
            self._cr.execute('DELETE FROM ir_module_module_exclusion WHERE module_id=%s AND name=%s', (self.id, name))
        self.invalidate_recordset(['exclusion_ids'])

    def _update_category(self, category='Uncategorized'):
        current_category = self.category_id
        seen = set()
        current_category_path = []
        while current_category:
            current_category_path.insert(0, current_category.name)
            seen.add(current_category.id)
            if current_category.parent_id.id in seen:
                current_category.parent_id = False
                _logger.warning('category %r ancestry loop has been detected and fixed', current_category)
            current_category = current_category.parent_id

        categs = category.split('/')
        if categs != current_category_path:
            cat_id = modules.db.create_categories(self._cr, categs)
            self.write({'category_id': cat_id})

    def _update_translations(self, filter_lang=None, overwrite=False):
        if not filter_lang:
            langs = self.env['res.lang'].get_installed()
            filter_lang = [code for code, _ in langs]
        elif not isinstance(filter_lang, (list, tuple)):
            filter_lang = [filter_lang]

        update_mods = self.filtered(lambda r: r.state in ('installed', 'to install', 'to upgrade'))
        mod_dict = {
            mod.name: mod.dependencies_id.mapped('name')
            for mod in update_mods
        }
        mod_names = topological_sort(mod_dict)
        self.env['ir.module.module']._load_module_terms(mod_names, filter_lang, overwrite)

    def _check(self):
        for module in self:
            if not module.description_html:
                _logger.warning('module %s: description is empty!', module.name)

    def _get(self, name):
        """ Return the (sudoed) `ir.module.module` record with the given name.
        The result may be an empty recordset if the module is not found.
        """
        model_id = self._get_id(name) if name else False
        return self.browse(model_id).sudo()

    @tools.ormcache('name')
    def _get_id(self, name):
        self.flush_model(['name'])
        self.env.cr.execute("SELECT id FROM ir_module_module WHERE name=%s", (name,))
        return self.env.cr.fetchone()

    @api.model
    @tools.ormcache()
    def _installed(self):
        """ Return the set of installed modules as a dictionary {name: id} """
        return {
            module.name: module.id
            for module in self.sudo().search([('state', '=', 'installed')])
        }

    @api.model
    def search_panel_select_range(self, field_name, **kwargs):
        if field_name == 'category_id':
            enable_counters = kwargs.get('enable_counters', False)
            domain = [('parent_id', '=', False), ('child_ids.module_ids', '!=', False)]

            excluded_xmlids = [
                'base.module_category_website_theme',
                'base.module_category_theme',
            ]
            if not self.user_has_groups('base.group_no_one'):
                excluded_xmlids.append('base.module_category_hidden')

            excluded_category_ids = []
            for excluded_xmlid in excluded_xmlids:
                categ = self.env.ref(excluded_xmlid, False)
                if not categ:
                    continue
                excluded_category_ids.append(categ.id)

            if excluded_category_ids:
                domain = expression.AND([
                    domain,
                    [('id', 'not in', excluded_category_ids)],
                ])

            records = self.env['ir.module.category'].search_read(domain, ['display_name'], order="sequence")

            values_range = OrderedDict()
            for record in records:
                record_id = record['id']
                if enable_counters:
                    model_domain = expression.AND([
                        kwargs.get('search_domain', []),
                        kwargs.get('category_domain', []),
                        kwargs.get('filter_domain', []),
                        [('category_id', 'child_of', record_id), ('category_id', 'not in', excluded_category_ids)]
                    ])
                    record['__count'] = self.env['ir.module.module'].search_count(model_domain)
                values_range[record_id] = record

            return {
                'parent_field': 'parent_id',
                'values': list(values_range.values()),
            }

        return super(Module, self).search_panel_select_range(field_name, **kwargs)

    @api.model
    def _load_module_terms(self, modules, langs, overwrite=False):
        """ Load PO files of the given modules for the given languages. """
        # load i18n files
        translation_importer = TranslationImporter(self.env.cr, verbose=False)

        for module_name in modules:
            modpath = get_module_path(module_name)
            if not modpath:
                continue
            for lang in langs:
                is_lang_imported = False
                for po_path in get_po_paths(module_name, lang):
                    _logger.info('module %s: loading translation file %s for language %s', module_name, po_path, lang)
                    translation_importer.load_file(po_path, lang)
                    is_lang_imported = True
                if lang != 'en_US' and not is_lang_imported:
                    _logger.info('module %s: no translation for language %s', module_name, lang)

        translation_importer.save(overwrite=overwrite)


DEP_STATES = STATES + [('unknown', 'Unknown')]

class ModuleDependency(models.Model):
    _name = "ir.module.module.dependency"
    _description = "Module dependency"
    _log_access = False  # inserts are done manually, create and write uid, dates are always null
    _allow_sudo_commands = False

    # the dependency name
    name = fields.Char(index=True)

    # the module that depends on it
    module_id = fields.Many2one('ir.module.module', 'Module', ondelete='cascade')

    # the module corresponding to the dependency, and its status
    depend_id = fields.Many2one('ir.module.module', 'Dependency',
                                compute='_compute_depend', search='_search_depend')
    state = fields.Selection(DEP_STATES, string='Status', compute='_compute_state')

    auto_install_required = fields.Boolean(
        default=True,
        help="Whether this dependency blocks automatic installation "
             "of the dependent")

    @api.depends('name')
    def _compute_depend(self):
        # retrieve all modules corresponding to the dependency names
        names = list(set(dep.name for dep in self))
        mods = self.env['ir.module.module'].search([('name', 'in', names)])

        # index modules by name, and assign dependencies
        name_mod = dict((mod.name, mod) for mod in mods)
        for dep in self:
            dep.depend_id = name_mod.get(dep.name)

    def _search_depend(self, operator, value):
        assert operator == 'in'
        modules = self.env['ir.module.module'].browse(set(value))
        return [('name', 'in', modules.mapped('name'))]

    @api.depends('depend_id.state')
    def _compute_state(self):
        for dependency in self:
            dependency.state = dependency.depend_id.state or 'unknown'


class ModuleExclusion(models.Model):
    _name = "ir.module.module.exclusion"
    _description = "Module exclusion"
    _allow_sudo_commands = False

    # the exclusion name
    name = fields.Char(index=True)

    # the module that excludes it
    module_id = fields.Many2one('ir.module.module', 'Module', ondelete='cascade')

    # the module corresponding to the exclusion, and its status
    exclusion_id = fields.Many2one('ir.module.module', 'Exclusion Module',
                                   compute='_compute_exclusion', search='_search_exclusion')
    state = fields.Selection(DEP_STATES, string='Status', compute='_compute_state')

    @api.depends('name')
    def _compute_exclusion(self):
        # retrieve all modules corresponding to the exclusion names
        names = list(set(excl.name for excl in self))
        mods = self.env['ir.module.module'].search([('name', 'in', names)])

        # index modules by name, and assign dependencies
        name_mod = {mod.name: mod for mod in mods}
        for excl in self:
            excl.exclusion_id = name_mod.get(excl.name)

    def _search_exclusion(self, operator, value):
        assert operator == 'in'
        modules = self.env['ir.module.module'].browse(set(value))
        return [('name', 'in', modules.mapped('name'))]

    @api.depends('exclusion_id.state')
    def _compute_state(self):
        for exclusion in self:
            exclusion.state = exclusion.exclusion_id.state or 'unknown'

```

  File: models/ir_profile.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import datetime
import json
import logging

from dateutil.relativedelta import relativedelta

from odoo import fields, models, api, _
from odoo.exceptions import UserError
from odoo.http import request
from odoo.tools.profiler import make_session
from odoo.tools.speedscope import Speedscope

_logger = logging.getLogger(__name__)


class IrProfile(models.Model):
    _name = 'ir.profile'
    _description = 'Profiling results'
    _log_access = False  # avoid useless foreign key on res_user
    _order = 'session desc, id desc'
    _allow_sudo_commands = False

    create_date = fields.Datetime('Creation Date')

    session = fields.Char('Session', index=True)
    name = fields.Char('Description')
    duration = fields.Float('Duration')

    init_stack_trace = fields.Text('Initial stack trace', prefetch=False)

    sql = fields.Text('Sql', prefetch=False)
    sql_count = fields.Integer('Queries Count')
    traces_async = fields.Text('Traces Async', prefetch=False)
    traces_sync = fields.Text('Traces Sync', prefetch=False)
    qweb = fields.Text('Qweb', prefetch=False)
    entry_count = fields.Integer('Entry count')

    speedscope = fields.Binary('Speedscope', compute='_compute_speedscope')
    speedscope_url = fields.Text('Open', compute='_compute_speedscope_url')

    @api.autovacuum
    def _gc_profile(self):
        # remove profiles older than 30 days
        domain = [('create_date', '<', fields.Datetime.now() - datetime.timedelta(days=30))]
        return self.sudo().search(domain).unlink()

    def _compute_speedscope(self):
        for execution in self:
            sp = Speedscope(init_stack_trace=json.loads(execution.init_stack_trace))
            if execution.sql:
                sp.add('sql', json.loads(execution.sql))
            if execution.traces_async:
                sp.add('frames', json.loads(execution.traces_async))
            if execution.traces_sync:
                sp.add('settrace', json.loads(execution.traces_sync))

            result = json.dumps(sp.add_default().make())
            execution.speedscope = base64.b64encode(result.encode('utf-8'))

    def _compute_speedscope_url(self):
        for profile in self:
            profile.speedscope_url = f'/web/speedscope/{profile.id}'

    def _enabled_until(self):
        """
        If the profiling is enabled, return until when it is enabled.
        Otherwise return ``None``.
        """
        limit = self.env['ir.config_parameter'].sudo().get_param('base.profiling_enabled_until', '')
        return limit if str(fields.Datetime.now()) < limit else None

    @api.model
    def set_profiling(self, profile=None, collectors=None, params=None):
        """
        Enable or disable profiling for the current user.

        :param profile: ``True`` to enable profiling, ``False`` to disable it.
        :param list collectors: optional list of collectors to use (string)
        :param dict params: optional parameters set on the profiler object
        """
        # Note: parameters are coming from a rpc calls or route param (public user),
        # meaning that corresponding session variables are client-defined.
        # This allows to activate any profiler, but can be
        # dangerous handling request.session.profile_collectors/profile_params.
        if profile:
            limit = self._enabled_until()
            _logger.info("User %s started profiling", self.env.user.name)
            if not limit:
                request.session.profile_session = None
                if self.env.user._is_system():
                    return {
                            'type': 'ir.actions.act_window',
                            'view_mode': 'form',
                            'res_model': 'base.enable.profiling.wizard',
                            'target': 'new',
                            'views': [[False, 'form']],
                        }
                raise UserError(_('Profiling is not enabled on this database. Please contact an administrator.'))
            if not request.session.profile_session:
                request.session.profile_session = make_session(self.env.user.name)
                request.session.profile_expiration = limit
                if request.session.profile_collectors is None:
                    request.session.profile_collectors = []
                if request.session.profile_params is None:
                    request.session.profile_params = {}
        elif profile is not None:
            request.session.profile_session = None

        if collectors is not None:
            request.session.profile_collectors = collectors

        if params is not None:
            request.session.profile_params = params

        return {
            'session': request.session.profile_session,
            'collectors': request.session.profile_collectors,
            'params': request.session.profile_params,
        }


class EnableProfilingWizard(models.TransientModel):
    _name = 'base.enable.profiling.wizard'
    _description = "Enable profiling for some time"

    duration = fields.Selection([
        ('minutes_5', "5 Minutes"),
        ('hours_1', "1 Hour"),
        ('days_1', "1 Day"),
        ('months_1', "1 Month"),
    ], string="Enable profiling for")
    expiration = fields.Datetime("Enable profiling until", compute='_compute_expiration', store=True, readonly=False)

    @api.depends('duration')
    def _compute_expiration(self):
        for record in self:
            unit, quantity = (record.duration or 'days_0').split('_')
            record.expiration = fields.Datetime.now() + relativedelta(**{unit: int(quantity)})

    def submit(self):
        self.env['ir.config_parameter'].set_param('base.profiling_enabled_until', self.expiration)
        return False

```

  File: models/ir_property.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, _
from odoo.exceptions import UserError
from odoo.osv.expression import TERM_OPERATORS_NEGATION
from odoo.tools import ormcache

TYPE2FIELD = {
    'char': 'value_text',
    'float': 'value_float',
    'boolean': 'value_integer',
    'integer': 'value_integer',
    'text': 'value_text',
    'binary': 'value_binary',
    'many2one': 'value_reference',
    'date': 'value_datetime',
    'datetime': 'value_datetime',
    'selection': 'value_text',
    'html': 'value_text',
}

TYPE2CLEAN = {
    'boolean': bool,
    'integer': lambda val: val or False,
    'float': lambda val: val or False,
    'char': lambda val: val or False,
    'text': lambda val: val or False,
    'selection': lambda val: val or False,
    'binary': lambda val: val or False,
    'date': lambda val: val.date() if val else False,
    'datetime': lambda val: val or False,
    'html': lambda val: val or False,
}


class Property(models.Model):
    _name = 'ir.property'
    _description = 'Company Property'
    _allow_sudo_commands = False

    name = fields.Char(index=True)
    res_id = fields.Char(string='Resource', index=True, help="If not set, acts as a default value for new resources",)
    company_id = fields.Many2one('res.company', string='Company', index=True)
    fields_id = fields.Many2one('ir.model.fields', string='Field', ondelete='cascade', required=True)
    value_float = fields.Float()
    value_integer = fields.Integer()
    value_text = fields.Text()  # will contain (char, text)
    value_binary = fields.Binary(attachment=False)
    value_reference = fields.Char()
    value_datetime = fields.Datetime()
    type = fields.Selection([('char', 'Char'),
                             ('float', 'Float'),
                             ('boolean', 'Boolean'),
                             ('integer', 'Integer'),
                             ('text', 'Text'),
                             ('binary', 'Binary'),
                             ('many2one', 'Many2One'),
                             ('date', 'Date'),
                             ('datetime', 'DateTime'),
                             ('selection', 'Selection'),
                             ('html', 'Html'),
                             ],
                            required=True,
                            default='many2one',
                            index=True)

    def init(self):
        # Ensure there is at most one active variant for each combination.
        query = """
            CREATE UNIQUE INDEX IF NOT EXISTS ir_property_unique_index
            ON %s (fields_id, COALESCE(company_id, 0), COALESCE(res_id, ''))
        """
        self.env.cr.execute(query % self._table)

    def _update_values(self, values):
        if 'value' not in values:
            return values
        value = values.pop('value')

        prop = None
        type_ = values.get('type')
        if not type_:
            if self:
                prop = self[0]
                type_ = prop.type
            else:
                type_ = self._fields['type'].default(self)

        field = TYPE2FIELD.get(type_)
        if not field:
            raise UserError(_('Invalid type'))

        if field == 'value_reference':
            if not value:
                value = False
            elif isinstance(value, models.BaseModel):
                value = '%s,%d' % (value._name, value.id)
            elif isinstance(value, int):
                field_id = values.get('fields_id')
                if not field_id:
                    if not prop:
                        raise ValueError()
                    field_id = prop.fields_id
                else:
                    field_id = self.env['ir.model.fields'].browse(field_id)

                value = '%s,%d' % (field_id.sudo().relation, value)

        values[field] = value
        return values

    def write(self, values):
        # if any of the records we're writing on has a res_id=False *or*
        # we're writing a res_id=False on any record
        default_set = False

        values = self._update_values(values)
        default_set = (
            # turning a record value into a fallback value
            values.get('res_id') is False and any(record.res_id for record in self)
        ) or any(
            # changing a fallback value
            not record.res_id and any(record[fname] != self._fields[fname].convert_to_record(value, self) for fname, value in values.items())
            for record in self
        )
        r = super().write(values)
        if default_set:
            # DLE P44: test `test_27_company_dependent`
            # Easy solution, need to flush write when changing a property.
            # Maybe it would be better to be able to compute all impacted cache value and update those instead
            # Then clear_cache must be removed as well.
            self.env.flush_all()
            self.env.registry.clear_cache()
        return r

    @api.model_create_multi
    def create(self, vals_list):
        vals_list = [self._update_values(vals) for vals in vals_list]
        created_default = any(not v.get('res_id') for v in vals_list)
        r = super(Property, self).create(vals_list)
        if created_default:
            # DLE P44: test `test_27_company_dependent`
            self.env.flush_all()
            self.env.registry.clear_cache()
        return r

    def unlink(self):
        default_deleted = any(not p.res_id for p in self)
        r = super().unlink()
        if default_deleted:
            self.env.registry.clear_cache()
        return r

    def get_by_record(self):
        self.ensure_one()
        if self.type in ('char', 'text', 'selection'):
            return self.value_text
        elif self.type == 'float':
            return self.value_float
        elif self.type == 'boolean':
            return bool(self.value_integer)
        elif self.type == 'integer':
            return self.value_integer
        elif self.type == 'binary':
            return self.value_binary
        elif self.type == 'many2one':
            if not self.value_reference:
                return False
            model, resource_id = self.value_reference.split(',')
            return self.env[model].browse(int(resource_id)).exists()
        elif self.type == 'datetime':
            return self.value_datetime
        elif self.type == 'date':
            if not self.value_datetime:
                return False
            return fields.Date.to_string(fields.Datetime.from_string(self.value_datetime))
        return False

    @api.model
    def _set_default(self, name, model, value, company=False):
        """ Set the given field's generic value for the given company.

        :param name: the field's name
        :param model: the field's model name
        :param value: the field's value
        :param company: the company (record or id)
        """
        field_id = self.env['ir.model.fields']._get(model, name).id
        company_id = int(company) if company else False
        prop = self.sudo().search([
            ('fields_id', '=', field_id),
            ('company_id', '=', company_id),
            ('res_id', '=', False),
        ])
        if prop:
            prop.write({'value': value})
        else:
            prop.create({
                'fields_id': field_id,
                'company_id': company_id,
                'res_id': False,
                'name': name,
                'value': value,
                'type': self.env[model]._fields[name].type,
            })

    @api.model
    def _get(self, name, model, res_id=False):
        """ Get the given field's generic value for the record.

        :param name: the field's name
        :param model: the field's model name
        :param res_id: optional resource, format: "<id>" (int) or
                       "<model>,<id>" (str)
        """
        if not res_id:
            t, v = self._get_default_property(name, model)
            if not v or t != 'many2one':
                return v
            return self.env[v[0]].browse(v[1])

        p = self._get_property(name, model, res_id=res_id)
        if p:
            return p.get_by_record()
        return False

    # only cache Property._get(res_id=False) as that's
    # sub-optimally.
    COMPANY_KEY = "self.env.company.id"
    @ormcache(COMPANY_KEY, 'name', 'model')
    def _get_default_property(self, name, model):
        prop = self._get_property(name, model, res_id=False)
        if not prop:
            return None, False
        v = prop.get_by_record()
        if prop.type != 'many2one':
            return prop.type, v
        return 'many2one', v and (v._name, v.id)

    def _get_property(self, name, model, res_id):
        domain = self._get_domain(name, model)
        if domain is not None:
            if res_id and isinstance(res_id, int):
                res_id = "%s,%s" % (model, res_id)
            domain = [('res_id', '=', res_id)] + domain
            #make the search with company_id asc to make sure that properties specific to a company are given first
            return self.sudo().search(domain, limit=1, order='company_id')
        return self.sudo().browse(())

    def _get_domain(self, prop_name, model):
        field_id = self.env['ir.model.fields']._get(model, prop_name).id
        if not field_id:
            return None
        company_id = self.env.company.id
        return [('fields_id', '=', field_id), ('company_id', 'in', [company_id, False])]

    @api.model
    def _get_multi(self, name, model, ids):
        """ Read the property field `name` for the records of model `model` with
            the given `ids`, and return a dictionary mapping `ids` to their
            corresponding value.
        """
        if not ids:
            return {}

        field = self.env[model]._fields[name]
        field_id = self.env['ir.model.fields']._get(model, name).id
        company_id = self.env.company.id or None

        if field.type == 'many2one':
            comodel = self.env[field.comodel_name]
            model_pos = len(model) + 2
            value_pos = len(comodel._name) + 2
            # retrieve values: both p.res_id and p.value_reference are formatted
            # as "<rec._name>,<rec.id>"; the purpose of the LEFT JOIN is to
            # return the value id if it exists, NULL otherwise
            query = """
                SELECT substr(p.res_id, %s)::integer, r.id
                FROM ir_property p
                LEFT JOIN {} r ON substr(p.value_reference, %s)::integer=r.id
                WHERE p.fields_id=%s
                    AND (p.company_id=%s OR p.company_id IS NULL)
                    AND (p.res_id IN %s OR p.res_id IS NULL)
                ORDER BY p.company_id NULLS FIRST
            """.format(comodel._table)
            params = [model_pos, value_pos, field_id, company_id]
            clean = comodel.browse

        elif field.type in TYPE2FIELD:
            model_pos = len(model) + 2
            # retrieve values: p.res_id is formatted as "<rec._name>,<rec.id>"
            query = """
                SELECT substr(p.res_id, %s)::integer, p.{}
                FROM ir_property p
                WHERE p.fields_id=%s
                    AND (p.company_id=%s OR p.company_id IS NULL)
                    AND (p.res_id IN %s OR p.res_id IS NULL)
                ORDER BY p.company_id NULLS FIRST
            """.format(TYPE2FIELD[field.type])
            params = [model_pos, field_id, company_id]
            clean = TYPE2CLEAN[field.type]

        else:
            return dict.fromkeys(ids, False)

        # retrieve values
        self.flush_model()
        cr = self.env.cr
        result = {}
        refs = {"%s,%s" % (model, id) for id in ids}
        for sub_refs in cr.split_for_in_conditions(refs):
            cr.execute(query, params + [sub_refs])
            result.update(cr.fetchall())

        # determine all values and format them
        default = result.get(None, None)
        return {
            id: clean(result.get(id, default))
            for id in ids
        }

    @api.model
    def _set_multi(self, name, model, values, default_value=None):
        """ Assign the property field `name` for the records of model `model`
            with `values` (dictionary mapping record ids to their value).
            If the value for a given record is the same as the default
            value, the property entry will not be stored, to avoid bloating
            the database.
            If `default_value` is provided, that value will be used instead
            of the computed default value, to determine whether the value
            for a record should be stored or not.
        """
        def clean(value):
            return value.id if isinstance(value, models.BaseModel) else value

        if not values:
            return

        if default_value is None:
            domain = self._get_domain(name, model)
            if domain is None:
                raise Exception()
            # retrieve the default value for the field
            default_value = clean(self._get(name, model))

        # retrieve the properties corresponding to the given record ids
        field_id = self.env['ir.model.fields']._get(model, name).id
        company_id = self.env.company.id
        refs = {('%s,%s' % (model, id)): id for id in values}
        props = self.sudo().search([
            ('fields_id', '=', field_id),
            ('company_id', '=', company_id),
            ('res_id', 'in', list(refs)),
        ])

        # modify existing properties
        for prop in props:
            id = refs.pop(prop.res_id)
            value = clean(values[id])
            if value == default_value:
                # avoid prop.unlink(), as it clears the record cache that can
                # contain the value of other properties to set on record!
                self._cr.execute("DELETE FROM ir_property WHERE id=%s", [prop.id])
            elif value != clean(prop.get_by_record()):
                prop.write({'value': value})

        # create new properties for records that do not have one yet
        vals_list = []
        for ref, id in refs.items():
            value = clean(values[id])
            if value != default_value:
                vals_list.append({
                    'fields_id': field_id,
                    'company_id': company_id,
                    'res_id': ref,
                    'name': name,
                    'value': value,
                    'type': self.env[model]._fields[name].type,
                })
        self.sudo().create(vals_list)

    @api.model
    def search_multi(self, name, model, operator, value):
        """ Return a domain for the records that match the given condition. """
        default_matches = False
        negate = False

        # For "is set" and "is not set", same logic for all types
        if operator == 'in' and False in value:
            operator = 'not in'
            negate = True
        elif operator == 'not in' and False not in value:
            operator = 'in'
            negate = True
        elif operator in ('!=', 'not like', 'not ilike') and value:
            operator = TERM_OPERATORS_NEGATION[operator]
            negate = True
        elif operator == '=' and not value:
            operator = '!='
            negate = True

        field = self.env[model]._fields[name]

        if field.type == 'many2one':
            def makeref(value):
                return value and f'{field.comodel_name},{value}'

            if operator in ('=', '!=', '<=', '<', '>', '>='):
                value = makeref(value)
            elif operator in ('in', 'not in'):
                value = [makeref(v) for v in value]
            elif operator in ('=like', '=ilike', 'like', 'not like', 'ilike', 'not ilike'):
                # most probably inefficient... but correct
                target = self.env[field.comodel_name]
                target_names = target.name_search(value, operator=operator, limit=None)
                target_ids = [n[0] for n in target_names]
                operator, value = 'in', [makeref(v) for v in target_ids]
            elif operator in ('any', 'not any'):
                if operator == 'not any':
                    negate = True
                operator = 'in'
                value = list(map(makeref, self.env[field.comodel_name]._search(value)))

        elif field.type in ('integer', 'float'):
            # No record is created in ir.property if the field's type is float or integer with a value
            # equal to 0. Then to match with the records that are linked to a property field equal to 0,
            # the negation of the operator must be taken  to compute the goods and the domain returned
            # to match the searched records is just the opposite.
            value = float(value) if field.type == 'float' else int(value)
            if operator == '>=' and value <= 0:
                operator = '<'
                negate = True
            elif operator == '>' and value < 0:
                operator = '<='
                negate = True
            elif operator == '<=' and value >= 0:
                operator = '>'
                negate = True
            elif operator == '<' and value > 0:
                operator = '>='
                negate = True

        elif field.type == 'boolean':
            # the value must be mapped to an integer value
            value = int(value)

        # retrieve the properties that match the condition
        domain = self._get_domain(name, model)
        if domain is None:
            raise Exception()
        props = self.search(domain + [(TYPE2FIELD[field.type], operator, value)])

        # retrieve the records corresponding to the properties that match
        good_ids = []
        for prop in props:
            if prop.res_id:
                __, res_id = prop.res_id.split(',')
                good_ids.append(int(res_id))
            else:
                default_matches = True

        if default_matches:
            # exclude all records with a property that does not match
            props = self.search(domain + [('res_id', '!=', False)])
            all_ids = {int(res_id.split(',')[1]) for res_id in props.mapped('res_id')}
            bad_ids = list(all_ids - set(good_ids))
            if negate:
                return [('id', 'in', bad_ids)]
            else:
                return [('id', 'not in', bad_ids)]
        elif negate:
            return [('id', 'not in', good_ids)]
        else:
            return [('id', 'in', good_ids)]

```

  File: models/ir_qweb.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
"""
================
IrQWeb / ir.qweb
================

Preamble
========

Technical documentation of the python operation of the rendering QWeb engine.

Templating
==========

QWeb is the primary templating engine used by Odoo. It is an XML templating
engine and used mostly to generate XML, HTML fragments and pages.

Template directives are specified as XML attributes prefixed with ``t-``,
for instance ``t-if`` for :ref:`reference/qweb/conditionals`, with elements
and other attributes being rendered directly.

To avoid element rendering, a placeholder element ``<t>`` is also available,
which executes its directive but doesn't generate any output in and of
itself.

To create new XML template, please see :doc:`QWeb Templates documentation
<https://www.odoo.com/documentation/17.0/developer/reference/frontend/qweb.html>`

Rendering process
=================

In **input** you have an XML template giving the corresponding input etree.
Each etree input nodes are used to generate a python function. This fonction is
called and will give the XML **output**.
The ``_compile`` method is responsible to generate the function from the
etree, that function is a python generator that yield one output line at a
time. This generator is consumed by ``_render``. The generated function is orm
cached.

For performance, the **compile time** (when input, XML template or template
id, is compiled into a function) is less important than the **rendering time**
(when the function is called with the different values). The generation of the
function is only done once (for a set of options, language, branding ...)
because it is cached orm

The output is in ``MarkupSafe`` format. ``MarkupSafe`` escapes characters so
text is safe to use in HTML and XML. Characters that have special meanings
are replaced so that they display as the actual characters. This mitigates
injection attacks, meaning untrusted user input can safely be displayed on a
page.

At **compile time**, each dynamic attribute ``t-*`` will be compiled into
specific python code. (For example ``<t t-out="5 + 5"/>`` will insert the
template "10" inside the output)

At **compile time**, each directive removes the dynamic attribute it uses from
the input node attributes. At the end of the compilation each input node, no
dynamic attributes must remain.

How the code works
==================

In the graphic below you can see theresume of the call of the methods performed
in the IrQweb class.

.. code-block:: rst

    Odoo
     ┗━► _render (returns MarkupSafe)
        ┗━► _compile (returns function)                                        ◄━━━━━━━━━━┓
           ┗━► _compile_node (returns code string array)                       ◄━━━━━━━━┓ ┃
              ┃  (skip the current node if found t-qweb-skip)                           ┃ ┃
              ┃  (add technical directives: t-tag-open, t-tag-close, t-inner-content)   ┃ ┃
              ┃                                                                         ┃ ┃
              ┣━► _directives_eval_order (defined directive order)                      ┃ ┃
              ┣━► _compile_directives (loop)    Consume all remaining directives ◄━━━┓  ┃ ┃
              ┃  ┃                              (e.g.: to change the indentation)    ┃  ┃ ┃
              ┃  ┣━► _compile_directive                                              ┃  ┃ ┃
              ┃  ┃    ┗━► t-nocache       ━━► _compile_directive_nocache            ━┫  ┃ ┃
              ┃  ┃    ┗━► t-cache         ━━► _compile_directive_cache              ━┫  ┃ ┃
              ┃  ┃    ┗━► t-groups        ━━► _compile_directive_groups             ━┫  ┃ ┃
              ┃  ┃    ┗━► t-foreach       ━━► _compile_directive_foreach            ━┫  ┃ ┃
              ┃  ┃    ┗━► t-if            ━━► _compile_directive_if                 ━┛  ┃ ┃
              ┃  ┃    ┗━► t-inner-content ━━► _compile_directive_inner_content ◄━━━━━┓ ━┛ ┃
              ┃  ┃    ┗━► t-options       ━━► _compile_directive_options             ┃    ┃
              ┃  ┃    ┗━► t-set           ━━► _compile_directive_set           ◄━━┓  ┃    ┃
              ┃  ┃    ┗━► t-call          ━━► _compile_directive_call            ━┛ ━┫ ━━━┛
              ┃  ┃    ┗━► t-att           ━━► _compile_directive_att                 ┃
              ┃  ┃    ┗━► t-tag-open      ━━► _compile_directive_open          ◄━━┓  ┃
              ┃  ┃    ┗━► t-tag-close     ━━► _compile_directive_close         ◄━━┫  ┃
              ┃  ┃    ┗━► t-out           ━━► _compile_directive_out             ━┛ ━┫ ◄━━┓
              ┃  ┃    ┗━► t-field         ━━► _compile_directive_field               ┃   ━┫
              ┃  ┃    ┗━► t-esc           ━━► _compile_directive_esc                 ┃   ━┛
              ┃  ┃    ┗━► t-*             ━━► ...                                    ┃
              ┃  ┃                                                                   ┃
              ┗━━┻━► _compile_static_node                                           ━┛


The QWeb ``_render`` uses the function generated by the ``_compile`` method.
Each XML node will go through the ``_compile_node`` method. If the
node does not have dynamic directives or attributes (``_is_static_node``).
A ``static`` is a node without ``t-*`` attributes, does not require dynamic
rendering for its attributes.
If it's a ``static`` node, the ``_compile_static_node`` method is called,
otherwise it is the ``_compile_directives`` method after having prepared the
order for calling the directives using the ``_directives_eval_order`` method.
In the defined order, for each directive the method ``_compile_directive`` is
called which itself dispatches to the methods corresponding to the directives
``_compile_directive_[name of the directive]`` (for example: ``t-if`` =>
``_compile_directive_if``). After all ordered directives, the directives
attributes still present on the element are compiled.

The ``_post_processing_att`` method is used for the generation of rendering
attributes. If the attributes come from static XML template nodes then the
method is called only once when generating the render function. Otherwise the
method is called during each rendering.

Each expression is compiled by the method ``_compile_expr`` into a python
expression whose values are namespaced.

Directives
----------

``t-debug``
~~~~~~~~~~~
**Values**: `''` (empty string), ``pdb``, ``ipdb``, ``pudb``, ``wdb``

Triggers a debugger breakpoint at that location. With an empty value, calls the
``breakpoint`` builtin invoking whichever breakpoint hook has been set up,
otherwise triggers a breakpoint uses the corresponding debugger.

When dev mode is enabled this allows python developers to have access to the
state of variables being rendered. The code generated by the QWeb engine is
not accessible, only the variables (values, self) can be analyzed or the
methods that called the QWeb rendering.

.. warning:: using a non-empty string is deprecated since 17.0, configure your
             preferred debugger via ``PYTHONBREAKPOINT`` or
             ``sys.setbreakpointhook``.

``t-if``
~~~~~~~~
**Values**: python expression


Add an python ``if`` condition to the code string array, and call
``_compile_directives`` to level and add the code string array corresponding
to the other directives and content.

The structure of the dom is checked to possibly find a ``t-else`` or
``t-elif``. If these directives exist then the compilation is performed and
the nodes are marked not to be rendered twice.

At **rendering time** the other directives code and content will used only if
the expression is evaluated as truely.

The ``t-else``, ``t-elif`` and ``t-if`` are not compiled at the same time like
defined in ``_directives_eval_order`` method.
```
<t t-set="check" t-value="1"/>
<section t-if="False">10</section>
<span t-elif="check == 1" t-foreach="range(3)" t-as="check" t-esc="check"/>

<section t-if="False">10</section>
<div t-else="" t-if="check == 1" t-foreach="range(3)" t-as="check" t-esc="check"/>

Result:

<span>0</span>
<span>1</span>
<span>2</span>

<div>1</div>
```

``t-else``
~~~~~~~~~~
**Values**: nothing

Only validate the **input**, the compilation if inside the ``t-if`` directive.

``t-elif``
~~~~~~~~~~
**Values**: python expression

Only validate the **input**, the compilation if inside the ``t-if`` directive.

``t-groups`` (``groups`` is an alias)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Values**: name of the allowed odoo user group, or preceded by ``!`` for
prohibited groups

The generated code uses ``user_has_groups`` Odoo method.

``t-foreach``
~~~~~~~~~~~~~
**Values**: an expression returning the collection to iterate on

This directive is used with ``t-as`` directive to defined the key name. The
directive will be converted into a ``for`` loop. In this loop, different values
are added to the dict (``values`` in the generated method) in addition to the
key defined by ``t-name``, these are (``*_value``, ``*_index``, ``*_size``,
``*_first``, ``*_last``).

``t-as``
~~~~~~~~
**Values**: key name

The compilation method only validates if ``t-as`` and ``t-foreach`` are on the
same node.

``t-options`` and ``t-options-*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Values**: python expression

It's use on the same node of another directive, it's used to configure the
other directive. Used on the same ``input node`` of the directives ``t-call``,
``t-field`` or ``t-out``.

Create a ``values['__qweb_options__']`` dict from the optional ``t-options``
expression and add each key-value ``t-options-key="expression value"`` to this
dict. (for example: ``t-options="{'widget': 'float'}"`` is equal to
``t-options-widget="'float'"``)

``t-att``, ``t-att-*`` and ``t-attf-*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Values**: python expression (or format string expression for ``t-attf-``)

Compile the attributes to create ``values['__qweb_attrs__']`` dictionary code
in the compiled function. Use the ``t-att`` expression and add each key-value
``t-att-key="expression value"`` to this dict. (for example:
``t-att="{'class': f'float_{1}'}"`` is equal to ``t-att-class="f'float_{1}'"``
and is equal to ``t-attf-class="float_{{1}}")

The attributes come from new namespaces, static elements (not preceded
by ``t-``) and dynamic attributes ``t-att``, attributes prefixed by ``t-att-``
(python expression) or ``t-attf`` (format string expression).

``t-call``
~~~~~~~~~~
**Values**: format string expression for template name

Serves the called template in place of the current ``t-call`` node.

Here are the different steps performed by the generated python code:

#. copy the ``values`` dictionary;
#. render the content (``_compile_directive_inner_content``) of the tag in a
   separate method called with the previous copied values. This values can be
   updated via t-set. The visible content of the rendering of the sub-content
   is added as a magical value ``0`` (can be rendered with ``t-out="0"``);
#. copy the ``compile_context`` dictionary;
#. compile the directive ``t-options`` and update the ``compile_context``
    are, in added to the calling template and the ``nsmap`` values;
#. get the compiled function from the ``_compile`` method;
#. use the compiled function to serves the called template.

``t-lang``
~~~~~~~~~~
**Values**: python expression

Used to serve the called template (``t-call``) in another language. Used
together with ``t-call``.

This directive will be evaluate like ``t-options-lang``. Allows you to change
the language in which the called template is rendered. It's in the ``t-call``
directive that the language of the context of the ``ir.qweb`` recordset on
which the ``_compile`` function is called is updated.

``t-call-assets``
~~~~~~~~~~~~~~~~~
**Values**: format string for template name

The generated code call the ``_get_asset_nodes`` method to get the list of
(tagName, attrs and content). From each tuple a tag is created into the
rendering.

``t-out``
~~~~~~~~~
**Values**: python expression

Output the given value or if falsy, display the content as default value.
(for example: ``<t t-out="given_value">Default content</t>``)

The generated code add the value into the ``MarkupSafe`` rendering.
If a widget is defined (``t-options-widget``), the generated code call the
``_get_widget`` method to have the formatted field value and attributes. It's
the ``ir.qweb.field.*`` models that format the value.

``t-field``
~~~~~~~~~~~
**Values**: String representing the path to the field. (for example:
``t-field="record.name"``)

Output the field value or if falsy, display the content as default value.
(for example: ``<span t-field="record.name">Default content</span>``)

Use ``t-out`` compile method but the generated code call ``_get_field``
instead of ``_get_widget``. It's the ``ir.qweb.field.*`` models that format
the value. The rendering model is chosen according to the type of field. The
rendering model can be modified via the ``t-options-widget``.

``t-esc``
~~~~~~~~~
Deprecated, please use ``t-out``

``t-raw``
~~~~~~~~~
Deprecated, please use ``t-out``

``t-set``
~~~~~~~~~
**Values**: key name

The generated code update the key ``values`` dictionary equal to the value
defined by ``t-value`` expression, ``t-valuef`` format string expression or
to the ``MarkupSafe`` rendering come from the content of the node.

``t-value``
~~~~~~~~~~~
**Values**: python expression

The compilation method only validates if ``t-value`` and ``t-set`` are on the
same node.

``t-valuef``
~~~~~~~~~~~~
**Values**: format string expression

The compilation method only validates if ``t-valuef`` and ``t-set`` are on the
same node.

Technical directives
--------------------

Directive added automatically by IrQweb in order to go through the compilation
methods.

``t-tag-open``
~~~~~~~~~~~~~~
Used to generate the opening HTML/XML tags.

``t-tag-close``
~~~~~~~~~~~~~~
Used to generate the closing HTML/XML tags.

``t-inner-content``
~~~~~~~~~~~~~~~~~~~
Used to add the content of the node (text, tail and children nodes).
If namespaces are declared on the current element then a copy of the options
is made.

``t-consumed-options``
~~~~~~~~~~~~~~~~~~~~~~
Raise an exception if the ``t-options`` is not consumed.

``t-qweb-skip``
~~~~~~~~~~~~~~~~~~~~~~
Ignore rendering and directives for the curent **input** node.

``t-else-valid``
~~~~~~~~~~~~~~~~~~~~~~
Mark a node with ``t-else`` or ``t-elif`` having a valid **input** dom
structure.

"""

import base64
import contextlib
import fnmatch
import io
import logging
import math
import re
import textwrap
import time
import token
import tokenize
import traceback
import warnings
import werkzeug

from markupsafe import Markup, escape
from collections.abc import Sized, Mapping
from itertools import count, chain
from lxml import etree
from dateutil.relativedelta import relativedelta
from psycopg2.extensions import TransactionRollbackError

from odoo import api, models, tools
from odoo.modules import registry
from odoo.tools import config, safe_eval, pycompat
from odoo.tools.constants import SUPPORTED_DEBUGGER, EXTERNAL_ASSET
from odoo.tools.safe_eval import assert_valid_codeobj, _BUILTINS, to_opcodes, _EXPR_OPCODES, _BLACKLIST
from odoo.tools.json import scriptsafe
from odoo.tools.lru import LRU
from odoo.tools.misc import str2bool
from odoo.tools.image import image_data_uri, FILETYPE_BASE64_MAGICWORD
from odoo.http import request
from odoo.tools.profiler import QwebTracker
from odoo.exceptions import UserError, AccessDenied, AccessError, MissingError, ValidationError

from odoo.addons.base.models.assetsbundle import AssetsBundle
from odoo.tools.constants import SCRIPT_EXTENSIONS, STYLE_EXTENSIONS, TEMPLATE_EXTENSIONS

_logger = logging.getLogger(__name__)


# QWeb token usefull for generate expression used in `_compile_expr_tokens` method
token.QWEB = token.NT_OFFSET - 1
token.tok_name[token.QWEB] = 'QWEB'


# security safe eval opcodes for generated expression validation, used in `_compile_expr`
_SAFE_QWEB_OPCODES = _EXPR_OPCODES.union(to_opcodes([
    'MAKE_FUNCTION', 'CALL_FUNCTION', 'CALL_FUNCTION_KW', 'CALL_FUNCTION_EX',
    'CALL_METHOD', 'LOAD_METHOD',

    'GET_ITER', 'FOR_ITER', 'YIELD_VALUE',
    'JUMP_FORWARD', 'JUMP_ABSOLUTE', 'JUMP_BACKWARD',
    'JUMP_IF_FALSE_OR_POP', 'JUMP_IF_TRUE_OR_POP', 'POP_JUMP_IF_FALSE', 'POP_JUMP_IF_TRUE',

    'LOAD_NAME', 'LOAD_ATTR',
    'LOAD_FAST', 'STORE_FAST', 'UNPACK_SEQUENCE',
    'STORE_SUBSCR',
    'LOAD_GLOBAL',
    # Following opcodes were added in 3.11 https://docs.python.org/3/whatsnew/3.11.html#new-opcodes
    'RESUME',
    'CALL',
    'PRECALL',
    'PUSH_NULL',
    'KW_NAMES',
    'FORMAT_VALUE', 'BUILD_STRING',
    'RETURN_GENERATOR',
    'SWAP',
    'POP_JUMP_FORWARD_IF_FALSE', 'POP_JUMP_FORWARD_IF_TRUE',
    'POP_JUMP_BACKWARD_IF_FALSE', 'POP_JUMP_BACKWARD_IF_TRUE',
    'POP_JUMP_FORWARD_IF_NONE', 'POP_JUMP_FORWARD_IF_NOT_NONE',
    'POP_JUMP_BACKWARD_IF_NONE', 'POP_JUMP_BACKWARD_IF_NOT_NONE',
    # 3.12 https://docs.python.org/3/whatsnew/3.12.html#new-opcodes
    'END_FOR',
    'LOAD_FAST_AND_CLEAR',
    'POP_JUMP_IF_NOT_NONE', 'POP_JUMP_IF_NONE',
    'RERAISE',
    'CALL_INTRINSIC_1',
])) - _BLACKLIST


# eval to compile generated string python code into binary code, used in `_compile`
unsafe_eval = eval


VOID_ELEMENTS = frozenset([
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])
# Terms allowed in addition to AVAILABLE_OBJECTS when compiling python expressions
ALLOWED_KEYWORD = frozenset(['False', 'None', 'True', 'and', 'as', 'elif', 'else', 'for', 'if', 'in', 'is', 'not', 'or'] + list(_BUILTINS))
# regexpr for string formatting and extract ( ruby-style )|( jinja-style  ) used in `_compile_format`
FORMAT_REGEX = re.compile(r'(?:#\{(.+?)\})|(?:\{\{(.+?)\}\})')
RSTRIP_REGEXP = re.compile(r'\n[ \t]*$')
LSTRIP_REGEXP = re.compile(r'^[ \t]*\n')
FIRST_RSTRIP_REGEXP = re.compile(r'^(\n[ \t]*)+(\n[ \t])')
VARNAME_REGEXP = re.compile(r'^[A-Za-z_][A-Za-z0-9_]*$')
TO_VARNAME_REGEXP = re.compile(r'[^A-Za-z0-9_]+')
# Attribute name used outside the context of the QWeb.
SPECIAL_DIRECTIVES = {'t-translation', 't-ignore', 't-title'}
# Name of the variable to insert the content in t-call in the template.
# The slot will be replaced by the `t-call` tag content of the caller.
T_CALL_SLOT = '0'


def indent_code(code, level):
    """Indent the code to respect the python syntax."""
    return textwrap.indent(textwrap.dedent(code).strip(), ' ' * 4 * level)


def keep_query(*keep_params, **additional_params):
    """
    Generate a query string keeping the current request querystring's parameters specified
    in ``keep_params`` and also adds the parameters specified in ``additional_params``.

    Multiple values query string params will be merged into a single one with comma seperated
    values.

    The ``keep_params`` arguments can use wildcards too, eg:

        keep_query('search', 'shop_*', page=4)
    """
    if not keep_params and not additional_params:
        keep_params = ('*',)
    params = additional_params.copy()
    qs_keys = list(request.httprequest.args) if request else []
    for keep_param in keep_params:
        for param in fnmatch.filter(qs_keys, keep_param):
            if param not in additional_params and param in qs_keys:
                params[param] = request.httprequest.args.getlist(param)
    return werkzeug.urls.url_encode(params)

####################################
###        QWebException         ###
####################################

class QWebException(Exception):
    """ Management of errors that raised when rendering a QWeb template.
    """
    def __init__(self, message, qweb, template=None, ref=None, path_xml=None, code=None):
        self.stack = traceback.format_exc()
        self.name = template
        self.ref = ref
        self.path, self.html = path_xml or (None, None)
        self.code = None
        if code:
            self.code = '\n'.join(code.split('\n')[:-1]) if qweb.env.context.get('dev_mode') else None
            line_nb = 0
            for error_line in reversed(self.stack.split('\n')):
                if f'File "<{self.ref}>"' in error_line:
                    line_function = error_line.split(', line ')[1]
                    line_nb = int(line_function.split(',')[0])
                    break
            for code_line in reversed(code.split('\n')[:line_nb]):
                match = re.match(r'\s*# element: (.*) , (.*)', code_line)
                if match:
                    self.path = match[1][1:-1]
                    self.html = match[2][1:-1]
                    break

        self.title = message
        super().__init__(message)

    def __str__(self):
        parts = [self.title]
        if self.__cause__ and str(self.__cause__) != '':
            parts.append(f"{self.__cause__.__class__.__name__}: {self.__cause__}")
        elif self.__context__ and str(self.__context__) != '':
            parts.append(f"{self.__context__.__class__.__name__}: {self.__context__}")
        if self.name is not None:
            parts.append(f"Template: {self.name}")
        if self.path is not None:
            parts.append(f"Path: {self.path}")
        if self.html is not None:
            parts.append(f"Node: {self.html}")
        if self.code is not None:
            parts.append(f"Compiled code:\n{self.code}")
        return "\n".join(parts)

    def __repr__(self):
        return f"QWebException({self.title!r})"

####################################
###             QWeb             ###
####################################


class IrQWeb(models.AbstractModel):
    """ Base QWeb rendering engine
    * to customize ``t-field`` rendering, subclass ``ir.qweb.field`` and
      create new models called :samp:`ir.qweb.field.{widget}`
    Beware that if you need extensions or alterations which could be
    incompatible with other subsystems, you should create a local object
    inheriting from ``ir.qweb`` and customize that.
    """

    _name = 'ir.qweb'
    _description = 'Qweb'

    @QwebTracker.wrap_render
    @api.model
    def _render(self, template, values=None, **options):
        """ render(template, values, **options)

        Render the template specified by the given name.

        :param template: etree, xml_id, template name (see _get_template)
            * Call the method ``load`` is not an etree.
        :param dict values: template values to be used for rendering
        :param options: used to compile the template
            Options will be add into the IrQweb.env.context for the rendering.
            * ``lang`` (str) used language to render the template
            * ``inherit_branding`` (bool) add the tag node branding
            * ``inherit_branding_auto`` (bool) add the branding on fields
            * ``minimal_qcontext``(bool) To use the minimum context and options
                from ``_prepare_environment``

        :returns: bytes marked as markup-safe (decode to :class:`markupsafe.Markup`
                  instead of `str`)
        :rtype: MarkupSafe
        """
        values = values.copy() if values else {}
        if T_CALL_SLOT in values:
            raise ValueError(f'values[{T_CALL_SLOT}] should be unset when call the _render method and only set into the template.')

        irQweb = self.with_context(**options)._prepare_environment(values)

        safe_eval.check_values(values)

        template_functions, def_name = irQweb._compile(template)
        render_template = template_functions[def_name]
        rendering = render_template(irQweb, values)
        result = ''.join(rendering)

        return Markup(result)

    # assume cache will be invalidated by third party on write to ir.ui.view
    def _get_template_cache_keys(self):
        """ Return the list of context keys to use for caching ``_compile``. """
        return ['lang', 'inherit_branding', 'inherit_branding_auto', 'edit_translations', 'profile']

    @tools.conditional(
        'xml' not in tools.config['dev_mode'],
        tools.ormcache('template', 'tuple(self.env.context.get(k) for k in self._get_template_cache_keys())', cache='templates'),
    )
    def _get_view_id(self, template):
        try:
            return self.env['ir.ui.view'].sudo().with_context(load_all_views=True)._get_view_id(template)
        except Exception:
            return None

    @QwebTracker.wrap_compile
    def _compile(self, template):
        if isinstance(template, etree._Element):
            self = self.with_context(is_t_cache_disabled=True)
            ref = None
        else:
            ref = self._get_view_id(template)

        # define the base key cache for code in cache and t-cache feature
        base_key_cache = None
        if ref:
            base_key_cache = self._get_cache_key(tuple([ref] + [self.env.context.get(k) for k in self._get_template_cache_keys()]))
        self = self.with_context(__qweb_base_key_cache=base_key_cache)

        # generate the template functions and the root function name
        def generate_functions():
            code, options, def_name = self._generate_code(template)
            if self.env.context.get('profile'):
                ref_value = None
                with contextlib.suppress(ValueError, TypeError):
                    ref_value = int(options.get('ref'))
                profile_options = {
                    'ref': ref_value,
                    'ref_xml': options.get('ref_xml') and str(options['ref_xml']) or None,
                }
            else:
                profile_options = None
            code = '\n'.join([
                "def generate_functions():",
                "    template_functions = {}",
                indent_code(code, 1),
                f"    template_functions['options'] = {profile_options!r}",
                "    return template_functions",
            ])

            try:
                compiled = compile(code, f"<{ref}>", 'exec')
                globals_dict = self.__prepare_globals()
                globals_dict['__builtins__'] = globals_dict # So that unknown/unsafe builtins are never added.
                unsafe_eval(compiled, globals_dict)
                return globals_dict['generate_functions'](), def_name
            except QWebException:
                raise
            except Exception as e:
                raise QWebException("Error when compiling xml template",
                    self, template, code=code, ref=ref) from e

        return self._load_values(base_key_cache, generate_functions)

    def _generate_code(self, template):
        """ Compile the given template into a rendering function (generator)::

            render_template(qweb, values)
            This method can be called only by the IrQweb `_render` method or by
            the compiled code of t-call from an other template.

            An `options` dictionary is created and attached to the function. It
            contains rendering options that are part of the cache key in
            addition to template references.

            where ``qweb`` is a QWeb instance and ``values`` are the values to
            render.

            :returns: tuple containing code, options and main method name
        """
        # The `compile_context`` dictionary includes the elements used for the
        # cache key to which are added the template references as well as
        # technical information useful for generating the function. This
        # dictionary is only used when compiling the template.
        compile_context = self.env.context.copy()

        try:
            element, document, ref = self._get_template(template)
        except (ValueError, UserError) as e:
            # return the error function if the template is not found or fail
            message = str(e)
            code = indent_code(f"""
                def not_found_template(self, values):
                    if self.env.context.get('raise_if_not_found', True):
                        raise {e.__class__.__name__}({message!r})
                    warning('Cannot load template %s: %s', {template!r}, {message!r})
                    return ''
                template_functions = {{'not_found_template': not_found_template}}
            """, 0)
            return (code, {}, 'not_found_template')

        compile_context.pop('raise_if_not_found', None)

        # reference to get xml and etree (usually the template ID)
        compile_context['ref'] = ref
        # reference name or key to get xml and etree (usually the template XML ID)
        compile_context['ref_name'] = element.attrib.pop('t-name', template if isinstance(template, str) and '<' not in template else None)
        # str xml of the reference template used for compilation. Useful for debugging, dev mode and profiling.
        compile_context['ref_xml'] = document
        # Identifier used to call `_compile`
        compile_context['template'] = template
        # Root of the etree which will be processed during compilation.
        compile_context['root'] = element.getroottree()
        # Reference to the last node being compiled. It is mainly used for debugging and displaying error messages.
        compile_context['_qweb_error_path_xml'] = None

        compile_context['nsmap'] = {
            ns_prefix: str(ns_definition)
            for ns_prefix, ns_definition in compile_context.get('nsmap', {}).items()
        }

        # The options dictionary includes cache key elements and template
        # references. It will be attached to the generated function. This
        # dictionary is only there for logs, performance or test information.
        # The values of these `options` cannot be changed and must always be
        # identical in `context` and `self.env.context`.
        options = {k: compile_context.get(k) for k in self._get_template_cache_keys() + ['ref', 'ref_name', 'ref_xml']}

        # generate code

        def_name = TO_VARNAME_REGEXP.sub(r'_', f'template_{ref}')

        name_gen = count()
        compile_context['make_name'] = lambda prefix: f"{def_name}_{prefix}_{next(name_gen)}"

        try:
            if element.text:
                element.text = FIRST_RSTRIP_REGEXP.sub(r'\2', element.text)

            compile_context['template_functions'] = {}

            compile_context['_text_concat'] = []
            self._append_text("", compile_context) # To ensure the template function is a generator and doesn't become a regular function
            compile_context['template_functions'][f'{def_name}_content'] = (
                [f"def {def_name}_content(self, values):"]
                + self._compile_node(element, compile_context, 2)
                + self._flush_text(compile_context, 2, rstrip=True))

            compile_context['template_functions'][def_name] = [indent_code(f"""
                def {def_name}(self, values):
                    try:
                        if '__qweb_loaded_values' not in values:
                            values['__qweb_loaded_values'] = {{}}
                            values['__qweb_root_values'] = values.copy()
                            values['xmlid'] = {options['ref_name']!r}
                            values['viewid'] = {options['ref']!r}
                        values['__qweb_loaded_values'].update(template_functions)

                        yield from {def_name}_content(self, values)
                    except QWebException:
                        raise
                    except Exception as e:
                        if isinstance(e, TransactionRollbackError):
                            raise
                        raise QWebException("Error while render the template",
                            self, template, ref={compile_context['ref']!r}, code=code) from e
                    """, 0)]
        except QWebException:
            raise
        except Exception as e:
            raise QWebException("Error when compiling xml template",
                self, template, ref=compile_context['ref'], path_xml=compile_context['_qweb_error_path_xml']) from e

        code_lines = ['code = None']
        code_lines.append(f'template = {(document if isinstance(template, etree._Element) else template)!r}')
        code_lines.append('template_functions = {}')

        for lines in compile_context['template_functions'].values():
            code_lines.extend(lines)

        for name in compile_context['template_functions']:
            code_lines.append(f'template_functions[{name!r}] = {name}')

        code = '\n'.join(code_lines)
        code += f'\n\ncode = {code!r}'

        return (code, options, def_name)

    # read and load input template

    def _get_template(self, template):
        """ Retrieve the given template, and return it as a tuple ``(etree,
        xml, ref)``, where ``element`` is an etree, ``document`` is the
        string document that contains ``element``, and ``ref`` if the uniq
        reference of the template (id, t-name or template).

        :param template: template identifier or etree
        """
        assert template not in (False, None, ""), "template is required"

        # template is an xml etree already
        if isinstance(template, etree._Element):
            element = template
            document = etree.tostring(template, encoding='unicode')
            ref = None
        # template is xml as string
        elif isinstance(template, str) and '<' in template:
            raise ValueError('Inline templates must be passed as `etree` documents')

        # template is (id or ref) to a database stored template
        else:
            try:
                ref_alias = int(template)  # e.g. <t t-call="33"/>
            except ValueError:
                ref_alias = template  # e.g. web.layout

            doc_or_elem, ref = self._load(ref_alias) or (None, None)
            if doc_or_elem is None:
                raise ValueError(f"Can not load template: {ref_alias!r}")
            if isinstance(doc_or_elem, etree._Element):
                element = doc_or_elem
                document = etree.tostring(doc_or_elem, encoding='unicode')
            elif isinstance(doc_or_elem, str):
                element = etree.fromstring(doc_or_elem)
                document = doc_or_elem
            else:
                raise TypeError(f"Loaded template {ref!r} should be a string.")

        # return etree, document and ref, or try to find the ref
        if ref:
            return (element, document, ref)

        # <templates>
        #   <template t-name=... /> <!-- return ONLY this element -->
        #   <template t-name=... />
        # </templates>
        for node in element.iter():
            ref = node.get('t-name')
            if ref:
                return (node, document, ref)

        # use the document itself as ref when no t-name was found
        return (element, document, document)

    def _load(self, ref):
        """
        Load the template referenced by ``ref``.

        :returns: The loaded template (as string or etree) and its
            identifier
        :rtype: Tuple[Union[etree, str], Optional[str, int]]
        """
        IrUIView = self.env['ir.ui.view'].sudo()
        view = IrUIView._get(ref)
        template = IrUIView._read_template(view.id)
        etree_view = etree.fromstring(template)

        xmlid = view.key or ref
        if isinstance(ref, int):
            domain = [('model', '=', 'ir.ui.view'), ('res_id', '=', view.id)]
            model_data = self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name'], limit=1)
            if model_data:
                xmlid = f"{model_data[0]['module']}.{model_data[0]['name']}"

        # QWeb's ``_read_template`` will check if one of the first children of
        # what we send to it has a "t-name" attribute having ``ref`` as value
        # to consider it has found it. As it'll never be the case when working
        # with view ids or children view or children primary views, force it here.
        if view.inherit_id is not None:
            for node in etree_view:
                if node.get('t-name') == str(ref) or node.get('t-name') == str(view.key):
                    node.attrib.pop('name', None)
                    node.attrib.pop('id', None)
                    etree_view = node
                    break
        etree_view.set('t-name', str(xmlid))
        return (etree_view, view.id)

    # values for running time

    def _get_converted_image_data_uri(self, base64_source):
        if self.env.context.get('webp_as_jpg'):
            mimetype = FILETYPE_BASE64_MAGICWORD.get(base64_source[:1], 'png')
            if 'webp' in mimetype:
                # Use converted image so that is recognized by wkhtmltopdf.
                bin_source = base64.b64decode(base64_source)
                Attachment = self.env['ir.attachment']
                checksum = Attachment._compute_checksum(bin_source)
                origins = Attachment.sudo().search([
                    ['id', '!=', False],  # No implicit condition on res_field.
                    ['checksum', '=', checksum],
                ])
                if origins:
                    converted_domain = [
                        ['id', '!=', False],  # No implicit condition on res_field.
                        ['res_model', '=', 'ir.attachment'],
                        ['res_id', 'in', origins.ids],
                        ['mimetype', '=', 'image/jpeg'],
                    ]
                    converted = Attachment.sudo().search(converted_domain, limit=1)
                    if converted:
                        base64_source = converted.datas
        return image_data_uri(base64_source)

    def _prepare_environment(self, values):
        """ Prepare the values and context that will sent to the
        compiled and evaluated function.

        :param values: template values to be used for rendering

        :returns self (with new context)
        """
        debug = request and request.session.debug or ''
        values.update(
            true=True,
            false=False,
        )
        if not self.env.context.get('minimal_qcontext'):
            values.setdefault('debug', debug)
            values.setdefault('user_id', self.env.user.with_env(self.env))
            values.setdefault('res_company', self.env.company.sudo())
            values.update(
                request=request,  # might be unbound if we're not in an httprequest context
                test_mode_enabled=bool(config['test_enable'] or config['test_file']),
                json=scriptsafe,
                quote_plus=werkzeug.urls.url_quote_plus,
                time=safe_eval.time,
                datetime=safe_eval.datetime,
                relativedelta=relativedelta,
                image_data_uri=self._get_converted_image_data_uri,
                # specific 'math' functions to ease rounding in templates and lessen controller marshmalling
                floor=math.floor,
                ceil=math.ceil,
                env=self.env,
                lang=self.env.context.get('lang'),
                keep_query=keep_query,
            )

        context = {'dev_mode': 'qweb' in tools.config['dev_mode']}
        if 'xml' in tools.config['dev_mode']:
            context['is_t_cache_disabled'] = True
        elif 'disable-t-cache' in debug:
            context['is_t_cache_disabled'] = True
        return self.with_context(**context)

    def __prepare_globals(self):
        """ Prepare the global context that will sent to eval the qweb
        generated code.
        """
        return {
            'Sized': Sized,
            'Mapping': Mapping,
            'Markup': Markup,
            'escape': escape,
            'VOID_ELEMENTS': VOID_ELEMENTS,
            'QWebException': QWebException,
            'Exception': Exception,
            'TransactionRollbackError': TransactionRollbackError, # for SerializationFailure in assets
            'ValueError': ValueError,
            'UserError': UserError,
            'AccessDenied': AccessDenied,
            'AccessError': AccessError,
            'MissingError': MissingError,
            'ValidationError': ValidationError,
            'warning': lambda *args: _logger.warning(*args),
            **_BUILTINS,
        }

    # helpers for compilation

    def _append_text(self, text, compile_context):
        """ Add an item (converts to a string) to the list.
            This will be concatenated and added during a call to the
            `_flush_text` method. This makes it possible to return only one
            yield containing all the parts."""
        compile_context['_text_concat'].append(self._compile_to_str(text))

    def _rstrip_text(self, compile_context):
        """ The text to flush is right stripped, and the stripped content are
        returned.
        """
        text_concat = compile_context['_text_concat']
        if not text_concat:
            return ''

        result = RSTRIP_REGEXP.search(text_concat[-1])
        strip = result.group(0) if result else ''
        text_concat[-1] = RSTRIP_REGEXP.sub('', text_concat[-1])

        return strip

    def _flush_text(self, compile_context, level, rstrip=False):
        """Concatenate all the textual chunks added by the `_append_text`
            method into a single yield.
            If no text to flush, return an empty list

            If rstrip the text is right stripped.

            @returns list(str)
        """
        text_concat = compile_context['_text_concat']
        if not text_concat:
            return []
        if rstrip:
            self._rstrip_text(compile_context)
        text = ''.join(text_concat)
        text_concat.clear()
        return [f"{'    ' * level}yield {text!r}"]

    def _is_static_node(self, el, compile_context):
        """ Test whether the given element is purely static, i.e. (there
        are no t-* attributes), does not require dynamic rendering for its
        attributes.
        """
        return el.tag != 't' and 'groups' not in el.attrib and not any(
            att.startswith('t-') and att not in ('t-tag-open', 't-inner-content')
            for att in el.attrib
        )

    # compile python expression and format string

    def _compile_format(self, expr):
        """ Parses the provided format string and compiles it to a single
        expression python, uses string with format method.
        Use format is faster to concat string and values.
        """
        # <t t-setf-name="Hello #{world} %s !"/>
        # =>
        # values['name'] = 'Hello %s %%s !' % (values['world'],)
        values = [
            f'self._compile_to_str({self._compile_expr(m.group(1) or m.group(2))})'
            for m in FORMAT_REGEX.finditer(expr)
        ]
        code = repr(FORMAT_REGEX.sub('%s', expr.replace('%', '%%')))
        if values:
            code += f' % ({", ".join(values)},)'
        return code

    def _compile_expr_tokens(self, tokens, allowed_keys, argument_names=None, raise_on_missing=False):
        """ Transform the list of token coming into a python instruction in
            textual form by adding the namepaces for the dynamic values.

            Example: `5 + a + b.c` to be `5 + values.get('a') + values['b'].c`
            Unknown values are considered to be None, but using `values['b']`
            gives a clear error message in cases where there is an attribute for
            example (have a `KeyError: 'b'`, instead of `AttributeError: 'NoneType'
            object has no attribute 'c'`).

            @returns str
        """
        # Finds and extracts the current "scope"'s "allowed values": values
        # which should not be accessed through the environment's namespace:
        # * the local variables of a lambda should be accessed directly e.g.
        #     lambda a: a + b should be compiled to lambda a: a + values['b'],
        #     since a is local to the lambda it has to be accessed directly
        #     but b needs to be accessed through the rendering environment
        # * similarly for a comprehensions [a + b for a in c] should be
        #     compiledto [a + values.get('b') for a in values.get('c')]
        # to avoid the risk of confusion between nested lambdas / comprehensions,
        # this is currently performed independently at each level of brackets
        # nesting (hence the function being recursive).
        open_bracket_index = -1
        bracket_depth = 0

        argument_name = '_arg_%s__'
        argument_names = argument_names or []

        for index, t in enumerate(tokens):
            if t.exact_type in [token.LPAR, token.LSQB, token.LBRACE]:
                bracket_depth += 1
            elif t.exact_type in [token.RPAR, token.RSQB, token.RBRACE]:
                bracket_depth -= 1
            elif bracket_depth == 0 and t.exact_type == token.NAME:
                string = t.string
                if string == 'lambda': # lambda => allowed values for the current bracket depth
                    for i in range(index + 1, len(tokens)):
                        t = tokens[i]
                        if t.exact_type == token.NAME:
                            argument_names.append(t.string)
                        elif t.exact_type == token.COMMA:
                            pass
                        elif t.exact_type == token.COLON:
                            break
                        elif t.exact_type == token.EQUAL:
                            raise NotImplementedError('Lambda default values are not supported')
                        else:
                            raise NotImplementedError('This lambda code style is not implemented.')
                elif string == 'for': # list comprehensions => allowed values for the current bracket depth
                    for i in range(index + 1, len(tokens)):
                        t = tokens[i]
                        if t.exact_type == token.NAME:
                            if t.string == 'in':
                                break
                            argument_names.append(t.string)
                        elif t.exact_type in [token.COMMA, token.LPAR, token.RPAR]:
                            pass
                        else:
                            raise NotImplementedError('This loop code style is not implemented.')

        # Use bracket to nest structures.
        # Recursively processes the "sub-scopes", and replace their content with
        # a compiled node. During this recursive call we add to the allowed
        # values the values provided by the list comprehension, lambda, etc.,
        # previously extracted.
        index = 0
        open_bracket_index = -1
        bracket_depth = 0

        while index < len(tokens):
            t = tokens[index]
            string = t.string

            if t.exact_type in [token.LPAR, token.LSQB, token.LBRACE]:
                if bracket_depth == 0:
                    open_bracket_index = index
                bracket_depth += 1
            elif t.exact_type in [token.RPAR, token.RSQB, token.RBRACE]:
                bracket_depth -= 1
                if bracket_depth == 0:
                    code = self._compile_expr_tokens(
                        tokens[open_bracket_index + 1:index],
                        list(allowed_keys),
                        list(argument_names),
                        raise_on_missing,
                    )
                    code = tokens[open_bracket_index].string + code + t.string
                    tokens[open_bracket_index:index + 1] = [tokenize.TokenInfo(token.QWEB, code, tokens[open_bracket_index].start, t.end, '')]
                    index = open_bracket_index

            index += 1

        # The keys will be namespaced by values if they are not allowed. In
        # order to have a clear keyError message, this will be replaced by
        # values['key'] for certain cases (for example if an attribute is called
        # key.attrib, or an index key[0] ...)
        code = []
        index = 0
        pos = tokens and tokens[0].start # to keep level when use expr on multi line
        while index < len(tokens):
            t = tokens[index]
            string = t.string

            if t.start[0] != pos[0]:
                pos = (t.start[0], 0)
            space = t.start[1] - pos[1]
            if space:
                code.append(' ' * space)
            pos = t.start

            if t.exact_type == token.NAME:
                if string == 'lambda': # lambda => allowed values
                    code.append('lambda ')
                    index += 1
                    while index < len(tokens):
                        t = tokens[index]
                        if t.exact_type == token.NAME and t.string in argument_names:
                            code.append(argument_name % t.string)
                        if t.exact_type in [token.COMMA, token.COLON]:
                            code.append(t.string)
                        if t.exact_type == token.COLON:
                            break
                        index += 1
                    if t.end[0] != pos[0]:
                        pos = (t.end[0], 0)
                    else:
                        pos = t.end
                elif string in argument_names:
                    code.append(argument_name % t.string)
                elif string in allowed_keys:
                    code.append(string)
                elif index + 1 < len(tokens) and tokens[index + 1].exact_type == token.EQUAL: # function kw
                    code.append(string)
                elif index > 0 and tokens[index - 1] and tokens[index - 1].exact_type == token.DOT:
                    code.append(string)
                elif raise_on_missing or index + 1 < len(tokens) and tokens[index + 1].exact_type in [token.DOT, token.LPAR, token.LSQB, 'qweb']:
                    # Should have values['product'].price to raise an error when get
                    # the 'product' value and not an 'NoneType' object has no
                    # attribute 'price' error.
                    code.append(f'values[{string!r}]')
                else:
                    # not assignation allowed, only getter
                    code.append(f'values.get({string!r})')
            elif t.type not in [tokenize.ENCODING, token.ENDMARKER, token.DEDENT]:
                code.append(string)

            if t.end[0] != pos[0]:
                pos = (t.end[0], 0)
            else:
                pos = t.end

            index += 1

        return ''.join(code)

    def _compile_expr(self, expr, raise_on_missing=False):
        """Transform string coming into a python instruction in textual form by
        adding the namepaces for the dynamic values.
        This method tokenize the string and call ``_compile_expr_tokens``
        method.

        :param expr: string: python expression
        :param [raise_on_missing]: boolean:
            Compile has `values['product'].price` instead of
            `values.get('product').price` to raise an error when get the
            'product' value and not an 'NoneType' object has no attribute
            'price' error.
        """
        # Parentheses are useful for compiling multi-line expressions such as
        # conditions existing in some templates. (see test_compile_expr tests)
        readable = io.BytesIO(f"({expr or ''})".encode('utf-8'))
        try:
            tokens = list(tokenize.tokenize(readable.readline))
        except tokenize.TokenError:
            raise ValueError(f"Can not compile expression: {expr}")

        expression = self._compile_expr_tokens(tokens, ALLOWED_KEYWORD, raise_on_missing=raise_on_missing)

        assert_valid_codeobj(_SAFE_QWEB_OPCODES, compile(expression, '<>', 'eval'), expr)

        return f"({expression})"

    def _compile_bool(self, attr, default=False):
        """Convert the statements as a boolean."""
        if attr:
            if attr is True:
                return True
            attr = attr.lower()
            if attr in ('false', '0'):
                return False
            elif attr in ('true', '1'):
                return True
        return bool(default)

    def _compile_to_str(self, expr):
        """ Generates a text value (an instance of text_type) from an arbitrary
            source.
        """
        return pycompat.to_text(expr)

    # order

    def _directives_eval_order(self):
        """ List all supported directives in the order in which they should be
        evaluated on a given element. For instance, a node bearing both
        ``foreach`` and ``if`` should see ``foreach`` executed before ``if`` aka
        .. code-block:: xml
            <el t-foreach="foo" t-as="bar" t-if="bar">
        should be equivalent to
        .. code-block:: xml
            <t t-foreach="foo" t-as="bar">
                <t t-if="bar">
                    <el>
        then this method should return ``['foreach', 'if']``.
        """
        return [
            'elif', # Must be the first because compiled by the previous if.
            'else', # Must be the first because compiled by the previous if.
            'debug',
            'nocache',
            'cache',
            'groups',
            'as', 'foreach',
            'if',
            'call-assets',
            'lang',
            'options',
            'att',
            'field', 'esc', 'raw', 'out',
            'tag-open',
            'call',
            'set',
            'inner-content',
            'tag-close',
        ]

    # compile

    def _compile_node(self, el, compile_context, level):
        """ Compile the given element into python code.

            The t-* attributes (directives) will be converted to a python instruction. If there
            are no t-* attributes, the element will be considered static.

            Directives are compiled using the order provided by the
            ``_directives_eval_order`` method (an create the
            ``compile_context['iter_directives']`` iterator).
            For compilation, the directives supported are those with a
            compilation method ``_compile_directive_*``

        :return: list of string
        """
        # Internal directive used to skip a rendering.
        if 't-qweb-skip' in el.attrib:
            return []

        # if tag don't have qweb attributes don't use directives
        if self._is_static_node(el, compile_context):
            return self._compile_static_node(el, compile_context, level)

        path = compile_context['root'].getpath(el)
        xml = etree.tostring(etree.Element(el.tag, el.attrib), encoding='unicode')
        compile_context['_qweb_error_path_xml'] = (path, xml)
        body = [indent_code(f'# element: {path!r} , {xml!r}', level)]

        # create an iterator on directives to compile in order
        compile_context['iter_directives'] = iter(self._directives_eval_order())

        # add technical directive tag-open, tag-close, inner-content and take
        # care of the namspace
        if not el.nsmap:
            unqualified_el_tag = el_tag = el.tag
        else:
            # Etree will remove the ns prefixes indirection by inlining the corresponding
            # nsmap definition into the tag attribute. Restore the tag and prefix here.
            # Note: we do not support namespace dynamic attributes, we need a default URI
            # on the root and use attribute directive t-att="{'xmlns:example': value}".
            unqualified_el_tag = etree.QName(el.tag).localname
            el_tag = unqualified_el_tag
            if el.prefix:
                el_tag = f'{el.prefix}:{el_tag}'

        if unqualified_el_tag != 't':
            el.set('t-tag-open', el_tag)
            if el_tag not in VOID_ELEMENTS:
                el.set('t-tag-close', el_tag)

        if not ({'t-out', 't-esc', 't-raw', 't-field'} & set(el.attrib)):
            el.set('t-inner-content', 'True')

        return body + self._compile_directives(el, compile_context, level)

    def _compile_static_node(self, el, compile_context, level):
        """ Compile a purely static element into a list of string. """
        if not el.nsmap:
            unqualified_el_tag = el_tag = el.tag
            attrib = self._post_processing_att(el.tag, el.attrib)
        else:
            # Etree will remove the ns prefixes indirection by inlining the corresponding
            # nsmap definition into the tag attribute. Restore the tag and prefix here.
            unqualified_el_tag = etree.QName(el.tag).localname
            el_tag = unqualified_el_tag
            if el.prefix:
                el_tag = f'{el.prefix}:{el_tag}'

            attrib = {}
            # If `el` introduced new namespaces, write them as attribute by using the
            # `attrib` dict.
            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(compile_context['nsmap'].items()):
                if ns_prefix is None:
                    attrib['xmlns'] = ns_definition
                else:
                    attrib[f'xmlns:{ns_prefix}'] = ns_definition

            # Etree will also remove the ns prefixes indirection in the attributes. As we only have
            # the namespace definition, we'll use an nsmap where the keys are the definitions and
            # the values the prefixes in order to get back the right prefix and restore it.
            ns = chain(compile_context['nsmap'].items(), el.nsmap.items())
            nsprefixmap = {v: k for k, v in ns}
            for key, value in el.attrib.items():
                attrib_qname = etree.QName(key)
                if attrib_qname.namespace:
                    attrib[f'{nsprefixmap[attrib_qname.namespace]}:{attrib_qname.localname}'] = value
                else:
                    attrib[key] = value

            attrib = self._post_processing_att(el.tag, attrib)

            # Update the dict of inherited namespaces before continuing the recursion. Note:
            # since `compile_context['nsmap']` is a dict (and therefore mutable) and we do **not**
            # want changes done in deeper recursion to bevisible in earlier ones, we'll pass
            # a copy before continuing the recursion and restore the original afterwards.
            original_nsmap = dict(compile_context['nsmap'])

        if unqualified_el_tag != 't':
            attributes = ''.join(f' {name}="{escape(str(value))}"'
                                for name, value in attrib.items() if value or isinstance(value, str))
            self._append_text(f'<{el_tag}{"".join(attributes)}', compile_context)
            if el_tag in VOID_ELEMENTS:
                self._append_text('/>', compile_context)
            else:
                self._append_text('>', compile_context)

        el.attrib.clear()

        if el.nsmap:
            compile_context['nsmap'].update(el.nsmap)
            body = self._compile_directive(el, compile_context, 'inner-content', level)
            compile_context['nsmap'] = original_nsmap
        else:
            body = self._compile_directive(el, compile_context, 'inner-content', level)

        if unqualified_el_tag != 't':
            if el_tag not in VOID_ELEMENTS:
                self._append_text(f'</{el_tag}>', compile_context)

        return body

    def _compile_directives(self, el, compile_context, level):
        """ Compile the given element, following the directives given in the
        iterator ``compile_context['iter_directives']`` create by
        `_compile_node`` method.

        :return: list of code lines
        """
        if self._is_static_node(el, compile_context):
            el.attrib.pop('t-tag-open', None)
            el.attrib.pop('t-inner-content', None)
            el.attrib.pop('t-tag-close', None)
            return self._compile_static_node(el, compile_context, level)

        code = []

        # compile the directives still present on the element
        for directive in compile_context['iter_directives']:
            if ('t-' + directive) in el.attrib:
                code.extend(self._compile_directive(el, compile_context, directive, level))
            elif directive == 'groups':
                if directive in el.attrib:
                    code.extend(self._compile_directive(el, compile_context, directive, level))
            elif directive == 'att':
                code.extend(self._compile_directive(el, compile_context, directive, level))
            elif directive == 'options':
                if any(name.startswith('t-options-') for name in el.attrib):
                    code.extend(self._compile_directive(el, compile_context, directive, level))
            elif directive == 'nocache':
                if any(name.startswith('t-nocache-') for name in el.attrib):
                    code.extend(self._compile_directive(el, compile_context, directive, level))

        # compile unordered directives still present on the element
        for att in el.attrib:
            if att not in SPECIAL_DIRECTIVES and att.startswith('t-') and getattr(self, f"_compile_directive_{att[2:].replace('-', '_')}", None):
                code.extend(self._compile_directive(el, compile_context, directive, level))

        remaining = set(el.attrib) - SPECIAL_DIRECTIVES
        if remaining:
            _logger.warning('Unknown directives or unused attributes: %s in %s', remaining, compile_context['template'])

        return code

    @QwebTracker.wrap_compile_directive
    def _compile_directive(self, el, compile_context, directive, level):
        compile_handler = getattr(self, f"_compile_directive_{directive.replace('-', '_')}", None)
        return compile_handler(el, compile_context, level)

    # compile directives

    def _compile_directive_debug(self, el, compile_context, level):
        """Compile `t-debug` expressions into a python code as a list of
        strings.

        The code will contains the call to the debugger chosen from the valid
        list.
        """
        debugger = el.attrib.pop('t-debug')
        code = []
        if compile_context.get('dev_mode'):
            code.append(indent_code(f"self._debug_trace({debugger!r}, values)", level))
        else:
            _logger.warning("@t-debug in template is only available in qweb dev mode")
        return code

    def _compile_directive_options(self, el, compile_context, level):
        """
        compile t-options and add to the dict the t-options-xxx. Will create
        the dictionary ``values['__qweb_options__']`` in compiled code.
        """
        code = []
        dict_options = []
        for key in list(el.attrib):
            if key.startswith('t-options-'):
                value = el.attrib.pop(key)
                option_name = key[10:]
                dict_options.append(f'{option_name!r}:{self._compile_expr(value)}')

        t_options = el.attrib.pop('t-options', None)
        if t_options and dict_options:
            code.append(indent_code(f"values['__qweb_options__'] = {{**{self._compile_expr(t_options)}, {', '.join(dict_options)}}}", level))
        elif dict_options:
            code.append(indent_code(f"values['__qweb_options__'] = {{{', '.join(dict_options)}}}", level))
        elif t_options:
            code.append(indent_code(f"values['__qweb_options__'] = {self._compile_expr(t_options)}", level))
        else:
            code.append(indent_code("values['__qweb_options__'] = {}", level))

        el.set('t-consumed-options', str(bool(code)))

        return code

    def _compile_directive_consumed_options(self, el, compile_context, level):
        raise SyntaxError('the t-options must be on the same tag as a directive that consumes it (for example: t-out, t-field, t-call)')

    def _compile_directive_att(self, el, compile_context, level):
        """ Compile the attributes of the given elements.

        The compiled function will create the ``values['__qweb_attrs__']``
        dictionary. Then the dictionary will be output.


        The new namespaces of the current element.

        The static attributes (not prefixed by ``t-``) are add to the
        dictionary in first.

        The dynamic attributes values will be add after. The dynamic
        attributes has different origins.
        - value from key equal to ``t-att``: python dictionary expression;
        - value from keys that start with ``t-att-``: python expression;
        - value from keys that start with ``t-attf-``: format string
            expression.
        """
        code = [indent_code("attrs = values['__qweb_attrs__'] = {}", level)]

        # Compile the introduced new namespaces of the given element.
        #
        # Add the found new attributes into the `attrs` dictionary like
        # the static attributes.
        if el.nsmap:
            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(compile_context['nsmap'].items()):
                key = 'xmlns'
                if ns_prefix is not None:
                    key = f'xmlns:{ns_prefix}'
                code.append(indent_code(f'attrs[{key!r}] = {ns_definition!r}', level))

        # Compile the static attributes of the given element.
        #
        # Etree will also remove the ns prefixes indirection in the
        # attributes. As we only have the namespace definition, we'll use
        # an nsmap where the keys are the definitions and the values the
        # prefixes in order to get back the right prefix and restore it.
        if any(not name.startswith('t-') for name in el.attrib):
            nsprefixmap = {v: k for k, v in chain(compile_context['nsmap'].items(), el.nsmap.items())}
            for key in list(el.attrib):
                if not key.startswith('t-'):
                    value = el.attrib.pop(key)
                    attrib_qname = etree.QName(key)
                    if attrib_qname.namespace:
                        key = f'{nsprefixmap[attrib_qname.namespace]}:{attrib_qname.localname}'
                    code.append(indent_code(f'attrs[{key!r}] = {value!r}', level))

        # Compile the dynamic attributes of the given element. All
        # attributes will be add to the ``attrs`` dictionary in the
        # compiled function.
        for key in list(el.attrib):
            if key.startswith('t-attf-'):
                value = el.attrib.pop(key)
                code.append(indent_code(f"attrs[{key[7:]!r}] = {self._compile_format(value)}", level))
            elif key.startswith('t-att-'):
                value = el.attrib.pop(key)
                code.append(indent_code(f"attrs[{key[6:]!r}] = {self._compile_expr(value)}", level))
            elif key == 't-att':
                value = el.attrib.pop(key)
                code.append(indent_code(f"""
                    atts_value = {self._compile_expr(value)}
                    if isinstance(atts_value, dict):
                        attrs.update(atts_value)
                    elif isinstance(atts_value, (list, tuple)) and not isinstance(atts_value[0], (list, tuple)):
                        attrs.update([atts_value])
                    elif isinstance(atts_value, (list, tuple)):
                        attrs.update(dict(atts_value))
                    """, level))

        return code

    def _compile_directive_tag_open(self, el, compile_context, level):
        """ Compile the opening tag with attributes of the given element into
        a list of python code line.

        The compiled function will fill the ``attrs`` dictionary. Then the
        ``attrs`` dictionary will be output and reset the value of ``attrs``.

        The static attributes (not prefixed by ``t-``) are add to the
        ``attrs`` dictionary in first.

        The dynamic attributes values will be add after. The dynamic
        attributes has different origins.
        - value from key equal to ``t-att``: python dictionary expression;
        - value from keys that start with ``t-att-``: python expression;
        - value from keys that start with ``t-attf-``: format string
            expression.
        """

        el_tag = el.attrib.pop('t-tag-open', None)
        if not el_tag:
            return []

        # open the open tag
        self._append_text(f"<{el_tag}", compile_context)

        code = self._flush_text(compile_context, level)

        # Generates the part of the code that prost process and output the
        # attributes from ``attrs`` dictionary. Consumes `attrs` dictionary
        # and reset it.
        #
        # Use str(value) to change Markup into str and escape it, then use str
        # to avoid the escaping of the other html content.
        code.append(indent_code(f"""
            attrs = values.pop('__qweb_attrs__', None)
            if attrs:
                tagName = {el.tag!r}
                attrs = self._post_processing_att(tagName, attrs)
                for name, value in attrs.items():
                    if value or isinstance(value, str):
                        yield f' {{escape(str(name))}}="{{escape(str(value))}}"'
        """, level))

        # close the open tag
        if 't-tag-close' in el.attrib:
            self._append_text('>', compile_context)
        else:
            self._append_text('/>', compile_context)

        return code

    def _compile_directive_tag_close(self, el, compile_context, level):
        """ Compile the closing tag of the given element into string.
        Returns an empty list because it's use only `_append_text`.
        """
        el_tag = el.attrib.pop("t-tag-close", None)
        if el_tag:
            self._append_text(f'</{el_tag}>', compile_context)
        return []

    def _compile_directive_set(self, el, compile_context, level):
        """Compile `t-set` expressions into a python code as a list of
        strings.

        There are 3 kinds of `t-set`:
        * `t-value` containing python code;
        * `t-valuef` containing strings to format;
        * whose value is the content of the tag (being Markup safe).

        The code will contain the assignment of the dynamically generated value.
        """

        code = self._flush_text(compile_context, level, rstrip=el.tag.lower() == 't')

        if 't-set' in el.attrib:
            varname = el.attrib.pop('t-set')
            if varname == "":
                raise KeyError('t-set')
            if varname != T_CALL_SLOT and varname[0] != '{' and not VARNAME_REGEXP.match(varname):
                raise ValueError('The varname can only contain alphanumeric characters and underscores.')

            if 't-value' in el.attrib or 't-valuef' in el.attrib or varname[0] == '{':
                el.attrib.pop('t-inner-content') # The content is considered empty.
                if varname == T_CALL_SLOT:
                    raise SyntaxError('t-set="0" should not be set from t-value or t-valuef')

            if 't-value' in el.attrib:
                expr = el.attrib.pop('t-value') or 'None'
                code.append(indent_code(f"values[{varname!r}] = {self._compile_expr(expr)}", level))
            elif 't-valuef' in el.attrib:
                exprf = el.attrib.pop('t-valuef')
                code.append(indent_code(f"values[{varname!r}] = {self._compile_format(exprf)}", level))
            elif varname[0] == '{':
                code.append(indent_code(f"values.update({self._compile_expr(varname)})", level))
            else:
                # set the content as value
                content = (
                    self._compile_directive(el, compile_context, 'inner-content', 1) +
                    self._flush_text(compile_context, 1))
                if content:
                    def_name = compile_context['make_name']('t_set')
                    compile_context['template_functions'][def_name] = [f"def {def_name}(self, values):"] + content
                    code.append(indent_code(f"""
                            t_set = []
                            for item in {def_name}(self, values):
                                if isinstance(item, str):
                                    t_set.append(item)
                                else:
                                    ref, function_name, cached_values = item
                                    t_nocache_function = values['__qweb_loaded_values'].get(function_name)
                                    if not t_nocache_function:
                                        t_call_template_functions, def_name = self._compile(ref)
                                        t_nocache_function = t_call_template_functions[function_name]

                                    nocache_values = values['__qweb_root_values'].copy()
                                    nocache_values.update(cached_values)
                                    t_set.extend(t_nocache_function(self, nocache_values))
                        """, level))
                    expr = "Markup(''.join(t_set))"
                else:
                    expr = "''"
                code.append(indent_code(f"values[{varname!r}] = {expr}", level))

        return code

    def _compile_directive_value(self, el, compile_context, level):
        """Compile `t-value` expressions into a python code as a list of strings.

        This method only check if this attributes is on the same node of a
         `t-set` attribute.
        """
        raise SyntaxError("t-value must be on the same node of t-set")

    def _compile_directive_valuef(self, el, compile_context, level):
        """Compile `t-valuef` expressions into a python code as a list of strings.

        This method only check if this attributes is on the same node of a
         `t-set` attribute.
        """
        raise SyntaxError("t-valuef must be on the same node of t-set")

    def _compile_directive_inner_content(self, el, compile_context, level):
        """Compiles the content of the element (is the technical `t-inner-content`
        directive created by QWeb) into a python code as a list of
        strings.

        The code will contains the text content of the node or the compliled
        code from the recursive call of ``_compile_node``.
        """
        el.attrib.pop('t-inner-content', None)

        if el.nsmap:
            # Update the dict of inherited namespaces before continuing the recursion. Note:
            # since `compile_context['nsmap']` is a dict (and therefore mutable) and we do **not**
            # want changes done in deeper recursion to bevisible in earlier ones, we'll pass
            # a copy before continuing the recursion and restore the original afterwards.
            compile_context = dict(compile_context, nsmap=el.nsmap)

        if el.text is not None:
            self._append_text(el.text, compile_context)
        body = []
        for item in el:
            if isinstance(item, etree._Comment):
                if compile_context.get('preserve_comments'):
                    self._append_text(f"<!--{item.text}-->", compile_context)
            elif isinstance(item, etree._ProcessingInstruction):
                if compile_context.get('preserve_comments'):
                    self._append_text(f"<?{item.target} {item.text}?>", compile_context)
            else:
                body.extend(self._compile_node(item, compile_context, level))
            # comments can also contains tail text
            if item.tail is not None:
                self._append_text(item.tail, compile_context)
        return body

    def _compile_directive_if(self, el, compile_context, level):
        """Compile `t-if` expressions into a python code as a list of strings.

        The code will contain the condition `if`, `else` and `elif` part that
        wrap the rest of the compiled code of this element.
        """
        expr = el.attrib.pop('t-if', el.attrib.pop('t-elif', None))

        assert not expr.isspace(), 't-if or t-elif expression should not be empty.'

        strip = self._rstrip_text(compile_context)  # the withspaces is visible only when display a content
        if el.tag.lower() == 't' and el.text and LSTRIP_REGEXP.search(el.text):
            strip = ''  # remove technical spaces
        code = self._flush_text(compile_context, level)

        code.append(indent_code(f"if {self._compile_expr(expr)}:", level))
        body = []
        if strip:
            self._append_text(strip, compile_context)
        body.extend(
            self._compile_directives(el, compile_context, level + 1) +
            self._flush_text(compile_context, level + 1, rstrip=True))
        code.extend(body or [indent_code('pass', level + 1)])

        # Look for the else or elif conditions
        next_el = el.getnext()
        comments_to_remove = []
        while isinstance(next_el, etree._Comment):
            comments_to_remove.append(next_el)
            next_el = next_el.getnext()

        # If there is a t-else directive, the comment nodes are deleted
        # and the t-else or t-elif is validated.
        if next_el is not None and {'t-else', 't-elif'} & set(next_el.attrib):
            # Insert a flag to allow t-else or t-elif rendering.
            next_el.attrib['t-else-valid'] = 'True'

            # remove comment node
            parent = el.getparent()
            for comment in comments_to_remove:
                parent.remove(comment)
            if el.tail and not el.tail.isspace():
                raise SyntaxError("Unexpected non-whitespace characters between t-if and t-else directives")
            el.tail = None

            # You have to render the `t-else` and `t-elif` here in order
            # to be able to put the log. Otherwise, the parent's
            # `t-inner-content`` directive will render the different
            # nodes without taking indentation into account such as:
            #    if (if_expression):
            #         content_if
            #    log ['last_path_node'] = path
            #    else:
            #       content_else

            code.append(indent_code("else:", level))
            body = []
            if strip:
                self._append_text(strip, compile_context)
            body.extend(
                self._compile_node(next_el, compile_context, level + 1)+
                self._flush_text(compile_context, level + 1, rstrip=True))
            code.extend(body or [indent_code('pass', level + 1)])

            # Insert a flag to avoid the t-else or t-elif rendering when
            # the parent t-inner-content dirrective compile his
            # children.
            next_el.attrib['t-qweb-skip'] = 'True'

        return code

    def _compile_directive_elif(self, el, compile_context, level):
        """Compile `t-elif` expressions into a python code as a list of
        strings. This method is linked with the `t-if` directive.

        Check if this directive is valide, the t-qweb-skip flag and call
        `t-if` directive
        """
        if not el.attrib.pop('t-else-valid', None):
            raise SyntaxError("t-elif directive must be preceded by t-if or t-elif directive")

        return self._compile_directive_if(el, compile_context, level)

    def _compile_directive_else(self, el, compile_context, level):
        """Compile `t-else` expressions into a python code as a list of strings.
        This method is linked with the `t-if` directive.

        Check if this directive is valide and add the t-qweb-skip flag.
        """
        if not el.attrib.pop('t-else-valid', None):
            raise SyntaxError("t-elif directive must be preceded by t-if or t-elif directive")
        el.attrib.pop('t-else')
        return []

    def _compile_directive_groups(self, el, compile_context, level):
        """Compile `t-groups` expressions into a python code as a list of
        strings.

        The code will contain the condition `if self.user_has_groups(groups)`
        part that wrap the rest of the compiled code of this element.
        """
        groups = el.attrib.pop('t-groups', el.attrib.pop('groups', None))

        strip = self._rstrip_text(compile_context)
        code = self._flush_text(compile_context, level)
        code.append(indent_code(f"if self.user_has_groups({groups!r}):", level))
        if strip and el.tag.lower() != 't':
            self._append_text(strip, compile_context)
        code.extend([
            *self._compile_directives(el, compile_context, level + 1),
            *self._flush_text(compile_context, level + 1, rstrip=True),
        ] or [indent_code('pass', level + 1)])
        return code

    def _compile_directive_foreach(self, el, compile_context, level):
        """Compile `t-foreach` expressions into a python code as a list of
        strings.

        `t-as` is used to define the key name.
        `t-foreach` compiled value can be an iterable, an dictionary or a
        number.

        The code will contain loop `for` that wrap the rest of the compiled
        code of this element.
        Some key into values dictionary are create automatically:
            *_size, *_index, *_value, *_first, *_last, *_odd, *_even, *_parity
        """
        expr_foreach = el.attrib.pop('t-foreach')
        expr_as = el.attrib.pop('t-as')

        if not expr_as:
            raise KeyError('t-as')

        if not VARNAME_REGEXP.match(expr_as):
            raise ValueError(f'The varname {expr_as!r} can only contain alphanumeric characters and underscores.')

        if el.tag.lower() == 't':
            self._rstrip_text(compile_context)

        code = self._flush_text(compile_context, level)

        content_foreach = (
            self._compile_directives(el, compile_context, level + 1) +
            self._flush_text(compile_context, level + 1, rstrip=True))

        t_foreach = compile_context['make_name']('t_foreach')
        size = compile_context['make_name']('size')
        has_value = compile_context['make_name']('has_value')

        if expr_foreach.isdigit():
            code.append(indent_code(f"""
                values[{expr_as + '_size'!r}] = {size} = {int(expr_foreach)}
                {t_foreach} = range({size})
                {has_value} = False
            """, level))
        else:
            code.append(indent_code(f"""
                {t_foreach} = {self._compile_expr(expr_foreach)} or []
                if isinstance({t_foreach}, Sized):
                    values[{expr_as + '_size'!r}] = {size} = len({t_foreach})
                elif ({t_foreach}).__class__ == int:
                    values[{expr_as + '_size'!r}] = {size} = {t_foreach}
                    {t_foreach} = range({size})
                else:
                    {size} = None
                {has_value} = False
                if isinstance({t_foreach}, Mapping):
                    {t_foreach} = {t_foreach}.items()
                    {has_value} = True
            """, level))

        code.append(indent_code(f"""
                for index, item in enumerate({t_foreach}):
                    values[{expr_as + '_index'!r}] = index
                    if {has_value}:
                        values[{expr_as!r}], values[{expr_as + '_value'!r}] = item
                    else:
                        values[{expr_as!r}] = values[{expr_as + '_value'!r}] = item
                    values[{expr_as + '_first'!r}] = values[{expr_as + '_index'!r}] == 0
                    if {size} is not None:
                        values[{expr_as + '_last'!r}] = index + 1 == {size}
                    values[{expr_as + '_odd'!r}] = index % 2
                    values[{expr_as + '_even'!r}] = not values[{expr_as + '_odd'!r}]
                    values[{expr_as + '_parity'!r}] = 'odd' if values[{expr_as + '_odd'!r}] else 'even'
            """, level))

        code.extend(content_foreach or indent_code('continue', level + 1))

        return code

    def _compile_directive_as(self, el, compile_context, level):
        """Compile `t-as` expressions into a python code as a list of strings.

        This method only check if this attributes is on the same node of a
         `t-foreach` attribute.
        """
        if 't-foreach' not in el.attrib:
            raise SyntaxError("t-as must be on the same node of t-foreach")
        return []

    def _compile_directive_out(self, el, compile_context, level):
        """Compile `t-out` expressions into a python code as a list of
        strings.

        The code will contain evalution and rendering of the compiled value. If
        the compiled value is None or False, the tag is not added to the render
        (Except if the widget forces rendering or there is default content).
        (eg: `<t t-out="my_value">Default content if falsy</t>`)

        The output can have some rendering option with `t-options-widget` or
        `t-options={'widget': ...}. At rendering time, The compiled code will
        call ``_get_widget`` method or ``_get_field`` method for `t-field`.

        A `t-field` will necessarily be linked to the value of a record field
        (eg: `<span t-field="record.field_name"/>`), a t-out` can be applied
        to any value (eg: `<span t-out="10" t-options-widget="'float'"/>`).
        """
        ttype = 't-out'
        expr = el.attrib.pop('t-out', None)
        if expr is None:
            ttype = 't-field'
            expr = el.attrib.pop('t-field', None)
            if expr is None:
                # deprecated use.
                ttype = 't-esc'
                expr = el.attrib.pop('t-esc', None)
                if expr is None:
                    ttype = 't-raw'
                    expr = el.attrib.pop('t-raw')

        code = self._flush_text(compile_context, level)

        code_options = el.attrib.pop('t-consumed-options', 'None')
        tag_open = (
            self._compile_directive(el, compile_context, 'tag-open', level + 1) +
            self._flush_text(compile_context, level + 1))
        tag_close = (
            self._compile_directive(el, compile_context, 'tag-close', level + 1) +
            self._flush_text(compile_context, level + 1))
        default_body = (
            self._compile_directive(el, compile_context, 'inner-content', level + 1) +
            self._flush_text(compile_context, level + 1))

        # The generated code will set the values of the content, attrs (used to
        # output attributes) and the force_display (if the widget or field
        # mark force_display as True, the tag will be inserted in the output
        # even the value of content is None and without default value)

        if expr == T_CALL_SLOT and code_options != 'True':
            code.append(indent_code("if True:", level))
            code.extend(tag_open)
            code.append(indent_code(f"yield from values.get({T_CALL_SLOT}, [])", level + 1))
            code.extend(tag_close)
            return code
        elif ttype == 't-field':
            record, field_name = expr.rsplit('.', 1)
            code.append(indent_code(f"""
                field_attrs, content, force_display = self._get_field({self._compile_expr(record, raise_on_missing=True)}, {field_name!r}, {expr!r}, {el.tag!r}, values.pop('__qweb_options__', {{}}), values)
                if values.get('__qweb_attrs__') is None:
                    values['__qweb_attrs__'] = field_attrs
                else:
                    values['__qweb_attrs__'].update(field_attrs)
                if content is not None and content is not False:
                    content = self._compile_to_str(content)
                """, level))
            force_display_dependent = True
        else:
            if expr == T_CALL_SLOT:
                code.append(indent_code(f"content = Markup(''.join(values.get({T_CALL_SLOT}, [])))", level))
            else:
                code.append(indent_code(f"content = {self._compile_expr(expr)}", level))

            if code_options == 'True':
                code.append(indent_code(f"""
                    widget_attrs, content, force_display = self._get_widget(content, {expr!r}, {el.tag!r}, values.pop('__qweb_options__', {{}}), values)
                    if values.get('__qweb_attrs__') is None:
                        values['__qweb_attrs__'] = widget_attrs
                    else:
                        values['__qweb_attrs__'].update(widget_attrs)
                    content = self._compile_to_str(content)
                    """, level))
                force_display_dependent = True
            else:
                force_display_dependent = False

            if ttype == 't-raw':
                # deprecated use.
                code.append(indent_code("""
                    if content is not None and content is not False:
                        content = Markup(content)
                """, level))

        # The generated code will create the output tag with all attribute.
        # If the value is not falsy or if there is default content or if it's
        # in force_display mode, the tag is add into the output.

        el.attrib.pop('t-tag', None) # code generating the output is done here

        # generate code to display the tag if the value is not Falsy

        code.append(indent_code("if content is not None and content is not False:", level))
        code.extend(tag_open)
        # Use str to avoid the escaping of the other html content because the
        # yield generator MarkupSafe values will be join into an string in
        # `_render`.
        code.append(indent_code("yield str(escape(content))", level + 1))
        code.extend(tag_close)

        # generate code to display the tag with default content if the value is
        # Falsy

        if default_body or compile_context['_text_concat']:
            _text_concat = list(compile_context['_text_concat'])
            compile_context['_text_concat'].clear()
            code.append(indent_code("else:", level))
            code.extend(tag_open)
            code.extend(default_body)
            compile_context['_text_concat'].extend(_text_concat)
            code.extend(tag_close)
        elif force_display_dependent:

            # generate code to display the tag if it's the force_diplay mode.

            if tag_open + tag_close:
                code.append(indent_code("elif force_display:", level))
                code.extend(tag_open + tag_close)

            code.append(indent_code("""else: values.pop('__qweb_attrs__', None)""", level))

        return code

    def _compile_directive_esc(self, el, compile_context, level):
        # deprecated use.
        if compile_context.get('dev_mode'):
            _logger.warning(
                "Found deprecated directive @t-esc=%r in template %r. Replace by @t-out",
                el.get('t-esc'),
                compile_context.get('ref', '<unknown>'),
            )
        return self._compile_directive_out(el, compile_context, level)

    def _compile_directive_raw(self, el, compile_context, level):
        # deprecated use.
        _logger.warning(
            "Found deprecated directive @t-raw=%r in template %r. Replace by "
            "@t-out, and explicitely wrap content in `Markup` if "
            "necessary (which likely is not the case)",
            el.get('t-raw'),
            compile_context.get('ref', '<unknown>'),
        )
        return self._compile_directive_out(el, compile_context, level)

    def _compile_directive_field(self, el, compile_context, level):
        """Compile `t-field` expressions into a python code as a list of
        strings.

        The compiled code will call ``_get_field`` method at rendering time
        using the type of value supplied by the field. This behavior can be
        changed with `t-options-widget` or `t-options={'widget': ...}.

        The code will contain evalution and rendering of the compiled value
        value from the record field. If the compiled value is None or False,
        the tag is not added to the render
        (Except if the widget forces rendering or there is default content.).
        """
        tagName = el.tag
        assert tagName not in ("table", "tbody", "thead", "tfoot", "tr", "td",
                                 "li", "ul", "ol", "dl", "dt", "dd"),\
            "QWeb widgets do not work correctly on %r elements" % tagName
        assert tagName != 't',\
            "t-field can not be used on a t element, provide an actual HTML node"
        assert "." in el.get('t-field'),\
            "t-field must have at least a dot like 'record.field_name'"

        return self._compile_directive_out(el, compile_context, level)

    def _compile_directive_call(self, el, compile_context, level):
        """Compile `t-call` expressions into a python code as a list of
        strings.

        `t-call` allow formating string dynamic at rendering time.
        Can use `t-options` used to call and render the sub-template at
        rendering time.
        The sub-template is called with a copy of the rendering values
        dictionary. The dictionary contains the key 0 coming from the
        compilation of the contents of this element

        The code will contain the call of the template and a function from the
        compilation of the content of this element.
        """
        expr = el.attrib.pop('t-call')

        if el.attrib.get('t-call-options'): # retro-compatibility
            el.attrib.set('t-options', el.attrib.pop('t-call-options'))

        nsmap = compile_context.get('nsmap')

        code = self._flush_text(compile_context, level, rstrip=el.tag.lower() == 't')

        # options
        el.attrib.pop('t-consumed-options', None)
        code.append(indent_code("t_call_options = values.pop('__qweb_options__', {})", level))
        if nsmap:
            # update this dict with the current nsmap so that the callee know
            # if he outputting the xmlns attributes is relevenat or not
            nsmap = []
            for key, value in compile_context['nsmap'].items():
                if isinstance(key, str):
                    nsmap.append(f'{key!r}:{value!r}')
                else:
                    nsmap.append(f'None:{value!r}')
            code.append(indent_code(f"t_call_options.update(nsmap={{{', '.join(nsmap)}}})", level))

        # values (t-out="0" from content and variables from t-set)
        def_name = compile_context['make_name']('t_call')

        # values from content (t-out="0" and t-set inside the content)
        code_content = [f"def {def_name}(self, values):"]
        code_content.extend(self._compile_directive(el, compile_context, 'inner-content', 1))
        self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function
        code_content.extend(self._flush_text(compile_context, 1, rstrip=True))
        compile_context['template_functions'][def_name] = code_content

        code.append(indent_code(f"""
            t_call_values = values.copy()
            t_call_values[{T_CALL_SLOT}] = list({def_name}(self, t_call_values))
            """, level))

        template = self._compile_format(expr)

        # call
        code.append(indent_code(f"""
            irQweb = self.with_context(**t_call_options)
            template = {template}
            if template.isnumeric():
                template = int(template)
            t_call_template_functions, def_name = irQweb._compile(template)
            render_template = t_call_template_functions[def_name]
            yield from render_template(irQweb, t_call_values)
            """, level))

        return code

    def _compile_directive_lang(self, el, compile_context, level):
        if 't-call' not in el.attrib:
            raise SyntaxError("t-lang is an alias of t-options-lang but only available on the same node of t-call")
        el.attrib['t-options-lang'] = el.attrib.pop('t-lang')
        return self._compile_node(el, compile_context, level)

    def _compile_directive_call_assets(self, el, compile_context, level):
        """ This special 't-call-assets' tag can be used in order to aggregate/minify javascript and css assets"""
        if len(el) > 0:
            raise SyntaxError("t-call-assets cannot contain children nodes")

        code = self._flush_text(compile_context, level)
        xmlid = el.attrib.pop('t-call-assets')
        css = self._compile_bool(el.attrib.pop('t-css', True))
        js = self._compile_bool(el.attrib.pop('t-js', True))
        # async_load support was removed
        defer_load = self._compile_bool(el.attrib.pop('defer_load', False))
        lazy_load = self._compile_bool(el.attrib.pop('lazy_load', False))
        media = el.attrib.pop('media', False)
        code.append(indent_code(f"""
            t_call_assets_nodes = self._get_asset_nodes(
                {xmlid!r},
                css={css},
                js={js},
                debug=values.get("debug"),
                defer_load={defer_load},
                lazy_load={lazy_load},
                media={media!r},
            )
        """.strip(), level))

        code.append(indent_code("""
            for index, (tagName, asset_attrs) in enumerate(t_call_assets_nodes):
                if index:
                    yield '\\n        '
                yield '<'
                yield tagName

                attrs = self._post_processing_att(tagName, asset_attrs)
                for name, value in attrs.items():
                    if value or isinstance(value, str):
                        yield f' {escape(str(name))}="{escape(str(value))}"'

                if tagName in VOID_ELEMENTS:
                    yield '/>'
                else:
                    yield '>'
                    yield '</'
                    yield tagName
                    yield '>'
                """, level))

        return code

    def _compile_directive_cache(self, el, compile_context, level):
        """Compile the `t-cache` tuple expression into a key cache.

        The `t-cache` directive allows you to keep the rendered result
        of a template part. The supplied key must be a tuple. This tuple
        can contain recordset in this case the zone will be invalidated
        each time the write_date of these records changes.
        The values are scoped into the `t-cache` and are not available
        outside.
        see: `t-nocache`
        """
        expr = el.attrib.pop('t-cache')
        code = self._flush_text(compile_context, level)

        def_name = compile_context['make_name']('t_cache')

        # Generate the content function
        def_code = [indent_code(f"""def {def_name}(self, values):""", 0)]
        def_content = self._compile_directives(el, compile_context, 1)
        if def_content and not compile_context['_text_concat']:
            self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function
        def_code.extend(def_content)
        def_code.extend(self._flush_text(compile_context, 1))
        compile_context['template_functions'][def_name] = def_code

        # Get the dynamic key for the cache and load the content.
        # The t-nocache yield a tuple (ref, function name) instead of a
        # When reading tuple coming from t-nocache, we check if the
        # method is already known otherwise the corresponding template
        # and its functions are loaded.
        code.append(indent_code(f"""
            template_cache_key = {self._compile_expr(expr)} if not self.env.context.get('is_t_cache_disabled') else None
            cache_key = self._get_cache_key(template_cache_key) if template_cache_key else None
            uniq_cache_key = cache_key and ({str(self.env.context['__qweb_base_key_cache'])!r}, '{def_name}_cache', cache_key)
            loaded_values = values['__qweb_loaded_values']
            def {def_name}_cache():
                content = []
                text = []
                for item in {def_name}(self, {{**values, '__qweb_in_cache': True}}):
                    if isinstance(item, str):
                        text.append(item)
                    else:
                        content.append(''.join(text))
                        content.append(item)
                        text = []
                if text:
                    content.append(''.join(text))
                return content
            cache_content = self._load_values(uniq_cache_key, {def_name}_cache, loaded_values)
            if values.get('__qweb_in_cache'):
                yield from cache_content
            else:
                for item in cache_content:
                    if isinstance(item, str):
                        yield item
                    else:
                        ref, function_name, cached_values = item
                        t_nocache_function = loaded_values.get(function_name)
                        if not t_nocache_function:
                            t_call_template_functions, def_name = self._compile(ref)
                            t_nocache_function = t_call_template_functions[function_name]

                        nocache_values = values['__qweb_root_values'].copy()
                        nocache_values.update(cached_values)
                        yield ''.join(t_nocache_function(self, nocache_values))
            """, level))

        return code

    def _compile_directive_nocache(self, el, compile_context, level):
        """
        The `t-nocache` directive makes it possible to force rendering
        of a part even if it is in a `t-cache`. The values available in
        the `t-nocache` are the one provided when calling the template
        (and therefore ignores any t-set that could have been done).

        The `t-nocache-*` are the values whose result of the
        expression will be cached and added to the root's values when
        rendering the no cache part. Only primitive types can be cached.

        see: `t-cache`
        """
        if 't-nocache' not in el.attrib:
            raise SyntaxError("t-nocache-* must be on the same node as t-nocache")

        el.attrib.pop('t-nocache')
        code = self._flush_text(compile_context, level)

        # t-nocache-* will generate the values to put in cache
        # must cosume this attributes before generate the cached content.
        code_cache_values = []
        for key in list(el.attrib):
            if key.startswith('t-nocache-'):
                expr = el.attrib.pop(key)
                varname = key[10:]
                if not VARNAME_REGEXP.match(varname):
                    raise ValueError(f'The varname {varname!r} can only contain alphanumeric characters and underscores.')
                code_cache_values.append(indent_code(f"""
                    cached_value = {self._compile_expr(expr)}
                    if cached_value is not None and not isinstance(cached_value, (str, int, float, bool)):
                        raise ValueError(f'''The value type of {key!r} cannot be cached: {{cached_value!r}}''')
                    cached_values[{varname!r}] = cached_value
                """, level + 1))

        # generate the cached content method
        def_name = compile_context['make_name']('t_nocache')
        def_code = [f"def {def_name}(self, values):"]
        def_code.append(indent_code("try:", 1))
        def_content = self._compile_directives(el, compile_context, 2)
        if def_content and not compile_context['_text_concat']:
            self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function
        def_code.extend(def_content)
        def_code.extend(self._flush_text(compile_context, 2))
        def_code.append(indent_code(f"""
                except QWebException:
                    raise
                except Exception as e:
                    raise QWebException("Error while render the template",
                        self, template, ref={compile_context['ref']!r}, code=code) from e
            """, 1))
        compile_context['template_functions'][def_name] = def_code

        # if the nocache is inside a cache return a tuple with the method name and the cached values
        code.append(indent_code("""
            if values.get('__qweb_in_cache'):
                cached_values = {}
            """, level))
        code.extend(code_cache_values)
        code.append(indent_code(f"yield ({compile_context['template']!r}, {def_name!r}, cached_values)", level+1))
        # else render the content
        code.append(indent_code(f"""
            else:
                yield from {def_name}(self, values)
            """, level))

        return code

    # methods called by the compiled function at rendering time.

    def _debug_trace(self, debugger, values):
        """Method called at running time to load debugger."""
        if not debugger:
            breakpoint()
        elif debugger in SUPPORTED_DEBUGGER:
            warnings.warn(
                "Using t-debug with an explicit debugger is deprecated "
                "since Odoo 17.0, keep the value empty and configure the "
                "``breakpoint`` builtin instead.",
                category=DeprecationWarning,
                stacklevel=2,
            )
            __import__(debugger).set_trace()
        else:
            raise ValueError(f"unsupported t-debug value: {debugger}")

    def _post_processing_att(self, tagName, atts):
        """ Method called at compile time for the static node and called at
            runing time for the dynamic attributes.

            This method may be overwrited to filter or modify the attributes
            (during compilation for static node or after they compilation in
            the case of dynamic elements).

            @returns dict
        """
        return atts

    def _get_field(self, record, field_name, expression, tagName, field_options, values):
        """Method called at compile time to return the field value.

        :returns: tuple:
            * dict: attributes
            * string or None: content
            * boolean: force_display display the tag if the content and default_content are None
        """
        field = record._fields[field_name]

        # adds generic field options
        field_options['tagName'] = tagName
        field_options['expression'] = expression
        field_options['type'] = field_options.get('widget', field.type)
        inherit_branding = (
                self.env.context['inherit_branding']
                if 'inherit_branding' in self.env.context
                else self.env.context.get('inherit_branding_auto') and record.check_access_rights('write', False))
        field_options['inherit_branding'] = inherit_branding
        translate = self.env.context.get('edit_translations') and values.get('translatable') and field.translate
        field_options['translate'] = translate

        # field converter
        model = 'ir.qweb.field.' + field_options['type']
        converter = self.env[model] if model in self.env else self.env['ir.qweb.field']

        # get content (the return values from fields are considered to be markup safe)
        content = converter.record_to_html(record, field_name, field_options)
        attributes = converter.attributes(record, field_name, field_options, values)

        return (attributes, content, inherit_branding or translate)

    def _get_widget(self, value, expression, tagName, field_options, values):
        """Method called at compile time to return the widget value.

        :returns: tuple:
            * dict: attributes
            * string or None: content
            * boolean: force_display display the tag if the content and default_content are None
        """
        field_options['type'] = field_options['widget']
        field_options['tagName'] = tagName
        field_options['expression'] = expression
        inherit_branding = self.env.context.get('inherit_branding')
        field_options['inherit_branding'] = inherit_branding

        # field converter
        model = 'ir.qweb.field.' + field_options['type']
        converter = self.env[model] if model in self.env else self.env['ir.qweb.field']

        # get content (the return values from widget are considered to be markup safe)
        content = converter.value_to_html(value, field_options)
        attributes = {}
        attributes['data-oe-type'] = field_options['type']
        attributes['data-oe-expression'] = field_options['expression']

        return (attributes, content, inherit_branding)

    def _get_asset_nodes(self, bundle, css=True, js=True, debug=False, defer_load=False, lazy_load=False, media=None):
        """Generates asset nodes.
        If debug=assets, the assets will be regenerated when a file which composes them has been modified.
        Else, the assets will be generated only once and then stored in cache.
        """
        media = css and media or None
        links = self._get_asset_links(bundle, css=css, js=js, debug=debug)
        return self._links_to_nodes(links, defer_load=defer_load, lazy_load=lazy_load, media=media)

    def _get_asset_links(self, bundle, css=True, js=True, debug=None):
        """Generates asset nodes.
        If debug=assets, the assets will be regenerated when a file which composes them has been modified.
        Else, the assets will be generated only once and then stored in cache.
        """
        rtl = self.env['res.lang'].sudo()._lang_get_direction(self.env.context.get('lang') or self.env.user.lang) == 'rtl'
        assets_params = self.env['ir.asset']._get_asset_params() # website_id
        debug_assets = debug and 'assets' in debug

        if debug_assets:
            return self._generate_asset_links(bundle, css=css, js=js, debug_assets=True, assets_params=assets_params, rtl=rtl)
        else:
            return self._generate_asset_links_cache(bundle, css=css, js=js, assets_params=assets_params, rtl=rtl)

    # qweb cache feature

    def _get_cache_key(self, cache_key):
        """
            Convert the template cache key item into a hashable key.
            :param cache_key: tuple
            :returns: tuple of hashable items
        """
        if not isinstance(cache_key, (tuple, list)):
            cache_key = (cache_key,)
        keys = []
        for item in cache_key:
            try:
                # use try catch instead of isinstance to detect lazy values
                keys.append(item._name)
                keys.append(tuple(item.ids))
                dates = item.mapped('write_date')
                if dates:
                    keys.append(max(dates).timestamp())
            except AttributeError:
                keys.append(repr(item))
        return tuple(keys)

    def _load_values(self, cache_key, get_value, loaded_values=None):
        """ generate value from the function if the result is not cached. """
        if not cache_key:
            return get_value()
        value = loaded_values and loaded_values.get(cache_key)
        if not value:
            value = self._get_cached_values(cache_key, get_value)
        if loaded_values is not None:
            loaded_values[cache_key] = value
        return value

    # The cache does not need to be invalidated if the 'base_key_cache'
    # in '_compile' method contains the write_date of all inherited views.
    @tools.conditional(
        'xml' not in tools.config['dev_mode'],
        tools.ormcache('cache_key', cache='templates.cached_values'),
    )
    def _get_cached_values(self, cache_key, get_value):
        """ generate value from the function if the result is not cached. """
        return get_value()

    # other methods used for the asset bundles
    @tools.conditional(
        # in non-xml-debug mode we want assets to be cached forever, and the admin can force a cache clear
        # by restarting the server after updating the source code (or using the "Clear server cache" in debug tools)
        'xml' not in tools.config['dev_mode'],
        tools.ormcache('bundle', 'css', 'js', 'tuple(sorted(assets_params.items()))', 'rtl', cache='assets'),
    )
    def _generate_asset_links_cache(self, bundle, css=True, js=True, assets_params=None, rtl=False):
        return self._generate_asset_links(bundle, css, js, False, assets_params, rtl)

    def _get_asset_content(self, bundle, assets_params=None):
        if assets_params is None:
            assets_params = self.env['ir.asset']._get_asset_params()  # website_id
        asset_paths = self.env['ir.asset']._get_asset_paths(bundle=bundle, assets_params=assets_params)
        files = []
        external_asset = []
        for path, full_path, _bundle, last_modified in asset_paths:
            if full_path is not EXTERNAL_ASSET:
                files.append({
                    'url': path,
                    'filename': full_path,
                    'content': '',
                    'last_modified': last_modified,
                })
            else:
                external_asset.append(path)
        return (files, external_asset)

    def _get_asset_bundle(self, bundle_name, css=True, js=True, debug_assets=False, rtl=False, assets_params=None):
        if assets_params is None:
            assets_params = self.env['ir.asset']._get_asset_params()
        files, external_assets = self._get_asset_content(bundle_name, assets_params)
        return AssetsBundle(bundle_name, files, external_assets, env=self.env, css=css, js=js, debug_assets=debug_assets, rtl=rtl, assets_params=assets_params)

    def _links_to_nodes(self, paths, defer_load=False, lazy_load=False, media=None):
        return [self._link_to_node(path, defer_load=defer_load, lazy_load=lazy_load, media=media) for path in paths]

    def _link_to_node(self, path, defer_load=False, lazy_load=False, media=None):
        ext = path.rsplit('.', maxsplit=1)[-1] if path else 'js'
        is_js = ext in SCRIPT_EXTENSIONS
        is_xml = ext in TEMPLATE_EXTENSIONS
        is_css = ext in STYLE_EXTENSIONS
        if not is_js and not is_xml and not is_css:
            return

        if is_js:
            is_asset_bundle = path and path.startswith('/web/assets/')
            attributes = {
                'type': 'text/javascript',
            }

            if (defer_load or lazy_load):
                attributes['defer'] = 'defer'
            if path:
                if lazy_load:
                    attributes['data-src'] = path
                else:
                    attributes['src'] = path

            if is_asset_bundle:
                attributes['onerror'] = "__odooAssetError=1"

            return ('script', attributes)


        if is_css:
            attributes = {
                'type': f'text/{ext}',  # we don't really expect to have anything else than pure css here
                'rel': 'stylesheet',
                'href': path,
                'media': media,
            }
            return ('link', attributes)

        if is_xml:
            attributes = {
                'type': 'text/xml',
                'async': 'async',
                'rel': 'prefetch',
                'data-src': path,
                }
            return ('script', attributes)

    def _generate_asset_links(self, bundle, css=True, js=True, debug_assets=False, assets_params=None, rtl=False):
        asset_bundle = self._get_asset_bundle(bundle, css=css, js=js, debug_assets=debug_assets, rtl=rtl, assets_params=assets_params)
        return asset_bundle.get_links()

    def _get_asset_link_urls(self, bundle, debug=False):
        asset_nodes = self._get_asset_nodes(bundle, js=False, debug=debug)
        return [node[1]['href'] for node in asset_nodes if node[0] == 'link']

    def _pregenerate_assets_bundles(self):
        """
        Pregenerates all assets that may be used in web pages to speedup first loading.
        This may is mainly usefull for tests.

        The current version is looking for all t-call-assets in view to generate the minimal
        set of bundles to generate.

        Current version only generate assets without extra, not taking care of rtl.
        """
        _logger.runbot('Pregenerating assets bundles')

        js_bundles, css_bundles = self._get_bundles_to_pregenarate()

        links = []
        start = time.time()
        for bundle in sorted(js_bundles):
            links += self._get_asset_bundle(bundle, css=False, js=True).js()
        _logger.info('JS Assets bundles generated in %s seconds', time.time()-start)
        start = time.time()
        for bundle in sorted(css_bundles):
            links += self._get_asset_bundle(bundle, css=True, js=False).css()
        _logger.info('CSS Assets bundles generated in %s seconds', time.time()-start)
        return links

    def _get_bundles_to_pregenarate(self):
        """
        Returns the list of bundles to pregenerate.
        """

        views = self.env['ir.ui.view'].search([('type', '=', 'qweb'), ('arch_db', 'like', 't-call-assets')])
        js_bundles = set()
        css_bundles = set()
        for view in views:
            for call_asset in etree.fromstring(view.arch_db).xpath("//*[@t-call-assets]"):
                asset = call_asset.get('t-call-assets')
                js = str2bool(call_asset.get('t-js', 'True'))
                css = str2bool(call_asset.get('t-css', 'True'))
                if js:
                    js_bundles.add(asset)
                if css:
                    css_bundles.add(asset)
        return (js_bundles, css_bundles)

def render(template_name, values, load, **options):
    """ Rendering of a qweb template without database and outside the registry.
    (Widget, field, or asset rendering is not implemented.)
    :param (string|int) template_name: template identifier
    :param dict values: template values to be used for rendering
    :param def load: function like `load(template_name)` which returns an etree
        from the given template name (from initial rendering or template
        `t-call`).
    :param options: used to compile the template
    :returns: bytes marked as markup-safe (decode to :class:`markupsafe.Markup`
                instead of `str`)
    :rtype: MarkupSafe
    """
    class MockPool:
        db_name = None
        _Registry__caches = {cache_name: LRU(cache_size) for cache_name, cache_size in registry._REGISTRY_CACHES.items()}
        _Registry__caches_groups = {}
        for cache_name, cache in _Registry__caches.items():
            _Registry__caches_groups.setdefault(cache_name.split('.')[0], []).append(cache)


    class MockIrQWeb(IrQWeb):
        _register = False               # not visible in real registry

        pool = MockPool()

        def _load(self, ref):
            """
            Load the template referenced by ``ref``.

            :returns: The loaded template (as string or etree) and its
                identifier
            :rtype: Tuple[Union[etree, str], Optional[str, int]]
            """
            return self.env.context['load'](ref)

        def _prepare_environment(self, values):
            values['true'] = True
            values['false'] = False
            return self.with_context(is_t_cache_disabled=True, __qweb_loaded_values={})

        def _get_field(self, *args):
            raise NotImplementedError("Fields are not allowed in this rendering mode. Please use \"env['ir.qweb']._render\" method")

        def _get_widget(self, *args):
            raise NotImplementedError("Widgets are not allowed in this rendering mode. Please use \"env['ir.qweb']._render\" method")

        def _get_asset_nodes(self, *args):
            raise NotImplementedError("Assets are not allowed in this rendering mode. Please use \"env['ir.qweb']._render\" method")

    class MockEnv(dict):
        def __init__(self):
            super().__init__()
            self.context = {}

        def __call__(self, cr=None, user=None, context=None, su=None):
            """ Return an mocked environment based and update the sent context.
                Allow to use `ir_qweb.with_context` with sand boxed qweb.
            """
            env = MockEnv()
            env.context.update(self.context if context is None else context)
            return env

    renderer = MockIrQWeb(MockEnv(), tuple(), tuple())
    return renderer._render(template_name, values, load=load, minimal_qcontext=True, **options)

```

  File: models/ir_qweb_fields.py
  Content:
```
# -*- coding: utf-8 -*-
import base64
import binascii
from datetime import time
import logging
import re
from io import BytesIO

import babel
import babel.dates
from markupsafe import Markup, escape
from PIL import Image
from lxml import etree, html

from odoo import api, fields, models, _, _lt, tools
from odoo.tools import posix_to_ldml, float_utils, format_date, format_duration, pycompat
from odoo.tools.mail import safe_attrs
from odoo.tools.misc import get_lang, babel_locale_parse
from odoo.tools.mimetypes import guess_mimetype

_logger = logging.getLogger(__name__)


def nl2br(string):
    """ Converts newlines to HTML linebreaks in ``string``. returns
    the unicode result

    :param str string:
    :rtype: unicode
    """
    return pycompat.to_text(string).replace('\n', Markup('<br>\n'))


def nl2br_enclose(string, enclosure_tag='div'):
    """ Like nl2br, but returns enclosed Markup allowing to better manipulate
    trusted and untrusted content. New lines added by use are trusted, other
    content is escaped. """
    converted = nl2br(escape(string))
    return Markup(f'<{enclosure_tag}>{converted}</{enclosure_tag}>')

#--------------------------------------------------------------------
# QWeb Fields converters
#--------------------------------------------------------------------

class FieldConverter(models.AbstractModel):
    """ Used to convert a t-field specification into an output HTML field.

    :meth:`~.to_html` is the entry point of this conversion from QWeb, it:

    * converts the record value to html using :meth:`~.record_to_html`
    * generates the metadata attributes (``data-oe-``) to set on the root
      result node
    * generates the root result node itself through :meth:`~.render_element`
    """
    _name = 'ir.qweb.field'
    _description = 'Qweb Field'

    @api.model
    def get_available_options(self):
        """
            Get the available option informations.

            Returns a dict of dict with:
            * key equal to the option key.
            * dict: type, params, name, description, default_value
            * type:
                'string'
                'integer'
                'float'
                'model' (e.g. 'res.partner')
                'array'
                'selection' (e.g. [key1, key2...])
        """
        return {}

    @api.model
    def attributes(self, record, field_name, options, values=None):
        """ attributes(record, field_name, field, options, values)

        Generates the metadata attributes (prefixed by ``data-oe-``) for the
        root node of the field conversion.

        The default attributes are:

        * ``model``, the name of the record's model
        * ``id`` the id of the record to which the field belongs
        * ``type`` the logical field type (widget, may not match the field's
          ``type``, may not be any Field subclass name)
        * ``translate``, a boolean flag (``0`` or ``1``) denoting whether the
          field is translatable
        * ``readonly``, has this attribute if the field is readonly
        * ``expression``, the original expression

        :returns: dict (attribute name, attribute value).
        """
        data = {}
        field = record._fields[field_name]

        if not options['inherit_branding'] and not options['translate']:
            return data

        data['data-oe-model'] = record._name
        data['data-oe-id'] = record.id
        data['data-oe-field'] = field.name
        data['data-oe-type'] = options.get('type')
        data['data-oe-expression'] = options.get('expression')
        if field.readonly:
            data['data-oe-readonly'] = 1
        return data

    @api.model
    def value_to_html(self, value, options):
        """ value_to_html(value, field, options=None)

        Converts a single value to its HTML version/output
        :rtype: unicode
        """
        return escape(pycompat.to_text(value))

    @api.model
    def record_to_html(self, record, field_name, options):
        """ record_to_html(record, field_name, options)

        Converts the specified field of the ``record`` to HTML

        :rtype: unicode
        """
        if not record:
            return False
        value = record.with_context(**self.env.context)[field_name]
        return False if value is False else self.value_to_html(value, options=options)

    @api.model
    def user_lang(self):
        """ user_lang()

        Fetches the res.lang record corresponding to the language code stored
        in the user's context.

        :returns: Model[res.lang]
        """
        return get_lang(self.env)


class IntegerConverter(models.AbstractModel):
    _name = 'ir.qweb.field.integer'
    _description = 'Qweb Field Integer'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(IntegerConverter, self).get_available_options()
        options.update(
            format_decimalized_number=dict(type='boolean', string=_('Decimalized number')),
            precision_digits=dict(type='integer', string=_('Precision Digits')),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        if options.get('format_decimalized_number'):
            return tools.format_decimalized_number(value, options.get('precision_digits', 1))
        return pycompat.to_text(self.user_lang().format('%d', value, grouping=True).replace(r'-', '-\N{ZERO WIDTH NO-BREAK SPACE}'))


class FloatConverter(models.AbstractModel):
    _name = 'ir.qweb.field.float'
    _description = 'Qweb Field Float'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(FloatConverter, self).get_available_options()
        options.update(
            precision=dict(type='integer', string=_('Rounding precision')),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        if 'decimal_precision' in options:
            precision = self.env['decimal.precision'].precision_get(options['decimal_precision'])
        else:
            precision = options['precision']

        if precision is None:
            fmt = '%f'
        else:
            value = float_utils.float_round(value, precision_digits=precision)
            fmt = '%.{precision}f'.format(precision=precision)

        formatted = self.user_lang().format(fmt, value, grouping=True).replace(r'-', '-\N{ZERO WIDTH NO-BREAK SPACE}')

        # %f does not strip trailing zeroes. %g does but its precision causes
        # it to switch to scientific notation starting at a million *and* to
        # strip decimals. So use %f and if no precision was specified manually
        # strip trailing 0.
        if precision is None:
            formatted = re.sub(r'(?:(0|\d+?)0+)$', r'\1', formatted)

        return pycompat.to_text(formatted)

    @api.model
    def record_to_html(self, record, field_name, options):
        if 'precision' not in options and 'decimal_precision' not in options:
            _, precision = record._fields[field_name].get_digits(record.env) or (None, None)
            options = dict(options, precision=precision)
        return super(FloatConverter, self).record_to_html(record, field_name, options)


class DateConverter(models.AbstractModel):
    _name = 'ir.qweb.field.date'
    _description = 'Qweb Field Date'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(DateConverter, self).get_available_options()
        options.update(
            format=dict(type='string', string=_('Date format'))
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        return format_date(self.env, value, date_format=options.get('format'))


class DateTimeConverter(models.AbstractModel):
    _name = 'ir.qweb.field.datetime'
    _description = 'Qweb Field Datetime'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(DateTimeConverter, self).get_available_options()
        options.update(
            format=dict(type='string', string=_('Pattern to format')),
            tz_name=dict(type='char', string=_('Optional timezone name')),
            time_only=dict(type='boolean', string=_('Display only the time')),
            hide_seconds=dict(type='boolean', string=_('Hide seconds')),
            date_only=dict(type='boolean', string=_('Display only the date')),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        if not value:
            return ''

        lang = self.user_lang()
        locale = babel_locale_parse(lang.code)
        format_func = babel.dates.format_datetime
        if isinstance(value, str):
            value = fields.Datetime.from_string(value)

        if options.get('tz_name'):
            self = self.with_context(tz=options['tz_name'])
            tzinfo = babel.dates.get_timezone(options['tz_name'])
        else:
            tzinfo = None

        value = fields.Datetime.context_timestamp(self, value)

        if 'format' in options:
            pattern = options['format']
        else:
            if options.get('time_only'):
                strftime_pattern = ("%s" % (lang.time_format))
            elif options.get('date_only'):
                strftime_pattern = ("%s" % (lang.date_format))
            else:
                strftime_pattern = ("%s %s" % (lang.date_format, lang.time_format))

            pattern = posix_to_ldml(strftime_pattern, locale=locale)

        if options.get('hide_seconds'):
            pattern = pattern.replace(":ss", "").replace(":s", "")

        if options.get('time_only'):
            format_func = babel.dates.format_time
            return pycompat.to_text(format_func(value, format=pattern, tzinfo=tzinfo, locale=locale))
        if options.get('date_only'):
            format_func = babel.dates.format_date
            return pycompat.to_text(format_func(value, format=pattern, locale=locale))

        return pycompat.to_text(format_func(value, format=pattern, tzinfo=tzinfo, locale=locale))


class TextConverter(models.AbstractModel):
    _name = 'ir.qweb.field.text'
    _description = 'Qweb Field Text'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        """
        Escapes the value and converts newlines to br. This is bullshit.
        """
        return nl2br(escape(value)) if value else ''


class SelectionConverter(models.AbstractModel):
    _name = 'ir.qweb.field.selection'
    _description = 'Qweb Field Selection'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(SelectionConverter, self).get_available_options()
        options.update(
            selection=dict(type='selection', string=_('Selection'), description=_('By default the widget uses the field information'), required=True)
        )
        options.update(
            selection=dict(type='json', string=_('Json'), description=_('By default the widget uses the field information'), required=True)
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        if not value:
            return ''
        return escape(pycompat.to_text(options['selection'][value]) or '')

    @api.model
    def record_to_html(self, record, field_name, options):
        if 'selection' not in options:
            options = dict(options, selection=dict(record._fields[field_name].get_description(self.env)['selection']))
        return super(SelectionConverter, self).record_to_html(record, field_name, options)


class ManyToOneConverter(models.AbstractModel):
    _name = 'ir.qweb.field.many2one'
    _description = 'Qweb Field Many to One'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        if not value:
            return False
        value = value.sudo().display_name
        if not value:
            return False
        return nl2br(escape(value))


class ManyToManyConverter(models.AbstractModel):
    _name = 'ir.qweb.field.many2many'
    _description = 'Qweb field many2many'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        if not value:
            return False
        text = ', '.join(value.sudo().mapped('display_name'))
        return nl2br(escape(text))


class HTMLConverter(models.AbstractModel):
    _name = 'ir.qweb.field.html'
    _description = 'Qweb Field HTML'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        irQweb = self.env['ir.qweb']
        # wrap value inside a body and parse it as HTML
        body = etree.fromstring("<body>%s</body>" % value, etree.HTMLParser(encoding='utf-8'))[0]
        # use pos processing for all nodes with attributes
        for element in body.iter():
            if element.attrib:
                attrib = dict(element.attrib)
                attrib = irQweb._post_processing_att(element.tag, attrib)
                element.attrib.clear()
                element.attrib.update(attrib)
        return Markup(etree.tostring(body, encoding='unicode', method='html')[6:-7])


class ImageConverter(models.AbstractModel):
    """ ``image`` widget rendering, inserts a data:uri-using image tag in the
    document. May be overridden by e.g. the website module to generate links
    instead.

    .. todo:: what happens if different output need different converters? e.g.
              reports may need embedded images or FS links whereas website
              needs website-aware
    """
    _name = 'ir.qweb.field.image'
    _description = 'Qweb Field Image'
    _inherit = 'ir.qweb.field'

    @api.model
    def _get_src_data_b64(self, value, options):
        try:
            img_b64 = base64.b64decode(value)
        except binascii.Error:
            raise ValueError("Invalid image content") from None

        if img_b64 and guess_mimetype(img_b64, '') == 'image/webp':
            return self.env["ir.qweb"]._get_converted_image_data_uri(value)

        try:
            image = Image.open(BytesIO(img_b64))
            image.verify()
        except IOError:
            raise ValueError("Non-image binary fields can not be converted to HTML") from None
        except: # image.verify() throws "suitable exceptions", I have no idea what they are
            raise ValueError("Invalid image content") from None

        return "data:%s;base64,%s" % (Image.MIME[image.format], value.decode('ascii'))

    @api.model
    def value_to_html(self, value, options):
        return Markup('<img src="%s">') % self._get_src_data_b64(value, options)

class ImageUrlConverter(models.AbstractModel):
    """ ``image_url`` widget rendering, inserts an image tag in the
    document.
    """
    _name = 'ir.qweb.field.image_url'
    _description = 'Qweb Field Image'
    _inherit = 'ir.qweb.field.image'

    @api.model
    def value_to_html(self, value, options):
        return Markup('<img src="%s">' % (value))

class MonetaryConverter(models.AbstractModel):
    """ ``monetary`` converter, has a mandatory option
    ``display_currency`` only if field is not of type Monetary.
    Otherwise, if we are in presence of a monetary field, the field definition must
    have a currency_field attribute set.

    The currency is used for formatting *and rounding* of the float value. It
    is assumed that the linked res_currency has a non-empty rounding value and
    res.currency's ``round`` method is used to perform rounding.

    .. note:: the monetary converter internally adds the qweb context to its
              options mapping, so that the context is available to callees.
              It's set under the ``_values`` key.
    """
    _name = 'ir.qweb.field.monetary'
    _description = 'Qweb Field Monetary'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(MonetaryConverter, self).get_available_options()
        options.update(
            from_currency=dict(type='model', params='res.currency', string=_('Original currency')),
            display_currency=dict(type='model', params='res.currency', string=_('Display currency'), required="value_to_html"),
            date=dict(type='date', string=_('Date'), description=_('Date used for the original currency (only used for t-esc). by default use the current date.')),
            company_id=dict(type='model', params='res.company', string=_('Company'), description=_('Company used for the original currency (only used for t-esc). By default use the user company')),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        display_currency = options['display_currency']

        if not isinstance(value, (int, float)):
            raise ValueError(_("The value send to monetary field is not a number."))

        # lang.format mandates a sprintf-style format. These formats are non-
        # minimal (they have a default fixed precision instead), and
        # lang.format will not set one by default. currency.round will not
        # provide one either. So we need to generate a precision value
        # (integer > 0) from the currency's rounding (a float generally < 1.0).
        fmt = "%.{0}f".format(options.get('decimal_places', display_currency.decimal_places))

        if options.get('from_currency'):
            date = options.get('date') or fields.Date.today()
            company_id = options.get('company_id')
            if company_id:
                company = self.env['res.company'].browse(company_id)
            else:
                company = self.env.company
            value = options['from_currency']._convert(value, display_currency, company, date)

        lang = self.user_lang()
        formatted_amount = lang.format(fmt, display_currency.round(value),
                                grouping=True, monetary=True).replace(r' ', '\N{NO-BREAK SPACE}').replace(r'-', '-\N{ZERO WIDTH NO-BREAK SPACE}')

        pre = post = ''
        if display_currency.position == 'before':
            pre = '{symbol}\N{NO-BREAK SPACE}'.format(symbol=display_currency.symbol or '')
        else:
            post = '\N{NO-BREAK SPACE}{symbol}'.format(symbol=display_currency.symbol or '')

        if options.get('label_price') and lang.decimal_point in formatted_amount:
            sep = lang.decimal_point
            integer_part, decimal_part = formatted_amount.split(sep)
            integer_part += sep
            return Markup('{pre}<span class="oe_currency_value">{0}</span><span class="oe_currency_value" style="font-size:0.5em">{1}</span>{post}').format(integer_part, decimal_part, pre=pre, post=post)

        return Markup('{pre}<span class="oe_currency_value">{0}</span>{post}').format(formatted_amount, pre=pre, post=post)

    @api.model
    def record_to_html(self, record, field_name, options):
        options = dict(options)
        #currency should be specified by monetary field
        field = record._fields[field_name]

        if not options.get('display_currency') and field.type == 'monetary' and field.get_currency_field(record):
            options['display_currency'] = record[field.get_currency_field(record)]
        if not options.get('display_currency'):
            # search on the model if they are a res.currency field to set as default
            fields = record._fields.items()
            currency_fields = [k for k, v in fields if v.type == 'many2one' and v.comodel_name == 'res.currency']
            if currency_fields:
                options['display_currency'] = record[currency_fields[0]]
        if 'date' not in options:
            options['date'] = record._context.get('date')
        if 'company_id' not in options:
            options['company_id'] = record._context.get('company_id')

        return super(MonetaryConverter, self).record_to_html(record, field_name, options)


TIMEDELTA_UNITS = (
    ('year',   _lt('year'),   3600 * 24 * 365),
    ('month',  _lt('month'),  3600 * 24 * 30),
    ('week',   _lt('week'),   3600 * 24 * 7),
    ('day',    _lt('day'),    3600 * 24),
    ('hour',   _lt('hour'),   3600),
    ('minute', _lt('minute'), 60),
    ('second', _lt('second'), 1)
)


class FloatTimeConverter(models.AbstractModel):
    """ ``float_time`` converter, to display integral or fractional values as
    human-readable time spans (e.g. 1.5 as "01:30").

    Can be used on any numerical field.
    """
    _name = 'ir.qweb.field.float_time'
    _description = 'Qweb Field Float Time'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        return format_duration(value)


class TimeConverter(models.AbstractModel):
    """ ``time`` converter, to display integer or fractional value as
    human-readable time (e.g. 1.5 as "1:30 AM"). The unit of this value
    is in hours.

    Can be used on any numerical field between: 0 <= value < 24
    """
    _name = 'ir.qweb.field.time'
    _description = 'QWeb Field Time'
    _inherit = 'ir.qweb.field'

    @api.model
    def value_to_html(self, value, options):
        if value < 0:
            raise ValueError(_("The value (%s) passed should be positive", value))
        hours, minutes = divmod(int(abs(value) * 60), 60)
        if hours > 23:
            raise ValueError(_("The hour must be between 0 and 23"))
        t = time(hour=hours, minute=minutes)

        locale = babel_locale_parse(self.user_lang().code)
        pattern = options.get('format', 'short')

        return babel.dates.format_time(t, format=pattern, tzinfo=None, locale=locale)


class DurationConverter(models.AbstractModel):
    """ ``duration`` converter, to display integral or fractional values as
    human-readable time spans (e.g. 1.5 as "1 hour 30 minutes").

    Can be used on any numerical field.

    Has an option ``unit`` which can be one of ``second``, ``minute``,
    ``hour``, ``day``, ``week`` or ``year``, used to interpret the numerical
    field value before converting it. By default use ``second``.

    Has an option ``round``. By default use ``second``.

    Has an option ``digital`` to display 01:00 instead of 1 hour

    Sub-second values will be ignored.
    """
    _name = 'ir.qweb.field.duration'
    _description = 'Qweb Field Duration'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(DurationConverter, self).get_available_options()
        unit = [(value, str(label)) for value, label, ratio in TIMEDELTA_UNITS]
        options.update(
            digital=dict(type="boolean", string=_('Digital formatting')),
            unit=dict(type="selection", params=unit, string=_('Date unit'), description=_('Date unit used for comparison and formatting'), default_value='second', required=True),
            round=dict(type="selection", params=unit, string=_('Rounding unit'), description=_("Date unit used for the rounding. The value must be smaller than 'hour' if you use the digital formatting."), default_value='second'),
            format=dict(
                type="selection",
                params=[
                    ('long', _('Long')),
                    ('short', _('Short')),
                    ('narrow', _('Narrow'))],
                string=_('Format'),
                description=_("Formatting: long, short, narrow (not used for digital)"),
                default_value='long'
            ),
            add_direction=dict(
                type="boolean",
                string=_("Add direction"),
                description=_("Add directional information (not used for digital)")
            ),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        units = {unit: duration for unit, label, duration in TIMEDELTA_UNITS}

        locale = babel_locale_parse(self.user_lang().code)
        factor = units[options.get('unit', 'second')]
        round_to = units[options.get('round', 'second')]

        if options.get('digital') and round_to > 3600:
            round_to = 3600

        r = round((value * factor) / round_to) * round_to

        sections = []
        sign = ''
        if value < 0:
            r = -r
            sign = '-'

        if options.get('digital'):
            for unit, label, secs_per_unit in TIMEDELTA_UNITS:
                if secs_per_unit > 3600:
                    continue
                v, r = divmod(r, secs_per_unit)
                if not v and (secs_per_unit > factor or secs_per_unit < round_to):
                    continue
                sections.append(u"%02.0f" % int(round(v)))
            return sign + u':'.join(sections)

        for unit, label, secs_per_unit in TIMEDELTA_UNITS:
            v, r = divmod(r, secs_per_unit)
            if not v:
                continue
            try:
                section = babel.dates.format_timedelta(
                    v*secs_per_unit,
                    granularity=round_to,
                    add_direction=options.get('add_direction'),
                    format=options.get('format', 'long'),
                    threshold=1,
                    locale=locale)
            except KeyError:
                # in case of wrong implementation of babel, try to fallback on en_US locale.
                # https://github.com/python-babel/babel/pull/827/files
                # Some bugs already fixed in 2.10 but ubuntu22 is 2.8
                localeUS = babel_locale_parse('en_US')
                section = babel.dates.format_timedelta(
                    v*secs_per_unit,
                    granularity=round_to,
                    add_direction=options.get('add_direction'),
                    format=options.get('format', 'long'),
                    threshold=1,
                    locale=localeUS)
            if section:
                sections.append(section)

        if sign:
            sections.insert(0, sign)
        return u' '.join(sections)


class RelativeDatetimeConverter(models.AbstractModel):
    _name = 'ir.qweb.field.relative'
    _description = 'Qweb Field Relative'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(RelativeDatetimeConverter, self).get_available_options()
        options.update(
            now=dict(type='datetime', string=_('Reference date'), description=_('Date to compare with the field value, by default use the current date.'))
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        locale = babel_locale_parse(self.user_lang().code)

        if isinstance(value, str):
            value = fields.Datetime.from_string(value)

        # value should be a naive datetime in UTC. So is fields.Datetime.now()
        reference = fields.Datetime.from_string(options['now'])

        return pycompat.to_text(babel.dates.format_timedelta(value - reference, add_direction=True, locale=locale))

    @api.model
    def record_to_html(self, record, field_name, options):
        if 'now' not in options:
            options = dict(options, now=record._fields[field_name].now())
        return super(RelativeDatetimeConverter, self).record_to_html(record, field_name, options)


class BarcodeConverter(models.AbstractModel):
    """ ``barcode`` widget rendering, inserts a data:uri-using image tag in the
    document. May be overridden by e.g. the website module to generate links
    instead.
    """
    _name = 'ir.qweb.field.barcode'
    _description = 'Qweb Field Barcode'
    _inherit = 'ir.qweb.field'

    @api.model
    def get_available_options(self):
        options = super(BarcodeConverter, self).get_available_options()
        options.update(
            symbology=dict(type='string', string=_('Barcode symbology'), description=_('Barcode type, eg: UPCA, EAN13, Code128'), default_value='Code128'),
            width=dict(type='integer', string=_('Width'), default_value=600),
            height=dict(type='integer', string=_('Height'), default_value=100),
            humanreadable=dict(type='integer', string=_('Human Readable'), default_value=0),
            quiet=dict(type='integer', string='Quiet', default_value=1),
            mask=dict(type='string', string='Mask', default_value='')
        )
        return options

    @api.model
    def value_to_html(self, value, options=None):
        if not value:
            return ''
        barcode_symbology = options.get('symbology', 'Code128')
        barcode = self.env['ir.actions.report'].barcode(
            barcode_symbology,
            value,
            **{key: value for key, value in options.items() if key in ['width', 'height', 'humanreadable', 'quiet', 'mask']})

        img_element = html.Element('img')
        for k, v in options.items():
            if k.startswith('img_') and k[4:] in safe_attrs:
                img_element.set(k[4:], v)
        if not img_element.get('alt'):
            img_element.set('alt', _('Barcode %s', value))
        img_element.set('src', 'data:image/png;base64,%s' % base64.b64encode(barcode).decode())
        return Markup(html.tostring(img_element, encoding='unicode'))


class Contact(models.AbstractModel):
    _name = 'ir.qweb.field.contact'
    _description = 'Qweb Field Contact'
    _inherit = 'ir.qweb.field.many2one'

    @api.model
    def get_available_options(self):
        options = super(Contact, self).get_available_options()
        contact_fields = [
            {'field_name': 'name', 'label': _('Name'), 'default': True},
            {'field_name': 'address', 'label': _('Address'), 'default': True},
            {'field_name': 'phone', 'label': _('Phone'), 'default': True},
            {'field_name': 'mobile', 'label': _('Mobile'), 'default': True},
            {'field_name': 'email', 'label': _('Email'), 'default': True},
            {'field_name': 'vat', 'label': _('VAT')},
        ]
        separator_params = dict(
            type='selection',
            selection=[[" ", _("Space")], [",", _("Comma")], ["-", _("Dash")], ["|", _("Vertical bar")], ["/", _("Slash")]],
            placeholder=_('Linebreak'),
        )
        options.update(
            fields=dict(type='array', params=dict(type='selection', params=contact_fields), string=_('Displayed fields'), description=_('List of contact fields to display in the widget'), default_value=[param.get('field_name') for param in contact_fields if param.get('default')]),
            separator=dict(type='selection', params=separator_params, string=_('Address separator'), description=_('Separator use to split the address from the display_name.'), default_value=False),
            no_marker=dict(type='boolean', string=_('Hide badges'), description=_("Don't display the font awesome marker")),
            no_tag_br=dict(type='boolean', string=_('Use comma'), description=_("Use comma instead of the <br> tag to display the address")),
            phone_icons=dict(type='boolean', string=_('Display phone icons'), description=_("Display the phone icons even if no_marker is True")),
            country_image=dict(type='boolean', string=_('Display country image'), description=_("Display the country image if the field is present on the record")),
        )
        return options

    @api.model
    def value_to_html(self, value, options):
        if not value:
            if options.get('null_text'):
                val = {
                    'options': options,
                }
                template_options = options.get('template_options', {})
                return self.env['ir.qweb']._render('base.no_contact', val, **template_options)
            return ''

        opf = options.get('fields') or ["name", "address", "phone", "mobile", "email"]
        sep = options.get('separator')
        if sep:
            opsep = escape(sep)
        elif options.get('no_tag_br'):
            # escaped joiners will auto-escape joined params
            opsep = escape(', ')
        else:
            opsep = Markup('<br/>')

        value = value.sudo().with_context(show_address=True)
        display_name = value.display_name or ''
        # Avoid having something like:
        # display_name = 'Foo\n  \n' -> This is a res.partner with a name and no address
        # That would return markup('<br/>') as address. But there is no address set.
        if any(elem.strip() for elem in display_name.split("\n")[1:]):
            address = opsep.join(display_name.split("\n")[1:]).strip()
        else:
            address = ''
        val = {
            'name': display_name.split("\n")[0],
            'address': address,
            'phone': value.phone,
            'mobile': value.mobile,
            'city': value.city,
            'country_id': value.country_id.display_name,
            'website': value.website,
            'email': value.email,
            'vat': value.vat,
            'vat_label': value.country_id.vat_label or _('VAT'),
            'fields': opf,
            'object': value,
            'options': options
        }
        return self.env['ir.qweb']._render('base.contact', val, minimal_qcontext=True)


class QwebView(models.AbstractModel):
    _name = 'ir.qweb.field.qweb'
    _description = 'Qweb Field qweb'
    _inherit = 'ir.qweb.field.many2one'

    @api.model
    def record_to_html(self, record, field_name, options):
        view = record[field_name]
        if not view:
            return ''

        if view._name != "ir.ui.view":
            _logger.warning("%s.%s must be a 'ir.ui.view', got %r.", record, field_name, view._name)
            return ''

        return self.env['ir.qweb']._render(view.id, options.get('values', {}))

```

  File: models/ir_rule.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import logging

from odoo import api, fields, models, tools, _
from odoo.exceptions import AccessError, ValidationError
from odoo.osv import expression
from odoo.tools import config
from odoo.tools.safe_eval import safe_eval, time

_logger = logging.getLogger(__name__)
class IrRule(models.Model):
    _name = 'ir.rule'
    _description = 'Record Rule'
    _order = 'model_id DESC,id'
    _MODES = ['read', 'write', 'create', 'unlink']
    _allow_sudo_commands = False

    name = fields.Char(index=True)
    active = fields.Boolean(default=True, help="If you uncheck the active field, it will disable the record rule without deleting it (if you delete a native record rule, it may be re-created when you reload the module).")
    model_id = fields.Many2one('ir.model', string='Model', index=True, required=True, ondelete="cascade")
    groups = fields.Many2many('res.groups', 'rule_group_rel', 'rule_group_id', 'group_id', ondelete='restrict')
    domain_force = fields.Text(string='Domain')
    perm_read = fields.Boolean(string='Read', default=True)
    perm_write = fields.Boolean(string='Write', default=True)
    perm_create = fields.Boolean(string='Create', default=True)
    perm_unlink = fields.Boolean(string='Delete', default=True)

    _sql_constraints = [
        ('no_access_rights',
         'CHECK (perm_read!=False or perm_write!=False or perm_create!=False or perm_unlink!=False)',
         'Rule must have at least one checked access right!'),
    ]

    @api.model
    def _eval_context(self):
        """Returns a dictionary to use as evaluation context for
           ir.rule domains.
           Note: company_ids contains the ids of the activated companies
           by the user with the switch company menu. These companies are
           filtered and trusted.
        """
        # use an empty context for 'user' to make the domain evaluation
        # independent from the context
        return {
            'user': self.env.user.with_context({}),
            'time': time,
            'company_ids': self.env.companies.ids,
            'company_id': self.env.company.id,
        }

    @api.depends('groups')
    def _compute_global(self):
        for rule in self:
            rule['global'] = not rule.groups

    @api.constrains('model_id')
    def _check_model_name(self):
        # Don't allow rules on rules records (this model).
        if any(rule.model_id.model == self._name for rule in self):
            raise ValidationError(_('Rules can not be applied on the Record Rules model.'))

    @api.constrains('active', 'domain_force', 'model_id')
    def _check_domain(self):
        eval_context = self._eval_context()
        for rule in self:
            if rule.active and rule.domain_force:
                try:
                    domain = safe_eval(rule.domain_force, eval_context)
                    expression.expression(domain, self.env[rule.model_id.model].sudo())
                except Exception as e:
                    raise ValidationError(_('Invalid domain: %s', e))

    def _compute_domain_keys(self):
        """ Return the list of context keys to use for caching ``_compute_domain``. """
        return ['allowed_company_ids']

    def _get_failing(self, for_records, mode='read'):
        """ Returns the rules for the mode for the current user which fail on
        the specified records.

        Can return any global rule and/or all local rules (since local rules
        are OR-ed together, the entire group succeeds or fails, while global
        rules get AND-ed and can each fail)
        """
        Model = for_records.browse(()).sudo()
        eval_context = self._eval_context()

        all_rules = self._get_rules(Model._name, mode=mode).sudo()

        # first check if the group rules fail for any record (aka if
        # searching on (records, group_rules) filters out some of the records)
        group_rules = all_rules.filtered(lambda r: r.groups and r.groups & self.env.user.groups_id)
        group_domains = expression.OR([
            safe_eval(r.domain_force, eval_context) if r.domain_force else []
            for r in group_rules
        ])
        # if all records get returned, the group rules are not failing
        if Model.search_count(expression.AND([[('id', 'in', for_records.ids)], group_domains])) == len(for_records):
            group_rules = self.browse(())

        # failing rules are previously selected group rules or any failing global rule
        def is_failing(r, ids=for_records.ids):
            dom = safe_eval(r.domain_force, eval_context) if r.domain_force else []
            return Model.search_count(expression.AND([
                [('id', 'in', ids)],
                expression.normalize_domain(dom)
            ])) < len(ids)

        return all_rules.filtered(lambda r: r in group_rules or (not r.groups and is_failing(r))).with_user(self.env.user)

    def _get_rules(self, model_name, mode='read'):
        """ Returns all the rules matching the model for the mode for the
        current user.
        """
        if mode not in self._MODES:
            raise ValueError('Invalid mode: %r' % (mode,))

        if self.env.su:
            return self.browse(())

        query = """ SELECT r.id FROM ir_rule r JOIN ir_model m ON (r.model_id=m.id)
                    WHERE m.model=%s AND r.active AND r.perm_{mode}
                    AND (r.id IN (SELECT rule_group_id FROM rule_group_rel rg
                                  JOIN res_groups_users_rel gu ON (rg.group_id=gu.gid)
                                  WHERE gu.uid=%s)
                         OR r.global)
                    ORDER BY r.id
                """.format(mode=mode)
        self._cr.execute(query, (model_name, self._uid))
        return self.browse(row[0] for row in self._cr.fetchall())

    @api.model
    @tools.conditional(
        'xml' not in config['dev_mode'],
        tools.ormcache('self.env.uid', 'self.env.su', 'model_name', 'mode',
                       'tuple(self._compute_domain_context_values())'),
    )
    def _compute_domain(self, model_name, mode="read"):
        global_domains = []                     # list of domains

        # add rules for parent models
        for parent_model_name, parent_field_name in self.env[model_name]._inherits.items():
            if domain := self._compute_domain(parent_model_name, mode):
                global_domains.append([(parent_field_name, 'any', domain)])

        rules = self._get_rules(model_name, mode=mode)
        if not rules:
            return expression.AND(global_domains) if global_domains else []

        # browse user and rules with sudo to avoid access errors!
        eval_context = self._eval_context()
        user_groups = self.env.user.groups_id
        group_domains = []                      # list of domains
        for rule in rules.sudo():
            # evaluate the domain for the current user
            dom = safe_eval(rule.domain_force, eval_context) if rule.domain_force else []
            dom = expression.normalize_domain(dom)
            if not rule.groups:
                global_domains.append(dom)
            elif rule.groups & user_groups:
                group_domains.append(dom)

        # combine global domains and group domains
        if not group_domains:
            return expression.AND(global_domains)
        return expression.AND(global_domains + [expression.OR(group_domains)])

    def _compute_domain_context_values(self):
        for k in self._compute_domain_keys():
            v = self._context.get(k)
            if isinstance(v, list):
                # currently this could be a frozenset (to avoid depending on
                # the order of allowed_company_ids) but it seems safer if
                # possibly slightly more miss-y to use a tuple
                v = tuple(v)
            yield v

    def unlink(self):
        res = super(IrRule, self).unlink()
        self.env.registry.clear_cache()
        return res

    @api.model_create_multi
    def create(self, vals_list):
        res = super(IrRule, self).create(vals_list)
        # DLE P33: tests
        self.env.flush_all()
        self.env.registry.clear_cache()
        return res

    def write(self, vals):
        res = super(IrRule, self).write(vals)
        # DLE P33: tests
        # - odoo/addons/test_access_rights/tests/test_feedback.py
        # - odoo/addons/test_access_rights/tests/test_ir_rules.py
        # - odoo/addons/base/tests/test_orm.py (/home/dle/src/odoo/master-nochange-fp/odoo/addons/base/tests/test_orm.py)
        self.env.flush_all()
        self.env.registry.clear_cache()
        return res

    def _make_access_error(self, operation, records):
        _logger.info('Access Denied by record rules for operation: %s on record ids: %r, uid: %s, model: %s', operation, records.ids[:6], self._uid, records._name)
        self = self.with_context(self.env.user.context_get())

        model = records._name
        description = self.env['ir.model']._get(model).name or model
        operations = {
            'read':  _("read"),
            'write': _("write"),
            'create': _("create"),
            'unlink': _("unlink"),
        }
        user_description = f"{self.env.user.name} (id={self.env.user.id})"
        operation_error = _("Uh-oh! Looks like you have stumbled upon some top-secret records.\n\n" \
            "Sorry, %s doesn't have '%s' access to:", user_description, operations[operation])
        failing_model = _("- %s (%s)", description, model)

        resolution_info = _("If you really, really need access, perhaps you can win over your friendly administrator with a batch of freshly baked cookies.")

        if not self.user_has_groups('base.group_no_one') or not self.env.user.has_group('base.group_user'):
            records.invalidate_recordset()
            return AccessError(f"{operation_error}\n{failing_model}\n\n{resolution_info}")

        # This extended AccessError is only displayed in debug mode.
        # Note that by default, public and portal users do not have
        # the group "base.group_no_one", even if debug mode is enabled,
        # so it is relatively safe here to include the list of rules and record names.
        rules = self._get_failing(records, mode=operation).sudo()

        records_sudo = records[:6].sudo()
        company_related = any('company_id' in (r.domain_force or '') for r in rules)

        def get_record_description(rec):
            # If the user has access to the company of the record, add this
            # information in the description to help them to change company
            if company_related and 'company_id' in rec and rec.company_id in self.env.user.company_ids:
                return f'{description}, {rec.display_name} ({model}: {rec.id}, company={rec.company_id.display_name})'
            return f'{description}, {rec.display_name} ({model}: {rec.id})'

        failing_records = '\n '.join(f'- {get_record_description(rec)}' for rec in records_sudo)

        rules_description = '\n'.join(f'- {rule.name}' for rule in rules)
        failing_rules = _("Blame the following rules:\n%s", rules_description)

        if company_related:
            failing_rules += "\n\n" + _('Note: this might be a multi-company issue. Switching company may help - in Odoo, not in real life!')

        # clean up the cache of records prefetched with display_name above
        records_sudo.invalidate_recordset()

        msg = f"{operation_error}\n{failing_records}\n\n{failing_rules}\n\n{resolution_info}"
        return AccessError(msg)


#
# Hack for field 'global': this field cannot be defined like others, because
# 'global' is a Python keyword. Therefore, we add it to the class by assignment.
# Note that the attribute '_module' is normally added by the class' metaclass.
#
global_ = fields.Boolean(compute='_compute_global', store=True,
                         help="If no group is specified the rule is global and applied to everyone")
setattr(IrRule, 'global', global_)
global_.__set_name__(IrRule, 'global')

```

  File: models/ir_sequence.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from datetime import datetime, timedelta
import logging
import pytz
from psycopg2 import sql

from odoo import api, fields, models, _
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


def _create_sequence(cr, seq_name, number_increment, number_next):
    """ Create a PostreSQL sequence. """
    if number_increment == 0:
        raise UserError(_('Step must not be zero.'))
    sql = "CREATE SEQUENCE %s INCREMENT BY %%s START WITH %%s" % seq_name
    cr.execute(sql, (number_increment, number_next))


def _drop_sequences(cr, seq_names):
    """ Drop the PostreSQL sequences if they exist. """
    if not seq_names:
        return
    names = sql.SQL(',').join(map(sql.Identifier, seq_names))
    # RESTRICT is the default; it prevents dropping the sequence if an
    # object depends on it.
    cr.execute(sql.SQL("DROP SEQUENCE IF EXISTS {} RESTRICT").format(names))


def _alter_sequence(cr, seq_name, number_increment=None, number_next=None):
    """ Alter a PostreSQL sequence. """
    if number_increment == 0:
        raise UserError(_("Step must not be zero."))
    cr.execute("SELECT relname FROM pg_class WHERE relkind=%s AND relname=%s", ('S', seq_name))
    if not cr.fetchone():
        # sequence is not created yet, we're inside create() so ignore it, will be set later
        return
    statement = sql.SQL("ALTER SEQUENCE") + sql.Identifier(seq_name)
    params = []
    if number_increment is not None:
        statement += sql.SQL("INCREMENT BY") + sql.Placeholder()
        params.append(number_increment)
    if number_next is not None:
        statement += sql.SQL("RESTART WITH") + sql.Placeholder()
        params.append(number_next)
    cr.execute(statement.join(' '), params)


def _select_nextval(cr, seq_name):
    cr.execute("SELECT nextval(%s)", [seq_name])
    return cr.fetchone()


def _update_nogap(self, number_increment):
    self.flush_recordset(['number_next'])
    number_next = self.number_next
    self._cr.execute("SELECT number_next FROM %s WHERE id=%%s FOR UPDATE NOWAIT" % self._table, [self.id])
    self._cr.execute("UPDATE %s SET number_next=number_next+%%s WHERE id=%%s " % self._table, (number_increment, self.id))
    self.invalidate_recordset(['number_next'])
    return number_next

def _predict_nextval(self, seq_id):
    """Predict next value for PostgreSQL sequence without consuming it"""
    # Cannot use currval() as it requires prior call to nextval()
    seqname = 'ir_sequence_%s' % seq_id
    seqtable = sql.Identifier(seqname)
    query = sql.SQL("""SELECT last_value,
                      (SELECT increment_by
                       FROM pg_sequences
                       WHERE sequencename = %s),
                      is_called
               FROM {}""")
    params = [seqname]
    if self.env.cr._cnx.server_version < 100000:
        query = sql.SQL("SELECT last_value, increment_by, is_called FROM {}")
        params = []
    self.env.cr.execute(query.format(seqtable), params)
    (last_value, increment_by, is_called) = self.env.cr.fetchone()
    if is_called:
        return last_value + increment_by
    # sequence has just been RESTARTed to return last_value next time
    return last_value


class IrSequence(models.Model):
    """ Sequence model.

    The sequence model allows to define and use so-called sequence objects.
    Such objects are used to generate unique identifiers in a transaction-safe
    way.

    """
    _name = 'ir.sequence'
    _description = 'Sequence'
    _order = 'name'
    _allow_sudo_commands = False

    def _get_number_next_actual(self):
        '''Return number from ir_sequence row when no_gap implementation,
        and number from postgres sequence when standard implementation.'''
        for seq in self:
            if not seq.id:
                seq.number_next_actual = 0
            elif seq.implementation != 'standard':
                seq.number_next_actual = seq.number_next
            else:
                seq_id = "%03d" % seq.id
                seq.number_next_actual = _predict_nextval(self, seq_id)

    def _set_number_next_actual(self):
        for seq in self:
            seq.write({'number_next': seq.number_next_actual or 1})

    @api.model
    def _get_current_sequence(self, sequence_date=None):
        '''Returns the object on which we can find the number_next to consider for the sequence.
        It could be an ir.sequence or an ir.sequence.date_range depending if use_date_range is checked
        or not. This function will also create the ir.sequence.date_range if none exists yet for today
        '''
        if not self.use_date_range:
            return self
        sequence_date = sequence_date or fields.Date.today()
        seq_date = self.env['ir.sequence.date_range'].search(
            [('sequence_id', '=', self.id), ('date_from', '<=', sequence_date), ('date_to', '>=', sequence_date)], limit=1)
        if seq_date:
            return seq_date[0]
        #no date_range sequence was found, we create a new one
        return self._create_date_range_seq(sequence_date)

    name = fields.Char(required=True)
    code = fields.Char(string='Sequence Code')
    implementation = fields.Selection([('standard', 'Standard'), ('no_gap', 'No gap')],
                                      string='Implementation', required=True, default='standard',
                                      help="While assigning a sequence number to a record, the 'no gap' sequence implementation ensures that each previous sequence number has been assigned already. "
                                      "While this sequence implementation will not skip any sequence number upon assignment, there can still be gaps in the sequence if records are deleted. "
                                      "The 'no gap' implementation is slower than the standard one.")
    active = fields.Boolean(default=True)
    prefix = fields.Char(help="Prefix value of the record for the sequence", trim=False)
    suffix = fields.Char(help="Suffix value of the record for the sequence", trim=False)
    number_next = fields.Integer(string='Next Number', required=True, default=1, help="Next number of this sequence")
    number_next_actual = fields.Integer(compute='_get_number_next_actual', inverse='_set_number_next_actual',
                                        string='Actual Next Number',
                                        help="Next number that will be used. This number can be incremented "
                                        "frequently so the displayed value might already be obsolete")
    number_increment = fields.Integer(string='Step', required=True, default=1,
                                      help="The next number of the sequence will be incremented by this number")
    padding = fields.Integer(string='Sequence Size', required=True, default=0,
                             help="Odoo will automatically adds some '0' on the left of the "
                                  "'Next Number' to get the required padding size.")
    company_id = fields.Many2one('res.company', string='Company',
                                 default=lambda s: s.env.company)
    use_date_range = fields.Boolean(string='Use subsequences per date_range')
    date_range_ids = fields.One2many('ir.sequence.date_range', 'sequence_id', string='Subsequences')

    @api.model_create_multi
    def create(self, vals_list):
        """ Create a sequence, in implementation == standard a fast gaps-allowed PostgreSQL sequence is used.
        """
        seqs = super().create(vals_list)
        for seq in seqs:
            if seq.implementation == 'standard':
                _create_sequence(self._cr, "ir_sequence_%03d" % seq.id, seq.number_increment or 1, seq.number_next or 1)
        return seqs

    def unlink(self):
        _drop_sequences(self._cr, ["ir_sequence_%03d" % x.id for x in self])
        return super(IrSequence, self).unlink()

    def write(self, values):
        new_implementation = values.get('implementation')
        for seq in self:
            # 4 cases: we test the previous impl. against the new one.
            i = values.get('number_increment', seq.number_increment)
            n = values.get('number_next', seq.number_next)
            if seq.implementation == 'standard':
                if new_implementation in ('standard', None):
                    # Implementation has NOT changed.
                    # Only change sequence if really requested.
                    if values.get('number_next'):
                        _alter_sequence(self._cr, "ir_sequence_%03d" % seq.id, number_next=n)
                    if seq.number_increment != i:
                        _alter_sequence(self._cr, "ir_sequence_%03d" % seq.id, number_increment=i)
                        seq.date_range_ids._alter_sequence(number_increment=i)
                else:
                    _drop_sequences(self._cr, ["ir_sequence_%03d" % seq.id])
                    for sub_seq in seq.date_range_ids:
                        _drop_sequences(self._cr, ["ir_sequence_%03d_%03d" % (seq.id, sub_seq.id)])
            else:
                if new_implementation in ('no_gap', None):
                    pass
                else:
                    _create_sequence(self._cr, "ir_sequence_%03d" % seq.id, i, n)
                    for sub_seq in seq.date_range_ids:
                        _create_sequence(self._cr, "ir_sequence_%03d_%03d" % (seq.id, sub_seq.id), i, n)
        res = super(IrSequence, self).write(values)
        # DLE P179
        self.flush_model(values.keys())
        return res

    def _next_do(self):
        if self.implementation == 'standard':
            number_next = _select_nextval(self._cr, 'ir_sequence_%03d' % self.id)
        else:
            number_next = _update_nogap(self, self.number_increment)
        return self.get_next_char(number_next)

    def _get_prefix_suffix(self, date=None, date_range=None):
        def _interpolate(s, d):
            return (s % d) if s else ''

        def _interpolation_dict():
            now = range_date = effective_date = datetime.now(pytz.timezone(self._context.get('tz') or 'UTC'))
            if date or self._context.get('ir_sequence_date'):
                effective_date = fields.Datetime.from_string(date or self._context.get('ir_sequence_date'))
            if date_range or self._context.get('ir_sequence_date_range'):
                range_date = fields.Datetime.from_string(date_range or self._context.get('ir_sequence_date_range'))

            sequences = {
                'year': '%Y', 'month': '%m', 'day': '%d', 'y': '%y', 'doy': '%j', 'woy': '%W',
                'weekday': '%w', 'h24': '%H', 'h12': '%I', 'min': '%M', 'sec': '%S'
            }
            res = {}
            for key, format in sequences.items():
                res[key] = effective_date.strftime(format)
                res['range_' + key] = range_date.strftime(format)
                res['current_' + key] = now.strftime(format)

            return res

        self.ensure_one()
        d = _interpolation_dict()
        try:
            interpolated_prefix = _interpolate(self.prefix, d)
            interpolated_suffix = _interpolate(self.suffix, d)
        except (ValueError, TypeError):
            raise UserError(_('Invalid prefix or suffix for sequence %r', self.name))
        return interpolated_prefix, interpolated_suffix

    def get_next_char(self, number_next):
        interpolated_prefix, interpolated_suffix = self._get_prefix_suffix()
        return interpolated_prefix + '%%0%sd' % self.padding % number_next + interpolated_suffix

    def _create_date_range_seq(self, date):
        year = fields.Date.from_string(date).strftime('%Y')
        date_from = '{}-01-01'.format(year)
        date_to = '{}-12-31'.format(year)
        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '>=', date), ('date_from', '<=', date_to)], order='date_from desc', limit=1)
        if date_range:
            date_to = date_range.date_from + timedelta(days=-1)
        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_to', '>=', date_from), ('date_to', '<=', date)], order='date_to desc', limit=1)
        if date_range:
            date_from = date_range.date_to + timedelta(days=1)
        seq_date_range = self.env['ir.sequence.date_range'].sudo().create({
            'date_from': date_from,
            'date_to': date_to,
            'sequence_id': self.id,
        })
        return seq_date_range

    def _next(self, sequence_date=None):
        """ Returns the next number in the preferred sequence in all the ones given in self."""
        if not self.use_date_range:
            return self._next_do()
        # date mode
        dt = sequence_date or self._context.get('ir_sequence_date', fields.Date.today())
        seq_date = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '<=', dt), ('date_to', '>=', dt)], limit=1)
        if not seq_date:
            seq_date = self._create_date_range_seq(dt)
        return seq_date.with_context(ir_sequence_date_range=seq_date.date_from)._next()

    def next_by_id(self, sequence_date=None):
        """ Draw an interpolated string using the specified sequence."""
        self.check_access_rights('read')
        return self._next(sequence_date=sequence_date)

    @api.model
    def next_by_code(self, sequence_code, sequence_date=None):
        """ Draw an interpolated string using a sequence with the requested code.
            If several sequences with the correct code are available to the user
            (multi-company cases), the one from the user's current company will
            be used.
        """
        self.check_access_rights('read')
        company_id = self.env.company.id
        seq_ids = self.search([('code', '=', sequence_code), ('company_id', 'in', [company_id, False])], order='company_id')
        if not seq_ids:
            _logger.debug("No ir.sequence has been found for code '%s'. Please make sure a sequence is set for current company." % sequence_code)
            return False
        seq_id = seq_ids[0]
        return seq_id._next(sequence_date=sequence_date)

    @api.model
    def get_id(self, sequence_code_or_id, code_or_id='id'):
        """ Draw an interpolated string using the specified sequence.

        The sequence to use is specified by the ``sequence_code_or_id``
        argument, which can be a code or an id (as controlled by the
        ``code_or_id`` argument. This method is deprecated.
        """
        _logger.warning("ir_sequence.get() and ir_sequence.get_id() are deprecated. "
                        "Please use ir_sequence.next_by_code() or ir_sequence.next_by_id().")
        if code_or_id == 'id':
            return self.browse(sequence_code_or_id).next_by_id()
        else:
            return self.next_by_code(sequence_code_or_id)

    @api.model
    def get(self, code):
        """ Draw an interpolated string using the specified sequence.

        The sequence to use is specified by its code. This method is
        deprecated.
        """
        return self.get_id(code, 'code')


class IrSequenceDateRange(models.Model):
    _name = 'ir.sequence.date_range'
    _description = 'Sequence Date Range'
    _rec_name = "sequence_id"
    _allow_sudo_commands = False

    def _get_number_next_actual(self):
        '''Return number from ir_sequence row when no_gap implementation,
        and number from postgres sequence when standard implementation.'''
        for seq in self:
            if seq.sequence_id.implementation != 'standard':
                seq.number_next_actual = seq.number_next
            else:
                seq_id = "%03d_%03d" % (seq.sequence_id.id, seq.id)
                seq.number_next_actual = _predict_nextval(self, seq_id)

    def _set_number_next_actual(self):
        for seq in self:
            seq.write({'number_next': seq.number_next_actual or 1})

    @api.model
    def default_get(self, fields):
        result = super(IrSequenceDateRange, self).default_get(fields)
        if 'number_next_actual' in fields:
            result['number_next_actual'] = 1
        return result

    date_from = fields.Date(string='From', required=True)
    date_to = fields.Date(string='To', required=True)
    sequence_id = fields.Many2one("ir.sequence", string='Main Sequence', required=True, ondelete='cascade')
    number_next = fields.Integer(string='Next Number', required=True, default=1, help="Next number of this sequence")
    number_next_actual = fields.Integer(compute='_get_number_next_actual', inverse='_set_number_next_actual',
                                        string='Actual Next Number',
                                        help="Next number that will be used. This number can be incremented "
                                             "frequently so the displayed value might already be obsolete")

    def _next(self):
        if self.sequence_id.implementation == 'standard':
            number_next = _select_nextval(self._cr, 'ir_sequence_%03d_%03d' % (self.sequence_id.id, self.id))
        else:
            number_next = _update_nogap(self, self.sequence_id.number_increment)
        return self.sequence_id.get_next_char(number_next)

    def _alter_sequence(self, number_increment=None, number_next=None):
        for seq in self:
            _alter_sequence(self._cr, "ir_sequence_%03d_%03d" % (seq.sequence_id.id, seq.id), number_increment=number_increment, number_next=number_next)

    @api.model_create_multi
    def create(self, vals_list):
        """ Create a sequence, in implementation == standard a fast gaps-allowed PostgreSQL sequence is used.
        """
        seqs = super().create(vals_list)
        for seq in seqs:
            main_seq = seq.sequence_id
            if main_seq.implementation == 'standard':
                _create_sequence(self._cr, "ir_sequence_%03d_%03d" % (main_seq.id, seq.id), main_seq.number_increment, seq.number_next_actual or 1)
        return seqs

    def unlink(self):
        _drop_sequences(self._cr, ["ir_sequence_%03d_%03d" % (x.sequence_id.id, x.id) for x in self])
        return super(IrSequenceDateRange, self).unlink()

    def write(self, values):
        if values.get('number_next'):
            seq_to_alter = self.filtered(lambda seq: seq.sequence_id.implementation == 'standard')
            seq_to_alter._alter_sequence(number_next=values.get('number_next'))
        # DLE P179: `test_in_invoice_line_onchange_sequence_number_1`
        # _update_nogap do a select to get the next sequence number_next
        # When changing (writing) the number next of a sequence, the number next must be flushed before doing the select.
        # Normally in such a case, we flush just above the execute, but for the sake of performance
        # I believe this is better to flush directly in the write:
        #  - Changing the number next of a sequence is really really rare,
        #  - But selecting the number next happens a lot,
        # Therefore, if I chose to put the flush just above the select, it would check the flush most of the time for no reason.
        res = super(IrSequenceDateRange, self).write(values)
        self.flush_model(values.keys())
        return res

```

  File: models/ir_ui_menu.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
from collections import defaultdict
from os.path import join as opj
import operator
import re

from odoo import api, fields, models, tools, _
from odoo.exceptions import ValidationError
from odoo.http import request
from odoo.osv import expression

MENU_ITEM_SEPARATOR = "/"
NUMBER_PARENS = re.compile(r"\(([0-9]+)\)")


class IrUiMenu(models.Model):
    _name = 'ir.ui.menu'
    _description = 'Menu'
    _order = "sequence,id"
    _parent_store = True
    _allow_sudo_commands = False

    name = fields.Char(string='Menu', required=True, translate=True)
    active = fields.Boolean(default=True)
    sequence = fields.Integer(default=10)
    child_id = fields.One2many('ir.ui.menu', 'parent_id', string='Child IDs')
    parent_id = fields.Many2one('ir.ui.menu', string='Parent Menu', index=True, ondelete="restrict")
    parent_path = fields.Char(index=True, unaccent=False)
    groups_id = fields.Many2many('res.groups', 'ir_ui_menu_group_rel',
                                 'menu_id', 'gid', string='Groups',
                                 help="If you have groups, the visibility of this menu will be based on these groups. "\
                                      "If this field is empty, Odoo will compute visibility based on the related object's read access.")
    complete_name = fields.Char(string='Full Path', compute='_compute_complete_name', recursive=True)
    web_icon = fields.Char(string='Web Icon File')
    action = fields.Reference(selection=[('ir.actions.report', 'ir.actions.report'),
                                         ('ir.actions.act_window', 'ir.actions.act_window'),
                                         ('ir.actions.act_url', 'ir.actions.act_url'),
                                         ('ir.actions.server', 'ir.actions.server'),
                                         ('ir.actions.client', 'ir.actions.client')])

    web_icon_data = fields.Binary(string='Web Icon Image', attachment=True)

    @api.depends('name', 'parent_id.complete_name')
    def _compute_complete_name(self):
        for menu in self:
            menu.complete_name = menu._get_full_name()

    def _get_full_name(self, level=6):
        """ Return the full name of ``self`` (up to a certain level). """
        if level <= 0:
            return '...'
        if self.parent_id:
            return self.parent_id._get_full_name(level - 1) + MENU_ITEM_SEPARATOR + (self.name or "")
        else:
            return self.name

    def _read_image(self, path):
        if not path:
            return False
        path_info = path.split(',')
        icon_path = opj(path_info[0], path_info[1])
        try:
            with tools.file_open(icon_path, 'rb', filter_ext=('.png',)) as icon_file:
                return base64.encodebytes(icon_file.read())
        except FileNotFoundError:
            return False

    @api.constrains('parent_id')
    def _check_parent_id(self):
        if not self._check_recursion():
            raise ValidationError(_('Error! You cannot create recursive menus.'))

    @api.model
    @tools.ormcache('frozenset(self.env.user.groups_id.ids)', 'debug')
    def _visible_menu_ids(self, debug=False):
        """ Return the ids of the menu items visible to the user. """
        # retrieve all menus, and determine which ones are visible
        context = {'ir.ui.menu.full_list': True}
        menus = self.with_context(context).search_fetch([], ['action', 'parent_id']).sudo()

        groups = self.env.user.groups_id
        if not debug:
            groups = groups - self.env.ref('base.group_no_one')
        # first discard all menus with groups the user does not have
        menus = menus.filtered(
            lambda menu: not menu.groups_id or menu.groups_id & groups)

        # take apart menus that have an action
        actions_by_model = defaultdict(set)
        for action in menus.mapped('action'):
            if action:
                actions_by_model[action._name].add(action.id)
        existing_actions = {
            action
            for model_name, action_ids in actions_by_model.items()
            for action in self.env[model_name].browse(action_ids).exists()
        }
        action_menus = menus.filtered(lambda m: m.action and m.action in existing_actions)
        folder_menus = menus - action_menus
        visible = self.browse()

        # process action menus, check whether their action is allowed
        access = self.env['ir.model.access']
        MODEL_BY_TYPE = {
            'ir.actions.act_window': 'res_model',
            'ir.actions.report': 'model',
            'ir.actions.server': 'model_name',
        }

        # performance trick: determine the ids to prefetch by type
        prefetch_ids = defaultdict(list)
        for action in action_menus.mapped('action'):
            prefetch_ids[action._name].append(action.id)

        for menu in action_menus:
            action = menu.action
            action = action.with_prefetch(prefetch_ids[action._name])
            model_name = action._name in MODEL_BY_TYPE and action[MODEL_BY_TYPE[action._name]]
            if not model_name or access.check(model_name, 'read', False):
                # make menu visible, and its folder ancestors, too
                visible += menu
                menu = menu.parent_id
                while menu and menu in folder_menus and menu not in visible:
                    visible += menu
                    menu = menu.parent_id

        return set(visible.ids)

    @api.returns('self')
    def _filter_visible_menus(self):
        """ Filter `self` to only keep the menu items that should be visible in
            the menu hierarchy of the current user.
            Uses a cache for speeding up the computation.
        """
        visible_ids = self._visible_menu_ids(request.session.debug if request else False)
        return self.filtered(lambda menu: menu.id in visible_ids)

    @api.model
    def search_fetch(self, domain, field_names, offset=0, limit=None, order=None):
        menus = super().search_fetch(domain, field_names, order=order)
        if menus:
            # menu filtering is done only on main menu tree, not other menu lists
            if not self._context.get('ir.ui.menu.full_list'):
                menus = menus._filter_visible_menus()
            if offset:
                menus = menus[offset:]
            if limit:
                menus = menus[:limit]
        return menus

    @api.model
    def search_count(self, domain, limit=None):
        # to be consistent with search() above
        return len(self.search(domain, limit=limit))

    @api.depends('parent_id')
    def _compute_display_name(self):
        for menu in self:
            menu.display_name = menu._get_full_name()

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache()
        for values in vals_list:
            if 'web_icon' in values:
                values['web_icon_data'] = self._compute_web_icon_data(values.get('web_icon'))
        return super(IrUiMenu, self).create(vals_list)

    def write(self, values):
        self.env.registry.clear_cache()
        if 'web_icon' in values:
            values['web_icon_data'] = self._compute_web_icon_data(values.get('web_icon'))
        return super(IrUiMenu, self).write(values)

    def _compute_web_icon_data(self, web_icon):
        """ Returns the image associated to `web_icon`.
            `web_icon` can either be:
              - an image icon [module, path]
              - a built icon [icon_class, icon_color, background_color]
            and it only has to call `_read_image` if it's an image.
        """
        if web_icon and len(web_icon.split(',')) == 2:
            return self._read_image(web_icon)

    def unlink(self):
        # Detach children and promote them to top-level, because it would be unwise to
        # cascade-delete submenus blindly. We also can't use ondelete=set null because
        # that is not supported when _parent_store is used (would silently corrupt it).
        # TODO: ideally we should move them under a generic "Orphans" menu somewhere?
        extra = {'ir.ui.menu.full_list': True,
                 'active_test': False}
        direct_children = self.with_context(**extra).search([('parent_id', 'in', self.ids)])
        direct_children.write({'parent_id': False})

        self.env.registry.clear_cache()
        return super(IrUiMenu, self).unlink()

    def copy(self, default=None):
        record = super(IrUiMenu, self).copy(default=default)
        match = NUMBER_PARENS.search(record.name)
        if match:
            next_num = int(match.group(1)) + 1
            record.name = NUMBER_PARENS.sub('(%d)' % next_num, record.name)
        else:
            record.name = record.name + '(1)'
        return record

    @api.model
    @api.returns('self')
    def get_user_roots(self):
        """ Return all root menu ids visible for the user.

        :return: the root menu ids
        :rtype: list(int)
        """
        return self.search([('parent_id', '=', False)])

    def _load_menus_blacklist(self):
        return []

    @api.model
    @tools.ormcache_context('self._uid', keys=('lang',))
    def load_menus_root(self):
        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon_data']
        menu_roots = self.get_user_roots()
        menu_roots_data = menu_roots.read(fields) if menu_roots else []

        menu_root = {
            'id': False,
            'name': 'root',
            'parent_id': [-1, ''],
            'children': menu_roots_data,
            'all_menu_ids': menu_roots.ids,
        }

        xmlids = menu_roots._get_menuitems_xmlids()
        for menu in menu_roots_data:
            menu['xmlid'] = xmlids.get(menu['id'], '')

        return menu_root

    @api.model
    @tools.ormcache_context('self._uid', 'debug', keys=('lang',))
    def load_menus(self, debug):
        """ Loads all menu items (all applications and their sub-menus).

        :return: the menu root
        :rtype: dict('children': menu_nodes)
        """
        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon']
        menu_roots = self.get_user_roots()
        menu_roots_data = menu_roots.read(fields) if menu_roots else []
        menu_root = {
            'id': False,
            'name': 'root',
            'parent_id': [-1, ''],
            'children': [menu['id'] for menu in menu_roots_data],
        }

        all_menus = {'root': menu_root}

        if not menu_roots_data:
            return all_menus

        # menus are loaded fully unlike a regular tree view, cause there are a
        # limited number of items (752 when all 6.1 addons are installed)
        menus_domain = [('id', 'child_of', menu_roots.ids)]
        blacklisted_menu_ids = self._load_menus_blacklist()
        if blacklisted_menu_ids:
            menus_domain = expression.AND([menus_domain, [('id', 'not in', blacklisted_menu_ids)]])
        menus = self.search(menus_domain)
        menu_items = menus.read(fields)
        xmlids = (menu_roots + menus)._get_menuitems_xmlids()

        # add roots at the end of the sequence, so that they will overwrite
        # equivalent menu items from full menu read when put into id:item
        # mapping, resulting in children being correctly set on the roots.
        menu_items.extend(menu_roots_data)

        mi_attachments = self.env['ir.attachment'].sudo().search_read(
            domain=[('res_model', '=', 'ir.ui.menu'),
                    ('res_id', 'in', [menu_item['id'] for menu_item in menu_items if menu_item['id']]),
                    ('res_field', '=', 'web_icon_data')],
            fields=['res_id', 'datas', 'mimetype'])

        mi_attachment_by_res_id = {attachment['res_id']: attachment for attachment in mi_attachments}

        # set children ids and xmlids
        menu_items_map = {menu_item["id"]: menu_item for menu_item in menu_items}
        for menu_item in menu_items:
            menu_item.setdefault('children', [])
            parent = menu_item['parent_id'] and menu_item['parent_id'][0]
            menu_item['xmlid'] = xmlids.get(menu_item['id'], "")
            if parent in menu_items_map:
                menu_items_map[parent].setdefault(
                    'children', []).append(menu_item['id'])
            attachment = mi_attachment_by_res_id.get(menu_item['id'])
            if attachment:
                menu_item['web_icon_data'] = attachment['datas']
                menu_item['web_icon_data_mimetype'] = attachment['mimetype']
            else:
                menu_item['web_icon_data'] = False
                menu_item['web_icon_data_mimetype'] = False
        all_menus.update(menu_items_map)

        # sort by sequence
        for menu_id in all_menus:
            all_menus[menu_id]['children'].sort(key=lambda id: all_menus[id]['sequence'])

        # recursively set app ids to related children
        def _set_app_id(app_id, menu):
            menu['app_id'] = app_id
            for child_id in menu['children']:
                _set_app_id(app_id, all_menus[child_id])

        for app in menu_roots_data:
            app_id = app['id']
            _set_app_id(app_id, all_menus[app_id])

        # filter out menus not related to an app (+ keep root menu)
        all_menus = {menu['id']: menu for menu in all_menus.values() if menu.get('app_id')}
        all_menus['root'] = menu_root

        return all_menus

    def _get_menuitems_xmlids(self):
        menuitems = self.env['ir.model.data'].sudo().search([
                ('res_id', 'in', self.ids),
                ('model', '=', 'ir.ui.menu')
            ])

        return {
            menu.res_id: menu.complete_name
            for menu in menuitems
        }

```

  File: models/ir_ui_view.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast
import collections
import functools
import inspect
import json
import logging
import pprint
import re
import uuid
import warnings

from itertools import chain

from lxml import etree
from lxml.etree import LxmlError
from lxml.builder import E

import odoo
from odoo import api, fields, models, tools, _
from odoo.exceptions import ValidationError, AccessError, UserError
from odoo.http import request
from odoo.modules.module import get_resource_from_path
from odoo.tools import config, ConstantMapping, get_diff, pycompat, apply_inheritance_specs, locate_node, str2bool
from odoo.tools import safe_eval, lazy, lazy_property, frozendict
from odoo.tools.convert import _fix_multiple_roots
from odoo.tools.misc import file_path
from odoo.tools.translate import xml_translate, TRANSLATED_ATTRS
from odoo.tools.view_validation import valid_view, get_domain_value_names, get_expression_field_names, get_dict_asts
from odoo.models import check_method_name
from odoo.osv.expression import expression

_logger = logging.getLogger(__name__)

MOVABLE_BRANDING = ['data-oe-model', 'data-oe-id', 'data-oe-field', 'data-oe-xpath', 'data-oe-source-id']
VIEW_MODIFIERS = ('column_invisible', 'invisible', 'readonly', 'required')

# Some views have a js compiler that generates an owl template from the arch. In that template,
# `__comp__` is a reserved keyword giving access to the component instance (e.g. the form renderer
# or the kanban record). However, we don't want to see implementation details leaking in archs, so
# we use the following regex to detect the use of `__comp__` in dynamic attributes, to forbid it.
COMP_REGEX = r'(^|[^\w])\s*__comp__\s*([^\w]|$)'

ref_re = re.compile(r"""
# first match 'form_view_ref' key, backrefs are used to handle single or
# double quoting of the value
(['"])(?P<view_type>\w+_view_ref)\1
# colon separator (with optional spaces around)
\s*:\s*
# open quote for value
(['"])
(?P<view_id>
    # we'll just match stuff which is normally part of an xid:
    # word and "." characters
    [.\w]+
)
# close with same quote as opening
\3
""", re.VERBOSE)


def att_names(name):
    yield name
    yield f"t-att-{name}"
    yield f"t-attf-{name}"


@lazy
def keep_query():
    mod = odoo.addons.base.models.ir_qweb
    warnings.warn(f"keep_query has been moved to {mod}", DeprecationWarning)
    return mod.keep_query


class ViewCustom(models.Model):
    _name = 'ir.ui.view.custom'
    _description = 'Custom View'
    _order = 'create_date desc'  # search(limit=1) should return the last customization
    _rec_name = 'user_id'
    _allow_sudo_commands = False

    ref_id = fields.Many2one('ir.ui.view', string='Original View', index=True, required=True, ondelete='cascade')
    user_id = fields.Many2one('res.users', string='User', index=True, required=True, ondelete='cascade')
    arch = fields.Text(string='View Architecture', required=True)

    def _auto_init(self):
        res = super(ViewCustom, self)._auto_init()
        tools.create_index(self._cr, 'ir_ui_view_custom_user_id_ref_id',
                           self._table, ['user_id', 'ref_id'])
        return res


def _hasclass(context, *cls):
    """ Checks if the context node has all the classes passed as arguments
    """
    node_classes = set(context.context_node.attrib.get('class', '').split())
    return node_classes.issuperset(cls)


def get_view_arch_from_file(filepath, xmlid):
    module, view_id = xmlid.split('.')

    xpath = f"//*[@id='{xmlid}' or @id='{view_id}']"
    # when view is created from model with inheritS of ir_ui_view, the
    # xmlid has been suffixed by '_ir_ui_view'. We need to also search
    # for views without this prefix.
    if view_id.endswith('_ir_ui_view'):
        # len('_ir_ui_view') == 11
        xpath = xpath[:-1] + f" or @id='{xmlid[:-11]}' or @id='{view_id[:-11]}']"

    document = etree.parse(filepath)
    for node in document.xpath(xpath):
        if node.tag == 'record':
            field_arch = node.find('field[@name="arch"]')
            if field_arch is not None:
                _fix_multiple_roots(field_arch)
                inner = ''.join(
                    etree.tostring(child, encoding='unicode')
                    for child in field_arch.iterchildren()
                )
                return field_arch.text + inner

            field_view = node.find('field[@name="view_id"]')
            if field_view is not None:
                ref_module, _, ref_view_id = field_view.attrib.get('ref').rpartition('.')
                ref_xmlid = f'{ref_module or module}.{ref_view_id}'
                return get_view_arch_from_file(filepath, ref_xmlid)

            return None

        elif node.tag == 'template':
            # The following dom operations has been copied from convert.py's _tag_template()
            if not node.get('inherit_id'):
                node.set('t-name', xmlid)
                node.tag = 't'
            else:
                node.tag = 'data'
            node.attrib.pop('id', None)
            return etree.tostring(node, encoding='unicode')

    _logger.warning("Could not find view arch definition in file '%s' for xmlid '%s'", filepath, xmlid)
    return None


xpath_utils = etree.FunctionNamespace(None)
xpath_utils['hasclass'] = _hasclass

TRANSLATED_ATTRS_RE = re.compile(r"@(%s)\b" % "|".join(TRANSLATED_ATTRS))
WRONGCLASS = re.compile(r"(@class\s*=|=\s*@class|contains\(@class)")


class View(models.Model):
    _name = 'ir.ui.view'
    _description = 'View'
    _order = "priority,name,id"
    _allow_sudo_commands = False

    name = fields.Char(string='View Name', required=True)
    model = fields.Char(index=True)
    key = fields.Char(index='btree_not_null')
    priority = fields.Integer(string='Sequence', default=16, required=True)
    type = fields.Selection([('tree', 'Tree'),
                             ('form', 'Form'),
                             ('graph', 'Graph'),
                             ('pivot', 'Pivot'),
                             ('calendar', 'Calendar'),
                             ('gantt', 'Gantt'),
                             ('kanban', 'Kanban'),
                             ('search', 'Search'),
                             ('qweb', 'QWeb')], string='View Type')
    arch = fields.Text(compute='_compute_arch', inverse='_inverse_arch', string='View Architecture',
                       help="""This field should be used when accessing view arch. It will use translation.
                               Note that it will read `arch_db` or `arch_fs` if in dev-xml mode.""")
    arch_base = fields.Text(compute='_compute_arch_base', inverse='_inverse_arch_base', string='Base View Architecture',
                            help="This field is the same as `arch` field without translations")
    arch_db = fields.Text(string='Arch Blob', translate=xml_translate,
                          help="This field stores the view arch.")
    arch_fs = fields.Char(string='Arch Filename', help="""File from where the view originates.
                                                          Useful to (hard) reset broken views or to read arch from file in dev-xml mode.""")
    arch_updated = fields.Boolean(string='Modified Architecture')
    arch_prev = fields.Text(string='Previous View Architecture', help="""This field will save the current `arch_db` before writing on it.
                                                                         Useful to (soft) reset a broken view.""")
    inherit_id = fields.Many2one('ir.ui.view', string='Inherited View', ondelete='restrict', index=True)
    inherit_children_ids = fields.One2many('ir.ui.view', 'inherit_id', string='Views which inherit from this one')
    model_data_id = fields.Many2one('ir.model.data', string="Model Data",
                                    compute='_compute_model_data_id', search='_search_model_data_id')
    xml_id = fields.Char(string="External ID", compute='_compute_xml_id',
                         help="ID of the view defined in xml file")
    groups_id = fields.Many2many('res.groups', 'ir_ui_view_group_rel', 'view_id', 'group_id',
                                 string='Groups', help="If this field is empty, the view applies to all users. Otherwise, the view applies to the users of those groups only.")
    mode = fields.Selection([('primary', "Base view"), ('extension', "Extension View")],
                            string="View inheritance mode", default='primary', required=True,
                            help="""Only applies if this view inherits from an other one (inherit_id is not False/Null).

* if extension (default), if this view is requested the closest primary view
is looked up (via inherit_id), then all views inheriting from it with this
view's model are applied
* if primary, the closest primary view is fully resolved (even if it uses a
different model than this one), then this view's inheritance specs
(<xpath/>) are applied, and the result is used as if it were this view's
actual arch.
""")

    # The "active" field is not updated during updates if <template> is used
    # instead of <record> to define the view in XML, see _tag_template. For
    # qweb views, you should not rely on the active field being updated anyway
    # as those views, if used in frontend layouts, can be duplicated (see COW)
    # and will thus always require upgrade scripts if you really want to change
    # the default value of their "active" field.
    active = fields.Boolean(default=True,
                            help="""If this view is inherited,
* if True, the view always extends its parent
* if False, the view currently does not extend its parent but can be enabled
         """)
    model_id = fields.Many2one("ir.model", string="Model of the view", compute='_compute_model_id', inverse='_inverse_compute_model_id')

    @api.depends('arch_db', 'arch_fs', 'arch_updated')
    @api.depends_context('read_arch_from_file', 'lang', 'edit_translations', 'check_translations')
    def _compute_arch(self):
        def resolve_external_ids(arch_fs, view_xml_id):
            def replacer(m):
                xmlid = m.group('xmlid')
                if '.' not in xmlid:
                    xmlid = '%s.%s' % (view_xml_id.split('.')[0], xmlid)
                return m.group('prefix') + str(self.env['ir.model.data']._xmlid_to_res_id(xmlid))
            return re.sub(r'(?P<prefix>[^%])%\((?P<xmlid>.*?)\)[ds]', replacer, arch_fs)

        lang = self.env.lang or 'en_US'
        env_en = self.with_context(edit_translations=None, lang='en_US').env
        env_lang = self.with_context(lang=lang).env
        field_arch_db = self._fields['arch_db']
        for view in self:
            arch_fs = None
            read_file = self._context.get('read_arch_from_file') or \
                ('xml' in config['dev_mode'] and not view.arch_updated)
            if read_file and view.arch_fs and (view.xml_id or view.key):
                xml_id = view.xml_id or view.key
                # It is safe to split on / herebelow because arch_fs is explicitely stored with '/'
                try:
                    fullpath = file_path(view.arch_fs)
                except FileNotFoundError:
                    _logger.warning("View %s: Full path [%s] cannot be found.", xml_id, view.arch_fs)
                    arch_fs = False
                    continue

                arch_fs = get_view_arch_from_file(fullpath, xml_id)
                # replace %(xml_id)s, %(xml_id)d, %%(xml_id)s, %%(xml_id)d by the res_id
                if arch_fs:
                    arch_fs = resolve_external_ids(arch_fs, xml_id).replace('%%', '%')
                    translation_dictionary = field_arch_db.get_translation_dictionary(
                        view.with_env(env_en).arch_db, {lang: view.with_env(env_lang).arch_db}
                    )
                    arch_fs = field_arch_db.translate(
                        lambda term: translation_dictionary[term][lang],
                        arch_fs
                    )
            view.arch = pycompat.to_text(arch_fs or view.arch_db)

    def _inverse_arch(self):
        for view in self:
            data = dict(arch_db=view.arch)
            if 'install_filename' in self._context:
                # we store the relative path to the resource instead of the absolute path, if found
                # (it will be missing e.g. when importing data-only modules using base_import_module)
                path_info = get_resource_from_path(self._context['install_filename'])
                if path_info:
                    data['arch_fs'] = '/'.join(path_info[0:2])
                    data['arch_updated'] = False
            view.write(data)
            # the xml_translate will clean the arch_db when write (e.g. ('<div>') -> ('<div></div>'))
            # view.arch should be reassigned here
            view.arch = view.arch_db
        # the field 'arch' depends on the context and has been implicitly
        # modified in all languages; the invalidation below ensures that the
        # field does not keep an old value in another environment
        self.invalidate_recordset(['arch'])

    @api.depends('arch')
    @api.depends_context('read_arch_from_file')
    def _compute_arch_base(self):
        # 'arch_base' is the same as 'arch' without translation
        for view, view_wo_lang in zip(self, self.with_context(lang=None)):
            view.arch_base = view_wo_lang.arch

    def _inverse_arch_base(self):
        for view, view_wo_lang in zip(self, self.with_context(lang=None)):
            view_wo_lang.arch = view.arch_base

    def reset_arch(self, mode='soft'):
        """ Reset the view arch to its previous arch (soft) or its XML file arch
        if exists (hard).
        """
        for view in self:
            arch = False
            if mode == 'soft':
                arch = view.arch_prev
            elif mode == 'hard' and view.arch_fs:
                arch = view.with_context(read_arch_from_file=True, lang=None).arch
            if arch:
                # Don't save current arch in previous since we reset, this arch is probably broken
                view.with_context(no_save_prev=True, lang=None).write({'arch_db': arch})

    @api.depends('write_date')
    def _compute_model_data_id(self):
        # get the first ir_model_data record corresponding to self
        for view in self:
            view.model_data_id = False
        domain = [('model', '=', 'ir.ui.view'), ('res_id', 'in', self.ids)]
        for data in self.env['ir.model.data'].sudo().search_read(domain, ['res_id'], order='id desc'):
            view = self.browse(data['res_id'])
            view.model_data_id = data['id']

    def _search_model_data_id(self, operator, value):
        name = 'name' if isinstance(value, str) else 'id'
        domain = [('model', '=', 'ir.ui.view'), (name, operator, value)]
        data = self.env['ir.model.data'].sudo().search(domain)
        return [('id', 'in', data.mapped('res_id'))]

    @api.depends('model')
    def _compute_model_id(self):
        for record in self:
            record.model_id = self.env['ir.model']._get(record.model)

    def _inverse_compute_model_id(self):
        for record in self:
            record.model = record.model_id.model

    def _compute_xml_id(self):
        xml_ids = collections.defaultdict(list)
        domain = [('model', '=', 'ir.ui.view'), ('res_id', 'in', self.ids)]
        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):
            xml_ids[data['res_id']].append("%s.%s" % (data['module'], data['name']))
        for view in self:
            view.xml_id = xml_ids.get(view.id, [''])[0]

    def _valid_inheritance(self, arch):
        """ Check whether view inheritance is based on translated attribute. """
        for node in arch.xpath('//*[@position]'):
            # inheritance may not use a translated attribute as selector
            if node.tag == 'xpath':
                match = TRANSLATED_ATTRS_RE.search(node.get('expr', ''))
                if match:
                    message = "View inheritance may not use attribute %r as a selector." % match.group(1)
                    self._raise_view_error(message, node)
                if WRONGCLASS.search(node.get('expr', '')):
                    _logger.warning(
                        "Error-prone use of @class in view %s (%s): use the "
                        "hasclass(*classes) function to filter elements by "
                        "their classes", self.name, self.xml_id
                    )
            else:
                for attr in TRANSLATED_ATTRS:
                    if node.get(attr):
                        message = "View inheritance may not use attribute %r as a selector." % attr
                        self._raise_view_error(message, node)
        return True

    @api.constrains('arch_db')
    def _check_xml(self):
        # Sanity checks: the view should not break anything upon rendering!
        # Any exception raised below will cause a transaction rollback.
        partial_validation = self.env.context.get('ir_ui_view_partial_validation')
        self = self.with_context(validate_view_ids=(self._ids if partial_validation else True))

        for view in self:
            try:
                # verify the view is valid xml and that the inheritance resolves
                if view.inherit_id:
                    view_arch = etree.fromstring(view.arch)
                    view._valid_inheritance(view_arch)
                combined_arch = view._get_combined_arch()
                if view.type == 'qweb':
                    continue
            except (etree.ParseError, ValueError) as e:
                err = ValidationError(_(
                    "Error while parsing or validating view:\n\n%(error)s",
                    error=tools.ustr(e),
                    view=self.key or self.id,
                )).with_traceback(e.__traceback__)
                err.context = getattr(e, 'context', None)
                raise err from None

            try:
                # verify that all fields used are valid, etc.
                view._validate_view(combined_arch, view.model)
                combined_archs = [combined_arch]

                if combined_arch.xpath('//*[@attrs]') or combined_arch.xpath('//*[@states]'):
                    view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name
                    err = ValidationError(_('Since 17.0, the "attrs" and "states" attributes are no longer used.\nView: %(name)s in %(file)s',
                        name=view_name, file=view.arch_fs
                    ))
                    err.context = {'name': 'invalid view'}
                    raise err

                if combined_archs[0].tag == 'data':
                    # A <data> element is a wrapper for multiple root nodes
                    combined_archs = combined_archs[0]
                for view_arch in combined_archs:
                    for node in view_arch.xpath('//*[@__validate__]'):
                        del node.attrib['__validate__']
                    check = valid_view(view_arch, env=self.env, model=view.model)
                    if not check:
                        view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name
                        raise ValidationError(_(
                            'Invalid view %(name)s definition in %(file)s',
                            name=view_name, file=view.arch_fs
                        ))
            except ValueError as e:
                if hasattr(e, 'context'):
                    lines = etree.tostring(combined_arch, encoding='unicode').splitlines(keepends=True)
                    fivelines = "".join(lines[max(0, e.context["line"]-3):e.context["line"]+2])
                    err = ValidationError(_(
                        "Error while validating view near:\n\n%(fivelines)s\n%(error)s",
                        fivelines=fivelines, error=tools.ustr(e),
                    ))
                    err.context = e.context
                    raise err.with_traceback(e.__traceback__) from None
                else:
                    err = ValidationError(_(
                        "Error while validating view (%(view)s):\n\n%(error)s", view=self.key or self.id, error=tools.ustr(e.__context__),
                    ))
                    err.context = {'name': 'invalid view'}
                    raise err.with_traceback(e.__context__.__traceback__) from None

        return True

    @api.constrains('type', 'groups_id', 'inherit_id')
    def _check_groups(self):
        for view in self:
            if (view.groups_id and
                view.inherit_id and
                view.mode != 'primary'):
                raise ValidationError(_("Inherited view cannot have 'Groups' define on the record. Use 'groups' attributes inside the view definition"))

    @api.constrains('inherit_id')
    def _check_000_inheritance(self):
        # NOTE: constraints methods are check alphabetically. Always ensure this method will be
        #       called before other constraint methods to avoid infinite loop in `_get_combined_arch`.
        if not self._check_recursion(parent='inherit_id'):
            raise ValidationError(_('You cannot create recursive inherited views.'))

    _sql_constraints = [
        ('inheritance_mode',
         "CHECK (mode != 'extension' OR inherit_id IS NOT NULL)",
         "Invalid inheritance mode: if the mode is 'extension', the view must"
         " extend an other view"),
        ('qweb_required_key',
         "CHECK (type != 'qweb' OR key IS NOT NULL)",
         "Invalid key: QWeb view should have a key"),
    ]

    def _auto_init(self):
        res = super(View, self)._auto_init()
        tools.create_index(self._cr, 'ir_ui_view_model_type_inherit_id',
                           self._table, ['model', 'inherit_id'])
        return res

    def _compute_defaults(self, values):
        if 'inherit_id' in values:
            # Do not automatically change the mode if the view already has an inherit_id,
            # and the user change it to another.
            if not values['inherit_id'] or all(not view.inherit_id for view in self):
                values.setdefault('mode', 'extension' if values['inherit_id'] else 'primary')
        return values

    @api.model_create_multi
    def create(self, vals_list):
        for values in vals_list:
            if 'arch_db' in values and not values['arch_db']:
                # delete empty arch_db to avoid triggering _check_xml before _inverse_arch_base is called
                del values['arch_db']

            if not values.get('type'):
                if values.get('inherit_id'):
                    values['type'] = self.browse(values['inherit_id']).type
                else:

                    try:
                        if not values.get('arch') and not values.get('arch_base'):
                            raise ValidationError(_('Missing view architecture.'))
                        values['type'] = etree.fromstring(values.get('arch') or values.get('arch_base')).tag
                    except LxmlError:
                        # don't raise here, the constraint that runs `self._check_xml` will
                        # do the job properly.
                        pass
            if not values.get('key') and values.get('type') == 'qweb':
                values['key'] = "gen_key.%s" % str(uuid.uuid4())[:6]
            if not values.get('name'):
                values['name'] = "%s %s" % (values.get('model'), values['type'])
            # Create might be called with either `arch` (xml files), `arch_base` (form view) or `arch_db`.
            values['arch_prev'] = values.get('arch_base') or values.get('arch_db') or values.get('arch')
            # write on arch: bypass _inverse_arch()
            if 'arch' in values:
                values['arch_db'] = values.pop('arch')
                if 'install_filename' in self._context:
                    # we store the relative path to the resource instead of the absolute path, if found
                    # (it will be missing e.g. when importing data-only modules using base_import_module)
                    path_info = get_resource_from_path(self._context['install_filename'])
                    if path_info:
                        values['arch_fs'] = '/'.join(path_info[0:2])
                        values['arch_updated'] = False
            values.update(self._compute_defaults(values))

        self.env.registry.clear_cache('templates')
        result = super(View, self.with_context(ir_ui_view_partial_validation=True)).create(vals_list)
        return result.with_env(self.env)

    def write(self, vals):
        # Keep track if view was modified. That will be useful for the --dev mode
        # to prefer modified arch over file arch.
        if 'arch_updated' not in vals and ('arch' in vals or 'arch_base' in vals) and 'install_filename' not in self._context:
            vals['arch_updated'] = True

        # drop the corresponding view customizations (used for dashboards for example), otherwise
        # not all users would see the updated views
        custom_view = self.env['ir.ui.view.custom'].sudo().search([('ref_id', 'in', self.ids)])
        if custom_view:
            custom_view.unlink()

        self.env.registry.clear_cache('templates')
        if 'arch_db' in vals and not self.env.context.get('no_save_prev'):
            vals['arch_prev'] = self.arch_db

        res = super(View, self).write(self._compute_defaults(vals))

        # Check the xml of the view if it gets re-activated.
        # Ideally, `active` shoud have been added to the `api.constrains` of `_check_xml`,
        # but the ORM writes and validates regular field (such as `active`) before inverse fields (such as `arch`),
        # and therefore when writing `active` and `arch` at the same time, `_check_xml` is called twice,
        # and the first time it tries to validate the view without the modification to the arch,
        # which is problematic if the user corrects the view at the same time he re-enables it.
        if vals.get('active'):
            # Call `_validate_fields` instead of `_check_xml` to have the regular constrains error dialog
            # instead of the traceback dialog.
            self._validate_fields(['arch_db'])

        return res

    def unlink(self):
        # if in uninstall mode and has children views, emulate an ondelete cascade
        if self.env.context.get('_force_unlink', False) and self.inherit_children_ids:
            self.inherit_children_ids.unlink()
        self.env.registry.clear_cache('templates')
        return super(View, self).unlink()

    def _update_field_translations(self, fname, translations, digest=None):
        return super(View, self.with_context(no_save_prev=True))._update_field_translations(fname, translations, digest)

    @api.returns('self', lambda value: value.id)
    def copy(self, default=None):
        self.ensure_one()
        if self.key and default and 'key' not in default:
            new_key = self.key + '_%s' % str(uuid.uuid4())[:6]
            default = dict(default or {}, key=new_key)
        return super(View, self).copy(default)

    # default view selection
    @api.model
    def default_view(self, model, view_type):
        """ Fetches the default view for the provided (model, view_type) pair:
         primary view with the lowest priority.

        :param str model:
        :param int view_type:
        :return: id of the default view of False if none found
        :rtype: int
        """
        domain = [('model', '=', model), ('type', '=', view_type), ('mode', '=', 'primary')]
        return self.search(domain, limit=1).id

    #------------------------------------------------------
    # Inheritance mecanism
    #------------------------------------------------------
    @api.model
    def _get_inheriting_views_domain(self):
        """ Return a domain to filter the sub-views to inherit from. """
        return [('active', '=', True)]

    @api.model
    def _get_filter_xmlid_query(self):
        """This method is meant to be overridden by other modules.
        """
        return """SELECT res_id FROM ir_model_data
                  WHERE res_id IN %(res_ids)s AND model = 'ir.ui.view' AND module IN %(modules)s
               """

    def _get_inheriting_views(self):
        """
        Determine the views that inherit from the current recordset, and return
        them as a recordset, ordered by priority then by id.
        """
        self.check_access_rights('read')
        domain = self._get_inheriting_views_domain()
        e = expression(domain, self.env['ir.ui.view'])
        from_clause, where_clause, where_params = e.query.get_sql()
        assert from_clause == '"ir_ui_view"', f"Unexpected from clause: {from_clause}"

        self._flush_search(domain, fields=['inherit_id', 'priority', 'model', 'mode'])
        query = f"""
            WITH RECURSIVE ir_ui_view_inherits AS (
                SELECT id, inherit_id, priority, mode, model
                FROM ir_ui_view
                WHERE id IN %s AND ({where_clause})
            UNION
                SELECT ir_ui_view.id, ir_ui_view.inherit_id, ir_ui_view.priority,
                       ir_ui_view.mode, ir_ui_view.model
                FROM ir_ui_view
                INNER JOIN ir_ui_view_inherits parent ON parent.id = ir_ui_view.inherit_id
                WHERE coalesce(ir_ui_view.model, '') = coalesce(parent.model, '')
                      AND ir_ui_view.mode = 'extension'
                      AND ({where_clause})
            )
            SELECT
                v.id, v.inherit_id, v.mode
            FROM ir_ui_view_inherits v
            ORDER BY v.priority, v.id
        """
        # ORDER BY v.priority, v.id:
        # 1/ sort by priority: abritrary value set by developers on some
        #    views to solve "dependency hell" problems and force a view
        #    to be combined earlier or later. e.g. all views created via
        #    studio have a priority=99 to be loaded last.
        # 2/ sort by view id: the order the views were inserted in the
        #    database. e.g. base views are placed before stock ones.

        self.env.cr.execute(query, [tuple(self.ids)] + where_params + where_params)
        rows = self.env.cr.fetchall()

        views = self.browse(row[0] for row in rows)

        # optimization: fill in cache of inherit_id and mode
        self.env.cache.update(views, self._fields['inherit_id'], [row[1] for row in rows])
        self.env.cache.update(views, self._fields['mode'], [row[2] for row in rows])

        # During an upgrade, we can only use the views that have been
        # fully upgraded already.
        if self.pool._init and not self._context.get('load_all_views'):
            views = views._filter_loaded_views()

        return views

    def _filter_loaded_views(self):
        """
        During the module upgrade phase it may happen that a view is
        present in the database but the fields it relies on are not
        fully loaded yet. This method only considers views that belong
        to modules whose code is already loaded. Custom views defined
        directly in the database are loaded only after the module
        initialization phase is completely finished.
        """
        # check that all found ids have a corresponding xml_id in a loaded module
        check_view_ids = self.env.context['check_view_ids']
        ids_to_check = [vid for vid in self.ids if vid not in check_view_ids]
        if not ids_to_check:
            return self
        loaded_modules = tuple(self.pool._init_modules) + (self._context.get('install_module'),)
        query = self._get_filter_xmlid_query()
        self.env.cr.execute(query, {'res_ids': tuple(ids_to_check), 'modules': loaded_modules})
        valid_view_ids = {r[0] for r in self.env.cr.fetchall()} | set(check_view_ids)
        return self.browse(vid for vid in self.ids if vid in valid_view_ids)

    def _check_view_access(self):
        """ Verify that a view is accessible by the current user based on the
        groups attribute. Views with no groups are considered private.
        """
        if self.inherit_id and self.mode != 'primary':
            return self.inherit_id._check_view_access()
        if self.groups_id & self.env.user.groups_id:
            return True
        if self.groups_id:
            error = _(
                "View '%(name)s' accessible only to groups %(groups)s ",
                name=self.key,
                groups=", ".join([g.name for g in self.groups_id]
            ))
        else:
            error = _("View '%(name)s' is private", name=self.key)
        raise AccessError(error)

    def _raise_view_error(self, message, node=None, *, from_exception=None, from_traceback=None):
        """ Handle a view error by raising an exception.

        :param str message: message to raise or log, augmented with contextual
                            view information
        :param node: the lxml element where the error is located (if any)
        :param BaseException from_exception:
            when raising an exception, chain it to the provided one (default:
            disable chaining)
        :param types.TracebackType from_traceback:
            when raising an exception, start with this traceback (default: start
            at exception creation)
        """
        err = ValueError(message).with_traceback(from_traceback)
        err.context = {
            'view': self,
            'name': getattr(self, 'name', None),
            'xmlid': self.env.context.get('install_xmlid') or self.xml_id,
            'view.model': self.model,
            'view.parent': self.inherit_id,
            'file': self.env.context.get('install_filename'),
            'line': node.sourceline if node is not None else 1,
        }
        raise err from from_exception

    def _log_view_warning(self, message, node):
        """ Handle a view issue by logging a warning.

        :param str message: message to raise or log, augmented with contextual
                            view information
        :param node: the lxml element where the error is located (if any)
        """
        error_context = {
            'view': self,
            'name': getattr(self, 'name', None),
            'xmlid': self.env.context.get('install_xmlid') or self.xml_id,
            'view.model': self.model,
            'view.parent': self.inherit_id,
            'file': self.env.context.get('install_filename'),
            'line': node.sourceline if node is not None else 1,
        }
        _logger.warning(
            "%s\nView error context:\n%s",
            message, pprint.pformat(error_context)
        )

    def locate_node(self, arch, spec):
        """ Locate a node in a source (parent) architecture.

        Given a complete source (parent) architecture (i.e. the field
        `arch` in a view), and a 'spec' node (a node in an inheriting
        view that specifies the location in the source view of what
        should be changed), return (if it exists) the node in the
        source view matching the specification.

        :param arch: a parent architecture to modify
        :param spec: a modifying node in an inheriting view
        :return: a node in the source matching the spec
        """
        return locate_node(arch, spec)

    def inherit_branding(self, specs_tree):
        for node in specs_tree.iterchildren(tag=etree.Element):
            xpath = node.getroottree().getpath(node)
            if node.tag == 'data' or node.tag == 'xpath' or node.get('position'):
                self.inherit_branding(node)
            elif node.get('t-field'):
                node.set('data-oe-xpath', xpath)
                self.inherit_branding(node)
            else:
                node.set('data-oe-id', str(self.id))
                node.set('data-oe-xpath', xpath)
                node.set('data-oe-model', 'ir.ui.view')
                node.set('data-oe-field', 'arch')
        return specs_tree

    def _add_validation_flag(self, combined_arch, view=None, arch=None):
        """ Add a validation flag on elements in ``combined_arch`` or ``arch``.
        This is part of the partial validation of views.

        :param Element combined_arch: the architecture to be modified by ``arch``
        :param view: an optional view inheriting ``self``
        :param Element arch: an optional modifying architecture from inheriting
            view ``view``
        """
        # validate_view_ids is either falsy (no validation), True (full
        # validation) or a collection of ids (partial validation)
        validate_view_ids = self.env.context.get('validate_view_ids')
        if not validate_view_ids:
            return

        if validate_view_ids is True or self.id in validate_view_ids:
            # optimization, flag the root node
            combined_arch.set('__validate__', '1')
            return

        if view is None or view.id not in validate_view_ids:
            return

        for node in arch.xpath('//*[@position]'):
            if node.get('position') in ('after', 'before', 'inside'):
                # validate the elements being inserted, except the ones that
                # specify a move, as in:
                #   <field name="foo" position="after">
                #       <field name="bar" position="move"/>
                #   </field>
                for child in node.iterchildren(tag=etree.Element):
                    if not child.get('position'):
                        child.set('__validate__', '1')
            if node.get('position') == 'replace':
                # validate everything, since this impacts the whole arch
                combined_arch.set('__validate__', '1')
                break
            if node.get('position') == 'attributes':
                # validate the element being modified by adding
                # attribute "__validate__" on it:
                #   <field name="foo" position="attributes">
                #       <attribute name="readonly">1</attribute>
                #       <attribute name="__validate__">1</attribute>    <!-- add this -->
                #   </field>
                node.append(E.attribute('1', name='__validate__'))

    @api.model
    def apply_inheritance_specs(self, source, specs_tree, pre_locate=lambda s: True):
        """ Apply an inheriting view (a descendant of the base view)

        Apply to a source architecture all the spec nodes (i.e. nodes
        describing where and what changes to apply to some parent
        architecture) given by an inheriting view.

        :param Element source: a parent architecture to modify
        :param Element specs_tree: a modifying architecture in an inheriting view
        :param (optional) pre_locate: function that is execute before locating a node.
                                        This function receives an arch as argument.
        :return: a modified source where the specs are applied
        :rtype: Element
        """
        # Queue of specification nodes (i.e. nodes describing where and
        # changes to apply to some parent architecture).
        try:
            source = apply_inheritance_specs(
                source, specs_tree,
                inherit_branding=self._context.get('inherit_branding'),
                pre_locate=pre_locate,
            )
        except ValueError as e:
            self._raise_view_error(str(e), specs_tree)
        return source

    def _combine(self, hierarchy: dict):
        """
        Return self's arch combined with its inherited views archs.

        :param hierarchy: mapping from parent views to their child views
        :return: combined architecture
        :rtype: Element
        """
        self.ensure_one()
        assert self.mode == 'primary'

        # We achieve a pre-order depth-first hierarchy traversal where
        # primary views (and their children) are traversed after all the
        # extensions for the current primary view have been visited.
        #
        # https://en.wikipedia.org/wiki/Tree_traversal#Depth-first_search_of_binary_tree
        #
        # Example:                  hierarchy = {
        #                               1: [2, 3],  # primary view
        #             1*                2: [4, 5],
        #            / \                3: [],
        #           2   3               4: [6],     # primary view
        #          / \                  5: [7, 8],
        #         4*  5                 6: [],
        #        /   / \                7: [],
        #       6   7   8               8: [],
        #                           }
        #
        # Tree traversal order (`view` and `queue` at the `while` stmt):
        #   1 [2, 3]
        #   2 [5, 3, 4]
        #   5 [7, 8, 3, 4]
        #   7 [8, 3, 4]
        #   8 [3, 4]
        #   3 [4]
        #   4 [6]
        #   6 []
        combined_arch = etree.fromstring(self.arch)
        if self.env.context.get('inherit_branding'):
            combined_arch.attrib.update({
                'data-oe-model': 'ir.ui.view',
                'data-oe-id': str(self.id),
                'data-oe-field': 'arch',
            })
        self._add_validation_flag(combined_arch)

        # The depth-first traversal is implemented with a double-ended queue.
        # The queue is traversed from left to right, and after each view in the
        # queue is processed, its children are pushed at the left of the queue,
        # so that they are traversed in order.  The queue is therefore mostly
        # used as a stack.  An exception is made for primary views, which are
        # pushed at the other end of the queue, so that they are applied after
        # all extensions have been applied.
        queue = collections.deque(sorted(hierarchy[self], key=lambda v: v.mode))
        while queue:
            view = queue.popleft()
            arch = etree.fromstring(view.arch)
            if view.env.context.get('inherit_branding'):
                view.inherit_branding(arch)
            self._add_validation_flag(combined_arch, view, arch)
            combined_arch = view.apply_inheritance_specs(combined_arch, arch)

            for child_view in reversed(hierarchy[view]):
                if child_view.mode == 'primary':
                    queue.append(child_view)
                else:
                    queue.appendleft(child_view)

        return combined_arch

    def read_combined(self, fields=None):
        """
        Utility function to get a view combined with its inherited views.

        * Gets the top of the view tree if a sub-view is requested
        * Applies all inherited archs on the root view
        * Returns the view with all requested fields
          .. note:: ``arch`` is always added to the fields list even if not
                    requested (similar to ``id``)
        """
        warnings.warn("use get_combined_arch() instead", DeprecationWarning, stacklevel=2)
        if fields:
            fields = list({'arch', 'model'}.union(fields))
        [result] = self.read(fields)
        result['arch'] = self.get_combined_arch()
        return result

    def get_combined_arch(self):
        """ Return the arch of ``self`` (as a string) combined with its inherited views. """
        return etree.tostring(self._get_combined_arch(), encoding='unicode')

    def _get_combined_arch(self):
        """ Return the arch of ``self`` (as an etree) combined with its inherited views. """
        root = self
        view_ids = []
        while True:
            view_ids.append(root.id)
            if not root.inherit_id:
                break
            root = root.inherit_id

        views = self.browse(view_ids)

        # Add inherited views to the list of loading forced views
        # Otherwise, inherited views could not find elements created in
        # their direct parents if that parent is defined in the same module
        # introduce check_view_ids in context
        if 'check_view_ids' not in views.env.context:
            views = views.with_context(check_view_ids=[])
        views.env.context['check_view_ids'].extend(view_ids)

        # Map each node to its children nodes. Note that all children nodes are
        # part of a single prefetch set, which is all views to combine.
        tree_views = views._get_inheriting_views()
        hierarchy = collections.defaultdict(list)
        for view in tree_views:
            hierarchy[view.inherit_id].append(view)

        # optimization: make root part of the prefetch set, too
        arch = root.with_prefetch(tree_views._prefetch_ids)._combine(hierarchy)
        return arch

    def _get_view_refs(self, node):
        """ Extract the `[view_type]_view_ref` keys and values from the node context attribute,
        giving the views to use for a field node.

        :param node: the field node as an etree
        :return: a dictonary mapping the `[view_type]_view_ref` key to the xmlid of the view to use for that view type.
        """
        if not node.get('context'):
            return {}
        return {
            m.group('view_type'): m.group('view_id')
            for m in ref_re.finditer(node.get('context'))
        }

    #------------------------------------------------------
    # Postprocessing: translation, groups and modifiers
    #------------------------------------------------------
    # TODO: remove group processing from ir_qweb
    #------------------------------------------------------
    def postprocess_and_fields(self, node, model=None, **options):
        """ Return an architecture and a description of all the fields.

        The field description combines the result of fields_get() and
        postprocess().

        :param self: the view to postprocess
        :param node: the architecture as an etree
        :param model: the view's reference model name
        :return: a tuple (arch, fields) where arch is the given node as a
            string and fields is the description of all the fields.

        """
        self and self.ensure_one()      # self is at most one view

        name_manager = self._postprocess_view(node, model or self.model, **options)

        arch = etree.tostring(node, encoding="unicode").replace('\t', '')

        models = {}
        name_managers = [name_manager]
        for name_manager in name_managers:
            models.setdefault(name_manager.model._name, set()).update(name_manager.available_fields)
            name_managers.extend(name_manager.children)
        return arch, models

    def _postprocess_access_rights(self, tree):
        """
        Apply group restrictions: elements with a 'groups' attribute should
        be removed from the view to people who are not members.

        Compute and set on node access rights based on view type. Specific
        views can add additional specific rights like creating columns for
        many2one-based grouping views.
        """

        for node in tree.xpath('//*[@groups]'):
            attrib_groups = node.attrib.pop('groups')
            if attrib_groups and not self.user_has_groups(attrib_groups):
                node.getparent().remove(node)
            elif node.tag == 't' and (not node.attrib or node.get('postprocess_added')):
                # Move content of <t groups=""> blocks
                # and remove the <t> node.
                # This is to keep the structure
                # <group>
                #   <field name="foo"/>
                #   <field name="bar"/>
                # <group>
                # so the web client adds the label as expected.
                # This is also to avoid having <t> nodes in tree views
                # e.g.
                # <tree>
                #   <field name="foo"/>
                #   <t groups="foo">
                #     <field name="bar" groups="bar"/>
                #   </t>
                # </tree>
                for child in reversed(node):
                    node.addnext(child)
                node.getparent().remove(node)

        base_model = tree.get('model_access_rights')
        for node in tree.xpath('//*[@model_access_rights]'):
            model = self.env[node.attrib.pop('model_access_rights')]
            if node.tag == 'field':
                can_create = model.check_access_rights('create', raise_exception=False)
                can_write = model.check_access_rights('write', raise_exception=False)
                node.set('can_create', str(bool(can_create)))
                node.set('can_write', str(bool(can_write)))
            else:
                is_base_model = base_model == model._name
                for action, operation in (('create', 'create'), ('delete', 'unlink'), ('edit', 'write')):
                    if not node.get(action) and not model.check_access_rights(operation, raise_exception=False):
                        node.set(action, 'False')
                if node.tag == 'kanban':
                    group_by_name = node.get('default_group_by')
                    group_by_field = model._fields.get(group_by_name)
                    if group_by_field and group_by_field.type == 'many2one':
                        group_by_model = model.env[group_by_field.comodel_name]
                        for action, operation in (('group_create', 'create'), ('group_delete', 'unlink'), ('group_edit', 'write')):
                            if not node.get(action) and not group_by_model.check_access_rights(operation, raise_exception=False):
                                node.set(action, 'False')

        return tree

    def _postprocess_view(self, node, model_name, editable=True, parent_name_manager=None, **options):
        """ Process the given architecture, modifying it in-place to add and
        remove stuff.

        :param self: the optional view to postprocess
        :param node: the combined architecture as an etree
        :param model_name: the view's reference model name
        :param editable: whether the view is considered editable
        :return: the processed architecture's NameManager
        """
        root = node

        if model_name not in self.env:
            self._raise_view_error(_('Model not found: %(model)s', model=model_name), root)
        model = self.env[model_name]

        if self._onchange_able_view(root):
            self._postprocess_on_change(root, model)

        name_manager = NameManager(model, parent=parent_name_manager)

        root_info = {
            'view_type': root.tag,
            'view_editable': editable and self._editable_node(root, name_manager),
            'mobile': options.get('mobile'),
        }

        # use a stack to recursively traverse the tree
        stack = [(root, editable)]
        while stack:
            node, editable = stack.pop()

            # compute default
            tag = node.tag
            had_parent = node.getparent() is not None
            node_info = dict(root_info, editable=editable and self._editable_node(node, name_manager))

            # tag-specific postprocessing
            postprocessor = getattr(self, f"_postprocess_tag_{tag}", None)
            if postprocessor is not None:
                postprocessor(node, name_manager, node_info)
                if had_parent and node.getparent() is None:
                    # the node has been removed, stop processing here
                    continue

            # if present, iterate on node_info['children'] instead of node
            for child in reversed(node_info.get('children', node)):
                stack.append((child, node_info['editable']))

        name_manager.update_available_fields()
        root.set('model_access_rights', model._name)

        return name_manager

    def _postprocess_on_change(self, arch, model):
        """ Add attribute on_change="1" on fields that are dependencies of
            computed fields on the same view.
        """
        # map each field object to its corresponding nodes in arch
        field_nodes = collections.defaultdict(list)

        def collect(node, model):
            if node.tag == 'field':
                field = model._fields.get(node.get('name'))
                if field:
                    field_nodes[field].append(node)
                    if field.relational:
                        model = self.env[field.comodel_name]
            for child in node:
                collect(child, model)

        collect(arch, model)

        for field, nodes in field_nodes.items():
            # if field should trigger an onchange, add on_change="1" on the
            # nodes referring to field
            model = self.env[field.model_name]
            if model._has_onchange(field, field_nodes):
                for node in nodes:
                    if not node.get('on_change'):
                        node.set('on_change', '1')

    def _get_x2many_missing_view_archs(self, field, field_node, node_info):
        """
        For x2many fields that require to have some multi-record arch (kanban or list) to display the records
        be available, this function fetches all arch that are needed and return them.
        The caller function is responsible to do what it needs with them.
        """
        current_view_types = [el.tag for el in field_node.xpath("./*[descendant::field]")]
        missing_view_types = []
        if not any(view_type in current_view_types for view_type in field_node.get('mode', 'kanban,tree').split(',')):
            missing_view_types.append(
                field_node.get('mode', 'kanban' if node_info.get('mobile') else 'tree').split(',')[0]
            )

        if not missing_view_types:
            return []

        comodel = self.env[field.comodel_name].sudo(False)
        refs = self._get_view_refs(field_node)
        # Do not propagate <view_type>_view_ref of parent call to `_get_view`
        comodel = comodel.with_context(**{
            f'{view_type}_view_ref': refs.get(f'{view_type}_view_ref')
            for view_type in missing_view_types
        })

        return [comodel._get_view(view_type=view_type) for view_type in missing_view_types]

    #------------------------------------------------------
    # Specific node postprocessors
    #------------------------------------------------------
    def _postprocess_tag_calendar(self, node, name_manager, node_info):
        for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day'):
            if node.get(additional_field):
                name_manager.has_field(node, node.get(additional_field).split('.', 1)[0])
        for f in node:
            if f.tag == 'filter':
                name_manager.has_field(node, f.get('name'))

    def _postprocess_tag_field(self, node, name_manager, node_info):
        if node.get('name'):
            attrs = {'id': node.get('id'), 'select': node.get('select')}
            field = name_manager.model._fields.get(node.get('name'))
            if field:
                if field.groups:
                    if node.get('groups'):
                        # if the node has a group (e.g. "base.group_no_one")
                        # and the field in the Python model has a group as well (e.g. "base.group_system")
                        # the user must have both group to see the field.
                        # groups="base.group_no_one,base.group_system" directly on the node
                        # would be one of the two groups, not both (OR instead of AND).
                        # To make mandatory to have both groups, wrap the field node in a <t> node with the group
                        # set on the field in the Python model
                        # e.g. <t groups="base.group_system"><field name="foo" groups="base.group_no_one"/></t>
                        # The <t> node will be removed later, in _postprocess_access_rights.
                        node_t = E.t(groups=field.groups, postprocess_added='1')
                        node.getparent().replace(node, node_t)
                        node_t.append(node)
                    else:
                        node.set('groups', field.groups)
                if (
                    node_info.get('view_type') == 'form'
                    and field.type in ('one2many', 'many2many')
                    and not node.get('widget')
                    and node.get('invisible') not in ('1', 'True')
                    and not name_manager.parent
                ):
                    # Embed kanban/tree/form views for visible x2many fields in form views
                    # if no widget or the widget requires it.
                    # So the web client doesn't have to call `get_views` for x2many fields not embedding their view
                    # in the main form view.
                    for arch, _view in self._get_x2many_missing_view_archs(field, node, node_info):
                        node.append(arch)

                for child in node:
                    if child.tag in ('form', 'tree', 'graph', 'kanban', 'calendar'):
                        node_info['children'] = []
                        self._postprocess_view(
                            child, field.comodel_name, editable=node_info['editable'], parent_name_manager=name_manager,
                        )
                if node_info['editable'] and field.type in ('many2one', 'many2many'):
                    node.set('model_access_rights', field.comodel_name)

            name_manager.has_field(node, node.get('name'), attrs)

    def _postprocess_tag_form(self, node, name_manager, node_info):
        result = name_manager.model.view_header_get(False, node.tag)
        if result:
            node.set('string', result)

    def _postprocess_tag_groupby(self, node, name_manager, node_info):
        # groupby nodes should be considered as nested view because they may
        # contain fields on the comodel
        name = node.get('name')
        field = name_manager.model._fields.get(name)
        if not field or not field.comodel_name:
            return
        # post-process the node as a nested view, and associate it to the field
        self._postprocess_view(node, field.comodel_name, editable=False, parent_name_manager=name_manager)
        name_manager.has_field(node, name)

    def _postprocess_tag_label(self, node, name_manager, node_info):
        if node.get('for'):
            field = name_manager.model._fields.get(node.get('for'))
            if field and field.groups:
                if node.get('groups'):
                    # See the comment for this in `_postprocess_tag_field`
                    node_t = E.t(groups=field.groups, postprocess_added="1")
                    node.getparent().replace(node, node_t)
                    node_t.append(node)
                else:
                    node.set('groups', field.groups)

    def _postprocess_tag_search(self, node, name_manager, node_info):
        searchpanel = [child for child in node if child.tag == 'searchpanel']
        if searchpanel:
            self._postprocess_view(
                searchpanel[0], name_manager.model._name, editable=False, parent_name_manager=name_manager
            )
            node_info['children'] = [child for child in node if child.tag != 'searchpanel']

    def _postprocess_tag_tree(self, node, name_manager, node_info):
        # reuse form view post-processing
        self._postprocess_tag_form(node, name_manager, node_info)

    #-------------------------------------------------------------------
    # view editability
    #-------------------------------------------------------------------

    def _editable_node(self, node, name_manager):
        """ Return whether the given node must be considered editable. """
        func = getattr(self, f"_editable_tag_{node.tag}", None)
        if func is not None:
            return func(node, name_manager)
        # by default views are non-editable
        return node.tag not in (item[0] for item in self._fields['type'].selection)

    def _editable_tag_form(self, node, name_manager):
        return True

    def _editable_tag_tree(self, node, name_manager):
        return node.get('editable') or node.get('multi_edit')

    def _editable_tag_field(self, node, name_manager):
        field = name_manager.model._fields.get(node.get('name'))
        return field is None or field.is_editable() and node.get('readonly') not in ('1', 'True')

    def _onchange_able_view(self, node):
        func = getattr(self, f"_onchange_able_view_{node.tag}", None)
        if func is not None:
            return func(node)

    def _onchange_able_view_form(self, node):
        return True

    def _onchange_able_view_tree(self, node):
        return True

    def _onchange_able_view_kanban(self, node):
        return True

    def _modifiers_from_model(self, node):
        modifier_names = []
        if node.tag in ('kanban', 'tree', 'form'):
            modifier_names += ['readonly', 'required']
        return modifier_names

    #-------------------------------------------------------------------
    # view validation
    #-------------------------------------------------------------------

    def _validate_view(self, node, model_name, view_type=None, editable=True, full=False):
        """ Validate the given architecture node, and return its corresponding
        NameManager.

        :param self: the view being validated
        :param node: the combined architecture as an etree
        :param model_name: the reference model name for the given architecture
        :param editable: whether the view is considered editable
        :param full: whether the whole view must be validated
        :return: the combined architecture's NameManager
        """
        self.ensure_one()

        view_type = view_type or self.type
        if node.tag != view_type:
            self._raise_view_error(_(
                'The root node of a %(view_type)s view should be a <%(view_type)s>, not a <%(tag)s>',
                view_type=view_type, tag=node.tag,
            ), node)

        if model_name not in self.env:
            self._raise_view_error(_('Model not found: %(model)s', model=model_name), node)

        # fields_get() optimization: validation does not require translations
        model = self.env[model_name].with_context(lang=None)
        name_manager = NameManager(model)

        view_type = node.tag
        # use a stack to recursively traverse the tree
        stack = [(node, editable, full)]
        while stack:
            node, editable, validate = stack.pop()

            # compute default
            tag = node.tag
            validate = validate or node.get('__validate__')
            node_info = {
                'editable': editable and self._editable_node(node, name_manager),
                'validate': validate,
                'view_type': view_type,
            }

            # tag-specific validation
            validator = getattr(self, f"_validate_tag_{tag}", None)
            if validator is not None:
                validator(node, name_manager, node_info)

            if validate:
                self._validate_attributes(node, name_manager, node_info)

            for child in reversed(node):
                stack.append((child, node_info['editable'], validate))

        name_manager.check(self)

        return name_manager

    #------------------------------------------------------
    # Node validator
    #------------------------------------------------------
    def _validate_tag_form(self, node, name_manager, node_info):
        pass

    def _validate_tag_tree(self, node, name_manager, node_info):
        # reuse form view validation
        self._validate_tag_form(node, name_manager, node_info)
        if not node_info['validate']:
            return
        allowed_tags = ('field', 'button', 'control', 'groupby', 'widget', 'header')
        for child in node.iterchildren(tag=etree.Element):
            if child.tag not in allowed_tags and not isinstance(child, etree._Comment):
                msg = _(
                    'Tree child can only have one of %(tags)s tag (not %(wrong_tag)s)',
                    tags=', '.join(allowed_tags), wrong_tag=child.tag,
                )
                self._raise_view_error(msg, child)

    def _validate_tag_graph(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        for child in node.iterchildren(tag=etree.Element):
            if child.tag != 'field' and not isinstance(child, etree._Comment):
                msg = _('A <graph> can only contains <field> nodes, found a <%s>', child.tag)
                self._raise_view_error(msg, child)

    def _validate_tag_calendar(self, node, name_manager, node_info):
        for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day'):
            if node.get(additional_field):
                name_manager.has_field(node, node.get(additional_field).split('.', 1)[0])
        for f in node:
            if f.tag == 'filter':
                name_manager.has_field(node, f.get('name'))

    def _validate_tag_search(self, node, name_manager, node_info):
        if node_info['validate'] and not node.iterdescendants(tag="field"):
            # the field of the search view may be within a group node, which is why we must check
            # for all descendants containing a node with a field tag, if this is not the case
            # then a search is not possible.
            self._log_view_warning('Search tag requires at least one field element', node)

        searchpanels = [child for child in node if child.tag == 'searchpanel']
        if searchpanels:
            if len(searchpanels) > 1:
                self._raise_view_error(_('Search tag can only contain one search panel'), node)
            node.remove(searchpanels[0])
            self._validate_view(searchpanels[0], name_manager.model._name, view_type="searchpanel",
                                editable=False, full=node_info['validate'])

    def _validate_tag_field(self, node, name_manager, node_info):
        validate = node_info['validate']

        name = node.get('name')
        if not name:
            self._raise_view_error(_("Field tag must have a \"name\" attribute defined"), node)

        field = name_manager.model._fields.get(name)
        if field:
            if validate and field.relational:
                domain = (
                    node.get('domain')
                    or node_info['editable'] and field._description_domain(self.env)
                )
                if isinstance(domain, str):
                    # dynamic domain: in [('foo', '=', bar)], field 'foo' must
                    # exist on the comodel and field 'bar' must be in the view
                    desc = (f'domain of <field name="{name}">' if node.get('domain')
                            else f"domain of python field {name!r}")
                    try:
                        self._validate_domain_identifiers(node, name_manager, domain, desc, field.comodel_name)
                    except ValueError as e:
                        if 'Modifier must be a domain' in str(e):
                            warnings.warn(f"Non-domain syntaxes are deprecated for attribute 'domain': {desc}\n{domain!r}", DeprecationWarning, 2)
                        else:
                            raise

            elif validate and node.get('domain'):
                msg = _(
                    'Domain on non-relational field "%(name)s" makes no sense (domain:%(domain)s)',
                    name=name, domain=node.get('domain'),
                )
                self._raise_view_error(msg, node)

            for child in node:
                if child.tag not in ('form', 'tree', 'graph', 'kanban', 'calendar'):
                    continue
                node.remove(child)
                sub_manager = self._validate_view(
                    child, field.comodel_name, view_type=child.tag, editable=node_info['editable'], full=validate,
                )
                for fname, groups_uses in sub_manager.mandatory_parent_fields.items():
                    for groups, use in groups_uses.items():
                        name_manager.must_have_field(node, fname, use, groups=groups)

        elif validate and name not in name_manager.field_info:
            msg = _(
                'Field "%(field_name)s" does not exist in model "%(model_name)s"',
                field_name=name, model_name=name_manager.model._name,
            )
            self._raise_view_error(msg, node)

        name_manager.has_field(node, name, {'id': node.get('id'), 'select': node.get('select')})

    def _validate_tag_filter(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        domain = node.get('domain')
        if domain:
            name = node.get('name')
            desc = f'domain of <filter name="{name}">' if name else 'domain of <filter>'
            self._validate_domain_identifiers(node, name_manager, domain, desc, name_manager.model._name)

    def _validate_tag_button(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        name = node.get('name')
        special = node.get('special')
        type_ = node.get('type')
        if special:
            if special not in ('cancel', 'save', 'add'):
                self._raise_view_error(_("Invalid special '%(value)s' in button", value=special), node)
        elif type_:
            if type_ == 'edit': # list_renderer, used in kanban view
                return
            elif not name:
                self._raise_view_error(_("Button must have a name"), node)
            elif type_ == 'object':
                func = getattr(name_manager.model, name, None)
                if not func:
                    msg = _(
                        "%(action_name)s is not a valid action on %(model_name)s",
                        action_name=name, model_name=name_manager.model._name,
                    )
                    self._raise_view_error(msg, node)
                try:
                    check_method_name(name)
                except AccessError:
                    msg = _(
                        "%(method)s on %(model)s is private and cannot be called from a button",
                        method=name, model=name_manager.model._name,
                    )
                    self._raise_view_error(msg, node)
                try:
                    inspect.signature(func).bind()
                except TypeError:
                    msg = "%s on %s has parameters and cannot be called from a button"
                    self._log_view_warning(msg % (name, name_manager.model._name), node)
            elif type_ == 'action':
                name_manager.must_exist_action(name, node)

            name_manager.has_action(name)

        if node.get('icon'):
            description = 'A button with icon attribute (%s)' % node.get('icon')
            self._validate_fa_class_accessibility(node, description)

    def _validate_tag_groupby(self, node, name_manager, node_info):
        # groupby nodes should be considered as nested view because they may
        # contain fields on the comodel
        name = node.get('name')
        if not name:
            return
        field = name_manager.model._fields.get(name)
        if field:
            if node_info['validate']:
                if field.type != 'many2one':
                    msg = _(
                        "Field '%(name)s' found in 'groupby' node can only be of type many2one, found %(type)s",
                        name=field.name, type=field.type,
                    )
                    self._raise_view_error(msg, node)
                domain = node_info['editable'] and field._description_domain(self.env)
                if isinstance(domain, str):
                    desc = f"domain of python field '{name}'"
                    self._validate_domain_identifiers(node, name_manager, domain, desc, field.comodel_name)

            # move all children nodes into a new node <groupby>
            groupby_node = E.groupby(*node)
            # validate the node as a nested view
            sub_manager = self._validate_view(
                groupby_node, field.comodel_name, view_type="groupby", editable=False, full=node_info['validate'],
            )
            name_manager.has_field(node, name)
            for fname, groups_uses in sub_manager.mandatory_parent_fields.items():
                for groups, use in groups_uses.items():
                    name_manager.must_have_field(node, fname, use, groups=groups)

        elif node_info['validate']:
            msg = _(
                "Field '%(field)s' found in 'groupby' node does not exist in model %(model)s",
                field=name, model=name_manager.model._name,
            )
            self._raise_view_error(msg, node)

    def _validate_tag_searchpanel(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        for child in node.iterchildren(tag=etree.Element):
            if child.get('domain') and child.get('select') != 'multi':
                msg = _('Searchpanel item with select multi cannot have a domain.')
                self._raise_view_error(msg, child)

    def _validate_tag_label(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        # replace return not arch.xpath('//label[not(@for) and not(descendant::input)]')
        for_ = node.get('for')
        if not for_:
            msg = _('Label tag must contain a "for". To match label style '
                    'without corresponding field or button, use \'class="o_form_label"\'.')
            self._raise_view_error(msg, node)
        else:
            name_manager.must_have_name(for_, '<label for="...">')

    def _validate_tag_page(self, node, name_manager, node_info):
        if not node_info['validate']:
            return
        if node.getparent() is None or node.getparent().tag != 'notebook':
            self._raise_view_error(_('Page direct ancestor must be notebook'), node)

    def _validate_tag_img(self, node, name_manager, node_info):
        if node_info['validate'] and not any(node.get(alt) for alt in att_names('alt')):
            self._log_view_warning('<img> tag must contain an alt attribute', node)

    def _validate_tag_a(self, node, name_manager, node_info):
        #('calendar', 'form', 'graph', 'kanban', 'pivot', 'search', 'tree', 'activity')
        if node_info['validate'] and any('btn' in node.get(cl, '') for cl in att_names('class')):
            if node.get('role') != 'button':
                msg = '"<a>" tag with "btn" class must have "button" role'
                self._log_view_warning(msg, node)

    def _validate_tag_ul(self, node, name_manager, node_info):
        if node_info['validate']:
            # was applied to all nodes, but in practice only used on div and ul
            self._check_dropdown_menu(node)

    def _validate_tag_div(self, node, name_manager, node_info):
        if node_info['validate']:
            self._check_dropdown_menu(node)
            self._check_progress_bar(node)

    #------------------------------------------------------
    # Validation tools
    #------------------------------------------------------

    def _check_dropdown_menu(self, node):
        #('calendar', 'form', 'graph', 'kanban', 'pivot', 'search', 'tree', 'activity')
        if any('dropdown-menu' in node.get(cl, '') for cl in att_names('class')):
            if node.get('role') != 'menu':
                msg = 'dropdown-menu class must have menu role'
                self._log_view_warning(msg, node)

    def _check_progress_bar(self, node):
        if any('o_progressbar' in node.get(cl, '') for cl in att_names('class')):
            if node.get('role') != 'progressbar':
                msg = 'o_progressbar class must have progressbar role'
                self._log_view_warning(msg, node)
            if not any(node.get(at) for at in att_names('aria-valuenow')):
                msg = 'o_progressbar class must have aria-valuenow attribute'
                self._log_view_warning(msg, node)
            if not any(node.get(at) for at in att_names('aria-valuemin')):
                msg = 'o_progressbar class must have aria-valuemin attribute'
                self._log_view_warning(msg, node)
            if not any(node.get(at) for at in att_names('aria-valuemax')):
                msg = 'o_progressbar class must have aria-valuemaxattribute'
                self._log_view_warning(msg, node)

    def _is_qweb_based_view(self, view_type):
        return view_type in ("kanban", "gantt")

    def _validate_attributes(self, node, name_manager, node_info):
        """ Generic validation of node attributes. """

        # python expression used in for readonly, invisible, ...
        # and thus are only executed client side
        for attr in VIEW_MODIFIERS:
            py_expression = node.attrib.get(attr)
            if py_expression:
                self._validate_expression(node, name_manager, py_expression, f"modifier {attr!r}")

        for attr, expr in node.items():
            if attr in ('class', 't-att-class', 't-attf-class'):
                self._validate_classes(node, expr)

            elif attr == 'context':
                try:
                    vnames = get_expression_field_names(expr) - {'id'}
                except SyntaxError as e:
                    message = _('Invalid context: %(expr)r is not a valid Python expression \n\n %(e)s', expr=expr, e=e)
                    self._raise_view_error(message)
                if vnames:
                    name_manager.must_have_fields(node, vnames, f"context ({expr})")
                for key, val_ast in get_dict_asts(expr).items():
                    if key == 'group_by':  # only in context
                        if not isinstance(val_ast, ast.Constant) or not isinstance(val_ast.value, str):
                            msg = _(
                                '"group_by" value must be a string %(attribute)s=%(value)r',
                                attribute=attr, value=expr,
                            )
                            self._raise_view_error(msg, node)
                        group_by = val_ast.value
                        fname = group_by.split(':')[0]
                        if fname not in name_manager.model._fields:
                            msg = _(
                                'Unknown field "%(field)s" in "group_by" value in %(attribute)s=%(value)r',
                                field=fname, attribute=attr, value=expr,
                            )
                            self._raise_view_error(msg, node)

            elif attr == 'groups':
                for group in expr.replace('!', '').split(','):
                    name_manager.must_exist_group(group.strip(), node)

            elif attr in ('col', 'colspan'):
                # col check is mainly there for the tag 'group', but previous
                # check was generic in view form
                if not expr.isdigit():
                    self._raise_view_error(
                        _('%(attribute)r value must be an integer (%(value)s)',
                          attribute=attr, value=expr),
                        node,
                    )

            elif attr.startswith('decoration-'):
                vnames = get_expression_field_names(expr) - {'id'}
                if vnames:
                    name_manager.must_have_fields(node, vnames, f"{attr}={expr!r}")

            elif attr == 'data-bs-toggle' and expr == 'tab':
                if node.get('role') != 'tab':
                    msg = 'tab link (data-bs-toggle="tab") must have "tab" role'
                    self._log_view_warning(msg, node)
                aria_control = node.get('aria-controls') or node.get('t-att-aria-controls')
                if not aria_control and not node.get('t-attf-aria-controls'):
                    msg = 'tab link (data-bs-toggle="tab") must have "aria_control" defined'
                    self._log_view_warning(msg, node)
                if aria_control and '#' in aria_control:
                    msg = 'aria-controls in tablink cannot contains "#"'
                    self._log_view_warning(msg, node)

            elif attr == "role" and expr in ('presentation', 'none'):
                msg = ("A role cannot be `none` or `presentation`. "
                    "All your elements must be accessible with screen readers, describe it.")
                self._log_view_warning(msg, node)

            elif attr == 'group':
                msg = "attribute 'group' is not valid.  Did you mean 'groups'?"
                self._log_view_warning(msg, node)

            elif (re.match(r'^(t\-att\-|t\-attf\-)?data-tooltip(-template|-info)?$', attr)):
                self._raise_view_error(_("Forbidden attribute used in arch (%s).", attr), node)

            elif (attr.startswith("t-")):
                self._validate_qweb_directive(node, attr, node_info["view_type"])
                if (re.search(COMP_REGEX, expr)):
                    self._raise_view_error(_("Forbidden use of `__comp__` in arch."), node)

    def _validate_classes(self, node, expr):
        """ Validate the classes present on node. """
        classes = set(expr.split(' '))
        # Be careful: not always true if it is an expression
        # example: <div t-attf-class="{{!selection_mode ? 'oe_kanban_color_' + kanban_getcolor(record.color.raw_value) : ''}} oe_kanban_card oe_kanban_global_click oe_applicant_kanban oe_semantic_html_override">
        if 'modal' in classes and node.get('role') != 'dialog':
            msg = '"modal" class should only be used with "dialog" role'
            self._log_view_warning(msg, node)

        if 'modal-header' in classes and node.tag != 'header':
            msg = '"modal-header" class should only be used in "header" tag'
            self._log_view_warning(msg, node)

        if 'modal-body' in classes and node.tag != 'main':
            msg = '"modal-body" class should only be used in "main" tag'
            self._log_view_warning(msg, node)

        if 'modal-footer' in classes and node.tag != 'footer':
            msg = '"modal-footer" class should only be used in "footer" tag'
            self._log_view_warning(msg, node)

        if 'tab-pane' in classes and node.get('role') != 'tabpanel':
            msg = '"tab-pane" class should only be used with "tabpanel" role'
            self._log_view_warning(msg, node)

        if 'nav-tabs' in classes and node.get('role') != 'tablist':
            msg = 'A tab list with class nav-tabs must have role="tablist"'
            self._log_view_warning(msg, node)

        if any(klass.startswith('alert-') for klass in classes):
            if (
                node.get('role') not in ('alert', 'alertdialog', 'status')
                and 'alert-link' not in classes
            ):
                msg = ("An alert (class alert-*) must have an alert, alertdialog or "
                        "status role or an alert-link class. Please use alert and "
                        "alertdialog only for what expects to stop any activity to "
                        "be read immediately.")
                self._log_view_warning(msg, node)

        if any(klass.startswith('fa-') for klass in classes):
            description = 'A <%s> with fa class (%s)' % (node.tag, expr)
            self._validate_fa_class_accessibility(node, description)

        if any(klass.startswith('btn') for klass in classes):
            if node.tag in ('a', 'button', 'select'):
                pass
            elif node.tag == 'input' and node.get('type') in ('button', 'submit', 'reset'):
                pass
            elif any(klass in classes for klass in ('btn-group', 'btn-toolbar', 'btn-addr')):
                pass
            else:
                msg = ("A simili button must be in tag a/button/select or tag `input` "
                        "with type button/submit/reset or have class in "
                        "btn-group/btn-toolbar/btn-addr")
                self._log_view_warning(msg, node)

    def _validate_fa_class_accessibility(self, node, description):
        valid_aria_attrs = {
            *att_names('title'), *att_names('aria-label'), *att_names('aria-labelledby'),
        }
        valid_t_attrs = {'t-value', 't-raw', 't-field', 't-esc', 't-out'}

        ## Following or preceding text
        if (node.tail or '').strip() or (node.getparent().text or '').strip():
            # text<i class="fa-..."/> or <i class="fa-..."/>text or
            return

        ## Following or preceding text in span
        def has_text(elem):
            if elem is None:
                return False
            if elem.tag == 'span' and elem.text:
                return True
            if elem.tag == 't' and (elem.get('t-esc') or elem.get('t-raw')):
                return True
            return False

        if has_text(node.getnext()) or has_text(node.getprevious()):
            return

        def has_title_or_aria_label(node):
            return any(node.get(attr) for attr in valid_aria_attrs)

        ## Aria label can be on ancestors
        if any(map(has_title_or_aria_label, node.iterancestors())):
            return

        if node.get('string'):
            return

        ## And we ignore all elements with describing in children
        def contains_description(node, depth=0):
            if depth > 2:
                _logger.warning('excessive depth in fa')
            if any(node.get(attr) for attr in valid_t_attrs):
                return True
            if has_title_or_aria_label(node):
                return True
            if node.tag in ('label', 'field'):
                return True
            if node.text:  # not sure, does it match *[text()]
                return True
            return any(contains_description(child, depth+1) for child in node)

        if contains_description(node):
            return

        msg = '%s must have title in its tag, parents, descendants or have text'
        self._log_view_warning(msg % description, node)

    def _validate_qweb_directive(self, node, directive, view_type):
        """Some views (e.g. kanban, form) generate owl templates from the archs.
        However, we don't want to see owl directives directly written in archs.
        There are exceptions though, since the kanban and gantt archs define qweb templates.
        We thus here validate that the given directive is allowed, according to the view_type.
        """
        allowed_directives = ["t-translation"]
        if self._is_qweb_based_view(view_type):
            allowed_directives.extend([
                "t-name",
                "t-esc",
                "t-out",
                "t-set",
                "t-value",
                "t-if",
                "t-else",
                "t-elif",
                "t-foreach",
                "t-as",
                "t-key",
                "t-att.*",
                "t-call",
                "t-debug",
            ])
        if (not next(filter(lambda regex: re.match(regex, directive), allowed_directives), None)):
            self._raise_view_error(_("Forbidden owl directive used in arch (%s).", directive), node)

    def _validate_expression(self, node, name_manager, py_expression, use):
        try:
            if py_expression.lower() in ("0", "false", "1", "true"):
                # most (~95%) elements are 1/True/0/False
                return
            fnames = get_expression_field_names(py_expression) - {"id"}
        except (SyntaxError, ValueError, AttributeError) as e:
            msg = _("Invalid %(use)s: %(expr)r\n%(error)s", use=use, expr=py_expression, error=e)
            self._raise_view_error(msg, node, from_exception=e)
        name_manager.must_have_fields(node, fnames, f"{use} ({py_expression})")

    def _validate_domain_identifiers(self, node, name_manager, domain, use, target_model):
        try:
            fnames, vnames = get_domain_value_names(domain)
        except (SyntaxError, ValueError, AttributeError) as e:
            msg = _("Invalid %(use)s: %(expr)r\n%(error)s", use=use, expr=domain, error=e)
            self._raise_view_error(msg, node, from_exception=e)

        self._check_field_paths(node, fnames, target_model, f"{use} ({domain})")
        name_manager.must_have_fields(node, vnames, f"{use} ({domain})")

    def _check_field_paths(self, node, field_paths, model_name, use):
        """ Check whether the given field paths (dot-separated field names)
        correspond to actual sequences of fields on the given model.
        """
        for field_path in field_paths:
            names = field_path.split('.')
            Model = self.pool[model_name]
            if names[0] == 'parent':
                continue
            for index, name in enumerate(names):
                if Model is None:
                    msg = _(
                        'Non-relational field %(field)r in path %(field_path)r in %(use)s)',
                        field=names[index - 1], field_path=field_path, use=use,
                    )
                    self._raise_view_error(msg, node)
                try:
                    field = Model._fields[name]
                except KeyError:
                    msg = _(
                        'Unknown field "%(model)s.%(field)s" in %(use)s)',
                        model=Model._name, field=name, use=use,
                    )
                    self._raise_view_error(msg, node)
                if not field._description_searchable:
                    msg = _(
                        'Unsearchable field %(field)r in path %(field_path)r in %(use)s)',
                        field=name, field_path=field_path, use=use,
                    )
                    self._raise_view_error(msg, node)
                Model = self.pool.get(field.comodel_name)

    #------------------------------------------------------
    # QWeb template views
    #------------------------------------------------------

    def _read_template_keys(self):
        """ Return the list of context keys to use for caching ``_read_template``. """
        return ['lang', 'inherit_branding', 'edit_translations']

    @api.model
    def _read_template(self, view_id):
        arch_tree = self.browse(view_id)._get_combined_arch()
        self.distribute_branding(arch_tree)
        return etree.tostring(arch_tree, encoding='unicode')

    @api.model
    def _get_view_id(self, template):
        """ Return the view ID corresponding to ``template``, which may be a
        view ID or an XML ID. Note that this method may be overridden for other
        kinds of template values.
        """
        if isinstance(template, int):
            return template
        if '.' not in template:
            raise ValueError('Invalid template id: %r' % template)
        view = self.sudo().search([('key', '=', template)], limit=1)
        if view:
            return view.id
        res_model, res_id = self.env['ir.model.data']._xmlid_to_res_model_res_id(template, raise_if_not_found=True)
        assert res_model == self._name, "Call _get_view_id, expected %r, got %r" % (self._name, res_model)
        return res_id

    @api.model
    def _get(self, view_ref):
        """ Return the view corresponding to ``view_ref``, which may be a
        view ID or an XML ID.
        """
        return self.browse(self._get_view_id(view_ref))

    def _contains_branded(self, node):
        return node.tag == 't'\
            or 't-raw' in node.attrib\
            or 't-call' in node.attrib\
            or any(self.is_node_branded(child) for child in node.iterdescendants())

    def _pop_view_branding(self, element):
        distributed_branding = dict(
            (attribute, element.attrib.pop(attribute))
            for attribute in MOVABLE_BRANDING
            if element.get(attribute))
        return distributed_branding

    def distribute_branding(self, e, branding=None, parent_xpath='',
                            index_map=ConstantMapping(1)):
        if e.get('t-ignore') or e.tag == 'head':
            # remove any view branding possibly injected by inheritance
            attrs = set(MOVABLE_BRANDING)
            for descendant in e.iterdescendants(tag=etree.Element):
                if not attrs.intersection(descendant.attrib):
                    continue
                self._pop_view_branding(descendant)

            # Remove the processing instructions indicating where nodes were
            # removed (see apply_inheritance_specs)
            for descendant in e.iterdescendants(tag=etree.ProcessingInstruction):
                if descendant.target == 'apply-inheritance-specs-node-removal':
                    descendant.getparent().remove(descendant)
            return

        node_path = e.get('data-oe-xpath')
        if node_path is None:
            node_path = "%s/%s[%d]" % (parent_xpath, e.tag, index_map[e.tag])
        if branding:
            if e.get('t-field'):
                e.set('data-oe-xpath', node_path)
            elif not e.get('data-oe-model'):
                e.attrib.update(branding)
                e.set('data-oe-xpath', node_path)
        if not e.get('data-oe-model'):
            return

        if {'t-esc', 't-raw', 't-out'}.intersection(e.attrib):
            # nodes which fully generate their content and have no reason to
            # be branded because they can not sensibly be edited
            self._pop_view_branding(e)
        elif self._contains_branded(e):
            # if a branded element contains branded elements distribute own
            # branding to children unless it's t-raw, then just remove branding
            # on current element
            distributed_branding = self._pop_view_branding(e)

            if 't-raw' not in e.attrib:
                # TODO: collections.Counter if remove p2.6 compat
                # running index by tag type, for XPath query generation
                indexes = collections.defaultdict(lambda: 0)
                for child in e.iterchildren(etree.Element, etree.ProcessingInstruction):
                    if child.get('data-oe-xpath'):
                        # injected by view inheritance, skip otherwise
                        # generated xpath is incorrect
                        self.distribute_branding(child)
                    elif child.tag is etree.ProcessingInstruction:
                        # If a node is known to have been replaced during
                        # applying an inheritance, increment its index to
                        # compute an accurate xpath for subsequent nodes
                        if child.target == 'apply-inheritance-specs-node-removal':
                            indexes[child.text] += 1
                            e.remove(child)
                    else:
                        indexes[child.tag] += 1
                        self.distribute_branding(
                            child, distributed_branding,
                            parent_xpath=node_path, index_map=indexes)

    def is_node_branded(self, node):
        """ Finds out whether a node is branded or qweb-active (bears a
        @data-oe-model or a @t-* *which is not t-field* as t-field does not
        section out views)

        :param node: an etree-compatible element to test
        :type node: etree._Element
        :rtype: boolean
        """
        return any(
            (attr in ('data-oe-model', 'groups') or (attr.startswith('t-')))
            for attr in node.attrib
        ) or (
            node.tag is etree.ProcessingInstruction
            and node.target == 'apply-inheritance-specs-node-removal'
        )

    @api.model
    def render_public_asset(self, template, values=None):
        template_sudo = self._get(template).sudo()
        template_sudo._check_view_access()
        return self.env['ir.qweb'].sudo()._render(template, values)

    def _render_template(self, template, values=None):
        return self.env['ir.qweb']._render(template, values)

    #------------------------------------------------------
    # Misc
    #------------------------------------------------------

    @api.model
    def _validate_custom_views(self, model):
        """Validate architecture of custom views (= without xml id) for a given model.
            This method is called at the end of registry update.
        """
        query = """SELECT max(v.id)
                     FROM ir_ui_view v
                LEFT JOIN ir_model_data md ON (md.model = 'ir.ui.view' AND md.res_id = v.id)
                    WHERE md.module IN (SELECT name FROM ir_module_module) IS NOT TRUE
                      AND v.model = %s
                      AND v.active = true
                 GROUP BY coalesce(v.inherit_id, v.id)"""
        self._cr.execute(query, [model])

        rec = self.browse(it[0] for it in self._cr.fetchall())
        return rec.with_context({'load_all_views': True})._check_xml()

    @api.model
    def _validate_module_views(self, module):
        """ Validate the architecture of all the views of a given module that
            are impacted by view updates, but have not been checked yet.
        """
        assert self.pool._init

        # only validate the views that still exist...
        prefix = module + '.'
        prefix_len = len(prefix)
        names = tuple(
            xmlid[prefix_len:]
            for xmlid in self.pool.loaded_xmlids
            if xmlid.startswith(prefix)
        )
        if not names:
            return

        # retrieve the views with an XML id that has not been checked yet, i.e.,
        # the views with noupdate=True on their xml id
        query = """
            SELECT v.id
            FROM ir_ui_view v
            JOIN ir_model_data md ON (md.model = 'ir.ui.view' AND md.res_id = v.id)
            WHERE md.module = %s AND md.name IN %s AND md.noupdate
        """
        self._cr.execute(query, (module, names))
        views = self.browse([row[0] for row in self._cr.fetchall()])

        for view in views:
            view._check_xml()

    def _create_all_specific_views(self, processed_modules):
        """To be overriden and have specific view behaviour on create"""
        pass

    def _get_specific_views(self):
        """ Given a view, return a record set containing all the specific views
            for that view's key.
        """
        self.ensure_one()
        # Only qweb views have a specific conterpart
        if self.type != 'qweb':
            return self.env['ir.ui.view']
        # A specific view can have a xml_id if exported/imported but it will not be equals to it's key (only generic view will).
        return self.with_context(active_test=False).search([('key', '=', self.key)]).filtered(lambda r: not r.xml_id == r.key)

    def _load_records_write(self, values):
        """ During module update, when updating a generic view, we should also
            update its specific views (COW'd).
            Note that we will only update unmodified fields. That will mimic the
            noupdate behavior on views having an ir.model.data.
        """
        if self.type == 'qweb':
            for cow_view in self._get_specific_views():
                authorized_vals = {}
                for key in values:
                    if key != 'inherit_id' and cow_view[key] == self[key]:
                        authorized_vals[key] = values[key]
                # if inherit_id update, replicate change on cow view but
                # only if that cow view inherit_id wasn't manually changed
                inherit_id = values.get('inherit_id')
                if inherit_id and self.inherit_id.id != inherit_id and \
                   cow_view.inherit_id.key == self.inherit_id.key:
                    self._load_records_write_on_cow(cow_view, inherit_id, authorized_vals)
                else:
                    cow_view.with_context(no_cow=True).write(authorized_vals)
        super(View, self)._load_records_write(values)

    def _load_records_write_on_cow(self, cow_view, inherit_id, values):
        # for modules updated before `website`, we need to
        # store the change to replay later on cow views
        if not hasattr(self.pool, 'website_views_to_adapt'):
            self.pool.website_views_to_adapt = []
        self.pool.website_views_to_adapt.append((
            cow_view.id,
            inherit_id,
            values,
        ))


class ResetViewArchWizard(models.TransientModel):
    """ A wizard to compare and reset views architecture. """
    _name = "reset.view.arch.wizard"
    _description = "Reset View Architecture Wizard"

    view_id = fields.Many2one('ir.ui.view', string='View')
    view_name = fields.Char(related='view_id.name', string='View Name')
    has_diff = fields.Boolean(compute='_compute_arch_diff')
    arch_diff = fields.Html(string='Architecture Diff', readonly=True,
                            compute='_compute_arch_diff', sanitize_tags=False)
    reset_mode = fields.Selection([
        ('soft', 'Restore previous version (soft reset).'),
        ('hard', 'Reset to file version (hard reset).'),
        ('other_view', 'Reset to another view.')],
        string='Reset Mode', default='soft', required=True)
    compare_view_id = fields.Many2one('ir.ui.view', string='Compare To View')
    arch_to_compare = fields.Text('Arch To Compare To', compute='_compute_arch_diff')

    @api.model
    def default_get(self, fields):
        view_ids = (self._context.get('active_model') == 'ir.ui.view' and
                    self._context.get('active_ids') or [])
        if len(view_ids) > 2:
            raise ValidationError(_("Can't compare more than two views."))

        result = super().default_get(fields)
        result['view_id'] = view_ids and view_ids[0]
        if len(view_ids) == 2:
            result['reset_mode'] = 'other_view'
            result['compare_view_id'] = view_ids[1]
        return result

    @api.depends('reset_mode', 'view_id', 'compare_view_id')
    def _compute_arch_diff(self):
        """ Depending of `reset_mode`, return the differences between the
        current view arch and either its previous arch, its initial arch or
        another view arch.
        """
        def get_table_name(view_id):
            name = view_id.display_name
            if view_id.key or view_id.xml_id:
                span = '<span class="ml-1 font-weight-normal small">(%s)</span>'
                name += span % (view_id.key or view_id.xml_id)
            return name

        for view in self:
            diff_to = False
            diff_to_name = False
            if view.reset_mode == 'soft':
                diff_to = view.view_id.arch_prev
                diff_to_name = _("Previous Arch")
            elif view.reset_mode == 'other_view':
                diff_to = view.compare_view_id.with_context(lang=None).arch
                diff_to_name = get_table_name(view.compare_view_id)
            elif view.reset_mode == 'hard' and view.view_id.arch_fs:
                diff_to = view.view_id.with_context(read_arch_from_file=True, lang=None).arch
                diff_to_name = _("File Arch")

            view.arch_to_compare = diff_to

            if not diff_to:
                view.arch_diff = False
                view.has_diff = False
            else:
                view_arch = view.view_id.with_context(lang=None).arch
                view.arch_diff = get_diff(
                    (view_arch, get_table_name(view.view_id) if view.reset_mode == 'other_view' else _("Current Arch")),
                    (diff_to, diff_to_name),
                    custom_style=False,
                    dark_color_scheme=request and request.httprequest.cookies.get('color_scheme') == 'dark',
                )
                view.has_diff = view_arch != diff_to

    def reset_view_button(self):
        self.ensure_one()
        if self.reset_mode == 'other_view':
            self.view_id.write({'arch_db': self.arch_to_compare})
        else:
            self.view_id.reset_arch(self.reset_mode)
        return {'type': 'ir.actions.act_window_close'}


class Model(models.AbstractModel):
    _inherit = 'base'

    _date_name = 'date'         #: field to use for default calendar view

    def _get_access_action(self, access_uid=None, force_website=False):
        """ Return an action to open the document. This method is meant to be
        overridden in addons that want to give specific access to the document.
        By default, it opens the formview of the document.

        :param integer access_uid: optional access_uid being the user that
            accesses the document. May be different from the current user as we
            may compute an access for someone else.
        :param integer force_website: force frontend redirection if available
            on self. Used in overrides, notably with portal / website addons.
        """
        self.ensure_one()
        return self.get_formview_action(access_uid=access_uid)

    @api.model
    def get_empty_list_help(self, help_message):
        """ Hook method to customize the help message in empty list/kanban views.

        By default, it returns the help received as parameter.

        :param str help: ir.actions.act_window help content
        :return: help message displayed when there is no result to display
          in a list/kanban view (by default, it returns the action help)
        :rtype: str
        """
        return help_message

    #
    # Override this method if you need a window title that depends on the context
    #
    @api.model
    def view_header_get(self, view_id=None, view_type='form'):
        return False

    @api.model
    def _get_default_form_view(self):
        """ Generates a default single-line form view using all fields
        of the current model.

        :returns: a form view as an lxml document
        :rtype: etree._Element
        """
        sheet = E.sheet(string=self._description)
        main_group = E.group()
        left_group = E.group()
        right_group = E.group()
        for fname, field in self._fields.items():
            if field.automatic:
                continue
            elif field.type in ('one2many', 'many2many', 'text', 'html'):
                # append to sheet left and right group if needed
                if len(left_group) > 0:
                    main_group.append(left_group)
                    left_group = E.group()
                if len(right_group) > 0:
                    main_group.append(right_group)
                    right_group = E.group()
                if len(main_group) > 0:
                    sheet.append(main_group)
                    main_group = E.group()
                # add an oneline group for field type 'one2many', 'many2many', 'text', 'html'
                sheet.append(E.group(E.field(name=fname)))
            else:
                if len(left_group) > len(right_group):
                    right_group.append(E.field(name=fname))
                else:
                    left_group.append(E.field(name=fname))
        if len(left_group) > 0:
            main_group.append(left_group)
        if len(right_group) > 0:
            main_group.append(right_group)
        sheet.append(main_group)
        sheet.append(E.group(E.separator()))
        return E.form(sheet)

    @api.model
    def _get_default_search_view(self):
        """ Generates a single-field search view, based on _rec_name.

        :returns: a tree view as an lxml document
        :rtype: etree._Element
        """
        element = E.field(name=self._rec_name_fallback())
        return E.search(element, string=self._description)

    @api.model
    def _get_default_tree_view(self):
        """ Generates a single-field tree view, based on _rec_name.

        :returns: a tree view as an lxml document
        :rtype: etree._Element
        """
        element = E.field(name=self._rec_name_fallback())
        return E.tree(element, string=self._description)

    @api.model
    def _get_default_pivot_view(self):
        """ Generates an empty pivot view.

        :returns: a pivot view as an lxml document
        :rtype: etree._Element
        """
        return E.pivot(string=self._description)

    @api.model
    def _get_default_kanban_view(self):
        """ Generates a single-field kanban view, based on _rec_name.

        :returns: a kanban view as an lxml document
        :rtype: etree._Element
        """

        field = E.field(name=self._rec_name_fallback())
        content_div = E.div(field, {'class': "o_kanban_card_content"})
        card_div = E.div(content_div, {'t-attf-class': "oe_kanban_card oe_kanban_global_click"})
        kanban_box = E.t(card_div, {'t-name': "kanban-box"})
        templates = E.templates(kanban_box)
        return E.kanban(templates, string=self._description)

    @api.model
    def _get_default_graph_view(self):
        """ Generates a single-field graph view, based on _rec_name.

        :returns: a graph view as an lxml document
        :rtype: etree._Element
        """
        element = E.field(name=self._rec_name_fallback())
        return E.graph(element, string=self._description)

    @api.model
    def _get_default_calendar_view(self):
        """ Generates a default calendar view by trying to infer
        calendar fields from a number of pre-set attribute names

        :returns: a calendar view
        :rtype: etree._Element
        """
        def set_first_of(seq, in_, to):
            """Sets the first value of ``seq`` also found in ``in_`` to
            the ``to`` attribute of the ``view`` being closed over.

            Returns whether it's found a suitable value (and set it on
            the attribute) or not
            """
            for item in seq:
                if item in in_:
                    view.set(to, item)
                    return True
            return False

        view = E.calendar(string=self._description)
        view.append(E.field(name=self._rec_name_fallback()))

        if not set_first_of([self._date_name, 'date', 'date_start', 'x_date', 'x_date_start'],
                            self._fields, 'date_start'):
            raise UserError(_("Insufficient fields for Calendar View!"))

        set_first_of(["user_id", "partner_id", "x_user_id", "x_partner_id"],
                     self._fields, 'color')

        if not set_first_of(["date_stop", "date_end", "x_date_stop", "x_date_end"],
                            self._fields, 'date_stop'):
            if not set_first_of(["date_delay", "planned_hours", "x_date_delay", "x_planned_hours"],
                                self._fields, 'date_delay'):
                raise UserError(_(
                    "Insufficient fields to generate a Calendar View for %s, missing a date_stop or a date_delay",
                    self._name
                ))

        return view

    @api.model
    def get_views(self, views, options=None):
        """ Returns the fields_views of given views, along with the fields of
        the current model, and optionally its filters for the given action.

        The return of the method can only depend on the requested view types,
        access rights (views or other records), view access rules, options,
        context lang and TYPE_view_ref (other context values cannot be used).

        Python expressions contained in views or representing domains (on
        python fields) will be evaluated by the client with all the context
        values as well as the record values it has.

        :param views: list of [view_id, view_type]
        :param dict options: a dict optional boolean flags, set to enable:

            ``toolbar``
                includes contextual actions when loading fields_views
            ``load_filters``
                returns the model's filters
            ``action_id``
                id of the action to get the filters, otherwise loads the global
                filters or the model

        :return: dictionary with fields_views, fields and optionally filters
        """
        options = options or {}
        result = {}

        result['views'] = {
            v_type: self.get_view(
                v_id, v_type if v_type != 'list' else 'tree',
                **options
            )
            for [v_id, v_type] in views
        }

        models = {}
        for view in result['views'].values():
            for model, model_fields in view.pop('models').items():
                models.setdefault(model, set()).update(model_fields)

        result['models'] = {}

        for model, model_fields in models.items():
            result['models'][model] = self.env[model].fields_get(
                allfields=model_fields, attributes=self._get_view_field_attributes()
            )

        # Add related action information if asked
        if options.get('toolbar'):
            for view in result['views'].values():
                view['toolbar'] = {}

            bindings = self.env['ir.actions.actions'].get_bindings(self._name)
            for action_type, key in (('report', 'print'), ('action', 'action')):
                for action in bindings.get(action_type, []):
                    view_types = (
                        action['binding_view_types'].split(',')
                        if action.get('binding_view_types')
                        else result['views'].keys()
                    )
                    for view_type in view_types:
                        view_type = view_type if view_type != 'tree' else 'list'
                        if view_type in result['views']:
                            result['views'][view_type]['toolbar'].setdefault(key, []).append(action)

        if options.get('load_filters') and 'search' in result['views']:
            result['views']['search']['filters'] = self.env['ir.filters'].get_filters(
                self._name, options.get('action_id')
            )

        return result

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        """Get the model view combined architecture (the view along all its inheriting views).

        :param int view_id: id of the view or None
        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)
        :param dict options: bool options to return additional features:
            - bool mobile: true if the web client is currently using the responsive mobile view
              (to use kanban views instead of list views for x2many fields)
        :return: architecture of the view as an etree node, and the browse record of the view used
        :rtype: tuple
        :raise AttributeError:
            if no view exists for that model, and no method `_get_default_[view_type]_view` exists for the view type

        """
        View = self.env['ir.ui.view'].sudo()

        # try to find a view_id if none provided
        if not view_id:
            # <view_type>_view_ref in context can be used to override the default view
            view_ref_key = view_type + '_view_ref'
            view_ref = self._context.get(view_ref_key)
            if view_ref:
                if '.' in view_ref:
                    module, view_ref = view_ref.split('.', 1)
                    query = "SELECT res_id FROM ir_model_data WHERE model='ir.ui.view' AND module=%s AND name=%s"
                    self._cr.execute(query, (module, view_ref))
                    view_ref_res = self._cr.fetchone()
                    if view_ref_res:
                        view_id = view_ref_res[0]
                else:
                    _logger.warning(
                        '%r requires a fully-qualified external id (got: %r for model %s). '
                        'Please use the complete `module.view_id` form instead.', view_ref_key, view_ref,
                        self._name
                    )

            if not view_id:
                # otherwise try to find the lowest priority matching ir.ui.view
                view_id = View.default_view(self._name, view_type)

        if view_id:
            # read the view with inherited views applied
            view = View.browse(view_id)
            arch = view._get_combined_arch()
        else:
            # fallback on default views methods if no ir.ui.view could be found
            view = View.browse()
            try:
                arch = getattr(self, '_get_default_%s_view' % view_type)()
            except AttributeError:
                raise UserError(_("No default view of type '%s' could be found!", view_type))
        return arch, view

    @api.model
    def _get_view_cache_key(self, view_id=None, view_type='form', **options):
        """ Get the key to use for caching `_get_view_cache`.

        This method is meant to be overriden by models needing additional keys.

        :param int view_id: id of the view or None
        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)
        :param dict options: bool options to return additional features:
            - bool mobile: true if the web client is currently using the responsive mobile view
              (to use kanban views instead of list views for x2many fields)
        :return: a cache key
        :rtype: tuple
        """
        return (view_id, view_type, options.get('mobile'), self.env.lang) + tuple(
            (key, value) for key, value in self.env.context.items() if key.endswith('_view_ref')
        )

    @api.model
    @tools.conditional(
        'xml' not in config['dev_mode'],
        tools.ormcache('self._get_view_cache_key(view_id, view_type, **options)', cache='templates'),
    )
    def _get_view_cache(self, view_id=None, view_type='form', **options):
        """ Get the view information ready to be cached

        The cached view includes the postprocessed view, including inherited views, for all groups.
        The blocks restricted to groups must therefore be removed after calling this method
        for users not part of the given groups.

        :param int view_id: id of the view or None
        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)
        :param dict options: boolean options to return additional features:
            - bool mobile: true if the web client is currently using the responsive mobile view
              (to use kanban views instead of list views for x2many fields)
        :return: a dictionnary including
            - string arch: the architecture of the view (including inherited views, postprocessed, for all groups)
            - int id: the view id
            - string model: the view model
            - dict models: the fields of the models used in the view (including sub-views)
        :rtype: dict
        """
        # Get the view arch and all other attributes describing the composition of the view
        arch, view = self._get_view(view_id, view_type, **options)

        # Apply post processing, groups and modifiers etc...
        arch, models = view.postprocess_and_fields(arch, model=self._name, **options)
        models = self._get_view_fields(view_type or view.type, models)
        result = {
            'arch': arch,
            # TODO: only `web_studio` seems to require this. I guess this is acceptable to keep it.
            'id': view.id,
            # TODO: only `web_studio` seems to require this. But this one on the other hand should be eliminated:
            # you just called `get_views` for that model, so obviously the web client already knows the model.
            'model': self._name,
            # Set a frozendict and tuple for the field list to make sure the value in cache cannot be updated.
            'models': frozendict({model: tuple(fields) for model, fields in models.items()}),
        }

        return frozendict(result)

    @api.model
    def get_view(self, view_id=None, view_type='form', **options):
        """ get_view([view_id | view_type='form'])

        Get the detailed composition of the requested view like model, view architecture.

        The return of the method can only depend on the requested view types,
        access rights (views or other records), view access rules, options,
        context lang and TYPE_view_ref (other context values cannot be used).

        :param int view_id: id of the view or None
        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)
        :param dict options: boolean options to return additional features:
            - bool mobile: true if the web client is currently using the responsive mobile view
            (to use kanban views instead of list views for x2many fields)
        :return: composition of the requested view (including inherited views and extensions)
        :rtype: dict
        :raise AttributeError:

            * if the inherited view has unknown position to work with other than 'before', 'after', 'inside', 'replace'
            * if some tag other than 'position' is found in parent view

        :raise Invalid ArchitectureError: if there is view type other than form, tree, calendar, search etc... defined on the structure
        """
        self.check_access_rights('read')

        result = dict(self._get_view_cache(view_id, view_type, **options))

        node = etree.fromstring(result['arch'])
        node = self.env['ir.ui.view']._postprocess_access_rights(node)
        result['arch'] = etree.tostring(node, encoding="unicode").replace('\t', '')

        return result

    @api.model
    def _get_view_fields(self, view_type, models):
        """ Returns the field names required by the web client to load the views according to the view type.

        The method is meant to be overridden by modules extending web client features and requiring additional
        fields.

        :param string view_type: type of the view
        :param dict models: dict holding the models and fields used in the view architecture.
        :return: dict holding the models and field required by the web client given the view type.
        :rtype: list
        """
        if view_type in ('kanban', 'tree', 'form'):
            for model, model_fields in models.items():
                model_fields.add('id')
                if 'write_date' in self.env[model]._fields:
                    model_fields.add('write_date')
        elif view_type == 'search':
            models[self._name] = list(self._fields.keys())
        elif view_type == 'graph':
            models[self._name].union(fname for fname, field in self._fields.items() if field.type in ('integer', 'float'))
        elif view_type == 'pivot':
            models[self._name].union(fname for fname, field in self._fields.items() if field.groupable)
        return models

    @api.model
    def _get_view_field_attributes(self):
        """ Returns the field attributes required by the web client to load the views.

        The method is meant to be overridden by modules extending web client features and requiring additional
        field attributes.

        :return: string list of field attribute names
        :rtype: list
        """
        return [
            'change_default', 'context', 'currency_field', 'definition_record', 'definition_record_field', 'digits', 'domain', 'group_operator', 'groups',
            'help', 'name', 'readonly', 'related', 'relation', 'relation_field', 'required', 'searchable', 'selection', 'size',
            'sortable', 'store', 'string', 'translate', 'trim', 'type',
        ]

    def get_formview_id(self, access_uid=None):
        """ Return a view id to open the document ``self`` with. This method is
            meant to be overridden in addons that want to give specific view ids
            for example.

            Optional access_uid holds the user that would access the form view
            id different from the current environment user.
        """
        return False

    def get_formview_action(self, access_uid=None):
        """ Return an action to open the document ``self``. This method is meant
            to be overridden in addons that want to give specific view ids for
            example.

        An optional access_uid holds the user that will access the document
        that could be different from the current user. """
        view_id = self.sudo().get_formview_id(access_uid=access_uid)
        return {
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'views': [(view_id, 'form')],
            'target': 'current',
            'res_id': self.id,
            'context': dict(self._context),
        }

    def _get_records_action(self, **kwargs):
        """ Return an action to open given records.
            If there's more than one record, it will be a List, otherwise it's a Form.
            Given keyword arguments will overwrite default ones. """
        match self.ids:  # `self.ids` will silently filter out new records (`NewId`s)
            case []:
                length_dependent = {'views': [(False, 'form')]}
            case [res_id]:
                length_dependent = {'views': [(False, 'form')], 'res_id': res_id}
            case ids:
                length_dependent = {
                    'views': [(False, 'list'), (False, 'form')],
                    'domain': [('id', 'in', ids)]
                }
        return {
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'target': 'current',
            'context': dict(self._context),
            **length_dependent,
            **kwargs
        }

    @api.model
    def _onchange_spec(self, view_info=None):
        """ Return the onchange spec from a view description; if not given, the
            result of ``self.get_view()`` is used.
        """
        result = {}

        # for traversing the XML arch and populating result
        def process(node, info, prefix):
            if node.tag == 'field':
                name = node.attrib['name']
                names = "%s.%s" % (prefix, name) if prefix else name
                if not result.get(names):
                    result[names] = node.attrib.get('on_change')
                # traverse the subviews included in relational fields
                for child_view in node.xpath("./*[descendant::field]"):
                    process(child_view, None, names)
            else:
                for child in node:
                    process(child, info, prefix)

        if view_info is None:
            view_info = self.get_view()
        process(etree.fromstring(view_info['arch']), view_info, '')
        return result

    @api.model
    def _get_fields_spec(self, view_info=None):
        """ Return the fields specification from a view description; if not
        given, the result of ``self.get_view()`` is used.
        """
        def fill_spec(node, model, fields_spec):
            if node.tag == 'field':
                field_name = node.attrib['name']
                field_spec = fields_spec.setdefault(field_name, {})
                field = model._fields.get(field_name)
                if field is not None:
                    sub_fields_spec = {}
                    if field.type == 'many2one':
                        sub_fields_spec.setdefault('display_name', {})
                    if field.relational:
                        comodel = model.env[field.comodel_name]
                        for child in node:
                            fill_spec(child, comodel, sub_fields_spec)
                    if field.type == 'one2many':
                        sub_fields_spec.pop(field.inverse_name, None)
                    if sub_fields_spec:
                        field_spec.setdefault('fields', {}).update(sub_fields_spec)
            else:
                for child in node:
                    fill_spec(child, model, fields_spec)

        if view_info is None:
            view_info = self.get_view()

        result = {}
        fill_spec(etree.fromstring(view_info['arch']), self, result)
        return result


class NameManager:
    """ An object that manages all the named elements in a view. """

    def __init__(self, model, parent=None):
        self.model = model
        self.available_fields = collections.defaultdict(dict)  # {field_name: {'groups': groups, 'info': field_info}}
        self.available_actions = set()
        self.available_names = set()
        self.mandatory_fields = collections.defaultdict(dict)  # {field_name: {'groups': 'use}}
        self.mandatory_parent_fields = collections.defaultdict(dict)  # {field_name: {'groups': use}}
        self.mandatory_names = dict()           # {name: use}
        self.must_exist_actions = {}
        self.must_exist_groups = {}
        self.parent = parent
        self.children = []
        if self.parent:
            self.parent.children.append(self)

    @lazy_property
    def field_info(self):
        field_info = self.model.fields_get(attributes=['readonly', 'required'])
        has_access = functools.partial(self.model.check_access_rights, raise_exception=False)
        if not (has_access('write') or has_access('create')):
            for info in field_info.values():
                info['readonly'] = True
        return field_info

    def has_field(self, node, name, info=frozendict()):
        groups = self._get_node_groups(node)
        self.available_fields[name].setdefault('info', {}).update(info)
        self.available_fields[name].setdefault('groups', []).append(groups)
        self.available_names.add(info.get('id') or name)

    def has_action(self, name):
        self.available_actions.add(name)

    def must_have_field(self, node, name, use, groups=None):
        node_groups = self._get_node_groups(node)
        if groups:
            groups = groups + node_groups
        else:
            groups = node_groups
        if name.startswith('parent.'):
            self.mandatory_parent_fields[name[7:]][groups] = use
        else:
            self.mandatory_fields[name][groups] = use

    def must_have_fields(self, node, names, use, groups=None):
        for name in names:
            self.must_have_field(node, name, use, groups=groups)

    def must_have_name(self, name, use):
        self.mandatory_names[name] = use

    def must_exist_action(self, action_id, node):
        self.must_exist_actions[action_id] = node

    def must_exist_group(self, name, node):
        self.must_exist_groups[name] = node

    def _get_node_groups(self, node):
        return tuple(tuple(n.get('groups').split(',')) for n in chain([node], node.iterancestors()) if n.get('groups'))

    def check(self, view):
        # context for translations below
        context = view.env.context          # pylint: disable=unused-variable

        for name, use in self.mandatory_names.items():
            if name not in self.available_actions and name not in self.available_names:
                msg = _(
                    "Name or id %(name_or_id)r in %(use)s must be present in view but is missing.",
                    name_or_id=name, use=use,
                )
                view._raise_view_error(msg)

        for name in self.available_fields:
            if name not in self.model._fields and name not in self.field_info:
                message = _("Field `%(name)s` does not exist", name=name)
                view._raise_view_error(message)

        for name, node in self.must_exist_actions.items():
            # logic mimics /web/action/load behaviour
            action = False
            try:
                action_id = int(name)
            except ValueError:
                model, action_id = view.env['ir.model.data']._xmlid_to_res_model_res_id(name, raise_if_not_found=False)
                if not action_id:
                    msg = _("Invalid xmlid %(xmlid)s for button of type action.", xmlid=name)
                    view._raise_view_error(msg, node)
                if not issubclass(view.pool[model], view.pool['ir.actions.actions']):
                    msg = _(
                        "%(xmlid)s is of type %(xmlid_model)s, expected a subclass of ir.actions.actions",
                        xmlid=name, xmlid_model=model,
                    )
                    view._raise_view_error(msg, node)
            action = view.env['ir.actions.actions'].browse(action_id).exists()
            if not action:
                msg = _(
                    "Action %(action_reference)s (id: %(action_id)s) does not exist for button of type action.",
                    action_reference=name, action_id=action_id,
                )
                view._raise_view_error(msg, node)

        for name, node in self.must_exist_groups.items():
            if not view.env['ir.model.data']._xmlid_to_res_id(name, raise_if_not_found=False):
                msg = _("The group %(name)r defined in view does not exist!", name=name)
                view._log_view_warning(msg, node)

        for name, groups_uses in self.mandatory_fields.items():
            use = next(iter(groups_uses.values()))
            if name == 'id':  # always available
                continue
            if "." in name:
                msg = _(
                    "Invalid composed field %(definition)s in %(use)s",
                    definition=name, use=use,
                )
                view._raise_view_error(msg)
            info = self.available_fields[name].get('info')
            if info is None:
                if name in ['active_id', 'active_ids', 'active_model']:
                    _logger.warning("Using active_id, active_ids and active_model in expressions is deprecated, found %s", name)
                    continue
                msg = _(
                    "Field %(name)r used in %(use)s must be present in view but is missing.",
                    name=name, use=use,
                )
                view._raise_view_error(msg)
            if info.get('select') == 'multi':  # mainly for searchpanel, but can be a generic behaviour.
                msg = _(
                    "Field %(name)r used in %(use)s is present in view but is in select multi.",
                    name=name, use=use,
                )
                view._raise_view_error(msg)

            def combinate(groups):
                # [['A'], ['B', 'C'], ['D', 'E']]
                # returns
                # [['A', 'B', 'D'], ['A', 'C', 'D'], ['A', 'B', 'E'], ['A', 'C', 'E']]

                # [['!A', '!B'], ['C', 'D']]
                # returns
                # [['!A', '!B', 'C'], ['!A', '!B', 'D']]

                # [['A', 'B'], ['!C', '!D']]
                # returns
                # [['A', '!C', '!D'], ['B', '!C', '!D']]

                # [['!A', '!B', 'C', 'D'], ['E', 'F']]
                # returns
                # [['!A', '!B', 'C', 'E'], ['!A', '!B', 'D', 'E'], ['!A', '!B', 'C', 'F'], ['!A', '!B', 'D', 'F']]
                if not groups:
                    return []
                positive = [(group,) for group in groups[0] if not group or not group.startswith('!')]
                negative = tuple(group for group in groups[0] if group and group.startswith('!'))
                combinations = [negative + p for p in positive] if positive else [negative]
                if len(groups) > 1:
                    combinations = [group + tuple(c) for c in combinate(groups[1:]) for group in combinations]
                return [set(combination) for combination in set(tuple(combination) for combination in combinations)]

            for mandatory_for_groups, use in groups_uses.items():
                mandatory_combinations = combinate(mandatory_for_groups or [(None,)])
                available_combinations = [
                    combination
                    for available_for_groups in self.available_fields[name]['groups']
                    for combination in combinate(available_for_groups or [(None,)])
                ]
                if (
                    # If (None,) is in available_combinations,
                    # it means the field is in the view without any group restriction,
                    # and is therefore available for anyone / any group
                    {None} not in available_combinations
                    # If there are two mutually exclusive combinations,
                    # it means the field is available for anyone / any group
                    and not any(
                        {group[1:] if group.startswith('!') else '!' + group for group in combination}
                        in available_combinations
                        for combination in available_combinations
                    )
                    and ((
                    # For all mandatory combinations, find an available combination
                    # which is included in the mandatory combination
                    # e.g.
                    # mandatory combination: A B C
                    # available combination: A B
                    # The above is valid, the field will be available for users having both A and B groups
                    # and the field is mandatory only for users having A B and C groups.
                    not all(
                        any(
                            available_combination.issubset(mandatory_combination)
                            for available_combination in available_combinations
                        ) for mandatory_combination in mandatory_combinations
                    )
                    # Same than above but take into account implied groups (e.g. group_system includes group_erp_manager and group_user)
                    # for positive groups
                    and not all(
                        any(
                            available_combination.issubset(combination)
                            for available_combination in available_combinations
                            for combination in
                            (
                                mandatory_combination - {group} | {trans_group}
                                for group in mandatory_combination if group and not group.startswith('!')
                                for trans_group in view.env.ref(group).trans_implied_ids.get_external_id().values()
                            )
                        )
                        for mandatory_combination in mandatory_combinations
                    )
                    # Same than above but take into account implied groups (e.g. group_system includes group_erp_manager and group_user)
                    # for negative groups
                    and not all(
                        any(
                            combination.issubset(mandatory_combination)
                            for available_combination in available_combinations
                            for combination in
                            (
                                available_combination - {group} | {'!' + trans_group}
                                for group in available_combination if group and group.startswith('!')
                                for trans_group in view.env.ref(group[1:]).trans_implied_ids.get_external_id().values()
                            )
                        ) for mandatory_combination in mandatory_combinations
                    )
                    )
                    # if 'base.group_no_one' is in available_combinations the group
                    # must be in mandatory_combinations because depending of session
                    or (
                        {'base.group_no_one'} in available_combinations and
                        not all('base.group_no_one' in combination for combination in mandatory_combinations)
                    ))
                ):
                    msg = _(
                        "Field %(name)r used in %(use)s is restricted to the group(s) %(groups)s.",
                        name=name, use=use, groups=','.join(
                            group
                            for availability in self.available_fields[name]['groups']
                            for combination in availability
                            for group in combination
                        )
                    )
                    view._raise_view_error(msg)

    def update_available_fields(self):
        for name, info in self.available_fields.items():
            info.update(self.field_info.get(name, ()))

```

  File: models/report_layout.py
  Content:
```
# -*- coding: ascii -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import fields, models


class ReportLayout(models.Model):
    _name = "report.layout"
    _description = 'Report Layout'
    _order = 'sequence'

    view_id = fields.Many2one('ir.ui.view', 'Document Template', required=True)
    image = fields.Char(string="Preview image src")
    pdf = fields.Char(string="Preview pdf src")

    sequence = fields.Integer(default=50)
    name = fields.Char()

```

  File: models/report_paperformat.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, _
from odoo.exceptions import ValidationError

# see http://doc.qt.io/archives/qt-4.8/qprinter.html#PaperSize-enum
PAPER_SIZES = [
    {
        'description': 'A0  5   841 x 1189 mm',
        'key': 'A0',
        'height': 1189.0,
        'width': 841.0,
    }, {
        'key': 'A1',
        'description': 'A1  6   594 x 841 mm',
        'height': 841.0,
        'width': 594.0,
    }, {
        'key': 'A2',
        'description': 'A2  7   420 x 594 mm',
        'height': 594.0,
        'width': 420.0,
    }, {
        'key': 'A3',
        'description': 'A3  8   297 x 420 mm',
        'height': 420.0,
        'width': 297.0,
    }, {
        'key': 'A4',
        'description': 'A4  0   210 x 297 mm, 8.26 x 11.69 inches',
        'height': 297.0,
        'width': 210.0,
    }, {
        'key': 'A5',
        'description': 'A5  9   148 x 210 mm',
        'height': 210.0,
        'width': 148.0,
    }, {
        'key': 'A6',
        'description': 'A6  10  105 x 148 mm',
        'height': 148.0,
        'width': 105.0,
    }, {
        'key': 'A7',
        'description': 'A7  11  74 x 105 mm',
        'height': 105.0,
        'width': 74.0,
    }, {
        'key': 'A8',
        'description': 'A8  12  52 x 74 mm',
        'height': 74.0,
        'width': 52.0,
    }, {
        'key': 'A9',
        'description': 'A9  13  37 x 52 mm',
        'height': 52.0,
        'width': 37.0,
    }, {
        'key': 'B0',
        'description': 'B0  14  1000 x 1414 mm',
        'height': 1414.0,
        'width': 1000.0,
    }, {
        'key': 'B1',
        'description': 'B1  15  707 x 1000 mm',
        'height': 1000.0,
        'width': 707.0,
    }, {
        'key': 'B2',
        'description': 'B2  17  500 x 707 mm',
        'height': 707.0,
        'width': 500.0,
    }, {
        'key': 'B3',
        'description': 'B3  18  353 x 500 mm',
        'height': 500.0,
        'width': 353.0,
    }, {
        'key': 'B4',
        'description': 'B4  19  250 x 353 mm',
        'height': 353.0,
        'width': 250.0,
    }, {
        'key': 'B5',
        'description': 'B5  1   176 x 250 mm, 6.93 x 9.84 inches',
        'height': 250.0,
        'width': 176.0,
    }, {
        'key': 'B6',
        'description': 'B6  20  125 x 176 mm',
        'height': 176.0,
        'width': 125.0,
    }, {
        'key': 'B7',
        'description': 'B7  21  88 x 125 mm',
        'height': 125.0,
        'width': 88.0,
    }, {
        'key': 'B8',
        'description': 'B8  22  62 x 88 mm',
        'height': 88.0,
        'width': 62.0,
    }, {
        'key': 'B9',
        'description': 'B9  23  33 x 62 mm',
        'height': 62.0,
        'width': 33.0,
    }, {
        'key': 'B10',
        'description': 'B10    16  31 x 44 mm',
        'height': 44.0,
        'width': 31.0,
    }, {
        'key': 'C5E',
        'description': 'C5E 24  163 x 229 mm',
        'height': 229.0,
        'width': 163.0,
    }, {
        'key': 'Comm10E',
        'description': 'Comm10E 25  105 x 241 mm, U.S. Common 10 Envelope',
        'height': 241.0,
        'width': 105.0,
    }, {
        'key': 'DLE',
        'description': 'DLE 26 110 x 220 mm',
        'height': 220.0,
        'width': 110.0,
    }, {
        'key': 'Executive',
        'description': 'Executive 4   7.5 x 10 inches, 190.5 x 254 mm',
        'height': 254.0,
        'width': 190.5,
    }, {
        'key': 'Folio',
        'description': 'Folio 27  210 x 330 mm',
        'height': 330.0,
        'width': 210.0,
    }, {
        'key': 'Ledger',
        'description': 'Ledger  28  431.8 x 279.4 mm',
        'height': 279.4,
        'width': 431.8,
    }, {
        'key': 'Legal',
        'description': 'Legal    3   8.5 x 14 inches, 215.9 x 355.6 mm',
        'height': 355.6,
        'width': 215.9,
    }, {
        'key': 'Letter',
        'description': 'Letter 2 8.5 x 11 inches, 215.9 x 279.4 mm',
        'height': 279.4,
        'width': 215.9,
    }, {
        'key': 'Tabloid',
        'description': 'Tabloid 29 279.4 x 431.8 mm',
        'height': 431.8,
        'width': 279.4,
    }, {
        'key': 'custom',
        'description': 'Custom',
    },
]


class report_paperformat(models.Model):
    _name = "report.paperformat"
    _description = "Paper Format Config"

    name = fields.Char('Name', required=True)
    default = fields.Boolean('Default paper format?')
    format = fields.Selection([(ps['key'], ps['description']) for ps in PAPER_SIZES], 'Paper size', default='A4', help="Select Proper Paper size")
    margin_top = fields.Float('Top Margin (mm)', default=40)
    margin_bottom = fields.Float('Bottom Margin (mm)', default=20)
    margin_left = fields.Float('Left Margin (mm)', default=7)
    margin_right = fields.Float('Right Margin (mm)', default=7)
    page_height = fields.Integer('Page height (mm)', default=False)
    page_width = fields.Integer('Page width (mm)', default=False)
    orientation = fields.Selection([
        ('Landscape', 'Landscape'),
        ('Portrait', 'Portrait')
        ], 'Orientation', default='Landscape')
    header_line = fields.Boolean('Display a header line', default=False)
    header_spacing = fields.Integer('Header spacing', default=35)
    disable_shrinking = fields.Boolean('Disable smart shrinking')
    dpi = fields.Integer('Output DPI', required=True, default=90)
    report_ids = fields.One2many('ir.actions.report', 'paperformat_id', 'Associated reports', help="Explicitly associated reports")
    print_page_width = fields.Float('Print page width (mm)', compute='_compute_print_page_size')
    print_page_height = fields.Float('Print page height (mm)', compute='_compute_print_page_size')

    @api.constrains('format')
    def _check_format_or_page(self):
        if self.filtered(lambda x: x.format != 'custom' and (x.page_width or x.page_height)):
            raise ValidationError(_('You can select either a format or a specific page width/height, but not both.'))

    def _compute_print_page_size(self):
        for record in self:
            width = height = 0.0
            if record.format:
                if record.format == 'custom':
                    width = record.page_width
                    height = record.page_height
                else:
                    paper_size = next(ps for ps in PAPER_SIZES if ps['key'] == record.format)
                    width = paper_size['width']
                    height = paper_size['height']

            if record.orientation == 'Landscape':
                # swap sizes
                width, height = height, width

            record.print_page_width = width
            record.print_page_height = height

```

  File: models/res_bank.py
  Content:
```
# -*- coding: utf-8 -*-

import re

from collections.abc import Iterable

from odoo import api, fields, models, _
from odoo.osv import expression

def sanitize_account_number(acc_number):
    if acc_number:
        return re.sub(r'\W+', '', acc_number).upper()
    return False


class Bank(models.Model):
    _description = 'Bank'
    _name = 'res.bank'
    _order = 'name'

    name = fields.Char(required=True)
    street = fields.Char()
    street2 = fields.Char()
    zip = fields.Char()
    city = fields.Char()
    state = fields.Many2one('res.country.state', 'Fed. State', domain="[('country_id', '=?', country)]")
    country = fields.Many2one('res.country')
    email = fields.Char()
    phone = fields.Char()
    active = fields.Boolean(default=True)
    bic = fields.Char('Bank Identifier Code', index=True, help="Sometimes called BIC or Swift.")

    @api.depends('bic')
    def _compute_display_name(self):
        for bank in self:
            name = (bank.name or '') + (bank.bic and (' - ' + bank.bic) or '')
            bank.display_name = name

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        domain = domain or []
        if name:
            name_domain = ['|', ('bic', '=ilike', name + '%'), ('name', operator, name)]
            if operator in expression.NEGATIVE_TERM_OPERATORS:
                name_domain = ['&', '!'] + name_domain[1:]
            domain = domain + name_domain
        return self._search(domain, limit=limit, order=order)

    @api.onchange('country')
    def _onchange_country_id(self):
        if self.country and self.country != self.state.country_id:
            self.state = False

    @api.onchange('state')
    def _onchange_state(self):
        if self.state.country_id:
            self.country = self.state.country_id


class ResPartnerBank(models.Model):
    _name = 'res.partner.bank'
    _rec_name = 'acc_number'
    _description = 'Bank Accounts'
    _order = 'sequence, id'

    @api.model
    def get_supported_account_types(self):
        return self._get_supported_account_types()

    @api.model
    def _get_supported_account_types(self):
        return [('bank', _('Normal'))]

    active = fields.Boolean(default=True)
    acc_type = fields.Selection(selection=lambda x: x.env['res.partner.bank'].get_supported_account_types(), compute='_compute_acc_type', string='Type', help='Bank account type: Normal or IBAN. Inferred from the bank account number.')
    acc_number = fields.Char('Account Number', required=True)
    sanitized_acc_number = fields.Char(compute='_compute_sanitized_acc_number', string='Sanitized Account Number', readonly=True, store=True)
    acc_holder_name = fields.Char(string='Account Holder Name', help="Account holder name, in case it is different than the name of the Account Holder", compute='_compute_account_holder_name', readonly=False, store=True)
    partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)], required=True)
    allow_out_payment = fields.Boolean('Send Money', help='This account can be used for outgoing payments', default=False, copy=False, readonly=False)
    bank_id = fields.Many2one('res.bank', string='Bank')
    bank_name = fields.Char(related='bank_id.name', readonly=False)
    bank_bic = fields.Char(related='bank_id.bic', readonly=False)
    sequence = fields.Integer(default=10)
    currency_id = fields.Many2one('res.currency', string='Currency')
    company_id = fields.Many2one('res.company', 'Company', related='partner_id.company_id', store=True, readonly=True)

    _sql_constraints = [(
        'unique_number',
        'unique(sanitized_acc_number, partner_id)',
        'The combination Account Number/Partner must be unique.'
    )]

    @api.depends('acc_number')
    def _compute_sanitized_acc_number(self):
        for bank in self:
            bank.sanitized_acc_number = sanitize_account_number(bank.acc_number)

    @api.depends('acc_number')
    def _compute_acc_type(self):
        for bank in self:
            bank.acc_type = self.retrieve_acc_type(bank.acc_number)

    @api.depends('partner_id')
    def _compute_account_holder_name(self):
        for bank in self:
            bank.acc_holder_name = bank.partner_id.name

    @api.model
    def retrieve_acc_type(self, acc_number):
        """ To be overridden by subclasses in order to support other account_types.
        """
        return 'bank'

    @api.depends('acc_number', 'bank_id')
    def _compute_display_name(self):
        for acc in self:
            acc.display_name = f'{acc.acc_number} - {acc.bank_id.name}' if acc.bank_id else acc.acc_number

    @api.model
    def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):
        def sanitize(arg):
            if isinstance(arg, (tuple, list)) and arg[0] == 'acc_number':
                value = arg[2]
                if not isinstance(value, str) and isinstance(value, Iterable):
                    value = [sanitize_account_number(i) for i in value]
                else:
                    value = sanitize_account_number(value)
                return ('sanitized_acc_number', arg[1], value)
            return arg

        domain = [sanitize(item) for item in domain]
        return super()._search(domain, offset, limit, order, access_rights_uid)

```

  File: models/res_company.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import logging
import warnings

from odoo import api, fields, models, tools, _, Command, SUPERUSER_ID
from odoo.exceptions import ValidationError, UserError
from odoo.tools import html2plaintext, file_open, ormcache

_logger = logging.getLogger(__name__)


class Company(models.Model):
    _name = "res.company"
    _description = 'Companies'
    _order = 'sequence, name'
    _parent_store = True

    def copy(self, default=None):
        raise UserError(_('Duplicating a company is not allowed. Please create a new company instead.'))

    def _get_logo(self):
        with file_open('base/static/img/res_company_logo.png', 'rb') as file:
            return base64.b64encode(file.read())

    def _default_currency_id(self):
        return self.env.user.company_id.currency_id

    name = fields.Char(related='partner_id.name', string='Company Name', required=True, store=True, readonly=False)
    active = fields.Boolean(default=True)
    sequence = fields.Integer(help='Used to order Companies in the company switcher', default=10)
    parent_id = fields.Many2one('res.company', string='Parent Company', index=True)
    child_ids = fields.One2many('res.company', 'parent_id', string='Branches')
    all_child_ids = fields.One2many('res.company', 'parent_id', context={'active_test': False})
    parent_path = fields.Char(index=True, unaccent=False)
    parent_ids = fields.Many2many('res.company', compute='_compute_parent_ids', compute_sudo=True)
    root_id = fields.Many2one('res.company', compute='_compute_parent_ids', compute_sudo=True)
    partner_id = fields.Many2one('res.partner', string='Partner', required=True)
    report_header = fields.Html(string='Company Tagline', translate=True, help="Company tagline, which is included in a printed document's header or footer (depending on the selected layout).")
    report_footer = fields.Html(string='Report Footer', translate=True, help="Footer text displayed at the bottom of all reports.")
    company_details = fields.Html(string='Company Details', translate=True, help="Header text displayed at the top of all reports.")
    is_company_details_empty = fields.Boolean(compute='_compute_empty_company_details')
    logo = fields.Binary(related='partner_id.image_1920', default=_get_logo, string="Company Logo", readonly=False)
    # logo_web: do not store in attachments, since the image is retrieved in SQL for
    # performance reasons (see addons/web/controllers/main.py, Binary.company_logo)
    logo_web = fields.Binary(compute='_compute_logo_web', store=True, attachment=False)
    uses_default_logo = fields.Boolean(compute='_compute_uses_default_logo', store=True)
    currency_id = fields.Many2one('res.currency', string='Currency', required=True, default=lambda self: self._default_currency_id())
    user_ids = fields.Many2many('res.users', 'res_company_users_rel', 'cid', 'user_id', string='Accepted Users')
    street = fields.Char(compute='_compute_address', inverse='_inverse_street')
    street2 = fields.Char(compute='_compute_address', inverse='_inverse_street2')
    zip = fields.Char(compute='_compute_address', inverse='_inverse_zip')
    city = fields.Char(compute='_compute_address', inverse='_inverse_city')
    state_id = fields.Many2one(
        'res.country.state', compute='_compute_address', inverse='_inverse_state',
        string="Fed. State", domain="[('country_id', '=?', country_id)]"
    )
    bank_ids = fields.One2many(related='partner_id.bank_ids', readonly=False)
    country_id = fields.Many2one('res.country', compute='_compute_address', inverse='_inverse_country', string="Country")
    email = fields.Char(related='partner_id.email', store=True, readonly=False)
    phone = fields.Char(related='partner_id.phone', store=True, readonly=False)
    mobile = fields.Char(related='partner_id.mobile', store=True, readonly=False)
    website = fields.Char(related='partner_id.website', readonly=False)
    vat = fields.Char(related='partner_id.vat', string="Tax ID", readonly=False)
    company_registry = fields.Char(related='partner_id.company_registry', string="Company ID", readonly=False)
    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('base.paperformat_euro', raise_if_not_found=False))
    external_report_layout_id = fields.Many2one('ir.ui.view', 'Document Template')
    font = fields.Selection([("Lato", "Lato"), ("Roboto", "Roboto"), ("Open_Sans", "Open Sans"), ("Montserrat", "Montserrat"), ("Oswald", "Oswald"), ("Raleway", "Raleway"), ('Tajawal', 'Tajawal')], default="Lato")
    primary_color = fields.Char()
    secondary_color = fields.Char()
    color = fields.Integer(compute='_compute_color', inverse='_inverse_color')
    layout_background = fields.Selection([('Blank', 'Blank'), ('Geometric', 'Geometric'), ('Custom', 'Custom')], default="Blank", required=True)
    layout_background_image = fields.Binary("Background Image")
    _sql_constraints = [
        ('name_uniq', 'unique (name)', 'The company name must be unique!')
    ]

    def init(self):
        for company in self.search([('paperformat_id', '=', False)]):
            paperformat_euro = self.env.ref('base.paperformat_euro', False)
            if paperformat_euro:
                company.write({'paperformat_id': paperformat_euro.id})
        sup = super(Company, self)
        if hasattr(sup, 'init'):
            sup.init()

    def _get_company_root_delegated_field_names(self):
        """Get the set of fields delegated to the root company.

        Some fields need to be identical on all branches of the company. All
        fields listed by this function will be copied from the root company and
        appear as readonly in the form view.
        :rtype: set
        """
        return ['currency_id']

    def _get_company_address_field_names(self):
        """ Return a list of fields coming from the address partner to match
        on company address fields. Fields are labeled same on both models. """
        return ['street', 'street2', 'city', 'zip', 'state_id', 'country_id']

    def _get_company_address_update(self, partner):
        return dict((fname, partner[fname])
                    for fname in self._get_company_address_field_names())

    @api.depends('parent_path')
    def _compute_parent_ids(self):
        for company in self.with_context(active_test=False):
            company.parent_ids = self.browse(int(id) for id in company.parent_path.split('/') if id) if company.parent_path else company
            company.root_id = company.parent_ids[0]

    # TODO @api.depends(): currently now way to formulate the dependency on the
    # partner's contact address
    def _compute_address(self):
        for company in self.filtered(lambda company: company.partner_id):
            address_data = company.partner_id.sudo().address_get(adr_pref=['contact'])
            if address_data['contact']:
                partner = company.partner_id.browse(address_data['contact']).sudo()
                company.update(company._get_company_address_update(partner))

    def _inverse_street(self):
        for company in self:
            company.partner_id.street = company.street

    def _inverse_street2(self):
        for company in self:
            company.partner_id.street2 = company.street2

    def _inverse_zip(self):
        for company in self:
            company.partner_id.zip = company.zip

    def _inverse_city(self):
        for company in self:
            company.partner_id.city = company.city

    def _inverse_state(self):
        for company in self:
            company.partner_id.state_id = company.state_id

    def _inverse_country(self):
        for company in self:
            company.partner_id.country_id = company.country_id

    @api.depends('partner_id.image_1920')
    def _compute_logo_web(self):
        for company in self:
            img = company.partner_id.image_1920
            company.logo_web = img and base64.b64encode(tools.image_process(base64.b64decode(img), size=(180, 0)))

    @api.depends('partner_id.image_1920')
    def _compute_uses_default_logo(self):
        default_logo = self._get_logo()
        for company in self:
            company.uses_default_logo = not company.logo or company.logo == default_logo

    @api.depends('root_id')
    def _compute_color(self):
        for company in self:
            company.color = company.root_id.partner_id.color or (company.root_id._origin.id % 12)

    def _inverse_color(self):
        for company in self:
            company.root_id.partner_id.color = company.color

    @api.onchange('state_id')
    def _onchange_state(self):
        if self.state_id.country_id:
            self.country_id = self.state_id.country_id

    @api.onchange('country_id')
    def _onchange_country_id(self):
        if self.country_id:
            self.currency_id = self.country_id.currency_id

    @api.onchange('parent_id')
    def _onchange_parent_id(self):
        if self.parent_id:
            for fname in self._get_company_root_delegated_field_names():
                if self[fname] != self.parent_id[fname]:
                    self[fname] = self.parent_id[fname]

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        def make_delegated_fields_readonly(node):
            for child in node.iterchildren():
                if child.tag == 'field' and child.get('name') in delegated_fnames:
                    child.set('readonly', "parent_id != False")
                else:
                    make_delegated_fields_readonly(child)
            return node

        delegated_fnames = set(self._get_company_root_delegated_field_names())
        arch, view = super()._get_view(view_id, view_type, **options)
        arch = make_delegated_fields_readonly(arch)
        return arch, view

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        context = dict(self.env.context)
        newself = self
        if context.pop('user_preference', None):
            # We browse as superuser. Otherwise, the user would be able to
            # select only the currently visible companies (according to rules,
            # which are probably to allow to see the child companies) even if
            # she belongs to some other companies.
            companies = self.env.user.company_ids
            domain = (domain or []) + [('id', 'in', companies.ids)]
            newself = newself.sudo()
        self = newself.with_context(context)
        return super()._name_search(name, domain, operator, limit, order)

    @api.model
    @api.returns('self', lambda value: value.id)
    def _company_default_get(self, object=False, field=False):
        """ Returns the user's company
            - Deprecated
        """
        _logger.warning("The method '_company_default_get' on res.company is deprecated and shouldn't be used anymore")
        return self.env.company

    @api.depends('company_details')
    def _compute_empty_company_details(self):
        # In recent change when an html field is empty a <p> balise remains with a <br> in it,
        # but when company details is empty we want to put the info of the company
        for record in self:
            record.is_company_details_empty = not html2plaintext(record.company_details or '')

    @api.model_create_multi
    def create(self, vals_list):

        # create missing partners
        no_partner_vals_list = [
            vals
            for vals in vals_list
            if vals.get('name') and not vals.get('partner_id')
        ]
        if no_partner_vals_list:
            partners = self.env['res.partner'].create([
                {
                    'name': vals['name'],
                    'is_company': True,
                    'image_1920': vals.get('logo'),
                    'email': vals.get('email'),
                    'phone': vals.get('phone'),
                    'website': vals.get('website'),
                    'vat': vals.get('vat'),
                    'country_id': vals.get('country_id'),
                }
                for vals in no_partner_vals_list
            ])
            # compute stored fields, for example address dependent fields
            partners.flush_model()
            for vals, partner in zip(no_partner_vals_list, partners):
                vals['partner_id'] = partner.id

        for vals in vals_list:
            # Copy delegated fields from root to branches
            if parent := self.browse(vals.get('parent_id')):
                for fname in self._get_company_root_delegated_field_names():
                    vals.setdefault(fname, self._fields[fname].convert_to_write(parent[fname], parent))

        self.env.registry.clear_cache()
        companies = super().create(vals_list)

        # The write is made on the user to set it automatically in the multi company group.
        if companies:
            (self.env.user | self.env['res.users'].browse(SUPERUSER_ID)).write({
                'company_ids': [Command.link(company.id) for company in companies],
            })

        # Make sure that the selected currencies are enabled
        companies.currency_id.sudo().filtered(lambda c: not c.active).active = True

        return companies

    def cache_invalidation_fields(self):
        # This list is not well defined and tests should be improved
        return {
            'active', # user._get_company_ids and other potential cached search
            'sequence', # user._get_company_ids and other potential cached search
        }

    @api.ondelete(at_uninstall=False)
    def _unlink_if_company_has_no_children(self):
        if any(company.child_ids for company in self):
            raise UserError(_("Companies that have associated branches cannot be deleted. Consider archiving them instead."))

    def write(self, values):
        invalidation_fields = self.cache_invalidation_fields()
        asset_invalidation_fields = {'font', 'primary_color', 'secondary_color', 'external_report_layout_id'}
        if not invalidation_fields.isdisjoint(values):
            self.env.registry.clear_cache()

        if not asset_invalidation_fields.isdisjoint(values):
            # this is used in the content of an asset (see asset_styles_company_report)
            # and thus needs to invalidate the assets cache when this is changed
            self.env.registry.clear_cache('assets')  # not 100% it is useful a test is missing if it is the case

        if 'parent_id' in values:
            raise UserError(_("The company hierarchy cannot be changed."))

        if values.get('currency_id'):
            currency = self.env['res.currency'].browse(values['currency_id'])
            if not currency.active:
                currency.write({'active': True})

        res = super(Company, self).write(values)

        # Archiving a company should also archive all of its branches
        if values.get('active') is False:
            self.child_ids.active = False

        for company in self:
            # Copy modified delegated fields from root to branches
            if (changed := set(values) & set(self._get_company_root_delegated_field_names())) and not company.parent_id:
                branches = self.sudo().search([
                    ('id', 'child_of', company.id),
                    ('id', '!=', company.id),
                ])
                for fname in sorted(changed):
                    branches[fname] = company[fname]

        # invalidate company cache to recompute address based on updated partner
        company_address_fields = self._get_company_address_field_names()
        company_address_fields_upd = set(company_address_fields) & set(values.keys())
        if company_address_fields_upd:
            self.invalidate_model(company_address_fields)
        return res

    @api.constrains('active')
    def _check_active(self):
        for company in self:
            if not company.active:
                company_active_users = self.env['res.users'].search_count([
                    ('company_id', '=', company.id),
                    ('active', '=', True),
                ])
                if company_active_users:
                    # You cannot disable companies with active users
                    raise ValidationError(_(
                        'The company %(company_name)s cannot be archived because it is still used '
                        'as the default company of %(active_users)s users.',
                        company_name=company.name,
                        active_users=company_active_users,
                    ))

    @api.constrains(lambda self: self._get_company_root_delegated_field_names() +['parent_id'])
    def _check_root_delegated_fields(self):
        for company in self:
            if company.parent_id:
                for fname in company._get_company_root_delegated_field_names():
                    if company[fname] != company.parent_id[fname]:
                        description = self.env['ir.model.fields']._get("res.company", fname).field_description
                        raise ValidationError(_("The %s of a subsidiary must be the same as it's root company.", description))

    def open_company_edit_report(self):
        warnings.warn("Since 17.0.", DeprecationWarning, 2)
        self.ensure_one()
        return self.env['res.config.settings'].open_company()

    def write_company_and_print_report(self):
        warnings.warn("Since 17.0.", DeprecationWarning, 2)
        context = self.env.context
        report_name = context.get('default_report_name')
        active_ids = context.get('active_ids')
        active_model = context.get('active_model')
        if report_name and active_ids and active_model:
            docids = self.env[active_model].browse(active_ids)
            return (self.env['ir.actions.report'].search([('report_name', '=', report_name)], limit=1)
                        .report_action(docids))

    @api.model
    def _get_main_company(self):
        try:
            main_company = self.sudo().env.ref('base.main_company')
        except ValueError:
            main_company = self.env['res.company'].sudo().search([], limit=1, order="id")

        return main_company

    @ormcache('tuple(self.env.companies.ids)', 'self.id', 'self.env.uid')
    def __accessible_branches(self):
        # Get branches of this company that the current user can use
        self.ensure_one()

        accessible_branch_ids = []
        accessible = self.env.companies
        current = self.sudo()
        while current:
            accessible_branch_ids.extend((current & accessible).ids)
            current = current.child_ids

        if not accessible_branch_ids and self.env.uid == SUPERUSER_ID:
            # Accessible companies will always be the same for super user when called in a cron.
            # Because of that, the intersection between them and self might be empty. The super user anyway always has
            # access to all companies (as it bypasses the record rules), so we return the current company in this case.
            return self.ids

        return accessible_branch_ids

    def _accessible_branches(self):
        return self.browse(self.__accessible_branches())

    def _all_branches_selected(self):
        """Return whether or all the branches of the companies in self are selected.

        Is ``True`` if all the branches, and only those, are selected.
        Can be used when some actions only make sense for whole companies regardless of the
        branches.
        """
        return self == self.sudo().search([('id', 'child_of', self.root_id.ids)])

    def action_all_company_branches(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Branches'),
            'res_model': 'res.company',
            'domain': [('parent_id', '=', self.id)],
            'context': {
                'active_test': False,
                'default_parent_id': self.id,
            },
            'views': [[False, 'tree'], [False, 'kanban'], [False, 'form']],
        }

```

  File: models/res_config.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import json
import logging
import re

from ast import literal_eval
from lxml import etree

from odoo import api, models, _
from odoo.exceptions import AccessError, RedirectWarning, UserError
from odoo.tools import ustr

_logger = logging.getLogger(__name__)


class ResConfigModuleInstallationMixin(object):
    __slots__ = ()

    @api.model
    def _install_modules(self, modules):
        """ Install the requested modules.

        :param modules: a recordset of ir.module.module records
        :return: the next action to execute
        """
        result = None

        to_install_modules = modules.filtered(lambda module: module.state == 'uninstalled')
        if to_install_modules:
            result = to_install_modules.button_immediate_install()

        return result


class ResConfigConfigurable(models.TransientModel):
    ''' Base classes for new-style configuration items

    Configuration items should inherit from this class, implement
    the execute method (and optionally the cancel one) and have
    their view inherit from the related res_config_view_base view.
    '''
    _name = 'res.config'
    _description = 'Config'

    def start(self):
        # pylint: disable=next-method-called
        return self.next()

    def next(self):
        """
        Reload the settings page
        """
        return {
            'type': 'ir.actions.client',
            'tag': 'reload',
        }

    def execute(self):
        """ Method called when the user clicks on the ``Next`` button.

        Execute *must* be overloaded unless ``action_next`` is overloaded
        (which is something you generally don't need to do).

        If ``execute`` returns an action dictionary, that action is executed
        rather than just going to the next configuration item.
        """
        raise NotImplementedError(
            'Configuration items need to implement execute')

    def cancel(self):
        """ Method called when the user click on the ``Skip`` button.

        ``cancel`` should be overloaded instead of ``action_skip``. As with
        ``execute``, if it returns an action dictionary that action is
        executed in stead of the default (going to the next configuration item)

        The default implementation is a NOOP.

        ``cancel`` is also called by the default implementation of
        ``action_cancel``.
        """
        pass

    def action_next(self):
        """ Action handler for the ``next`` event.

        Sets the status of the todo the event was sent from to
        ``done``, calls ``execute`` and -- unless ``execute`` returned
        an action dictionary -- executes the action provided by calling
        ``next``.
        """
        # pylint: disable=next-method-called
        return self.execute() or self.next()

    def action_skip(self):
        """ Action handler for the ``skip`` event.

        Sets the status of the todo the event was sent from to
        ``skip``, calls ``cancel`` and -- unless ``cancel`` returned
        an action dictionary -- executes the action provided by calling
        ``next``.
        """
        # pylint: disable=next-method-called
        return self.cancel() or self.next()

    def action_cancel(self):
        """ Action handler for the ``cancel`` event. That event isn't
        generated by the res.config.view.base inheritable view, the
        inherited view has to overload one of the buttons (or add one
        more).

        Sets the status of the todo the event was sent from to
        ``cancel``, calls ``cancel`` and -- unless ``cancel`` returned
        an action dictionary -- executes the action provided by calling
        ``next``.
        """
        # pylint: disable=next-method-called
        return self.cancel() or self.next()


class ResConfigInstaller(models.TransientModel, ResConfigModuleInstallationMixin):
    """ New-style configuration base specialized for addons selection
    and installation.

    Basic usage
    -----------

    Subclasses can simply define a number of boolean fields. The field names
    should be the names of the addons to install (when selected). Upon action
    execution, selected boolean fields (and those only) will be interpreted as
    addons to install, and batch-installed.

    Additional addons
    -----------------

    It is also possible to require the installation of an additional
    addon set when a specific preset of addons has been marked for
    installation (in the basic usage only, additionals can't depend on
    one another).

    These additionals are defined through the ``_install_if``
    property. This property is a mapping of a collection of addons (by
    name) to a collection of addons (by name) [#]_, and if all the *key*
    addons are selected for installation, then the *value* ones will
    be selected as well. For example::

        _install_if = {
            ('sale','crm'): ['sale_crm'],
        }

    This will install the ``sale_crm`` addon if and only if both the
    ``sale`` and ``crm`` addons are selected for installation.

    You can define as many additionals as you wish, and additionals
    can overlap in key and value. For instance::

        _install_if = {
            ('sale','crm'): ['sale_crm'],
            ('sale','project'): ['sale_service'],
        }

    will install both ``sale_crm`` and ``sale_service`` if all of
    ``sale``, ``crm`` and ``project`` are selected for installation.

    Hook methods
    ------------

    Subclasses might also need to express dependencies more complex
    than that provided by additionals. In this case, it's possible to
    define methods of the form ``_if_%(name)s`` where ``name`` is the
    name of a boolean field. If the field is selected, then the
    corresponding module will be marked for installation *and* the
    hook method will be executed.

    Hook methods take the usual set of parameters (cr, uid, ids,
    context) and can return a collection of additional addons to
    install (if they return anything, otherwise they should not return
    anything, though returning any "falsy" value such as None or an
    empty collection will have the same effect).

    Complete control
    ----------------

    The last hook is to simply overload the ``modules_to_install``
    method, which implements all the mechanisms above. This method
    takes the usual set of parameters (cr, uid, ids, context) and
    returns a ``set`` of addons to install (addons selected by the
    above methods minus addons from the *basic* set which are already
    installed) [#]_ so an overloader can simply manipulate the ``set``
    returned by ``ResConfigInstaller.modules_to_install`` to add or
    remove addons.

    Skipping the installer
    ----------------------

    Unless it is removed from the view, installers have a *skip*
    button which invokes ``action_skip`` (and the ``cancel`` hook from
    ``res.config``). Hooks and additionals *are not run* when skipping
    installation, even for already installed addons.

    Again, setup your hooks accordingly.

    .. [#] note that since a mapping key needs to be hashable, it's
           possible to use a tuple or a frozenset, but not a list or a
           regular set

    .. [#] because the already-installed modules are only pruned at
           the very end of ``modules_to_install``, additionals and
           hooks depending on them *are guaranteed to execute*. Setup
           your hooks accordingly.
    """
    _name = 'res.config.installer'
    _inherit = 'res.config'
    _description = 'Config Installer'

    _install_if = {}

    def already_installed(self):
        """ For each module, check if it's already installed and if it
        is return its name

        :returns: a list of the already installed modules in this
                  installer
        :rtype: [str]
        """
        return [m.name for m in self._already_installed()]

    def _already_installed(self):
        """ For each module (boolean fields in a res.config.installer),
        check if it's already installed (either 'to install', 'to upgrade'
        or 'installed') and if it is return the module's record

        :returns: a list of all installed modules in this installer
        :rtype: recordset (collection of Record)
        """
        selectable = [name for name, field in self._fields.items()
                      if field.type == 'boolean']
        return self.env['ir.module.module'].search([('name', 'in', selectable),
                            ('state', 'in', ['to install', 'installed', 'to upgrade'])])

    def modules_to_install(self):
        """ selects all modules to install:

        * checked boolean fields
        * return values of hook methods. Hook methods are of the form
          ``_if_%(addon_name)s``, and are called if the corresponding
          addon is marked for installation. They take the arguments
          cr, uid, ids and context, and return an iterable of addon
          names
        * additionals, additionals are setup through the ``_install_if``
          class variable. ``_install_if`` is a dict of {iterable:iterable}
          where key and value are iterables of addon names.

          If all the addons in the key are selected for installation
          (warning: addons added through hooks don't count), then the
          addons in the value are added to the set of modules to install
        * not already installed
        """
        base = set(module_name
                   for installer in self.read()
                   for module_name, to_install in installer.items()
                   if self._fields[module_name].type == 'boolean' and to_install)

        hooks_results = set()
        for module in base:
            hook = getattr(self, '_if_%s'% module, None)
            if hook:
                hooks_results.update(hook() or set())

        additionals = set(module
                          for requirements, consequences in self._install_if.items()
                          if base.issuperset(requirements)
                          for module in consequences)

        return (base | hooks_results | additionals) - set(self.already_installed())

    @api.model
    def default_get(self, fields_list):
        ''' If an addon is already installed, check it by default
        '''
        defaults = super(ResConfigInstaller, self).default_get(fields_list)
        return dict(defaults, **dict.fromkeys(self.already_installed(), True))

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        """ If an addon is already installed, set it to readonly as
        res.config.installer doesn't handle uninstallations of already
        installed addons
        """
        fields = super().fields_get(allfields=allfields, attributes=attributes)

        for name in self.already_installed():
            if name not in fields:
                continue
            fields[name].update(
                readonly=True,
                help= ustr(fields[name].get('help', '')) +
                     _('\n\nThis addon is already installed on your system'))
        return fields

    def execute(self):
        to_install = list(self.modules_to_install())
        _logger.info('Selecting addons %s to install', to_install)

        IrModule = self.env['ir.module.module']
        modules = IrModule.search([('name', 'in', to_install)])
        return self._install_modules(modules)


class ResConfigSettings(models.TransientModel, ResConfigModuleInstallationMixin):
    """ Base configuration wizard for application settings.  It provides support for setting
        default values, assigning groups to employee users, and installing modules.
        To make such a 'settings' wizard, define a model like::

            class MyConfigWizard(models.TransientModel):
                _name = 'my.settings'
                _inherit = 'res.config.settings'

                default_foo = fields.type(..., default_model='my.model'),
                group_bar = fields.Boolean(..., group='base.group_user', implied_group='my.group'),
                module_baz = fields.Boolean(...),
                config_qux = fields.Char(..., config_parameter='my.parameter')
                other_field = fields.type(...),

        The method ``execute`` provides some support based on a naming convention:

        *   For a field like 'default_XXX', ``execute`` sets the (global) default value of
            the field 'XXX' in the model named by ``default_model`` to the field's value.

        *   For a boolean field like 'group_XXX', ``execute`` adds/removes 'implied_group'
            to/from the implied groups of 'group', depending on the field's value.
            By default 'group' is the group Employee.  Groups are given by their xml id.
            The attribute 'group' may contain several xml ids, separated by commas.

        *   For a selection field like 'group_XXX' composed of 2 string values ('0' and '1'),
            ``execute`` adds/removes 'implied_group' to/from the implied groups of 'group',
            depending on the field's value.
            By default 'group' is the group Employee.  Groups are given by their xml id.
            The attribute 'group' may contain several xml ids, separated by commas.

        *   For a boolean field like 'module_XXX', ``execute`` triggers the immediate
            installation of the module named 'XXX' if the field has value ``True``.

        *   For a selection field like 'module_XXX' composed of 2 string values ('0' and '1'),
            ``execute`` triggers the immediate installation of the module named 'XXX'
            if the field has the value ``'1'``.

        *   For a field with no specific prefix BUT an attribute 'config_parameter',
            ``execute``` will save its value in an ir.config.parameter (global setting for the
            database).

        *   For the other fields, the method ``execute`` invokes `set_values`.
            Override it to implement the effect of those fields.

        The method ``default_get`` retrieves values that reflect the current status of the
        fields like 'default_XXX', 'group_XXX', 'module_XXX' and config_XXX.
        It also invokes all methods with a name that starts with 'get_default_';
        such methods can be defined to provide current values for other fields.
    """
    _name = 'res.config.settings'
    _description = 'Config Settings'

    def _valid_field_parameter(self, field, name):
        return (
            name in ('default_model', 'config_parameter')
            or field.type in ('boolean', 'selection') and name in ('group', 'implied_group')
            or super()._valid_field_parameter(field, name)
        )

    def copy(self, default=None):
        raise UserError(_("Cannot duplicate configuration!"))

    def onchange_module(self, field_value, module_name):
        module_sudo = self.env['ir.module.module']._get(module_name[7:])
        if not int(field_value) and module_sudo.state in ('to install', 'installed', 'to upgrade'):
            deps = module_sudo.downstream_dependencies()
            dep_names = (deps | module_sudo).mapped('shortdesc')
            message = '\n'.join(dep_names)
            return {
                'warning': {
                    'title': _('Warning!'),
                    'message': _('Disabling this option will also uninstall the following modules \n%s', message),
                }
            }
        return {}

    def _register_hook(self):
        """ Add an onchange method for each module field. """
        def make_method(name):
            return lambda self: self.onchange_module(self[name], name)

        for name in self._fields:
            if name.startswith('module_'):
                method = make_method(name)
                self._onchange_methods[name].append(method)

    @api.model
    def _get_classified_fields(self, fnames=None):
        """ return a dictionary with the fields classified by category::

                {   'default': [('default_foo', 'model', 'foo'), ...],
                    'group':   [('group_bar', [browse_group], browse_implied_group), ...],
                    'module':  [('module_baz', browse_module), ...],
                    'config':  [('config_qux', 'my.parameter'), ...],
                    'other':   ['other_field', ...],
                }
        """
        IrModule = self.env['ir.module.module']
        IrModelData = self.env['ir.model.data']
        Groups = self.env['res.groups']

        def ref(xml_id):
            res_model, res_id = IrModelData._xmlid_to_res_model_res_id(xml_id)
            return self.env[res_model].browse(res_id)

        if fnames is None:
            fnames = self._fields.keys()

        defaults, groups, configs, others = [], [], [], []
        modules = IrModule
        for name in fnames:
            field = self._fields[name]
            if name.startswith('default_'):
                if not hasattr(field, 'default_model'):
                    raise Exception("Field %s without attribute 'default_model'" % field)
                defaults.append((name, field.default_model, name[8:]))
            elif name.startswith('group_'):
                if field.type not in ('boolean', 'selection'):
                    raise Exception("Field %s must have type 'boolean' or 'selection'" % field)
                if not hasattr(field, 'implied_group'):
                    raise Exception("Field %s without attribute 'implied_group'" % field)
                field_group_xmlids = getattr(field, 'group', 'base.group_user').split(',')
                field_groups = Groups.concat(*(ref(it) for it in field_group_xmlids))
                groups.append((name, field_groups, ref(field.implied_group)))
            elif name.startswith('module_'):
                if field.type not in ('boolean', 'selection'):
                    raise Exception("Field %s must have type 'boolean' or 'selection'" % field)
                modules += IrModule._get(name[7:])
            elif hasattr(field, 'config_parameter') and field.config_parameter:
                if field.type not in ('boolean', 'integer', 'float', 'char', 'selection', 'many2one', 'datetime'):
                    raise Exception("Field %s must have type 'boolean', 'integer', 'float', 'char', 'selection', 'many2one' or 'datetime'" % field)
                configs.append((name, field.config_parameter))
            else:
                others.append(name)

        return {'default': defaults, 'group': groups, 'module': modules, 'config': configs, 'other': others}

    def get_values(self):
        """
        Return values for the fields other that `default`, `group` and `module`
        """
        return {}

    @api.model
    def default_get(self, fields):
        res = super().default_get(fields)
        if not fields:
            return res

        IrDefault = self.env['ir.default']
        IrConfigParameter = self.env['ir.config_parameter'].sudo()
        classified = self._get_classified_fields(fields)

        # defaults: take the corresponding default value they set
        for name, model, field in classified['default']:
            value = IrDefault._get(model, field)
            if value is not None:
                res[name] = value

        # groups: which groups are implied by the group Employee
        for name, groups, implied_group in classified['group']:
            res[name] = all(implied_group in group.implied_ids for group in groups)
            if self._fields[name].type == 'selection':
                res[name] = str(int(res[name]))     # True, False -> '1', '0'

        # modules: which modules are installed/to install
        for module in classified['module']:
            res[f'module_{module.name}'] = module.state in ('installed', 'to install', 'to upgrade')

        # config: get & convert stored ir.config_parameter (or default)
        WARNING_MESSAGE = "Error when converting value %r of field %s for ir.config.parameter %r"
        for name, icp in classified['config']:
            field = self._fields[name]
            value = IrConfigParameter.get_param(icp, field.default(self) if field.default else False)
            if value is not False:
                if field.type == 'many2one':
                    try:
                        # Special case when value is the id of a deleted record, we do not want to
                        # block the settings screen
                        value = self.env[field.comodel_name].browse(int(value)).exists().id
                    except (ValueError, TypeError):
                        _logger.warning(WARNING_MESSAGE, value, field, icp)
                        value = False
                elif field.type == 'integer':
                    try:
                        value = int(value)
                    except (ValueError, TypeError):
                        _logger.warning(WARNING_MESSAGE, value, field, icp)
                        value = 0
                elif field.type == 'float':
                    try:
                        value = float(value)
                    except (ValueError, TypeError):
                        _logger.warning(WARNING_MESSAGE, value, field, icp)
                        value = 0.0
                elif field.type == 'boolean':
                    value = bool(value)
            res[name] = value

        res.update(self.get_values())

        return res

    def set_values(self):
        """
        Set values for the fields other that `default`, `group` and `module`
        """
        self = self.with_context(active_test=False)
        classified = self._get_classified_fields()
        current_settings = self.default_get(list(self.fields_get()))

        # default values fields
        IrDefault = self.env['ir.default'].sudo()
        for name, model, field in classified['default']:
            if isinstance(self[name], models.BaseModel):
                if self._fields[name].type == 'many2one':
                    value = self[name].id
                else:
                    value = self[name].ids
            else:
                value = self[name]
            if name not in current_settings or value != current_settings[name]:
                IrDefault.set(model, field, value)

        # group fields: modify group / implied groups
        for name, groups, implied_group in sorted(classified['group'], key=lambda k: self[k[0]]):
            groups = groups.sudo()
            implied_group = implied_group.sudo()
            if self[name] == current_settings[name]:
                continue
            if int(self[name]):
                groups._apply_group(implied_group)
            else:
                groups._remove_group(implied_group)

        # config fields: store ir.config_parameters
        IrConfigParameter = self.env['ir.config_parameter'].sudo()
        for name, icp in classified['config']:
            field = self._fields[name]
            value = self[name]
            current_value = IrConfigParameter.get_param(icp)

            if field.type == 'char':
                # storing developer keys as ir.config_parameter may lead to nasty
                # bugs when users leave spaces around them
                value = (value or "").strip() or False
            elif field.type in ('integer', 'float'):
                value = repr(value) if value else False
            elif field.type == 'many2one':
                # value is a (possibly empty) recordset
                value = value.id

            if current_value == str(value) or current_value == value:
                continue
            IrConfigParameter.set_param(icp, value)

    def execute(self):
        """
        Called when settings are saved.

        This method will call `set_values` and will install/uninstall any modules defined by
        `module_` Boolean fields and then trigger a web client reload.

        .. warning::

            This method **SHOULD NOT** be overridden, in most cases what you want to override is
            `~set_values()` since `~execute()` does little more than simply call `~set_values()`.

            The part that installs/uninstalls modules **MUST ALWAYS** be at the end of the
            transaction, otherwise there's a big risk of registry <-> database desynchronisation.
        """
        self.ensure_one()
        if not self.env.is_admin():
            raise AccessError(_("Only administrators can change the settings"))

        self = self.with_context(active_test=False)
        classified = self._get_classified_fields()

        self.set_values()

        # module fields: install/uninstall the selected modules
        to_install = classified['module'].filtered(
            lambda m: self[f'module_{m.name}'] and m.state != 'installed')
        to_uninstall = classified['module'].filtered(
            lambda m: not self[f'module_{m.name}'] and m.state in ('installed', 'to upgrade'))

        if to_install or to_uninstall:
            self.env.flush_all()

        if to_uninstall:
            to_uninstall.button_immediate_uninstall()

        installation_status = self._install_modules(to_install)

        if installation_status or to_uninstall:
            # After the uninstall/install calls, the registry and environments
            # are no longer valid. So we reset the environment.
            self.env.reset()
            self = self.env()[self._name]

        # pylint: disable=next-method-called
        config = self.env['res.config'].next() or {}
        if config.get('type') not in ('ir.actions.act_window_close',):
            return config

        # force client-side reload (update user menu and current view)
        return {
            'type': 'ir.actions.client',
            'tag': 'reload',
        }

    def cancel(self):
        # ignore the current record, and send the action to reopen the view
        actions = self.env['ir.actions.act_window'].search([('res_model', '=', self._name)], limit=1)
        if actions:
            return actions.read()[0]
        return {}

    def _compute_display_name(self):
        """ Override display_name method to return an appropriate configuration wizard
        name, and not the generated name."""
        action = self.env['ir.actions.act_window'].search([('res_model', '=', self._name)], limit=1)
        self.display_name = action.name or self._name

    @api.model
    def get_option_path(self, menu_xml_id):
        """
        Fetch the path to a specified configuration view and the action id to access it.

        :param string menu_xml_id: the xml id of the menuitem where the view is located,
            structured as follows: module_name.menuitem_xml_id (e.g.: "sales_team.menu_sale_config")
        :return tuple:
            - t[0]: string: full path to the menuitem (e.g.: "Settings/Configuration/Sales")
            - t[1]: int or long: id of the menuitem's action
        """
        ir_ui_menu = self.env.ref(menu_xml_id)
        return (ir_ui_menu.complete_name, ir_ui_menu.action.id)

    @api.model
    def get_option_name(self, full_field_name):
        """
        Fetch the human readable name of a specified configuration option.

        :param string full_field_name: the full name of the field, structured as follows:
            model_name.field_name (e.g.: "sale.config.settings.fetchmail_lead")
        :return string: human readable name of the field (e.g.: "Create leads from incoming mails")
        """
        model_name, field_name = full_field_name.rsplit('.', 1)
        return self.env[model_name].fields_get([field_name])[field_name]['string']

    @api.model
    def get_config_warning(self, msg):
        """
        Helper: return a Warning exception with the given message where the %(field:xxx)s
        and/or %(menu:yyy)s are replaced by the human readable field's name and/or menuitem's
        full path.

        Usage:
        ------
        Just include in your error message %(field:model_name.field_name)s to obtain the human
        readable field's name, and/or %(menu:module_name.menuitem_xml_id)s to obtain the menuitem's
        full path.

        Example of use:
        ---------------
        from odoo.addons.base.models.res_config import get_warning_config
        raise get_warning_config(cr, _("Error: this action is prohibited. You should check the field %(field:sale.config.settings.fetchmail_lead)s in %(menu:sales_team.menu_sale_config)s."), context=context)

        This will return an exception containing the following message:
            Error: this action is prohibited. You should check the field Create leads from incoming mails in Settings/Configuration/Sales.

        What if there is another substitution in the message already?
        -------------------------------------------------------------
        You could have a situation where the error message you want to upgrade already contains a substitution. Example:
            Cannot find any account journal of %s type for this company.\n\nYou can create one in the menu: \nConfiguration\\Journals\\Journals.
        What you want to do here is simply to replace the path by %menu:account.menu_account_config)s, and leave the rest alone.
        In order to do that, you can use the double percent (%%) to escape your new substitution, like so:
            Cannot find any account journal of %s type for this company.\n\nYou can create one in the %%(menu:account.menu_account_config)s.
        """
        self = self.sudo()

        # Process the message
        # 1/ find the menu and/or field references, put them in a list
        regex_path = r'%\(((?:menu|field):[a-z_\.]*)\)s'
        references = re.findall(regex_path, msg, flags=re.I)

        # 2/ fetch the menu and/or field replacement values (full path and
        #    human readable field's name) and the action_id if any
        values = {}
        action_id = None
        for item in references:
            ref_type, ref = item.split(':')
            if ref_type == 'menu':
                values[item], action_id = self.get_option_path(ref)
            elif ref_type == 'field':
                values[item] = self.get_option_name(ref)

        # 3/ substitute and return the result
        if (action_id):
            return RedirectWarning(msg % values, action_id, _('Go to the configuration panel'))
        return UserError(msg % values)

    @api.model_create_multi
    def create(self, vals_list):
        # Optimisation: saving a res.config.settings even without changing any
        # values will trigger the write of all related values. This in turn may
        # trigger chain of further recomputation. To avoid it, delete values
        # that were not changed.
        for vals in vals_list:
            for field in self._fields.values():
                if not (field.name in vals and field.related and not field.readonly):
                    continue
                # we write on a related field like
                # qr_code = fields.Boolean(related='company_id.qr_code', readonly=False)
                fname0, *fnames = field.related.split(".")
                if fname0 not in vals:
                    continue

                # determine the current value
                field0 = self._fields[fname0]
                old_value = field0.convert_to_record(
                    field0.convert_to_cache(vals[fname0], self), self)
                for fname in fnames:
                    old_value = next(iter(old_value), old_value)[fname]

                # determine the new value
                new_value = field.convert_to_record(
                    field.convert_to_cache(vals[field.name], self), self)

                # drop if the value is the same
                if old_value == new_value:
                    vals.pop(field.name)

        return super().create(vals_list)

    def action_open_template_user(self):
        action = self.env["ir.actions.actions"]._for_xml_id("base.action_res_users")
        template_user_id = literal_eval(self.env['ir.config_parameter'].sudo().get_param('base.template_portal_user_id', 'False'))
        template_user = self.env['res.users'].browse(template_user_id)
        if not template_user.exists():
            raise UserError(_('Invalid template user. It seems it has been deleted.'))
        action['res_id'] = template_user_id
        action['views'] = [[self.env.ref('base.view_users_form').id, 'form']]
        return action

```

  File: models/res_country.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import re
import logging
from odoo import api, fields, models, tools
from odoo.osv import expression
from odoo.exceptions import UserError
from psycopg2 import IntegrityError
from odoo.tools.translate import _
_logger = logging.getLogger(__name__)


FLAG_MAPPING = {
    "GF": "fr",
    "BV": "no",
    "BQ": "nl",
    "GP": "fr",
    "HM": "au",
    "YT": "fr",
    "RE": "fr",
    "MF": "fr",
    "UM": "us",
}

NO_FLAG_COUNTRIES = [
    "AQ", #Antarctica
    "SJ", #Svalbard + Jan Mayen : separate jurisdictions : no dedicated flag
]


class Country(models.Model):
    _name = 'res.country'
    _description = 'Country'
    _order = 'name'

    name = fields.Char(
        string='Country Name', required=True, translate=True)
    code = fields.Char(
        string='Country Code', size=2,
        required=True,
        help='The ISO country code in two chars. \nYou can use this field for quick search.')
    address_format = fields.Text(string="Layout in Reports",
        help="Display format to use for addresses belonging to this country.\n\n"
             "You can use python-style string pattern with all the fields of the address "
             "(for example, use '%(street)s' to display the field 'street') plus"
             "\n%(state_name)s: the name of the state"
             "\n%(state_code)s: the code of the state"
             "\n%(country_name)s: the name of the country"
             "\n%(country_code)s: the code of the country",
        default='%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s')
    address_view_id = fields.Many2one(
        comodel_name='ir.ui.view', string="Input View",
        domain=[('model', '=', 'res.partner'), ('type', '=', 'form')],
        help="Use this field if you want to replace the usual way to encode a complete address. "
             "Note that the address_format field is used to modify the way to display addresses "
             "(in reports for example), while this field is used to modify the input form for "
             "addresses.")
    currency_id = fields.Many2one('res.currency', string='Currency')
    image_url = fields.Char(
        compute="_compute_image_url", string="Flag",
        help="Url of static flag image",
    )
    phone_code = fields.Integer(string='Country Calling Code')
    country_group_ids = fields.Many2many('res.country.group', 'res_country_res_country_group_rel',
                         'res_country_id', 'res_country_group_id', string='Country Groups')
    state_ids = fields.One2many('res.country.state', 'country_id', string='States')
    name_position = fields.Selection([
            ('before', 'Before Address'),
            ('after', 'After Address'),
        ], string="Customer Name Position", default="before",
        help="Determines where the customer/company name should be placed, i.e. after or before the address.")
    vat_label = fields.Char(string='Vat Label', translate=True, prefetch=True, help="Use this field if you want to change vat label.")

    state_required = fields.Boolean(default=False)
    zip_required = fields.Boolean(default=True)

    _sql_constraints = [
        ('name_uniq', 'unique (name)',
            'The name of the country must be unique!'),
        ('code_uniq', 'unique (code)',
            'The code of the country must be unique!')
    ]

    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        if domain is None:
            domain = []

        ids = []
        if len(name) == 2:
            ids = list(self._search([('code', 'ilike', name)] + domain, limit=limit, order=order))

        search_domain = [('name', operator, name)]
        if ids:
            search_domain.append(('id', 'not in', ids))
        ids += list(self._search(search_domain + domain, limit=limit, order=order))

        return ids

    @api.model
    @tools.ormcache('code')
    def _phone_code_for(self, code):
        return self.search([('code', '=', code)]).phone_code

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if vals.get('code'):
                vals['code'] = vals['code'].upper()
        return super(Country, self).create(vals_list)

    def write(self, vals):
        if vals.get('code'):
            vals['code'] = vals['code'].upper()
        res = super().write(vals)
        if ('code' in vals or 'phone_code' in vals):
            # Intentionally simplified by not clearing the cache in create and unlink.
            self.env.registry.clear_cache()
        if 'address_view_id' in vals:
            # Changing the address view of the company must invalidate the view cached for res.partner
            # because of _view_get_address
            self.env.registry.clear_cache('templates')
        return res

    def get_address_fields(self):
        self.ensure_one()
        return re.findall(r'\((.+?)\)', self.address_format)

    @api.depends('code')
    def _compute_image_url(self):
        for country in self:
            if not country.code or country.code in NO_FLAG_COUNTRIES:
                country.image_url = False
            else:
                code = FLAG_MAPPING.get(country.code, country.code.lower())
                country.image_url = "/base/static/img/country_flags/%s.png" % code

    @api.constrains('address_format')
    def _check_address_format(self):
        for record in self:
            if record.address_format:
                address_fields = self.env['res.partner']._formatting_address_fields() + ['state_code', 'state_name', 'country_code', 'country_name', 'company_name']
                try:
                    record.address_format % {i: 1 for i in address_fields}
                except (ValueError, KeyError):
                    raise UserError(_('The layout contains an invalid format key'))

class CountryGroup(models.Model):
    _description = "Country Group"
    _name = 'res.country.group'

    name = fields.Char(required=True, translate=True)
    country_ids = fields.Many2many('res.country', 'res_country_res_country_group_rel',
                                   'res_country_group_id', 'res_country_id', string='Countries')


class CountryState(models.Model):
    _description = "Country state"
    _name = 'res.country.state'
    _order = 'code'

    country_id = fields.Many2one('res.country', string='Country', required=True)
    name = fields.Char(string='State Name', required=True,
               help='Administrative divisions of a country. E.g. Fed. State, Departement, Canton')
    code = fields.Char(string='State Code', help='The state code.', required=True)

    _sql_constraints = [
        ('name_code_uniq', 'unique(country_id, code)', 'The code of the state must be unique by country!')
    ]

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        domain = domain or []
        if self.env.context.get('country_id'):
            domain = expression.AND([domain, [('country_id', '=', self.env.context.get('country_id'))]])

        if operator == 'ilike' and not (name or '').strip():
            domain1 = []
            domain2 = []
        else:
            domain1 = [('code', '=ilike', name)]
            domain2 = [('name', operator, name)]

        first_state_ids = []
        if domain1:
            first_state_ids = list(self._search(
                expression.AND([domain1, domain]), limit=limit, order=order,
            ))
        fallback_domain = None

        if name and operator in ['ilike', '=']:
            fallback_domain = self._get_name_search_domain(name, operator)

        if name and operator in ['in', 'any']:
            fallback_domain = expression.OR([self._get_name_search_domain(n, '=') for n in name])

        return first_state_ids + [
            state_id
            for state_id in self._search(expression.AND([domain2, domain]),
                                         limit=limit, order=order)
            if state_id not in first_state_ids
        ] or (
            list(self._search(expression.AND([fallback_domain, domain]), limit=limit))
            if fallback_domain
            else []
        )

    def _get_name_search_domain(self, name, operator):
        m = re.fullmatch(r"(?P<name>.+)\((?P<country>.+)\)", name)
        if m:
            return [
                ('name', operator, m['name'].strip()),
                '|', ('country_id.name', 'ilike', m['country'].strip()),
                ('country_id.code', '=', m['country'].strip()),
            ]
        return None

    @api.depends('country_id')
    def _compute_display_name(self):
        for record in self:
            record.display_name = f"{record.name} ({record.country_id.code})"

```

  File: models/res_currency.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import logging
import math

from lxml import etree

from odoo import api, fields, models, tools, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools import parse_date

_logger = logging.getLogger(__name__)

try:
    from num2words import num2words
except ImportError:
    _logger.warning("The num2words python library is not installed, amount-to-text features won't be fully available.")
    num2words = None


class Currency(models.Model):
    _name = "res.currency"
    _description = "Currency"
    _rec_names_search = ['name', 'full_name']
    _order = 'active desc, name'

    # Note: 'code' column was removed as of v6.0, the 'name' should now hold the ISO code.
    name = fields.Char(string='Currency', size=3, required=True, help="Currency Code (ISO 4217)")
    full_name = fields.Char(string='Name')
    symbol = fields.Char(help="Currency sign, to be used when printing amounts.", required=True)
    rate = fields.Float(compute='_compute_current_rate', string='Current Rate', digits=0,
                        help='The rate of the currency to the currency of rate 1.')
    inverse_rate = fields.Float(compute='_compute_current_rate', digits=0, readonly=True,
                                help='The currency of rate 1 to the rate of the currency.')
    rate_string = fields.Char(compute='_compute_current_rate')
    rate_ids = fields.One2many('res.currency.rate', 'currency_id', string='Rates')
    rounding = fields.Float(string='Rounding Factor', digits=(12, 6), default=0.01,
        help='Amounts in this currency are rounded off to the nearest multiple of the rounding factor.')
    decimal_places = fields.Integer(compute='_compute_decimal_places', store=True,
        help='Decimal places taken into account for operations on amounts in this currency. It is determined by the rounding factor.')
    active = fields.Boolean(default=True)
    position = fields.Selection([('after', 'After Amount'), ('before', 'Before Amount')], default='after',
        string='Symbol Position', help="Determines where the currency symbol should be placed after or before the amount.")
    date = fields.Date(compute='_compute_date')
    currency_unit_label = fields.Char(string="Currency Unit")
    currency_subunit_label = fields.Char(string="Currency Subunit")
    is_current_company_currency = fields.Boolean(compute='_compute_is_current_company_currency')

    _sql_constraints = [
        ('unique_name', 'unique (name)', 'The currency code must be unique!'),
        ('rounding_gt_zero', 'CHECK (rounding>0)', 'The rounding factor must be greater than 0!')
    ]

    @api.model_create_multi
    def create(self, vals_list):
        res = super().create(vals_list)
        self._toggle_group_multi_currency()
        # Currency info is cached to reduce the number of SQL queries when building the session
        # info. See `ir_http.get_currencies`.
        self.env.registry.clear_cache()
        return res

    def unlink(self):
        res = super().unlink()
        self._toggle_group_multi_currency()
        # Currency info is cached to reduce the number of SQL queries when building the session
        # info. See `ir_http.get_currencies`.
        self.env.registry.clear_cache()
        return res

    def write(self, vals):
        res = super().write(vals)
        if vals.keys() & {'active', 'digits', 'position', 'symbol'}:
            # Currency info is cached to reduce the number of SQL queries when building the session
            # info. See `ir_http.get_currencies`.
            self.env.registry.clear_cache()
        if 'active' not in vals:
            return res
        self._toggle_group_multi_currency()
        return res

    @api.model
    def _toggle_group_multi_currency(self):
        """
        Automatically activate group_multi_currency if there is more than 1 active currency; deactivate it otherwise
        """
        active_currency_count = self.search_count([('active', '=', True)])
        if active_currency_count > 1:
            self._activate_group_multi_currency()
        elif active_currency_count <= 1:
            self._deactivate_group_multi_currency()

    @api.model
    def _activate_group_multi_currency(self):
        group_user = self.env.ref('base.group_user', raise_if_not_found=False)
        group_mc = self.env.ref('base.group_multi_currency', raise_if_not_found=False)
        if group_user and group_mc:
            group_user.sudo()._apply_group(group_mc)

    @api.model
    def _deactivate_group_multi_currency(self):
        group_user = self.env.ref('base.group_user', raise_if_not_found=False)
        group_mc = self.env.ref('base.group_multi_currency', raise_if_not_found=False)
        if group_user and group_mc:
            group_user.sudo()._remove_group(group_mc.sudo())

    @api.constrains('active')
    def _check_company_currency_stays_active(self):
        if self._context.get('install_mode') or self._context.get('force_deactivate'):
            # install_mode : At install, when this check is run, the "active" field of a currency added to a company will
            #                still be evaluated as False, despite it's automatically set at True when added to the company.
            # force_deactivate : Allows deactivation of a currency in tests to enable non multi_currency behaviors
            return

        currencies = self.filtered(lambda c: not c.active)
        if self.env['res.company'].search([('currency_id', 'in', currencies.ids)]):
            raise UserError(_("This currency is set on a company and therefore cannot be deactivated."))

    def _get_rates(self, company, date):
        if not self.ids:
            return {}
        self.env['res.currency.rate'].flush_model(['rate', 'currency_id', 'company_id', 'name'])
        query = """SELECT c.id,
                          COALESCE((SELECT r.rate FROM res_currency_rate r
                                  WHERE r.currency_id = c.id AND r.name <= %s
                                    AND (r.company_id IS NULL OR r.company_id = %s)
                               ORDER BY r.company_id, r.name DESC
                                  LIMIT 1), 1.0) AS rate
                   FROM res_currency c
                   WHERE c.id IN %s"""
        self._cr.execute(query, (date, company.root_id.id, tuple(self.ids)))
        currency_rates = dict(self._cr.fetchall())
        return currency_rates

    @api.depends_context('company')
    def _compute_is_current_company_currency(self):
        for currency in self:
            currency.is_current_company_currency = self.env.company.root_id.currency_id == currency

    @api.depends('rate_ids.rate')
    @api.depends_context('to_currency', 'date', 'company', 'company_id')
    def _compute_current_rate(self):
        date = self._context.get('date') or fields.Date.context_today(self)
        company = self.env['res.company'].browse(self._context.get('company_id')) or self.env.company
        company = company.root_id
        to_currency = self.browse(self.env.context.get('to_currency')) or company.currency_id
        # the subquery selects the last rate before 'date' for the given currency/company
        currency_rates = (self + to_currency)._get_rates(self.env.company, date)
        for currency in self:
            currency.rate = (currency_rates.get(currency.id) or 1.0) / currency_rates.get(to_currency.id)
            currency.inverse_rate = 1 / currency.rate
            if currency != company.currency_id:
                currency.rate_string = '1 %s = %.6f %s' % (to_currency.name, currency.rate, currency.name)
            else:
                currency.rate_string = ''

    @api.depends('rounding')
    def _compute_decimal_places(self):
        for currency in self:
            if 0 < currency.rounding < 1:
                currency.decimal_places = int(math.ceil(math.log10(1/currency.rounding)))
            else:
                currency.decimal_places = 0

    @api.depends('rate_ids.name')
    def _compute_date(self):
        for currency in self:
            currency.date = currency.rate_ids[:1].name

    def amount_to_text(self, amount):
        self.ensure_one()
        def _num2words(number, lang):
            try:
                return num2words(number, lang=lang).title()
            except NotImplementedError:
                return num2words(number, lang='en').title()

        if num2words is None:
            logging.getLogger(__name__).warning("The library 'num2words' is missing, cannot render textual amounts.")
            return ""

        formatted = "%.{0}f".format(self.decimal_places) % amount
        parts = formatted.partition('.')
        integer_value = int(parts[0])
        fractional_value = int(parts[2] or 0)

        lang = tools.get_lang(self.env)
        amount_words = tools.ustr('{amt_value} {amt_word}').format(
                        amt_value=_num2words(integer_value, lang=lang.iso_code),
                        amt_word=self.currency_unit_label,
                        )
        if not self.is_zero(amount - integer_value):
            amount_words += ' ' + _('and') + tools.ustr(' {amt_value} {amt_word}').format(
                        amt_value=_num2words(fractional_value, lang=lang.iso_code),
                        amt_word=self.currency_subunit_label,
                        )
        return amount_words

    def format(self, amount):
        """Return ``amount`` formatted according to ``self``'s rounding rules, symbols and positions.

           Also take care of removing the minus sign when 0.0 is negative

           :param float amount: the amount to round
           :return: formatted str
        """
        self.ensure_one()
        return tools.format_amount(self.env, amount + 0.0, self)

    def round(self, amount):
        """Return ``amount`` rounded  according to ``self``'s rounding rules.

           :param float amount: the amount to round
           :return: rounded float
        """
        self.ensure_one()
        return tools.float_round(amount, precision_rounding=self.rounding)

    def compare_amounts(self, amount1, amount2):
        """Compare ``amount1`` and ``amount2`` after rounding them according to the
           given currency's precision..
           An amount is considered lower/greater than another amount if their rounded
           value is different. This is not the same as having a non-zero difference!

           For example 1.432 and 1.431 are equal at 2 digits precision,
           so this method would return 0.
           However 0.006 and 0.002 are considered different (returns 1) because
           they respectively round to 0.01 and 0.0, even though
           0.006-0.002 = 0.004 which would be considered zero at 2 digits precision.

           :param float amount1: first amount to compare
           :param float amount2: second amount to compare
           :return: (resp.) -1, 0 or 1, if ``amount1`` is (resp.) lower than,
                    equal to, or greater than ``amount2``, according to
                    ``currency``'s rounding.

           With the new API, call it like: ``currency.compare_amounts(amount1, amount2)``.
        """
        self.ensure_one()
        return tools.float_compare(amount1, amount2, precision_rounding=self.rounding)

    def is_zero(self, amount):
        """Returns true if ``amount`` is small enough to be treated as
           zero according to current currency's rounding rules.
           Warning: ``is_zero(amount1-amount2)`` is not always equivalent to
           ``compare_amounts(amount1,amount2) == 0``, as the former will round after
           computing the difference, while the latter will round before, giving
           different results for e.g. 0.006 and 0.002 at 2 digits precision.

           :param float amount: amount to compare with currency's zero

           With the new API, call it like: ``currency.is_zero(amount)``.
        """
        self.ensure_one()
        return tools.float_is_zero(amount, precision_rounding=self.rounding)

    @api.model
    def _get_conversion_rate(self, from_currency, to_currency, company=None, date=None):
        if from_currency == to_currency:
            return 1
        company = company or self.env.company
        date = date or fields.Date.context_today(self)
        return from_currency.with_company(company).with_context(to_currency=to_currency.id, date=str(date)).inverse_rate

    def _convert(self, from_amount, to_currency, company=None, date=None, round=True):  # noqa: A002 builtin-argument-shadowing
        """Returns the converted amount of ``from_amount``` from the currency
           ``self`` to the currency ``to_currency`` for the given ``date`` and
           company.

           :param company: The company from which we retrieve the convertion rate
           :param date: The nearest date from which we retriev the conversion rate.
           :param round: Round the result or not
        """
        self, to_currency = self or to_currency, to_currency or self
        assert self, "convert amount from unknown currency"
        assert to_currency, "convert amount to unknown currency"
        # apply conversion rate
        if from_amount:
            to_amount = from_amount * self._get_conversion_rate(self, to_currency, company, date)
        else:
            return 0.0

        # apply rounding
        return to_currency.round(to_amount) if round else to_amount

    def _select_companies_rates(self):
        return """
            SELECT
                r.currency_id,
                COALESCE(r.company_id, c.id) as company_id,
                r.rate,
                r.name AS date_start,
                (SELECT name FROM res_currency_rate r2
                 WHERE r2.name > r.name AND
                       r2.currency_id = r.currency_id AND
                       (r2.company_id is null or r2.company_id = c.id)
                 ORDER BY r2.name ASC
                 LIMIT 1) AS date_end
            FROM res_currency_rate r
            JOIN res_company c ON (r.company_id is null or r.company_id = c.id)
        """

    @api.model
    def _get_view_cache_key(self, view_id=None, view_type='form', **options):
        """The override of _get_view changing the rate field labels according to the company currency
        makes the view cache dependent on the company currency"""
        key = super()._get_view_cache_key(view_id, view_type, **options)
        return key + ((self.env['res.company'].browse(self._context.get('company_id')) or self.env.company.root_id).currency_id.name,)

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        arch, view = super()._get_view(view_id, view_type, **options)
        if view_type in ('tree', 'form'):
            currency_name = (self.env['res.company'].browse(self._context.get('company_id')) or self.env.company.root_id).currency_id.name
            fields_maps = [
                [['company_rate', 'rate'], _('Unit per %s', currency_name)],
                [['inverse_company_rate', 'inverse_rate'], _('%s per Unit', currency_name)],
            ]
            for fnames, label in fields_maps:
                xpath_expression = '//tree//field[' + " or ".join(f"@name='{f}'" for f in fnames) + "][1]"
                node = arch.xpath(xpath_expression)
                if node:
                    node[0].set('string', label)
        return arch, view


class CurrencyRate(models.Model):
    _name = "res.currency.rate"
    _description = "Currency Rate"
    _rec_names_search = ['name', 'rate']
    _order = "name desc"

    name = fields.Date(string='Date', required=True, index=True,
                           default=fields.Date.context_today)
    rate = fields.Float(
        digits=0,
        group_operator="avg",
        help='The rate of the currency to the currency of rate 1',
        string='Technical Rate'
    )
    company_rate = fields.Float(
        digits=0,
        compute="_compute_company_rate",
        inverse="_inverse_company_rate",
        group_operator="avg",
        help="The currency of rate 1 to the rate of the currency.",
    )
    inverse_company_rate = fields.Float(
        digits=0,
        compute="_compute_inverse_company_rate",
        inverse="_inverse_inverse_company_rate",
        group_operator="avg",
        help="The rate of the currency to the currency of rate 1 ",
    )
    currency_id = fields.Many2one('res.currency', string='Currency', readonly=True, required=True, ondelete="cascade")
    company_id = fields.Many2one('res.company', string='Company',
                                 default=lambda self: self.env.company.root_id)

    _sql_constraints = [
        ('unique_name_per_day', 'unique (name,currency_id,company_id)', 'Only one currency rate per day allowed!'),
        ('currency_rate_check', 'CHECK (rate>0)', 'The currency rate must be strictly positive.'),
    ]

    def _sanitize_vals(self, vals):
        if 'inverse_company_rate' in vals and ('company_rate' in vals or 'rate' in vals):
            del vals['inverse_company_rate']
        if 'company_rate' in vals and 'rate' in vals:
            del vals['company_rate']
        return vals

    def write(self, vals):
        self.env['res.currency'].invalidate_model(['inverse_rate'])
        return super().write(self._sanitize_vals(vals))

    @api.model_create_multi
    def create(self, vals_list):
        self.env['res.currency'].invalidate_model(['inverse_rate'])
        return super().create([self._sanitize_vals(vals) for vals in vals_list])

    def _get_latest_rate(self):
        # Make sure 'name' is defined when creating a new rate.
        if not self.name:
            raise UserError(_("The name for the current rate is empty.\nPlease set it."))
        return self.currency_id.rate_ids.sudo().filtered(lambda x: (
            x.rate
            and x.company_id == (self.company_id or self.env.company.root_id)
            and x.name < (self.name or fields.Date.today())
        )).sorted('name')[-1:]

    def _get_last_rates_for_companies(self, companies):
        return {
            company: company.currency_id.rate_ids.sudo().filtered(lambda x: (
                x.rate
                and x.company_id == company or not x.company_id
            )).sorted('name')[-1:].rate or 1
            for company in companies
        }

    @api.depends('currency_id', 'company_id', 'name')
    def _compute_rate(self):
        for currency_rate in self:
            currency_rate.rate = currency_rate.rate or currency_rate._get_latest_rate().rate or 1.0

    @api.depends('rate', 'name', 'currency_id', 'company_id', 'currency_id.rate_ids.rate')
    @api.depends_context('company')
    def _compute_company_rate(self):
        last_rate = self.env['res.currency.rate']._get_last_rates_for_companies(self.company_id | self.env.company.root_id)
        for currency_rate in self:
            company = currency_rate.company_id or self.env.company.root_id
            currency_rate.company_rate = (currency_rate.rate or currency_rate._get_latest_rate().rate or 1.0) / last_rate[company]

    @api.onchange('company_rate')
    def _inverse_company_rate(self):
        last_rate = self.env['res.currency.rate']._get_last_rates_for_companies(self.company_id | self.env.company.root_id)
        for currency_rate in self:
            company = currency_rate.company_id or self.env.company.root_id
            currency_rate.rate = currency_rate.company_rate * last_rate[company]

    @api.depends('company_rate')
    def _compute_inverse_company_rate(self):
        for currency_rate in self:
            if not currency_rate.company_rate:
                currency_rate.company_rate = 1.0
            currency_rate.inverse_company_rate = 1.0 / currency_rate.company_rate

    @api.onchange('inverse_company_rate')
    def _inverse_inverse_company_rate(self):
        for currency_rate in self:
            if not currency_rate.inverse_company_rate:
                currency_rate.inverse_company_rate = 1.0
            currency_rate.company_rate = 1.0 / currency_rate.inverse_company_rate

    @api.onchange('company_rate')
    def _onchange_rate_warning(self):
        latest_rate = self._get_latest_rate()
        if latest_rate:
            diff = (latest_rate.rate - self.rate) / latest_rate.rate
            if abs(diff) > 0.2:
                return {
                    'warning': {
                        'title': _("Warning for %s", self.currency_id.name),
                        'message': _(
                            "The new rate is quite far from the previous rate.\n"
                            "Incorrect currency rates may cause critical problems, make sure the rate is correct!"
                        )
                    }
                }

    @api.constrains('company_id')
    def _check_company_id(self):
        for rate in self:
            if rate.company_id.parent_id:
                raise ValidationError("Currency rates should only be created for main companies")

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        return super()._name_search(parse_date(self.env, name), domain, operator, limit, order)

    @api.model
    def _get_view_cache_key(self, view_id=None, view_type='form', **options):
        """The override of _get_view changing the rate field labels according to the company currency
        makes the view cache dependent on the company currency"""
        key = super()._get_view_cache_key(view_id, view_type, **options)
        return key + ((self.env['res.company'].browse(self._context.get('company_id')) or self.env.company.root_id).currency_id.name,)

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        arch, view = super()._get_view(view_id, view_type, **options)
        if view_type in ('tree'):
            names = {
                'company_currency_name': (self.env['res.company'].browse(self._context.get('company_id')) or self.env.company.root_id).currency_id.name,
                'rate_currency_name': self.env['res.currency'].browse(self._context.get('active_id')).name or 'Unit',
            }
            for field in [['company_rate', _('%(rate_currency_name)s per %(company_currency_name)s', **names)],
                          ['inverse_company_rate', _('%(company_currency_name)s per %(rate_currency_name)s', **names)]]:
                node = arch.xpath("//tree//field[@name='%s']" % field[0])
                if node:
                    node[0].set('string', field[1])
        return arch, view

```

  File: models/res_lang.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast
import json
import locale
import logging
import re
from operator import itemgetter

from odoo import api, fields, models, tools, _
from odoo.exceptions import UserError, ValidationError

_logger = logging.getLogger(__name__)

DEFAULT_DATE_FORMAT = '%m/%d/%Y'
DEFAULT_TIME_FORMAT = '%H:%M:%S'


class Lang(models.Model):
    _name = "res.lang"
    _description = "Languages"
    _order = "active desc,name"
    _allow_sudo_commands = False

    _disallowed_datetime_patterns = list(tools.DATETIME_FORMATS_MAP)
    _disallowed_datetime_patterns.remove('%y') # this one is in fact allowed, just not good practice

    name = fields.Char(required=True)
    code = fields.Char(string='Locale Code', required=True, help='This field is used to set/get locales for user')
    iso_code = fields.Char(string='ISO code', help='This ISO code is the name of po files to use for translations')
    url_code = fields.Char('URL Code', required=True, help='The Lang Code displayed in the URL')
    active = fields.Boolean()
    direction = fields.Selection([('ltr', 'Left-to-Right'), ('rtl', 'Right-to-Left')], required=True, default='ltr')
    date_format = fields.Char(string='Date Format', required=True, default=DEFAULT_DATE_FORMAT)
    time_format = fields.Char(string='Time Format', required=True, default=DEFAULT_TIME_FORMAT)
    week_start = fields.Selection([('1', 'Monday'),
                                   ('2', 'Tuesday'),
                                   ('3', 'Wednesday'),
                                   ('4', 'Thursday'),
                                   ('5', 'Friday'),
                                   ('6', 'Saturday'),
                                   ('7', 'Sunday')], string='First Day of Week', required=True, default='7')
    grouping = fields.Char(string='Separator Format', required=True, default='[]',
        help="The Separator Format should be like [,n] where 0 < n :starting from Unit digit. "
             "-1 will end the separation. e.g. [3,2,-1] will represent 106500 to be 1,06,500; "
             "[1,2,-1] will represent it to be 106,50,0;[3] will represent it as 106,500. "
             "Provided ',' as the thousand separator in each case.")
    decimal_point = fields.Char(string='Decimal Separator', required=True, default='.', trim=False)
    thousands_sep = fields.Char(string='Thousands Separator', default=',', trim=False)

    @api.depends('code', 'flag_image')
    def _compute_field_flag_image_url(self):
        for lang in self:
            if lang.flag_image:
                lang.flag_image_url = f"/web/image/res.lang/{lang.id}/flag_image"
            else:
                lang.flag_image_url = f"/base/static/img/country_flags/{lang.code.lower().rsplit('_')[-1]}.png"

    flag_image = fields.Image("Image")
    flag_image_url = fields.Char(compute=_compute_field_flag_image_url)

    _sql_constraints = [
        ('name_uniq', 'unique(name)', 'The name of the language must be unique!'),
        ('code_uniq', 'unique(code)', 'The code of the language must be unique!'),
        ('url_code_uniq', 'unique(url_code)', 'The URL code of the language must be unique!'),
    ]

    @api.constrains('active')
    def _check_active(self):
        # do not check during installation
        if self.env.registry.ready and not self.search_count([]):
            raise ValidationError(_('At least one language must be active.'))

    @api.constrains('time_format', 'date_format')
    def _check_format(self):
        for lang in self:
            for pattern in lang._disallowed_datetime_patterns:
                if (lang.time_format and pattern in lang.time_format) or \
                        (lang.date_format and pattern in lang.date_format):
                    raise ValidationError(_('Invalid date/time format directive specified. '
                                            'Please refer to the list of allowed directives, '
                                            'displayed when you edit a language.'))

    @api.onchange('time_format', 'date_format')
    def _onchange_format(self):
        warning = {
            'warning': {
                'title': _("Using 24-hour clock format with AM/PM can cause issues."),
                'message': _("Changing to 12-hour clock format instead."),
                'type': 'notification'
            }
        }
        for lang in self:
            if lang.date_format and "%H" in lang.date_format and "%p" in lang.date_format:
                lang.date_format = lang.date_format.replace("%H", "%I")
                return warning
            if lang.time_format and "%H" in lang.time_format and "%p" in lang.time_format:
                lang.time_format = lang.time_format.replace("%H", "%I")
                return warning

    @api.constrains('grouping')
    def _check_grouping(self):
        warning = _('The Separator Format should be like [,n] where 0 < n :starting from Unit digit. '
                    '-1 will end the separation. e.g. [3,2,-1] will represent 106500 to be 1,06,500;'
                    '[1,2,-1] will represent it to be 106,50,0;[3] will represent it as 106,500. '
                    'Provided as the thousand separator in each case.')
        for lang in self:
            try:
                if any(not isinstance(x, int) for x in json.loads(lang.grouping)):
                    raise ValidationError(warning)
            except Exception:
                raise ValidationError(warning)

    def _register_hook(self):
        # check that there is at least one active language
        if not self.search_count([]):
            _logger.error("No language is active.")

    def _activate_lang(self, code):
        """ Activate languages
        :param code: code of the language to activate
        :return: the language matching 'code' activated
        """
        lang = self.with_context(active_test=False).search([('code', '=', code)])
        if lang and not lang.active:
            lang.active = True
        return lang

    def _create_lang(self, lang, lang_name=None):
        """ Create the given language and make it active. """
        # create the language with locale information
        fail = True
        iso_lang = tools.get_iso_codes(lang)
        for ln in tools.get_locales(lang):
            try:
                locale.setlocale(locale.LC_ALL, str(ln))
                fail = False
                break
            except locale.Error:
                continue
        if fail:
            lc = locale.getlocale()[0]
            msg = 'Unable to get information for locale %s. Information from the default locale (%s) have been used.'
            _logger.warning(msg, lang, lc)

        if not lang_name:
            lang_name = lang

        def fix_xa0(s):
            """Fix badly-encoded non-breaking space Unicode character from locale.localeconv(),
               coercing to utf-8, as some platform seem to output localeconv() in their system
               encoding, e.g. Windows-1252"""
            if s == '\xa0':
                return '\xc2\xa0'
            return s

        def fix_datetime_format(format):
            """Python's strftime supports only the format directives
               that are available on the platform's libc, so in order to
               be 100% cross-platform we map to the directives required by
               the C standard (1989 version), always available on platforms
               with a C standard implementation."""
            # For some locales, nl_langinfo returns a D_FMT/T_FMT that contains
            # unsupported '%-' patterns, e.g. for cs_CZ
            format = format.replace('%-', '%')
            for pattern, replacement in tools.DATETIME_FORMATS_MAP.items():
                format = format.replace(pattern, replacement)
            return str(format)

        conv = locale.localeconv()
        lang_info = {
            'code': lang,
            'iso_code': iso_lang,
            'name': lang_name,
            'active': True,
            'date_format' : fix_datetime_format(locale.nl_langinfo(locale.D_FMT)),
            'time_format' : fix_datetime_format(locale.nl_langinfo(locale.T_FMT)),
            'decimal_point' : fix_xa0(str(conv['decimal_point'])),
            'thousands_sep' : fix_xa0(str(conv['thousands_sep'])),
            'grouping' : str(conv.get('grouping', [])),
        }
        try:
            return self.create(lang_info)
        finally:
            tools.resetlocale()

    @api.model
    def install_lang(self):
        """

        This method is called from odoo/addons/base/data/res_lang_data.xml to load
        some language and set it as the default for every partners. The
        language is set via tools.config by the '_initialize_db' method on the
        'db' object. This is a fragile solution and something else should be
        found.

        """
        # config['load_language'] is a comma-separated list or None
        lang_code = (tools.config.get('load_language') or 'en_US').split(',')[0]
        lang = self._activate_lang(lang_code) or self._create_lang(lang_code)
        IrDefault = self.env['ir.default']
        default_value = IrDefault._get('res.partner', 'lang')
        if default_value is None:
            IrDefault.set('res.partner', 'lang', lang_code)
            # set language of main company, created directly by db bootstrap SQL
            partner = self.env.company.partner_id
            if not partner.lang:
                partner.write({'lang': lang_code})
        return True

    @tools.ormcache('code')
    def _lang_get_id(self, code):
        return self.with_context(active_test=True).search([('code', '=', code)]).id

    @tools.ormcache('code')
    def _lang_get_direction(self, code):
        return self.with_context(active_test=True).search([('code', '=', code)]).direction

    @tools.ormcache('url_code')
    def _lang_get_code(self, url_code):
        return self.with_context(active_test=True).search([('url_code', '=', url_code)]).code or url_code

    def _lang_get(self, code):
        """ Return the language using this code if it is active """
        return self.browse(self._lang_get_id(code))

    @tools.ormcache('self.code', 'monetary')
    def _data_get(self, monetary=False):
        thousands_sep = self.thousands_sep or ''
        decimal_point = self.decimal_point
        grouping = self.grouping
        return grouping, thousands_sep, decimal_point

    @api.model
    @tools.ormcache()
    def get_available(self):
        """ Return the available languages as a list of (code, url_code, name,
            active) sorted by name.
        """
        langs = self.with_context(active_test=False).search([])
        return langs.get_sorted()

    def get_sorted(self):
        return sorted([(lang.code, lang.url_code, lang.name, lang.active, lang.flag_image_url) for lang in self], key=itemgetter(2))

    @tools.ormcache('self.id')
    def _get_cached_values(self):
        self.ensure_one()
        return {
            'id': self.id,
            'code': self.code,
            'url_code': self.url_code,
            'name': self.name,
        }

    def _get_cached(self, field):
        return self._get_cached_values()[field]

    @api.model
    @tools.ormcache('code')
    def _lang_code_to_urlcode(self, code):
        for c, urlc, name, *_ in self.get_available():
            if c == code:
                return urlc
        return self._lang_get(code).url_code

    @api.model
    @tools.ormcache()
    def get_installed(self):
        """ Return the installed languages as a list of (code, name) sorted by name. """
        langs = self.with_context(active_test=True).search([])
        return sorted([(lang.code, lang.name) for lang in langs], key=itemgetter(1))

    def toggle_active(self):
        super().toggle_active()
        # Automatically load translation
        active_lang = [lang.code for lang in self.filtered(lambda l: l.active)]
        if active_lang:
            mods = self.env['ir.module.module'].search([('state', '=', 'installed')])
            mods._update_translations(active_lang)

    @api.model_create_multi
    def create(self, vals_list):
        self.env.registry.clear_cache()
        for vals in vals_list:
            if not vals.get('url_code'):
                vals['url_code'] = vals.get('iso_code') or vals['code']
        return super(Lang, self).create(vals_list)

    def write(self, vals):
        lang_codes = self.mapped('code')
        if 'code' in vals and any(code != vals['code'] for code in lang_codes):
            raise UserError(_("Language code cannot be modified."))
        if vals.get('active') == False:
            if self.env['res.users'].with_context(active_test=True).search_count([('lang', 'in', lang_codes)], limit=1):
                raise UserError(_("Cannot deactivate a language that is currently used by users."))
            if self.env['res.partner'].with_context(active_test=True).search_count([('lang', 'in', lang_codes)], limit=1):
                raise UserError(_("Cannot deactivate a language that is currently used by contacts."))
            if self.env['res.users'].with_context(active_test=False).search_count([('lang', 'in', lang_codes)], limit=1):
                raise UserError(_("You cannot archive the language in which Odoo was setup as it is used by automated processes."))
            # delete linked ir.default specifying default partner's language
            self.env['ir.default'].discard_values('res.partner', 'lang', lang_codes)

        res = super(Lang, self).write(vals)
        self.env.flush_all()
        self.env.registry.clear_cache()
        return res

    @api.ondelete(at_uninstall=True)
    def _unlink_except_default_lang(self):
        for language in self:
            if language.code == 'en_US':
                raise UserError(_("Base Language 'en_US' can not be deleted."))
            ctx_lang = self._context.get('lang')
            if ctx_lang and (language.code == ctx_lang):
                raise UserError(_("You cannot delete the language which is the user's preferred language."))
            if language.active:
                raise UserError(_("You cannot delete the language which is Active!\nPlease de-activate the language first."))

    def unlink(self):
        self.env.registry.clear_cache()
        return super(Lang, self).unlink()

    def format(self, percent, value, grouping=False, monetary=False):
        """ Format() will return the language-specific output for float values"""
        self.ensure_one()
        if percent[0] != '%':
            raise ValueError(_("format() must be given exactly one %char format specifier"))

        formatted = percent % value

        # floats and decimal ints need special action!
        if grouping:
            lang_grouping, thousands_sep, decimal_point = self._data_get(monetary)
            eval_lang_grouping = ast.literal_eval(lang_grouping)

            if percent[-1] in 'eEfFgG':
                parts = formatted.split('.')
                parts[0] = intersperse(parts[0], eval_lang_grouping, thousands_sep)[0]

                formatted = decimal_point.join(parts)

            elif percent[-1] in 'diu':
                formatted = intersperse(formatted, eval_lang_grouping, thousands_sep)[0]

        return formatted

    def action_activate_langs(self):
        """ Activate the selected languages """
        for lang in self.filtered(lambda l: not l.active):
            lang.toggle_active()
        message = _("The languages that you selected have been successfully installed. Users can choose their favorite language in their preferences.")
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'target': 'new',
            'params': {
                'message': message,
                'type': 'success',
                'sticky': False,
                'next': {'type': 'ir.actions.act_window_close'},
            }
        }

def split(l, counts):
    """

    >>> split("hello world", [])
    ['hello world']
    >>> split("hello world", [1])
    ['h', 'ello world']
    >>> split("hello world", [2])
    ['he', 'llo world']
    >>> split("hello world", [2,3])
    ['he', 'llo', ' world']
    >>> split("hello world", [2,3,0])
    ['he', 'llo', ' wo', 'rld']
    >>> split("hello world", [2,-1,3])
    ['he', 'llo world']

    """
    res = []
    saved_count = len(l) # count to use when encoutering a zero
    for count in counts:
        if not l:
            break
        if count == -1:
            break
        if count == 0:
            while l:
                res.append(l[:saved_count])
                l = l[saved_count:]
            break
        res.append(l[:count])
        l = l[count:]
        saved_count = count
    if l:
        res.append(l)
    return res

intersperse_pat = re.compile('([^0-9]*)([^ ]*)(.*)')

def intersperse(string, counts, separator=''):
    """

    See the asserts below for examples.

    """
    left, rest, right = intersperse_pat.match(string).groups()
    def reverse(s): return s[::-1]
    splits = split(reverse(rest), counts)
    res = separator.join(reverse(s) for s in reverse(splits))
    return left + res + right, len(splits) > 0 and len(splits) -1 or 0

```

  File: models/res_partner.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import collections
import datetime
import hashlib
import pytz
import threading
import re
import warnings

import requests
from collections import defaultdict
from lxml import etree
from random import randint
from werkzeug import urls

from odoo import api, fields, models, tools, SUPERUSER_ID, _, Command
from odoo.osv.expression import get_unaccent_wrapper
from odoo.exceptions import RedirectWarning, UserError, ValidationError

# Global variables used for the warning fields declared on the res.partner
# in the following modules : sale, purchase, account, stock
WARNING_MESSAGE = [
                   ('no-message','No Message'),
                   ('warning','Warning'),
                   ('block','Blocking Message')
                   ]
WARNING_HELP = 'Selecting the "Warning" option will notify user with the message, Selecting "Blocking Message" will throw an exception with the message and block the flow. The Message has to be written in the next field.'


ADDRESS_FIELDS = ('street', 'street2', 'zip', 'city', 'state_id', 'country_id')
@api.model
def _lang_get(self):
    return self.env['res.lang'].get_installed()


# put POSIX 'Etc/*' entries at the end to avoid confusing users - see bug 1086728
_tzs = [(tz, tz) for tz in sorted(pytz.all_timezones, key=lambda tz: tz if not tz.startswith('Etc/') else '_')]
def _tz_get(self):
    return _tzs


class FormatAddressMixin(models.AbstractModel):
    _name = "format.address.mixin"
    _description = 'Address Format'

    def _view_get_address(self, arch):
        # consider the country of the user, not the country of the partner we want to display
        address_view_id = self.env.company.country_id.address_view_id.sudo()
        address_format = self.env.company.country_id.address_format
        if address_view_id and not self._context.get('no_address_format') and (not address_view_id.model or address_view_id.model == self._name):
            #render the partner address accordingly to address_view_id
            for address_node in arch.xpath("//div[hasclass('o_address_format')]"):
                Partner = self.env['res.partner'].with_context(no_address_format=True)
                sub_arch, _sub_view = Partner._get_view(address_view_id.id, 'form')
                #if the model is different than res.partner, there are chances that the view won't work
                #(e.g fields not present on the model). In that case we just return arch
                if self._name != 'res.partner':
                    try:
                        self.env['ir.ui.view'].postprocess_and_fields(sub_arch, model=self._name)
                    except ValueError:
                        return arch
                address_node.getparent().replace(address_node, sub_arch)
        elif address_format and not self._context.get('no_address_format'):
            # For the zip, city and state fields we need to move them around in order to follow the country address format.
            # The purpose of this is to help the user by following a format he is used to.
            city_line = [line.split(' ') for line in address_format.split('\n') if 'city' in line]
            if city_line:
                field_order = [field.replace('%(', '').replace(')s', '') for field in city_line[0]]
                for address_node in arch.xpath("//div[hasclass('o_address_format')]"):
                    concerned_fields = {'zip', 'city', 'state_id'} - {field_order[0]}
                    current_field = address_node.find(f".//field[@name='{field_order[0]}']")
                    # First loop into the fields displayed in the address_format, and order them.
                    for field in field_order[1:]:
                        if field in ('state_code', 'state_name'):
                            field = 'state_id'
                        previous_field = current_field
                        current_field = address_node.find(f".//field[@name='{field}']")
                        if previous_field is not None and current_field is not None:
                            previous_field.addnext(current_field)
                        concerned_fields -= {field}
                    # Add the remaining fields in 'concerned_fields' at the end, after the others
                    for field in concerned_fields:
                        previous_field = current_field
                        current_field = address_node.find(f".//field[@name='{field}']")
                        if previous_field is not None and current_field is not None:
                            previous_field.addnext(current_field)

        return arch

    @api.model
    def _get_view_cache_key(self, view_id=None, view_type='form', **options):
        """The override of _get_view, using _view_get_address,
        changing the architecture according to the address view of the company,
        makes the view cache dependent on the company.
        Different companies could use each a different address view"""
        key = super()._get_view_cache_key(view_id, view_type, **options)
        return key + (self.env.company, self._context.get('no_address_format'),)

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        arch, view = super()._get_view(view_id, view_type, **options)
        if view.type == 'form':
            arch = self._view_get_address(arch)
        return arch, view


class PartnerCategory(models.Model):
    _description = 'Partner Tags'
    _name = 'res.partner.category'
    _order = 'name'
    _parent_store = True

    def _get_default_color(self):
        return randint(1, 11)

    name = fields.Char(string='Tag Name', required=True, translate=True)
    color = fields.Integer(string='Color', default=_get_default_color)
    parent_id = fields.Many2one('res.partner.category', string='Parent Category', index=True, ondelete='cascade')
    child_ids = fields.One2many('res.partner.category', 'parent_id', string='Child Tags')
    active = fields.Boolean(default=True, help="The active field allows you to hide the category without removing it.")
    parent_path = fields.Char(index=True, unaccent=False)
    partner_ids = fields.Many2many('res.partner', column1='category_id', column2='partner_id', string='Partners', copy=False)

    @api.constrains('parent_id')
    def _check_parent_id(self):
        if not self._check_recursion():
            raise ValidationError(_('You can not create recursive tags.'))

    @api.depends('parent_id')
    def _compute_display_name(self):
        """ Return the categories' display name, including their direct
            parent by default.
        """
        for category in self:
            names = []
            current = category
            while current:
                names.append(current.name or "")
                current = current.parent_id
            category.display_name = ' / '.join(reversed(names))

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        domain = domain or []
        if name:
            # Be sure name_search is symetric to display_name
            name = name.split(' / ')[-1]
            domain = [('name', operator, name)] + domain
        return self._search(domain, limit=limit, order=order)


class PartnerTitle(models.Model):
    _name = 'res.partner.title'
    _order = 'name'
    _description = 'Partner Title'

    name = fields.Char(string='Title', required=True, translate=True)
    shortcut = fields.Char(string='Abbreviation', translate=True)


class Partner(models.Model):
    _description = 'Contact'
    _inherit = ['format.address.mixin', 'avatar.mixin']
    _name = "res.partner"
    _order = "complete_name ASC, id DESC"
    _rec_names_search = ['complete_name', 'email', 'ref', 'vat', 'company_registry']  # TODO vat must be sanitized the same way for storing/searching
    _allow_sudo_commands = False
    _check_company_domain = models.check_company_domain_parent_of

    # the partner types that must be added to a partner's complete name, like "Delivery"
    _complete_name_displayed_types = ('invoice', 'delivery', 'other')

    def _default_category(self):
        return self.env['res.partner.category'].browse(self._context.get('category_id'))

    @api.model
    def default_get(self, default_fields):
        """Add the company of the parent as default if we are creating a child partner.
        Also take the parent lang by default if any, otherwise, fallback to default DB lang."""
        values = super().default_get(default_fields)
        parent = self.env["res.partner"]
        if 'parent_id' in default_fields and values.get('parent_id'):
            parent = self.browse(values.get('parent_id'))
            values['company_id'] = parent.company_id.id
        if 'lang' in default_fields:
            values['lang'] = values.get('lang') or parent.lang or self.env.lang
        # protection for `default_type` values leaking from menu action context (e.g. for crm's email)
        if 'type' in default_fields and values.get('type'):
            if values['type'] not in self._fields['type'].get_values(self.env):
                values['type'] = None
        return values

    name = fields.Char(index=True, default_export_compatible=True)
    complete_name = fields.Char(compute='_compute_complete_name', store=True, index=True)
    date = fields.Date(index=True)
    title = fields.Many2one('res.partner.title')
    parent_id = fields.Many2one('res.partner', string='Related Company', index=True)
    parent_name = fields.Char(related='parent_id.name', readonly=True, string='Parent name')
    child_ids = fields.One2many('res.partner', 'parent_id', string='Contact', domain=[('active', '=', True)])
    ref = fields.Char(string='Reference', index=True)
    lang = fields.Selection(_lang_get, string='Language',
                            help="All the emails and documents sent to this contact will be translated in this language.")
    active_lang_count = fields.Integer(compute='_compute_active_lang_count')
    tz = fields.Selection(_tz_get, string='Timezone', default=lambda self: self._context.get('tz'),
                          help="When printing documents and exporting/importing data, time values are computed according to this timezone.\n"
                               "If the timezone is not set, UTC (Coordinated Universal Time) is used.\n"
                               "Anywhere else, time values are computed according to the time offset of your web client.")

    tz_offset = fields.Char(compute='_compute_tz_offset', string='Timezone offset')
    user_id = fields.Many2one(
        'res.users', string='Salesperson',
        compute='_compute_user_id',
        precompute=True,  # avoid queries post-create
        readonly=False, store=True,
        help='The internal user in charge of this contact.')
    vat = fields.Char(string='Tax ID', index=True, help="The Tax Identification Number. Values here will be validated based on the country format. You can use '/' to indicate that the partner is not subject to tax.")
    same_vat_partner_id = fields.Many2one('res.partner', string='Partner with same Tax ID', compute='_compute_same_vat_partner_id', store=False)
    same_company_registry_partner_id = fields.Many2one('res.partner', string='Partner with same Company Registry', compute='_compute_same_vat_partner_id', store=False)
    company_registry = fields.Char(string="Company ID", compute='_compute_company_registry', store=True, readonly=False,
       help="The registry number of the company. Use it if it is different from the Tax ID. It must be unique across all partners of a same country")
    bank_ids = fields.One2many('res.partner.bank', 'partner_id', string='Banks')
    website = fields.Char('Website Link')
    comment = fields.Html(string='Notes')

    category_id = fields.Many2many('res.partner.category', column1='partner_id',
                                    column2='category_id', string='Tags', default=_default_category)
    active = fields.Boolean(default=True)
    employee = fields.Boolean(help="Check this box if this contact is an Employee.")
    function = fields.Char(string='Job Position')
    type = fields.Selection(
        [('contact', 'Contact'),
         ('invoice', 'Invoice Address'),
         ('delivery', 'Delivery Address'),
         ('other', 'Other Address'),
        ], string='Address Type',
        default='contact',
        help="- Contact: Use this to organize the contact details of employees of a given company (e.g. CEO, CFO, ...).\n"
             "- Invoice Address: Preferred address for all invoices. Selected by default when you invoice an order that belongs to this company.\n"
             "- Delivery Address: Preferred address for all deliveries. Selected by default when you deliver an order that belongs to this company.\n"
             "- Other: Other address for the company (e.g. subsidiary, ...)")
    # address fields
    street = fields.Char()
    street2 = fields.Char()
    zip = fields.Char(change_default=True)
    city = fields.Char()
    state_id = fields.Many2one("res.country.state", string='State', ondelete='restrict', domain="[('country_id', '=?', country_id)]")
    country_id = fields.Many2one('res.country', string='Country', ondelete='restrict')
    country_code = fields.Char(related='country_id.code', string="Country Code")
    partner_latitude = fields.Float(string='Geo Latitude', digits=(10, 7))
    partner_longitude = fields.Float(string='Geo Longitude', digits=(10, 7))
    email = fields.Char()
    email_formatted = fields.Char(
        'Formatted Email', compute='_compute_email_formatted',
        help='Format email address "Name <email@domain>"')
    phone = fields.Char(unaccent=False)
    mobile = fields.Char(unaccent=False)
    is_company = fields.Boolean(string='Is a Company', default=False,
        help="Check if the contact is a company, otherwise it is a person")
    is_public = fields.Boolean(compute='_compute_is_public')
    industry_id = fields.Many2one('res.partner.industry', 'Industry')
    # company_type is only an interface field, do not use it in business logic
    company_type = fields.Selection(string='Company Type',
        selection=[('person', 'Individual'), ('company', 'Company')],
        compute='_compute_company_type', inverse='_write_company_type')
    company_id = fields.Many2one('res.company', 'Company', index=True)
    color = fields.Integer(string='Color Index', default=0)
    user_ids = fields.One2many('res.users', 'partner_id', string='Users', auto_join=True)
    partner_share = fields.Boolean(
        'Share Partner', compute='_compute_partner_share', store=True,
        help="Either customer (not a user), either shared user. Indicated the current partner is a customer without "
             "access or with a limited access created for sharing data.")
    contact_address = fields.Char(compute='_compute_contact_address', string='Complete Address')

    # technical field used for managing commercial fields
    commercial_partner_id = fields.Many2one(
        'res.partner', string='Commercial Entity',
        compute='_compute_commercial_partner', store=True,
        recursive=True, index=True)
    commercial_company_name = fields.Char('Company Name Entity', compute='_compute_commercial_company_name',
                                          store=True)
    company_name = fields.Char('Company Name')
    barcode = fields.Char(help="Use a barcode to identify this contact.", copy=False, company_dependent=True)

    # hack to allow using plain browse record in qweb views, and used in ir.qweb.field.contact
    self = fields.Many2one(comodel_name=_name, compute='_compute_get_ids')

    _sql_constraints = [
        ('check_name', "CHECK( (type='contact' AND name IS NOT NULL) or (type!='contact') )", 'Contacts require a name'),
    ]

    def _get_street_split(self):
        self.ensure_one()
        return tools.street_split(self.street or '')

    @api.depends('name', 'user_ids.share', 'image_1920', 'is_company', 'type')
    def _compute_avatar_1920(self):
        super()._compute_avatar_1920()

    @api.depends('name', 'user_ids.share', 'image_1024', 'is_company', 'type')
    def _compute_avatar_1024(self):
        super()._compute_avatar_1024()

    @api.depends('name', 'user_ids.share', 'image_512', 'is_company', 'type')
    def _compute_avatar_512(self):
        super()._compute_avatar_512()

    @api.depends('name', 'user_ids.share', 'image_256', 'is_company', 'type')
    def _compute_avatar_256(self):
        super()._compute_avatar_256()

    @api.depends('name', 'user_ids.share', 'image_128', 'is_company', 'type')
    def _compute_avatar_128(self):
        super()._compute_avatar_128()

    def _compute_avatar(self, avatar_field, image_field):
        partners_with_internal_user = self.filtered(lambda partner: partner.user_ids - partner.user_ids.filtered('share'))
        super(Partner, partners_with_internal_user)._compute_avatar(avatar_field, image_field)
        partners_without_image = (self - partners_with_internal_user).filtered(lambda p: not p[image_field])
        for _, group in tools.groupby(partners_without_image, key=lambda p: p._avatar_get_placeholder_path()):
            group_partners = self.env['res.partner'].concat(*group)
            group_partners[avatar_field] = base64.b64encode(group_partners[0]._avatar_get_placeholder())

        for partner in self - partners_with_internal_user - partners_without_image:
            partner[avatar_field] = partner[image_field]

    def _avatar_get_placeholder_path(self):
        if self.is_company:
            return "base/static/img/company_image.png"
        if self.type == 'delivery':
            return "base/static/img/truck.png"
        if self.type == 'invoice':
            return "base/static/img/money.png"
        return super()._avatar_get_placeholder_path()

    def _get_complete_name(self):
        self.ensure_one()

        displayed_types = self._complete_name_displayed_types
        type_description = dict(self._fields['type']._description_selection(self.env))

        name = self.name or ''
        if self.company_name or self.parent_id:
            if not name and self.type in displayed_types:
                name = type_description[self.type]
            if not self.is_company:
                name = f"{self.commercial_company_name or self.sudo().parent_id.name}, {name}"
        return name.strip()

    @api.depends('is_company', 'name', 'parent_id.name', 'type', 'company_name', 'commercial_company_name')
    def _compute_complete_name(self):
        for partner in self:
            partner.complete_name = partner.with_context({})._get_complete_name()

    @api.depends('lang')
    def _compute_active_lang_count(self):
        lang_count = len(self.env['res.lang'].get_installed())
        for partner in self:
            partner.active_lang_count = lang_count

    @api.depends('tz')
    def _compute_tz_offset(self):
        for partner in self:
            partner.tz_offset = datetime.datetime.now(pytz.timezone(partner.tz or 'GMT')).strftime('%z')

    @api.depends('parent_id')
    def _compute_user_id(self):
        """ Synchronize sales rep with parent if partner is a person """
        for partner in self.filtered(lambda partner: not partner.user_id and partner.company_type == 'person' and partner.parent_id.user_id):
            partner.user_id = partner.parent_id.user_id

    @api.depends('user_ids.share', 'user_ids.active')
    def _compute_partner_share(self):
        super_partner = self.env['res.users'].browse(SUPERUSER_ID).partner_id
        if super_partner in self:
            super_partner.partner_share = False
        for partner in self - super_partner:
            partner.partner_share = not partner.user_ids or not any(not user.share for user in partner.user_ids)

    @api.depends('vat', 'company_id', 'company_registry')
    def _compute_same_vat_partner_id(self):
        for partner in self:
            # use _origin to deal with onchange()
            partner_id = partner._origin.id
            #active_test = False because if a partner has been deactivated you still want to raise the error,
            #so that you can reactivate it instead of creating a new one, which would loose its history.
            Partner = self.with_context(active_test=False).sudo()
            domain = [
                ('vat', '=', partner.vat),
            ]
            if partner.company_id:
                domain += [('company_id', 'in', [False, partner.company_id.id])]
            if partner_id:
                domain += [('id', '!=', partner_id), '!', ('id', 'child_of', partner_id)]
            # For VAT number being only one character, we will skip the check just like the regular check_vat
            should_check_vat = partner.vat and len(partner.vat) != 1
            partner.same_vat_partner_id = should_check_vat and not partner.parent_id and Partner.search(domain, limit=1)
            # check company_registry
            domain = [
                ('company_registry', '=', partner.company_registry),
                ('company_id', 'in', [False, partner.company_id.id]),
            ]
            if partner_id:
                domain += [('id', '!=', partner_id), '!', ('id', 'child_of', partner_id)]
            partner.same_company_registry_partner_id = bool(partner.company_registry) and not partner.parent_id and Partner.search(domain, limit=1)

    @api.depends(lambda self: self._display_address_depends())
    def _compute_contact_address(self):
        for partner in self:
            partner.contact_address = partner._display_address()

    def _compute_get_ids(self):
        for partner in self:
            partner.self = partner.id

    @api.depends('is_company', 'parent_id.commercial_partner_id')
    def _compute_commercial_partner(self):
        for partner in self:
            if partner.is_company or not partner.parent_id:
                partner.commercial_partner_id = partner
            else:
                partner.commercial_partner_id = partner.parent_id.commercial_partner_id

    @api.depends('company_name', 'parent_id.is_company', 'commercial_partner_id.name')
    def _compute_commercial_company_name(self):
        for partner in self:
            p = partner.commercial_partner_id
            partner.commercial_company_name = p.is_company and p.name or partner.company_name

    def _compute_company_registry(self):
        # exists to allow overrides
        for company in self:
            company.company_registry = company.company_registry

    @api.model
    def _get_view(self, view_id=None, view_type='form', **options):
        arch, view = super()._get_view(view_id, view_type, **options)
        company = self.env.company
        if company.country_id.vat_label:
            for node in arch.xpath("//field[@name='vat']"):
                node.attrib["string"] = company.country_id.vat_label
        return arch, view

    @api.constrains('parent_id')
    def _check_parent_id(self):
        if not self._check_recursion():
            raise ValidationError(_('You cannot create recursive Partner hierarchies.'))

    def copy(self, default=None):
        self.ensure_one()
        chosen_name = default.get('name') if default else ''
        new_name = chosen_name or _('%s (copy)', self.name)
        default = dict(default or {}, name=new_name)
        return super(Partner, self).copy(default)

    @api.onchange('parent_id')
    def onchange_parent_id(self):
        # return values in result, as this method is used by _fields_sync()
        if not self.parent_id:
            return
        result = {}
        partner = self._origin
        if partner.parent_id and partner.parent_id != self.parent_id:
            result['warning'] = {
                'title': _('Warning'),
                'message': _('Changing the company of a contact should only be done if it '
                             'was never correctly set. If an existing contact starts working for a new '
                             'company then a new contact should be created under that new '
                             'company. You can use the "Discard" button to abandon this change.')}
        if partner.type == 'contact' or self.type == 'contact':
            # for contacts: copy the parent address, if set (aka, at least one
            # value is set in the address: otherwise, keep the one from the
            # contact)
            address_fields = self._address_fields()
            if any(self.parent_id[key] for key in address_fields):
                def convert(value):
                    return value.id if isinstance(value, models.BaseModel) else value
                result['value'] = {key: convert(self.parent_id[key]) for key in address_fields}
        return result

    @api.onchange('parent_id')
    def _onchange_parent_id_for_lang(self):
        # While creating / updating child contact, take the parent lang by default if any
        # otherwise, fallback to default context / DB lang
        if self.parent_id:
            self.lang = self.parent_id.lang or self.env.context.get('default_lang') or self.env.lang

    @api.onchange('country_id')
    def _onchange_country_id(self):
        if self.country_id and self.country_id != self.state_id.country_id:
            self.state_id = False

    @api.onchange('state_id')
    def _onchange_state(self):
        if self.state_id.country_id and self.country_id != self.state_id.country_id:
            self.country_id = self.state_id.country_id

    @api.onchange('email')
    def onchange_email(self):
        if not self.image_1920 and self._context.get('gravatar_image') and self.email:
            self.image_1920 = self._get_gravatar_image(self.email)

    @api.onchange('parent_id', 'company_id')
    def _onchange_company_id(self):
        if self.parent_id:
            self.company_id = self.parent_id.company_id.id

    @api.depends('name', 'email')
    def _compute_email_formatted(self):
        """ Compute formatted email for partner, using formataddr. Be defensive
        in computation, notably

          * double format: if email already holds a formatted email like
            'Name' <email@domain.com> we should not use it as it to compute
            email formatted like "Name <'Name' <email@domain.com>>";
          * multi emails: sometimes this field is used to hold several addresses
            like email1@domain.com, email2@domain.com. We currently let this value
            untouched, but remove any formatting from multi emails;
          * invalid email: if something is wrong, keep it in email_formatted as
            this eases management and understanding of failures at mail.mail,
            mail.notification and mailing.trace level;
          * void email: email_formatted is False, as we cannot do anything with
            it;
        """
        self.email_formatted = False
        for partner in self:
            emails_normalized = tools.email_normalize_all(partner.email)
            if emails_normalized:
                # note: multi-email input leads to invalid email like "Name" <email1, email2>
                # but this is current behavior in Odoo 14+ and some servers allow it
                partner.email_formatted = tools.formataddr((
                    partner.name or u"False",
                    ','.join(emails_normalized)
                ))
            elif partner.email:
                partner.email_formatted = tools.formataddr((
                    partner.name or u"False",
                    partner.email
                ))

    @api.depends('is_company')
    def _compute_company_type(self):
        for partner in self:
            partner.company_type = 'company' if partner.is_company else 'person'

    def _write_company_type(self):
        for partner in self:
            partner.is_company = partner.company_type == 'company'

    @api.onchange('company_type')
    def onchange_company_type(self):
        self.is_company = (self.company_type == 'company')

    @api.constrains('barcode')
    def _check_barcode_unicity(self):
        for partner in self:
            if partner.barcode and self.env['res.partner'].search_count([('barcode', '=', partner.barcode)]) > 1:
                raise ValidationError(_('Another partner already has this barcode'))

    def _update_fields_values(self, fields):
        """ Returns dict of write() values for synchronizing ``fields`` """
        values = {}
        for fname in fields:
            field = self._fields[fname]
            if field.type == 'many2one':
                values[fname] = self[fname].id
            elif field.type == 'one2many':
                raise AssertionError(_('One2Many fields cannot be synchronized as part of `commercial_fields` or `address fields`'))
            elif field.type == 'many2many':
                values[fname] = [Command.set(self[fname].ids)]
            else:
                values[fname] = self[fname]
        return values

    @api.model
    def _address_fields(self):
        """Returns the list of address fields that are synced from the parent."""
        return list(ADDRESS_FIELDS)

    @api.model
    def _formatting_address_fields(self):
        """Returns the list of address fields usable to format addresses."""
        return self._address_fields()

    def update_address(self, vals):
        addr_vals = {key: vals[key] for key in self._address_fields() if key in vals}
        if addr_vals:
            return super(Partner, self).write(addr_vals)

    @api.model
    def _commercial_fields(self):
        """ Returns the list of fields that are managed by the commercial entity
        to which a partner belongs. These fields are meant to be hidden on
        partners that aren't `commercial entities` themselves, and will be
        delegated to the parent `commercial entity`. The list is meant to be
        extended by inheriting classes. """
        return ['vat', 'company_registry', 'industry_id']

    def _commercial_sync_from_company(self):
        """ Handle sync of commercial fields when a new parent commercial entity is set,
        as if they were related fields """
        commercial_partner = self.commercial_partner_id
        if commercial_partner != self:
            sync_vals = commercial_partner._update_fields_values(self._commercial_fields())
            self.write(sync_vals)
            self._commercial_sync_to_children()

    def _commercial_sync_to_children(self):
        """ Handle sync of commercial fields to descendants """
        commercial_partner = self.commercial_partner_id
        sync_vals = commercial_partner._update_fields_values(self._commercial_fields())
        sync_children = self.child_ids.filtered(lambda c: not c.is_company)
        for child in sync_children:
            child._commercial_sync_to_children()
        res = sync_children.write(sync_vals)
        sync_children._compute_commercial_partner()
        return res

    def _fields_sync(self, values):
        """ Sync commercial fields and address fields from company and to children after create/update,
        just as if those were all modeled as fields.related to the parent """
        # 1. From UPSTREAM: sync from parent
        if values.get('parent_id') or values.get('type') == 'contact':
            # 1a. Commercial fields: sync if parent changed
            if values.get('parent_id'):
                self.sudo()._commercial_sync_from_company()
            # 1b. Address fields: sync if parent or use_parent changed *and* both are now set
            if self.parent_id and self.type == 'contact':
                onchange_vals = self.onchange_parent_id().get('value', {})
                self.update_address(onchange_vals)

        # 2. To DOWNSTREAM: sync children
        self._children_sync(values)

    def _children_sync(self, values):
        if not self.child_ids:
            return
        # 2a. Commercial Fields: sync if commercial entity
        if self.commercial_partner_id == self:
            commercial_fields = self._commercial_fields()
            if any(field in values for field in commercial_fields):
                self.sudo()._commercial_sync_to_children()
        for child in self.child_ids.filtered(lambda c: not c.is_company):
            if child.commercial_partner_id != self.commercial_partner_id:
                self.sudo()._commercial_sync_to_children()
                break
        # 2b. Address fields: sync if address changed
        address_fields = self._address_fields()
        if any(field in values for field in address_fields):
            contacts = self.child_ids.filtered(lambda c: c.type == 'contact')
            contacts.update_address(values)

    def _handle_first_contact_creation(self):
        """ On creation of first contact for a company (or root) that has no address, assume contact address
        was meant to be company address """
        parent = self.parent_id
        address_fields = self._address_fields()
        if (parent.is_company or not parent.parent_id) and len(parent.child_ids) == 1 and \
            any(self[f] for f in address_fields) and not any(parent[f] for f in address_fields):
            addr_vals = self._update_fields_values(address_fields)
            parent.update_address(addr_vals)

    def _clean_website(self, website):
        url = urls.url_parse(website)
        if not url.scheme:
            if not url.netloc:
                url = url.replace(netloc=url.path, path='')
            website = url.replace(scheme='http').to_url()
        return website

    def _compute_is_public(self):
        for partner in self.with_context(active_test=False):
            users = partner.user_ids
            partner.is_public = users and any(user._is_public() for user in users)

    def write(self, vals):
        if vals.get('active') is False:
            # DLE: It should not be necessary to modify this to make work the ORM. The problem was just the recompute
            # of partner.user_ids when you create a new user for this partner, see test test_70_archive_internal_partners
            # You modified it in a previous commit, see original commit of this:
            # https://github.com/odoo/odoo/commit/9d7226371730e73c296bcc68eb1f856f82b0b4ed
            #
            # RCO: when creating a user for partner, the user is automatically added in partner.user_ids.
            # This is wrong if the user is not active, as partner.user_ids only returns active users.
            # Hence this temporary hack until the ORM updates inverse fields correctly.
            self.invalidate_recordset(['user_ids'])
            users = self.env['res.users'].sudo().search([('partner_id', 'in', self.ids)])
            if users:
                if self.env['res.users'].sudo(False).check_access_rights('write', raise_exception=False):
                    error_msg = _('You cannot archive contacts linked to an active user.\n'
                                  'You first need to archive their associated user.\n\n'
                                  'Linked active users : %(names)s', names=", ".join([u.display_name for u in users]))
                    action_error = users._action_show()
                    raise RedirectWarning(error_msg, action_error, _('Go to users'))
                else:
                    raise ValidationError(_('You cannot archive contacts linked to an active user.\n'
                                            'Ask an administrator to archive their associated user first.\n\n'
                                            'Linked active users :\n%(names)s', names=", ".join([u.display_name for u in users])))
        # res.partner must only allow to set the company_id of a partner if it
        # is the same as the company of all users that inherit from this partner
        # (this is to allow the code from res_users to write to the partner!) or
        # if setting the company_id to False (this is compatible with any user
        # company)
        if vals.get('website'):
            vals['website'] = self._clean_website(vals['website'])
        if vals.get('parent_id'):
            vals['company_name'] = False
        if 'company_id' in vals:
            company_id = vals['company_id']
            for partner in self:
                if company_id and partner.user_ids:
                    company = self.env['res.company'].browse(company_id)
                    companies = set(user.company_id for user in partner.user_ids)
                    if len(companies) > 1 or company not in companies:
                        raise UserError(
                            ("The selected company is not compatible with the companies of the related user(s)"))
                if partner.child_ids:
                    partner.child_ids.write({'company_id': company_id})
        result = True
        # To write in SUPERUSER on field is_company and avoid access rights problems.
        if 'is_company' in vals and self.user_has_groups('base.group_partner_manager') and not self.env.su:
            result = super(Partner, self.sudo()).write({'is_company': vals.get('is_company')})
            del vals['is_company']
        result = result and super(Partner, self).write(vals)
        for partner in self:
            if any(u._is_internal() for u in partner.user_ids if u != self.env.user):
                self.env['res.users'].check_access_rights('write')
            partner._fields_sync(vals)
        return result

    @api.model_create_multi
    def create(self, vals_list):
        if self.env.context.get('import_file'):
            self._check_import_consistency(vals_list)
        for vals in vals_list:
            if vals.get('website'):
                vals['website'] = self._clean_website(vals['website'])
            if vals.get('parent_id'):
                vals['company_name'] = False
        partners = super(Partner, self).create(vals_list)

        if self.env.context.get('_partners_skip_fields_sync'):
            return partners

        for partner, vals in zip(partners, vals_list):
            partner._fields_sync(vals)
            # Lang: propagate from parent if no value was given
            if 'lang' not in vals and partner.parent_id:
                partner._onchange_parent_id_for_lang()
            partner._handle_first_contact_creation()
        return partners

    @api.ondelete(at_uninstall=False)
    def _unlink_except_user(self):
        users = self.env['res.users'].sudo().search([('partner_id', 'in', self.ids)])
        if not users:
            return  # no linked user, operation is allowed
        if self.env['res.users'].sudo(False).check_access_rights('write', raise_exception=False):
            error_msg = _('You cannot delete contacts linked to an active user.\n'
                          'You should rather archive them after archiving their associated user.\n\n'
                          'Linked active users : %(names)s', names=", ".join([u.display_name for u in users]))
            action_error = users._action_show()
            raise RedirectWarning(error_msg, action_error, _('Go to users'))
        else:
            raise ValidationError(_('You cannot delete contacts linked to an active user.\n'
                                    'Ask an administrator to archive their associated user first.\n\n'
                                    'Linked active users :\n%(names)s', names=", ".join([u.display_name for u in users])))

    def _load_records_create(self, vals_list):
        partners = super(Partner, self.with_context(_partners_skip_fields_sync=True))._load_records_create(vals_list)

        # batch up first part of _fields_sync
        # group partners by commercial_partner_id (if not self) and parent_id (if type == contact)
        groups = collections.defaultdict(list)
        for partner, vals in zip(partners, vals_list):
            cp_id = None
            if vals.get('parent_id') and partner.commercial_partner_id != partner:
                cp_id = partner.commercial_partner_id.id

            add_id = None
            if partner.parent_id and partner.type == 'contact':
                add_id = partner.parent_id.id
            groups[(cp_id, add_id)].append(partner.id)

        for (cp_id, add_id), children in groups.items():
            # values from parents (commercial, regular) written to their common children
            to_write = {}
            # commercial fields from commercial partner
            if cp_id:
                to_write = self.browse(cp_id)._update_fields_values(self._commercial_fields())
            # address fields from parent
            if add_id:
                parent = self.browse(add_id)
                for f in self._address_fields():
                    v = parent[f]
                    if v:
                        to_write[f] = v.id if isinstance(v, models.BaseModel) else v
            if to_write:
                self.sudo().browse(children).write(to_write)

        # do the second half of _fields_sync the "normal" way
        for partner, vals in zip(partners, vals_list):
            partner._children_sync(vals)
            partner._handle_first_contact_creation()
        return partners

    def create_company(self):
        self.ensure_one()
        if self.company_name:
            # Create parent company
            values = dict(name=self.company_name, is_company=True, vat=self.vat)
            values.update(self._update_fields_values(self._address_fields()))
            new_company = self.create(values)
            # Set new company as my parent
            self.write({
                'parent_id': new_company.id,
                'child_ids': [Command.update(partner_id, dict(parent_id=new_company.id)) for partner_id in self.child_ids.ids]
            })
        return True

    def open_commercial_entity(self):
        """ Utility method used to add an "Open Company" button in partner views """
        self.ensure_one()
        return {'type': 'ir.actions.act_window',
                'res_model': 'res.partner',
                'view_mode': 'form',
                'res_id': self.commercial_partner_id.id,
                'target': 'current',
                }

    def open_parent(self):
        """ Utility method used to add an "Open Parent" button in partner views """
        self.ensure_one()
        address_form_id = self.env.ref('base.view_partner_address_form').id
        return {'type': 'ir.actions.act_window',
                'res_model': 'res.partner',
                'view_mode': 'form',
                'views': [(address_form_id, 'form')],
                'res_id': self.parent_id.id,
                'target': 'new',
                }

    @api.depends('complete_name', 'email', 'vat', 'state_id', 'country_id', 'commercial_company_name')
    @api.depends_context('show_address', 'partner_show_db_id', 'address_inline', 'show_email', 'show_vat', 'lang')
    def _compute_display_name(self):
        for partner in self:
            name = partner.with_context({'lang': self.env.lang})._get_complete_name()
            if partner._context.get('show_address'):
                name = name + "\n" + partner._display_address(without_company=True)
            name = re.sub(r'\s+\n', '\n', name)
            if partner._context.get('partner_show_db_id'):
                name = f"{name} ({partner.id})"
            if partner._context.get('address_inline'):
                splitted_names = name.split("\n")
                name = ", ".join([n for n in splitted_names if n.strip()])
            if partner._context.get('show_email') and partner.email:
                name = f"{name} <{partner.email}>"
            if partner._context.get('show_vat') and partner.vat:
                name = f"{name} ‒ {partner.vat}"

            partner.display_name = name.strip()

    @api.model
    def name_create(self, name):
        """ Override of orm's name_create method for partners. The purpose is
            to handle some basic formats to create partners using the
            name_create.
            If only an email address is received and that the regex cannot find
            a name, the name will have the email value.
            If 'force_email' key in context: must find the email address. """
        default_type = self._context.get('default_type')
        if default_type and default_type not in self._fields['type'].get_values(self.env):
            context = dict(self._context)
            context.pop('default_type')
            self = self.with_context(context)
        name, email_normalized = tools.parse_contact_from_email(name)
        if self._context.get('force_email') and not email_normalized:
            raise ValidationError(_("Couldn't create contact without email address!"))

        create_values = {self._rec_name: name or email_normalized}
        if email_normalized:  # keep default_email in context
            create_values['email'] = email_normalized
        partner = self.create(create_values)
        return partner.id, partner.display_name

    @api.model
    @api.returns('self', lambda value: value.id)
    def find_or_create(self, email, assert_valid_email=False):
        """ Find a partner with the given ``email`` or use :py:method:`~.name_create`
        to create a new one.

        :param str email: email-like string, which should contain at least one email,
            e.g. ``"Raoul Grosbedon <r.g@grosbedon.fr>"``
        :param boolean assert_valid_email: raise if no valid email is found
        :return: newly created record
        """
        if not email:
            raise ValueError(_('An email is required for find_or_create to work'))

        parsed_name, parsed_email_normalized = tools.parse_contact_from_email(email)
        if not parsed_email_normalized and assert_valid_email:
            raise ValueError(_('A valid email is required for find_or_create to work properly.'))

        partners = self.search([('email', '=ilike', parsed_email_normalized)], limit=1)
        if partners:
            return partners

        create_values = {self._rec_name: parsed_name or parsed_email_normalized}
        if parsed_email_normalized:  # keep default_email in context
            create_values['email'] = parsed_email_normalized
        return self.create(create_values)

    def _get_gravatar_image(self, email):
        email_hash = hashlib.md5(email.lower().encode('utf-8')).hexdigest()
        url = "https://www.gravatar.com/avatar/" + email_hash
        try:
            res = requests.get(url, params={'d': '404', 's': '128'}, timeout=5)
            if res.status_code != requests.codes.ok:
                return False
        except requests.exceptions.ConnectionError as e:
            return False
        except requests.exceptions.Timeout as e:
            return False
        return base64.b64encode(res.content)

    def _email_send(self, email_from, subject, body, on_error=None):
        warnings.warn("Partner._email_send has not done anything but raise errors since 15.0", stacklevel=2, category=DeprecationWarning)
        return True

    def address_get(self, adr_pref=None):
        """ Find contacts/addresses of the right type(s) by doing a depth-first-search
        through descendants within company boundaries (stop at entities flagged ``is_company``)
        then continuing the search at the ancestors that are within the same company boundaries.
        Defaults to partners of type ``'default'`` when the exact type is not found, or to the
        provided partner itself if no type ``'default'`` is found either. """
        adr_pref = set(adr_pref or [])
        if 'contact' not in adr_pref:
            adr_pref.add('contact')
        result = {}
        visited = set()
        for partner in self:
            current_partner = partner
            while current_partner:
                to_scan = [current_partner]
                # Scan descendants, DFS
                while to_scan:
                    record = to_scan.pop(0)
                    visited.add(record)
                    if record.type in adr_pref and not result.get(record.type):
                        result[record.type] = record.id
                    if len(result) == len(adr_pref):
                        return result
                    to_scan = [c for c in record.child_ids
                                 if c not in visited
                                 if not c.is_company] + to_scan

                # Continue scanning at ancestor if current_partner is not a commercial entity
                if current_partner.is_company or not current_partner.parent_id:
                    break
                current_partner = current_partner.parent_id

        # default to type 'contact' or the partner itself
        default = result.get('contact', self.id or False)
        for adr_type in adr_pref:
            result[adr_type] = result.get(adr_type) or default
        return result

    @api.model
    def view_header_get(self, view_id, view_type):
        if self.env.context.get('category_id'):
            return  _(
                'Partners: %(category)s',
                category=self.env['res.partner.category'].browse(self.env.context['category_id']).name,
            )
        return super().view_header_get(view_id, view_type)

    @api.model
    @api.returns('self')
    def main_partner(self):
        ''' Return the main partner '''
        return self.env.ref('base.main_partner')

    @api.model
    def _get_default_address_format(self):
        return "%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s"

    @api.model
    def _get_address_format(self):
        return self.country_id.address_format or self._get_default_address_format()

    def _prepare_display_address(self, without_company=False):
        # get the information that will be injected into the display format
        # get the address format
        address_format = self._get_address_format()
        args = defaultdict(str, {
            'state_code': self.state_id.code or '',
            'state_name': self.state_id.name or '',
            'country_code': self.country_id.code or '',
            'country_name': self._get_country_name(),
            'company_name': self.commercial_company_name or '',
        })
        for field in self._formatting_address_fields():
            args[field] = self[field] or ''
        if without_company:
            args['company_name'] = ''
        elif self.commercial_company_name:
            address_format = '%(company_name)s\n' + address_format
        return address_format, args

    def _display_address(self, without_company=False):
        '''
        The purpose of this function is to build and return an address formatted accordingly to the
        standards of the country where it belongs.

        :param without_company: if address contains company
        :returns: the address formatted in a display that fit its country habits (or the default ones
            if not country is specified)
        :rtype: string
        '''
        address_format, args = self._prepare_display_address(without_company)
        return address_format % args

    def _display_address_depends(self):
        # field dependencies of method _display_address()
        return self._formatting_address_fields() + [
            'country_id', 'company_name', 'state_id',
        ]

    @api.model
    def get_import_templates(self):
        return [{
            'label': _('Import Template for Customers'),
            'template': '/base/static/xls/res_partner.xlsx'
        }]

    @api.model
    def _check_import_consistency(self, vals_list):
        """
        The values created by an import are generated by a name search, field by field.
        As a result there is no check that the field values are consistent with each others.
        We check that if the state is given a value, it does belong to the given country, or we remove it.
        """
        States = self.env['res.country.state']
        states_ids = {vals['state_id'] for vals in vals_list if vals.get('state_id')}
        state_to_country = States.search_read([('id', 'in', list(states_ids))], ['country_id'])
        for vals in vals_list:
            if vals.get('state_id'):
                country_id = next(c['country_id'][0] for c in state_to_country if c['id'] == vals.get('state_id'))
                state = States.browse(vals['state_id'])
                if state.country_id.id != country_id:
                    state_domain = [('code', '=', state.code),
                                    ('country_id', '=', country_id)]
                    state = States.search(state_domain, limit=1)
                    vals['state_id'] = state.id  # replace state or remove it if not found

    def _get_country_name(self):
        return self.country_id.name or ''

    def _get_all_addr(self):
        self.ensure_one()
        return [{
            'contact_type': self.street,
            'street': self.street,
            'zip': self.zip,
            'city': self.city,
            'country': self.country_id.code,
        }]


class ResPartnerIndustry(models.Model):
    _description = 'Industry'
    _name = "res.partner.industry"
    _order = "name"

    name = fields.Char('Name', translate=True)
    full_name = fields.Char('Full Name', translate=True)
    active = fields.Boolean('Active', default=True)

```

  File: models/res_users.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import binascii
import contextlib
import datetime
import hmac
import ipaddress
import itertools
import json
import logging
import os
import time
from collections import defaultdict
from functools import wraps
from hashlib import sha256
from itertools import chain, repeat
from markupsafe import Markup

import babel.core
import pytz
from lxml import etree
from lxml.builder import E
from passlib.context import CryptContext as _CryptContext
from psycopg2 import sql

from odoo import api, fields, models, tools, SUPERUSER_ID, _, Command
from odoo.addons.base.models.ir_model import MODULE_UNINSTALL_FLAG
from odoo.exceptions import AccessDenied, AccessError, UserError, ValidationError
from odoo.http import request, DEFAULT_LANG
from odoo.osv import expression
from odoo.service.db import check_super
from odoo.tools import is_html_empty, partition, collections, frozendict, lazy_property

_logger = logging.getLogger(__name__)

class CryptContext:
    def __init__(self, *args, **kwargs):
        self.__obj__ = _CryptContext(*args, **kwargs)

    @property
    def encrypt(self):
        # deprecated alias
        return self.hash

    @property
    def copy(self):
        return self.__obj__.copy

    @property
    def hash(self):
        return self.__obj__.hash

    @property
    def identify(self):
        return self.__obj__.identify

    @property
    def verify(self):
        return self.__obj__.verify

    @property
    def verify_and_update(self):
        return self.__obj__.verify_and_update

    def schemes(self):
        return self.__obj__.schemes()

    def update(self, **kwargs):
        if kwargs.get("schemes"):
            assert isinstance(kwargs["schemes"], str) or all(isinstance(s, str) for s in kwargs["schemes"])
        return self.__obj__.update(**kwargs)


# Only users who can modify the user (incl. the user herself) see the real contents of these fields
USER_PRIVATE_FIELDS = []
MIN_ROUNDS = 600_000
concat = chain.from_iterable

#
# Functions for manipulating boolean and selection pseudo-fields
#
def name_boolean_group(id):
    return 'in_group_' + str(id)

def name_selection_groups(ids):
    return 'sel_groups_' + '_'.join(str(it) for it in sorted(ids))

def is_boolean_group(name):
    return name.startswith('in_group_')

def is_selection_groups(name):
    return name.startswith('sel_groups_')

def is_reified_group(name):
    return is_boolean_group(name) or is_selection_groups(name)

def get_boolean_group(name):
    return int(name[9:])

def get_selection_groups(name):
    return [int(v) for v in name[11:].split('_')]

def parse_m2m(commands):
    "return a list of ids corresponding to a many2many value"
    ids = []
    for command in commands:
        if isinstance(command, (tuple, list)):
            if command[0] in (Command.UPDATE, Command.LINK):
                ids.append(command[1])
            elif command[0] == Command.CLEAR:
                ids = []
            elif command[0] == Command.SET:
                ids = list(command[2])
        else:
            ids.append(command)
    return ids

def _jsonable(o):
    try: json.dumps(o)
    except TypeError: return False
    else: return True

def check_identity(fn):
    """ Wrapped method should be an *action method* (called from a button
    type=object), and requires extra security to be executed. This decorator
    checks if the identity (password) has been checked in the last 10mn, and
    pops up an identity check wizard if not.

    Prevents access outside of interactive contexts (aka with a request)
    """
    @wraps(fn)
    def wrapped(self):
        if not request:
            raise UserError(_("This method can only be accessed over HTTP"))

        if request.session.get('identity-check-last', 0) > time.time() - 10 * 60:
            # update identity-check-last like github?
            return fn(self)

        w = self.sudo().env['res.users.identitycheck'].create({
            'request': json.dumps([
                { # strip non-jsonable keys (e.g. mapped to recordsets)
                    k: v for k, v in self.env.context.items()
                    if _jsonable(v)
                },
                self._name,
                self.ids,
                fn.__name__
            ])
        })
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'res.users.identitycheck',
            'res_id': w.id,
            'name': _("Security Control"),
            'target': 'new',
            'views': [(False, 'form')],
        }
    wrapped.__has_check_identity = True
    return wrapped

#----------------------------------------------------------
# Basic res.groups and res.users
#----------------------------------------------------------

class Groups(models.Model):
    _name = "res.groups"
    _description = "Access Groups"
    _rec_name = 'full_name'
    _order = 'name'
    _allow_sudo_commands = False

    name = fields.Char(required=True, translate=True)
    users = fields.Many2many('res.users', 'res_groups_users_rel', 'gid', 'uid')
    model_access = fields.One2many('ir.model.access', 'group_id', string='Access Controls', copy=True)
    rule_groups = fields.Many2many('ir.rule', 'rule_group_rel',
        'group_id', 'rule_group_id', string='Rules', domain="[('global', '=', False)]")
    menu_access = fields.Many2many('ir.ui.menu', 'ir_ui_menu_group_rel', 'gid', 'menu_id', string='Access Menu')
    view_access = fields.Many2many('ir.ui.view', 'ir_ui_view_group_rel', 'group_id', 'view_id', string='Views')
    comment = fields.Text(translate=True)
    category_id = fields.Many2one('ir.module.category', string='Application', index=True)
    color = fields.Integer(string='Color Index')
    full_name = fields.Char(compute='_compute_full_name', string='Group Name', search='_search_full_name')
    share = fields.Boolean(string='Share Group', help="Group created to set access rights for sharing data with some users.")

    _sql_constraints = [
        ('name_uniq', 'unique (category_id, name)', 'The name of the group must be unique within an application!')
    ]

    @api.constrains('users')
    def _check_one_user_type(self):
        self.users._check_one_user_type()

    @api.ondelete(at_uninstall=False)
    def _unlink_except_settings_group(self):
        classified = self.env['res.config.settings']._get_classified_fields()
        for _name, _groups, implied_group in classified['group']:
            if implied_group.id in self.ids:
                raise ValidationError(_('You cannot delete a group linked with a settings field.'))

    @api.depends('category_id.name', 'name')
    def _compute_full_name(self):
        # Important: value must be stored in environment of group, not group1!
        for group, group1 in zip(self, self.sudo()):
            if group1.category_id:
                group.full_name = '%s / %s' % (group1.category_id.name, group1.name)
            else:
                group.full_name = group1.name

    def _search_full_name(self, operator, operand):
        lst = True
        if isinstance(operand, bool):
            return [('name', operator, operand)]
        if isinstance(operand, str):
            lst = False
            operand = [operand]
        where = []
        for group in operand:
            values = [v for v in group.split('/') if v]
            group_name = values.pop().strip()
            category_name = values and '/'.join(values).strip() or group_name
            group_domain = [('name', operator, lst and [group_name] or group_name)]
            category_ids = self.env['ir.module.category'].sudo()._search(
                [('name', operator, [category_name] if lst else category_name)])
            category_domain = [('category_id', 'in', category_ids)]
            if operator in expression.NEGATIVE_TERM_OPERATORS and not values:
                category_domain = expression.OR([category_domain, [('category_id', '=', False)]])
            if (operator in expression.NEGATIVE_TERM_OPERATORS) == (not values):
                sub_where = expression.AND([group_domain, category_domain])
            else:
                sub_where = expression.OR([group_domain, category_domain])
            if operator in expression.NEGATIVE_TERM_OPERATORS:
                where = expression.AND([where, sub_where])
            else:
                where = expression.OR([where, sub_where])
        return where

    @api.model
    def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):
        # add explicit ordering if search is sorted on full_name
        if order and order.startswith('full_name'):
            groups = super().search(domain)
            groups = groups.sorted('full_name', reverse=order.endswith('DESC'))
            groups = groups[offset:offset+limit] if limit else groups[offset:]
            return groups._as_query(order)
        return super()._search(domain, offset, limit, order, access_rights_uid)

    def copy(self, default=None):
        self.ensure_one()
        chosen_name = default.get('name') if default else ''
        default_name = chosen_name or _('%s (copy)', self.name)
        default = dict(default or {}, name=default_name)
        return super(Groups, self).copy(default)

    def write(self, vals):
        if 'name' in vals:
            if vals['name'].startswith('-'):
                raise UserError(_('The name of the group can not start with "-"'))
        # invalidate caches before updating groups, since the recomputation of
        # field 'share' depends on method has_group()
        # DLE P139
        if self.ids:
            self.env['ir.model.access'].call_cache_clearing_methods()
        return super(Groups, self).write(vals)

    def _ensure_xml_id(self):
        """Return the groups external identifiers, creating the external identifier for groups missing one"""
        result = self.get_external_id()
        missings = {group_id: f'__custom__.group_{group_id}' for group_id, ext_id in result.items() if not ext_id}
        if missings:
            self.env['ir.model.data'].sudo().create(
                [
                    {
                        'name': name.split('.')[1],
                        'model': 'res.groups',
                        'res_id': group_id,
                        'module': name.split('.')[0],
                    }
                    for group_id, name in missings.items()
                ]
            )
            result.update(missings)

        return result


class ResUsersLog(models.Model):
    _name = 'res.users.log'
    _order = 'id desc'
    _description = 'Users Log'
    # Uses the magical fields `create_uid` and `create_date` for recording logins.
    # See `bus.presence` for more recent activity tracking purposes.

    @api.autovacuum
    def _gc_user_logs(self):
        self._cr.execute("""
            DELETE FROM res_users_log log1 WHERE EXISTS (
                SELECT 1 FROM res_users_log log2
                WHERE log1.create_uid = log2.create_uid
                AND log1.create_date < log2.create_date
            )
        """)
        _logger.info("GC'd %d user log entries", self._cr.rowcount)


class Users(models.Model):
    """ User class. A res.users record models an OpenERP user and is different
        from an employee.

        res.users class now inherits from res.partner. The partner model is
        used to store the data related to the partner: lang, name, address,
        avatar, ... The user model is now dedicated to technical data.
    """
    _name = "res.users"
    _description = 'User'
    _inherits = {'res.partner': 'partner_id'}
    _order = 'name, login'
    _allow_sudo_commands = False

    def _check_company_domain(self, companies):
        if not companies:
            return []
        return [('company_ids', 'in', models.to_company_ids(companies))]

    @property
    def SELF_READABLE_FIELDS(self):
        """ The list of fields a user can read on their own user record.
        In order to add fields, please override this property on model extensions.
        """
        return [
            'signature', 'company_id', 'login', 'email', 'name', 'image_1920',
            'image_1024', 'image_512', 'image_256', 'image_128', 'lang', 'tz',
            'tz_offset', 'groups_id', 'partner_id', 'write_date', 'action_id',
            'avatar_1920', 'avatar_1024', 'avatar_512', 'avatar_256', 'avatar_128',
            'share',
        ]

    @property
    def SELF_WRITEABLE_FIELDS(self):
        """ The list of fields a user can write on their own user record.
        In order to add fields, please override this property on model extensions.
        """
        return ['signature', 'action_id', 'company_id', 'email', 'name', 'image_1920', 'lang', 'tz']

    def _default_groups(self):
        """Default groups for employees

        All the groups of the Template User
        """
        default_user = self.env.ref('base.default_user', raise_if_not_found=False)
        return default_user.sudo().groups_id if default_user else []

    partner_id = fields.Many2one('res.partner', required=True, ondelete='restrict', auto_join=True, index=True,
        string='Related Partner', help='Partner-related data of the user')
    login = fields.Char(required=True, help="Used to log into the system")
    password = fields.Char(
        compute='_compute_password', inverse='_set_password', copy=False,
        help="Keep empty if you don't want the user to be able to connect on the system.")
    new_password = fields.Char(string='Set Password',
        compute='_compute_password', inverse='_set_new_password',
        help="Specify a value only when creating a user or if you're "\
             "changing the user's password, otherwise leave empty. After "\
             "a change of password, the user has to login again.")
    signature = fields.Html(string="Email Signature", compute='_compute_signature', readonly=False, store=True)
    active = fields.Boolean(default=True)
    active_partner = fields.Boolean(related='partner_id.active', readonly=True, string="Partner is Active")
    action_id = fields.Many2one('ir.actions.actions', string='Home Action',
        help="If specified, this action will be opened at log on for this user, in addition to the standard menu.")
    groups_id = fields.Many2many('res.groups', 'res_groups_users_rel', 'uid', 'gid', string='Groups', default=lambda s: s._default_groups())
    log_ids = fields.One2many('res.users.log', 'create_uid', string='User log entries')
    login_date = fields.Datetime(related='log_ids.create_date', string='Latest authentication', readonly=False)
    share = fields.Boolean(compute='_compute_share', compute_sudo=True, string='Share User', store=True,
         help="External user with limited access, created only for the purpose of sharing data.")
    companies_count = fields.Integer(compute='_compute_companies_count', string="Number of Companies")
    tz_offset = fields.Char(compute='_compute_tz_offset', string='Timezone offset')
    res_users_settings_ids = fields.One2many('res.users.settings', 'user_id')
    # Provide a target for relateds that is not a x2Many field.
    res_users_settings_id = fields.Many2one('res.users.settings', string="Settings", compute='_compute_res_users_settings_id', search='_search_res_users_settings_id')

    # Special behavior for this field: res.company.search() will only return the companies
    # available to the current user (should be the user's companies?), when the user_preference
    # context is set.
    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company.id,
        help='The default company for this user.', context={'user_preference': True})
    company_ids = fields.Many2many('res.company', 'res_company_users_rel', 'user_id', 'cid',
        string='Companies', default=lambda self: self.env.company.ids)

    # overridden inherited fields to bypass access rights, in case you have
    # access to the user but not its corresponding partner
    name = fields.Char(related='partner_id.name', inherited=True, readonly=False)
    email = fields.Char(related='partner_id.email', inherited=True, readonly=False)

    accesses_count = fields.Integer('# Access Rights', help='Number of access rights that apply to the current user',
                                    compute='_compute_accesses_count', compute_sudo=True)
    rules_count = fields.Integer('# Record Rules', help='Number of record rules that apply to the current user',
                                 compute='_compute_accesses_count', compute_sudo=True)
    groups_count = fields.Integer('# Groups', help='Number of groups that apply to the current user',
                                  compute='_compute_accesses_count', compute_sudo=True)

    _sql_constraints = [
        ('login_key', 'UNIQUE (login)', 'You can not have two users with the same login!')
    ]

    def init(self):
        cr = self.env.cr

        # allow setting plaintext passwords via SQL and have them
        # automatically encrypted at startup: look for passwords which don't
        # match the "extended" MCF and pass those through passlib.
        # Alternative: iterate on *all* passwords and use CryptContext.identify
        cr.execute(r"""
        SELECT id, password FROM res_users
        WHERE password IS NOT NULL
          AND password !~ '^\$[^$]+\$[^$]+\$.'
        """)
        if self.env.cr.rowcount:
            Users = self.sudo()
            for uid, pw in cr.fetchall():
                Users.browse(uid).password = pw

    def _set_password(self):
        ctx = self._crypt_context()
        for user in self:
            self._set_encrypted_password(user.id, ctx.hash(user.password))

    def _set_encrypted_password(self, uid, pw):
        assert self._crypt_context().identify(pw) != 'plaintext'

        self.env.cr.execute(
            'UPDATE res_users SET password=%s WHERE id=%s',
            (pw, uid)
        )
        self.browse(uid).invalidate_recordset(['password'])

    def _check_credentials(self, password, env):
        """ Validates the current user's password.

        Override this method to plug additional authentication methods.

        Overrides should:

        * call `super` to delegate to parents for credentials-checking
        * catch AccessDenied and perform their own checking
        * (re)raise AccessDenied if the credentials are still invalid
          according to their own validation method

        When trying to check for credentials validity, call _check_credentials
        instead.
        """
        """ Override this method to plug additional authentication methods"""
        assert password
        self.env.cr.execute(
            "SELECT COALESCE(password, '') FROM res_users WHERE id=%s",
            [self.env.user.id]
        )
        [hashed] = self.env.cr.fetchone()
        valid, replacement = self._crypt_context()\
            .verify_and_update(password, hashed)
        if replacement is not None:
            self._set_encrypted_password(self.env.user.id, replacement)
        if not valid:
            raise AccessDenied()

    def _compute_password(self):
        for user in self:
            user.password = ''
            user.new_password = ''

    def _set_new_password(self):
        for user in self:
            if not user.new_password:
                # Do not update the password if no value is provided, ignore silently.
                # For example web client submits False values for all empty fields.
                continue
            if user == self.env.user:
                # To change their own password, users must use the client-specific change password wizard,
                # so that the new password is immediately used for further RPC requests, otherwise the user
                # will face unexpected 'Access Denied' exceptions.
                raise UserError(_('Please use the change password wizard (in User Preferences or User menu) to change your own password.'))
            else:
                user.password = user.new_password

    @api.depends('name')
    def _compute_signature(self):
        for user in self.filtered(lambda user: user.name and is_html_empty(user.signature)):
            user.signature = Markup('<p>--<br />%s</p>') % user['name']

    @api.depends('groups_id')
    def _compute_share(self):
        user_group_id = self.env['ir.model.data']._xmlid_to_res_id('base.group_user')
        internal_users = self.filtered_domain([('groups_id', 'in', [user_group_id])])
        internal_users.share = False
        (self - internal_users).share = True

    @api.depends('company_id')
    def _compute_companies_count(self):
        self.companies_count = self.env['res.company'].sudo().search_count([])

    @api.depends('tz')
    def _compute_tz_offset(self):
        for user in self:
            user.tz_offset = datetime.datetime.now(pytz.timezone(user.tz or 'GMT')).strftime('%z')

    @api.depends('groups_id')
    def _compute_accesses_count(self):
        for user in self:
            groups = user.groups_id
            user.accesses_count = len(groups.model_access)
            user.rules_count = len(groups.rule_groups)
            user.groups_count = len(groups)

    @api.depends('res_users_settings_ids')
    def _compute_res_users_settings_id(self):
        for user in self:
            user.res_users_settings_id = user.res_users_settings_ids and user.res_users_settings_ids[0]

    @api.model
    def _search_res_users_settings_id(self, operator, operand):
        return [('res_users_settings_ids', operator, operand)]

    @api.onchange('login')
    def on_change_login(self):
        if self.login and tools.single_email_re.match(self.login):
            self.email = self.login

    @api.onchange('parent_id')
    def onchange_parent_id(self):
        return self.partner_id.onchange_parent_id()

    def _fetch_query(self, query, fields):
        records = super()._fetch_query(query, fields)
        if not set(USER_PRIVATE_FIELDS).isdisjoint(field.name for field in fields):
            if self.check_access_rights('write', raise_exception=False):
                return records
            for fname in USER_PRIVATE_FIELDS:
                self.env.cache.update(records, self._fields[fname], repeat('********'))
        return records

    @api.constrains('company_id', 'company_ids', 'active')
    def _check_company(self):
        for user in self.filtered(lambda u: u.active):
            if user.company_id not in user.company_ids:
                raise ValidationError(
                    _('Company %(company_name)s is not in the allowed companies for user %(user_name)s (%(company_allowed)s).',
                      company_name=user.company_id.name,
                      user_name=user.name,
                      company_allowed=', '.join(user.mapped('company_ids.name')))
                )

    @api.constrains('action_id')
    def _check_action_id(self):
        action_open_website = self.env.ref('base.action_open_website', raise_if_not_found=False)
        if action_open_website and any(user.action_id.id == action_open_website.id for user in self):
            raise ValidationError(_('The "App Switcher" action cannot be selected as home action.'))
        # Prevent using reload actions.
        # We use sudo() because  "Access rights" admins can't read action models
        for user in self.sudo():
            if user.action_id.type == "ir.actions.client":
                action = self.env["ir.actions.client"].browse(user.action_id.id)  # magic
                if action.tag == "reload":
                    raise ValidationError(_('The "%s" action cannot be selected as home action.', action.name))


    @api.constrains('groups_id')
    def _check_one_user_type(self):
        """We check that no users are both portal and users (same with public).
           This could typically happen because of implied groups.
        """
        user_types_category = self.env.ref('base.module_category_user_type', raise_if_not_found=False)
        user_types_groups = self.env['res.groups'].search(
            [('category_id', '=', user_types_category.id)]) if user_types_category else False
        if user_types_groups:  # needed at install
            if self._has_multiple_groups(user_types_groups.ids):
                raise ValidationError(_('The user cannot have more than one user types.'))

    def _has_multiple_groups(self, group_ids):
        """The method is not fast if the list of ids is very long;
           so we rather check all users than limit to the size of the group
        :param group_ids: list of group ids
        :return: boolean: is there at least a user in at least 2 of the provided groups
        """
        if group_ids:
            args = [tuple(group_ids)]
            if len(self.ids) == 1:
                where_clause = "AND r.uid = %s"
                args.append(self.id)
            else:
                where_clause = ""  # default; we check ALL users (actually pretty efficient)
            query = """
                    SELECT 1 FROM res_groups_users_rel WHERE EXISTS(
                        SELECT r.uid
                        FROM res_groups_users_rel r
                        WHERE r.gid IN %s""" + where_clause + """
                        GROUP BY r.uid HAVING COUNT(r.gid) > 1
                    )
            """
            self.env.cr.execute(query, args)
            return bool(self.env.cr.fetchall())
        else:
            return False

    def toggle_active(self):
        for user in self:
            if not user.active and not user.partner_id.active:
                user.partner_id.toggle_active()
        super(Users, self).toggle_active()

    def onchange(self, values, field_names, fields_spec):
        # Hacky fix to access fields in `SELF_READABLE_FIELDS` in the onchange logic.
        # Put field values in the cache.
        if self == self.env.user:
            [self.sudo()[field_name] for field_name in self.SELF_READABLE_FIELDS]
        return super().onchange(values, field_names, fields_spec)

    def read(self, fields=None, load='_classic_read'):
        readable = self.SELF_READABLE_FIELDS
        if fields and self == self.env.user and all(key in readable or key.startswith('context_') for key in fields):
            # safe fields only, so we read as super-user to bypass access rights
            self = self.sudo()
        return super(Users, self).read(fields=fields, load=load)

    @api.model
    def check_field_access_rights(self, operation, field_names):
        readable = self.SELF_READABLE_FIELDS
        if field_names and self == self.env.user and all(key in readable or key.startswith('context_') for key in field_names):
            # safe fields only, so we read as super-user to bypass access rights
            self = self.sudo()
        return super(Users, self).check_field_access_rights(operation, field_names)

    @api.model
    def _read_group_check_field_access_rights(self, field_names):
        super()._read_group_check_field_access_rights(field_names)
        if set(field_names).intersection(USER_PRIVATE_FIELDS):
            raise AccessError(_("Invalid 'group by' parameter"))

    @api.model
    def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):
        if not self.env.su and domain:
            domain_fields = {term[0] for term in domain if isinstance(term, (tuple, list))}
            if domain_fields.intersection(USER_PRIVATE_FIELDS):
                raise AccessError(_('Invalid search criterion'))
        return super()._search(domain, offset, limit, order, access_rights_uid)

    @api.model_create_multi
    def create(self, vals_list):
        users = super(Users, self).create(vals_list)
        for user in users:
            # if partner is global we keep it that way
            if user.partner_id.company_id:
                user.partner_id.company_id = user.company_id
            user.partner_id.active = user.active
            # Generate employee initals as avatar for internal users without image
            if not user.image_1920 and not user.share and user.name:
                user.image_1920 = user.partner_id._avatar_generate_svg()

        return users

    def _apply_groups_to_existing_employees(self):
        """ Should new groups be added to existing employees?

        If the template user is being modified, the groups should be applied to
        every other base_user users
        """
        default_user = self.env.ref('base.default_user', raise_if_not_found=False)
        return default_user and default_user in self

    def write(self, values):
        if values.get('active') and SUPERUSER_ID in self._ids:
            raise UserError(_("You cannot activate the superuser."))
        if values.get('active') == False and self._uid in self._ids:
            raise UserError(_("You cannot deactivate the user you're currently logged in as."))

        if values.get('active'):
            for user in self:
                if not user.active and not user.partner_id.active:
                    user.partner_id.toggle_active()
        if self == self.env.user:
            writeable = self.SELF_WRITEABLE_FIELDS
            for key in list(values):
                if not (key in writeable or key.startswith('context_')):
                    break
            else:
                if 'company_id' in values:
                    if values['company_id'] not in self.env.user.company_ids.ids:
                        del values['company_id']
                # safe fields only, so we write as super-user to bypass access rights
                self = self.sudo()

        old_groups = []
        if 'groups_id' in values and self._apply_groups_to_existing_employees():
            # if modify groups_id content, compute the delta of groups to apply
            # the new ones to other existing users
            old_groups = self._default_groups()

        res = super(Users, self).write(values)

        if old_groups:
            # new elements in _default_groups() means new groups for default users
            # that needs to be added to existing ones as well for consistency
            added_groups = self._default_groups() - old_groups
            if added_groups:
                internal_users = self.env.ref('base.group_user').users - self
                internal_users.write({'groups_id': [Command.link(gid) for gid in added_groups.ids]})

        if 'company_id' in values:
            for user in self:
                # if partner is global we keep it that way
                if user.partner_id.company_id and user.partner_id.company_id.id != values['company_id']:
                    user.partner_id.write({'company_id': user.company_id.id})

        if 'company_id' in values or 'company_ids' in values:
            # Reset lazy properties `company` & `companies` on all envs,
            # and also their _cache_key, which may depend on them.
            # This is unlikely in a business code to change the company of a user and then do business stuff
            # but in case it happens this is handled.
            # e.g. `account_test_savepoint.py` `setup_company_data`, triggered by `test_account_invoice_report.py`
            for env in list(self.env.transaction.envs):
                if env.user in self:
                    lazy_property.reset_all(env)
                    env._cache_key.clear()

        # clear caches linked to the users
        if self.ids and 'groups_id' in values:
            # DLE P139: Calling invalidate_cache on a new, well you lost everything as you wont be able to take it back from the cache
            # `test_00_equipment_multicompany_user`
            self.env['ir.model.access'].call_cache_clearing_methods()

        # per-method / per-model caches have been removed so the various
        # clear_cache/clear_caches methods pretty much just end up calling
        # Registry.clear_cache
        invalidation_fields = self._get_invalidation_fields()
        if (invalidation_fields & values.keys()) or any(key.startswith('context_') for key in values):
            self.env.registry.clear_cache()

        return res

    @api.ondelete(at_uninstall=True)
    def _unlink_except_master_data(self):
        portal_user_template = self.env.ref('base.template_portal_user_id', False)
        default_user_template = self.env.ref('base.default_user', False)
        if SUPERUSER_ID in self.ids:
            raise UserError(_('You can not remove the admin user as it is used internally for resources created by Odoo (updates, module installation, ...)'))
        user_admin = self.env.ref('base.user_admin', raise_if_not_found=False)
        if user_admin and user_admin in self:
            raise UserError(_('You cannot delete the admin user because it is utilized in various places (such as security configurations,...). Instead, archive it.'))
        self.env.registry.clear_cache()
        if (portal_user_template and portal_user_template in self) or (default_user_template and default_user_template in self):
            raise UserError(_('Deleting the template users is not allowed. Deleting this profile will compromise critical functionalities.'))

    @api.model
    def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):
        domain = domain or []
        user_ids = []
        if operator not in expression.NEGATIVE_TERM_OPERATORS:
            if operator == 'ilike' and not (name or '').strip():
                name_domain = []
            else:
                name_domain = [('login', '=', name)]
            user_ids = self._search(expression.AND([name_domain, domain]), limit=limit, order=order)
        if not user_ids:
            user_ids = self._search(expression.AND([[('name', operator, name)], domain]), limit=limit, order=order)
        return user_ids

    def copy(self, default=None):
        self.ensure_one()
        default = dict(default or {})
        if ('name' not in default) and ('partner_id' not in default):
            default['name'] = _("%s (copy)", self.name)
        if 'login' not in default:
            default['login'] = _("%s (copy)", self.login)
        return super(Users, self).copy(default)

    @api.model
    @tools.ormcache('self._uid')
    def context_get(self):
        user = self.env.user
        # determine field names to read
        name_to_key = {
            name: name[8:] if name.startswith('context_') else name
            for name in self._fields
            if name.startswith('context_') or name in ('lang', 'tz')
        }
        # use read() to not read other fields: this must work while modifying
        # the schema of models res.users or res.partner
        values = user.read(list(name_to_key), load=False)[0]

        context = {
            key: values[name]
            for name, key in name_to_key.items()
        }

        # ensure lang is set and available
        # context > request > company > english > any lang installed
        langs = [code for code, _ in self.env['res.lang'].get_installed()]
        lang = context.get('lang')
        if lang not in langs:
            lang = request.best_lang if request else None
            if lang not in langs:
                lang = self.env.user.company_id.partner_id.lang
                if lang not in langs:
                    lang = DEFAULT_LANG
                    if lang not in langs:
                        lang = langs[0] if langs else DEFAULT_LANG
        context['lang'] = lang

        # ensure uid is set
        context['uid'] = self.env.uid

        return frozendict(context)

    @tools.ormcache('self.id')
    def _get_company_ids(self):
        # use search() instead of `self.company_ids` to avoid extra query for `active_test`
        domain = [('active', '=', True), ('user_ids', 'in', self.id)]
        return self.env['res.company'].search(domain)._ids

    @api.model
    def action_get(self):
        return self.sudo().env.ref('base.action_res_users_my').read()[0]

    def check_super(self, passwd):
        return check_super(passwd)

    @api.model
    def _get_invalidation_fields(self):
        return {
            'groups_id', 'active', 'lang', 'tz', 'company_id', 'company_ids',
            *USER_PRIVATE_FIELDS,
            *self._get_session_token_fields()
        }

    @api.model
    def _update_last_login(self):
        # only create new records to avoid any side-effect on concurrent transactions
        # extra records will be deleted by the periodical garbage collection
        self.env['res.users.log'].sudo().create({}) # populated by defaults

    @api.model
    def _get_login_domain(self, login):
        return [('login', '=', login)]

    @api.model
    def _get_email_domain(self, email):
        return [('email', '=', email)]

    @api.model
    def _get_login_order(self):
        return self._order

    @classmethod
    def _login(cls, db, login, password, user_agent_env):
        if not password:
            raise AccessDenied()
        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
        try:
            with cls.pool.cursor() as cr:
                self = api.Environment(cr, SUPERUSER_ID, {})[cls._name]
                with self._assert_can_auth(user=login):
                    user = self.search(self._get_login_domain(login), order=self._get_login_order(), limit=1)
                    if not user:
                        raise AccessDenied()
                    user = user.with_user(user)
                    user._check_credentials(password, user_agent_env)
                    tz = request.httprequest.cookies.get('tz') if request else None
                    if tz in pytz.all_timezones and (not user.tz or not user.login_date):
                        # first login or missing tz -> set tz to browser tz
                        user.tz = tz
                    user._update_last_login()
        except AccessDenied:
            _logger.info("Login failed for db:%s login:%s from %s", db, login, ip)
            raise

        _logger.info("Login successful for db:%s login:%s from %s", db, login, ip)

        return user.id

    @classmethod
    def authenticate(cls, db, login, password, user_agent_env):
        """Verifies and returns the user ID corresponding to the given
          ``login`` and ``password`` combination, or False if there was
          no matching user.
           :param str db: the database on which user is trying to authenticate
           :param str login: username
           :param str password: user password
           :param dict user_agent_env: environment dictionary describing any
               relevant environment attributes
        """
        uid = cls._login(db, login, password, user_agent_env=user_agent_env)
        if user_agent_env and user_agent_env.get('base_location'):
            with cls.pool.cursor() as cr:
                env = api.Environment(cr, uid, {})
                if env.user.has_group('base.group_system'):
                    # Successfully logged in as system user!
                    # Attempt to guess the web base url...
                    try:
                        base = user_agent_env['base_location']
                        ICP = env['ir.config_parameter']
                        if not ICP.get_param('web.base.url.freeze'):
                            ICP.set_param('web.base.url', base)
                    except Exception:
                        _logger.exception("Failed to update web.base.url configuration parameter")
        return uid

    @classmethod
    @tools.ormcache('uid', 'passwd')
    def check(cls, db, uid, passwd):
        """Verifies that the given (uid, password) is authorized for the database ``db`` and
           raise an exception if it is not."""
        if not passwd:
            # empty passwords disallowed for obvious security reasons
            raise AccessDenied()

        with contextlib.closing(cls.pool.cursor()) as cr:
            self = api.Environment(cr, uid, {})[cls._name]
            with self._assert_can_auth(user=uid):
                if not self.env.user.active:
                    raise AccessDenied()
                self._check_credentials(passwd, {'interactive': False})

    def _get_session_token_fields(self):
        return {'id', 'login', 'password', 'active'}

    @tools.ormcache('sid')
    def _compute_session_token(self, sid):
        """ Compute a session token given a session id and a user id """
        # retrieve the fields used to generate the session token
        session_fields = ', '.join(sorted(self._get_session_token_fields()))
        self.env.cr.execute("""SELECT %s, (SELECT value FROM ir_config_parameter WHERE key='database.secret')
                                FROM res_users
                                WHERE id=%%s""" % (session_fields), (self.id,))
        if self.env.cr.rowcount != 1:
            self.env.registry.clear_cache()
            return False
        data_fields = self.env.cr.fetchone()
        # generate hmac key
        key = (u'%s' % (data_fields,)).encode('utf-8')
        # hmac the session id
        data = sid.encode('utf-8')
        h = hmac.new(key, data, sha256)
        # keep in the cache the token
        return h.hexdigest()

    @api.model
    def change_password(self, old_passwd, new_passwd):
        """Change current user password. Old password must be provided explicitly
        to prevent hijacking an existing user session, or for cases where the cleartext
        password is not used to authenticate requests.

        :return: True
        :raise: odoo.exceptions.AccessDenied when old password is wrong
        :raise: odoo.exceptions.UserError when new password is not set or empty
        """
        if not old_passwd:
            raise AccessDenied()

        # alternatively: use identitycheck wizard?
        self._check_credentials(old_passwd, {'interactive': True})

        # use self.env.user here, because it has uid=SUPERUSER_ID
        self.env.user._change_password(new_passwd)
        return True

    def _change_password(self, new_passwd):
        new_passwd = new_passwd.strip()
        if not new_passwd:
            raise UserError(_("Setting empty passwords is not allowed for security reasons!"))

        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
        _logger.info(
            "Password change for %r (#%d) by %r (#%d) from %s",
             self.login, self.id,
             self.env.user.login, self.env.user.id,
             ip
        )

        self.password = new_passwd

    def _deactivate_portal_user(self, **post):
        """Try to remove the current portal user.

        This is used to give the opportunity to portal users to de-activate their accounts.
        Indeed, as the portal users can easily create accounts, they will sometimes wish
        it removed because they don't use this Odoo portal anymore.

        Before this feature, they would have to contact the website or the support to get
        their account removed, which could be tedious.
        """
        non_portal_users = self.filtered(lambda user: not user.share)
        if non_portal_users:
            raise AccessDenied(_(
                'Only the portal users can delete their accounts. '
                'The user(s) %s can not be deleted.',
                ', '.join(non_portal_users.mapped('name')),
            ))

        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'

        res_users_deletion_values = []

        for user in self:
            _logger.info(
                'Account deletion asked for "%s" (#%i) from %s. '
                'Archive the user and remove login information.',
                user.login, user.id, ip,
            )

            user.write({
                'login': f'__deleted_user_{user.id}_{time.time()}',
                'password': '',
            })
            user.api_key_ids._remove()

            res_users_deletion_values.append({
                'user_id': user.id,
                'state': 'todo',
            })

        # Here we try to archive the user / partner, and then add the user in a deletion
        # queue, to remove it from the database. As the deletion might fail (if the
        # partner is related to an invoice e.g.) it's important to archive it here.
        try:
            # A user can not self-deactivate
            self.with_user(SUPERUSER_ID).action_archive()
        except Exception:
            pass
        try:
            self.partner_id.action_archive()
        except Exception:
            pass
        # Add users in the deletion queue
        self.env['res.users.deletion'].create(res_users_deletion_values)

    def preference_save(self):
        return {
            'type': 'ir.actions.client',
            'tag': 'reload_context',
        }

    @check_identity
    def preference_change_password(self):
        return {
            'type': 'ir.actions.act_window',
            'target': 'new',
            'res_model': 'change.password.own',
            'view_mode': 'form',
        }

    def action_revoke_all_devices(self):
        ctx = dict(self.env.context, dialog_size='medium')
        return {
            'name': _('Log out from all devices?'),
            'type': 'ir.actions.act_window',
            'target': 'new',
            'res_model': 'res.users.identitycheck',
            'view_mode': 'form',
            'view_id': self.env.ref('base.res_users_identitycheck_view_form_revokedevices').id,
            'context': ctx,
        }

    @api.model
    def has_group(self, group_ext_id):
        # use singleton's id if called on a non-empty recordset, otherwise
        # context uid
        uid = self.id
        if uid and uid != self._uid:
            self = self.with_user(uid)
        return self._has_group(group_ext_id)

    @api.model
    @tools.ormcache('self._uid', 'group_ext_id')
    def _has_group(self, group_ext_id):
        """Checks whether user belongs to given group.

        :param str group_ext_id: external ID (XML ID) of the group.
           Must be provided in fully-qualified form (``module.ext_id``), as there
           is no implicit module to use..
        :return: True if the current user is a member of the group with the
           given external ID (XML ID), else False.
        """
        assert group_ext_id and '.' in group_ext_id, "External ID '%s' must be fully qualified" % group_ext_id
        module, ext_id = group_ext_id.split('.')
        self._cr.execute("""SELECT 1 FROM res_groups_users_rel WHERE uid=%s AND gid IN
                            (SELECT res_id FROM ir_model_data WHERE module=%s AND name=%s AND model='res.groups')""",
                         (self._uid, module, ext_id))
        return bool(self._cr.fetchone())

    def _action_show(self):
        """If self is a singleton, directly access the form view. If it is a recordset, open a tree view"""
        view_id = self.env.ref('base.view_users_form').id
        action = {
            'type': 'ir.actions.act_window',
            'res_model': 'res.users',
            'context': {'create': False},
        }
        if len(self) > 1:
            action.update({
                'name': _('Users'),
                'view_mode': 'list,form',
                'views': [[None, 'list'], [view_id, 'form']],
                'domain': [('id', 'in', self.ids)],
            })
        else:
            action.update({
                'view_mode': 'form',
                'views': [[view_id, 'form']],
                'res_id': self.id,
            })
        return action

    def action_show_groups(self):
        self.ensure_one()
        return {
            'name': _('Groups'),
            'view_mode': 'tree,form',
            'res_model': 'res.groups',
            'type': 'ir.actions.act_window',
            'context': {'create': False, 'delete': False},
            'domain': [('id','in', self.groups_id.ids)],
            'target': 'current',
        }

    def action_show_accesses(self):
        self.ensure_one()
        return {
            'name': _('Access Rights'),
            'view_mode': 'tree,form',
            'res_model': 'ir.model.access',
            'type': 'ir.actions.act_window',
            'context': {'create': False, 'delete': False},
            'domain': [('id', 'in', self.groups_id.model_access.ids)],
            'target': 'current',
        }

    def action_show_rules(self):
        self.ensure_one()
        return {
            'name': _('Record Rules'),
            'view_mode': 'tree,form',
            'res_model': 'ir.rule',
            'type': 'ir.actions.act_window',
            'context': {'create': False, 'delete': False},
            'domain': [('id', 'in', self.groups_id.rule_groups.ids)],
            'target': 'current',
        }

    def _is_internal(self):
        self.ensure_one()
        return not self.sudo().share

    def _is_portal(self):
        self.ensure_one()
        return self.has_group('base.group_portal')

    def _is_public(self):
        self.ensure_one()
        return self.has_group('base.group_public')

    def _is_system(self):
        self.ensure_one()
        return self.has_group('base.group_system')

    def _is_admin(self):
        self.ensure_one()
        return self._is_superuser() or self.has_group('base.group_erp_manager')

    def _is_superuser(self):
        self.ensure_one()
        return self.id == SUPERUSER_ID

    @api.model
    def get_company_currency_id(self):
        return self.env.company.currency_id.id

    @tools.ormcache()
    def _crypt_context(self):
        """ Passlib CryptContext instance used to encrypt and verify
        passwords. Can be overridden if technical, legal or political matters
        require different kdfs than the provided default.

        The work factor of the default KDF can be configured using the
        ``password.hashing.rounds`` ICP.
        """
        cfg = self.env['ir.config_parameter'].sudo()
        return CryptContext(
            # kdf which can be verified by the context. The default encryption
            # kdf is the first of the list
            ['pbkdf2_sha512', 'plaintext'],
            # deprecated algorithms are still verified as usual, but
            # ``needs_update`` will indicate that the stored hash should be
            # replaced by a more recent algorithm.
            deprecated=['auto'],
            pbkdf2_sha512__rounds=max(MIN_ROUNDS, int(cfg.get_param('password.hashing.rounds', 0))),
        )

    @contextlib.contextmanager
    def _assert_can_auth(self, user=None):
        """ Checks that the current environment even allows the current auth
        request to happen.

        The baseline implementation is a simple linear login cooldown: after
        a number of failures trying to log-in, the user (by login) is put on
        cooldown. During the cooldown period, login *attempts* are ignored
        and logged.

        :param user: user id or login, for logging purpose

        .. warning::

            The login counter is not shared between workers and not
            specifically thread-safe, the feature exists mostly for
            rate-limiting on large number of login attempts (brute-forcing
            passwords) so that should not be much of an issue.

            For a more complex strategy (e.g. database or distribute storage)
            override this method. To simply change the cooldown criteria
            (configuration, ...) override _on_login_cooldown instead.

        .. note::

            This is a *context manager* so it can be called around the login
            procedure without having to call it itself.
        """
        # needs request for remote address
        if not request:
            yield
            return

        reg = self.env.registry
        failures_map = getattr(reg, '_login_failures', None)
        if failures_map is None:
            failures_map = reg._login_failures = collections.defaultdict(lambda : (0, datetime.datetime.min))

        source = request.httprequest.remote_addr
        (failures, previous) = failures_map[source]
        if self._on_login_cooldown(failures, previous):
            _logger.warning(
                "Login attempt ignored for %s (user %r) on %s: "
                "%d failures since last success, last failure at %s. "
                "You can configure the number of login failures before a "
                "user is put on cooldown as well as the duration in the "
                "System Parameters. Disable this feature by setting "
                "\"base.login_cooldown_after\" to 0.",
                source, user or "?", self.env.cr.dbname, failures, previous)
            if ipaddress.ip_address(source).is_private:
                _logger.warning(
                    "The rate-limited IP address %s is classified as private "
                    "and *might* be a proxy. If your Odoo is behind a proxy, "
                    "it may be mis-configured. Check that you are running "
                    "Odoo in Proxy Mode and that the proxy is properly configured, see "
                    "https://www.odoo.com/documentation/17.0/administration/install/deploy.html#https for details.",
                    source
                )
            raise AccessDenied(_("Too many login failures, please wait a bit before trying again."))

        try:
            yield
        except AccessDenied:
            (failures, __) = reg._login_failures[source]
            reg._login_failures[source] = (failures + 1, datetime.datetime.now())
            raise
        else:
            reg._login_failures.pop(source, None)

    def _on_login_cooldown(self, failures, previous):
        """ Decides whether the user trying to log in is currently
        "on cooldown" and not even allowed to attempt logging in.

        The default cooldown function simply puts the user on cooldown for
        <login_cooldown_duration> seconds after each failure following the
        <login_cooldown_after>th (0 to disable).

        Can be overridden to implement more complex backoff strategies, or
        e.g. wind down or reset the cooldown period as the previous failure
        recedes into the far past.

        :param int failures: number of recorded failures (since last success)
        :param previous: timestamp of previous failure
        :type previous:  datetime.datetime
        :returns: whether the user is currently in cooldown phase (true if cooldown, false if no cooldown and login can continue)
        :rtype: bool
        """
        cfg = self.env['ir.config_parameter'].sudo()
        min_failures = int(cfg.get_param('base.login_cooldown_after', 5))
        if min_failures == 0:
            return False

        delay = int(cfg.get_param('base.login_cooldown_duration', 60))
        return failures >= min_failures and (datetime.datetime.now() - previous) < datetime.timedelta(seconds=delay)

    def _register_hook(self):
        if hasattr(self, 'check_credentials'):
            _logger.warning("The check_credentials method of res.users has been renamed _check_credentials. One of your installed modules defines one, but it will not be called anymore.")

    def _mfa_type(self):
        """ If an MFA method is enabled, returns its type as a string. """
        return

    def _mfa_url(self):
        """ If an MFA method is enabled, returns the URL for its second step. """
        return

    def _should_alert_new_device(self):
        """ Determine if an alert should be sent to the user regarding a new device

        To be overriden in 2FA modules implementing known devices
        """
        return False

#
# Implied groups
#
# Extension of res.groups and res.users with a relation for "implied" or
# "inherited" groups.  Once a user belongs to a group, it automatically belongs
# to the implied groups (transitively).
#

class GroupsImplied(models.Model):
    _inherit = 'res.groups'

    implied_ids = fields.Many2many('res.groups', 'res_groups_implied_rel', 'gid', 'hid',
        string='Inherits', help='Users of this group automatically inherit those groups')
    trans_implied_ids = fields.Many2many('res.groups', string='Transitively inherits',
        compute='_compute_trans_implied', recursive=True)

    @api.depends('implied_ids.trans_implied_ids')
    def _compute_trans_implied(self):
        # Compute the transitive closure recursively. Note that the performance
        # is good, because the record cache behaves as a memo (the field is
        # never computed twice on a given group.)
        for g in self:
            g.trans_implied_ids = g.implied_ids | g.implied_ids.trans_implied_ids

    @api.model_create_multi
    def create(self, vals_list):
        user_ids_list = [vals.pop('users', None) for vals in vals_list]
        groups = super(GroupsImplied, self).create(vals_list)
        for group, user_ids in zip(groups, user_ids_list):
            if user_ids:
                # delegate addition of users to add implied groups
                group.write({'users': user_ids})
        return groups

    def write(self, values):
        res = super(GroupsImplied, self).write(values)
        if values.get('users') or values.get('implied_ids'):
            # add all implied groups (to all users of each group)
            for group in self:
                self._cr.execute("""
                    WITH RECURSIVE group_imply(gid, hid) AS (
                        SELECT gid, hid
                          FROM res_groups_implied_rel
                         UNION
                        SELECT i.gid, r.hid
                          FROM res_groups_implied_rel r
                          JOIN group_imply i ON (i.hid = r.gid)
                    )
                    INSERT INTO res_groups_users_rel (gid, uid)
                         SELECT i.hid, r.uid
                           FROM group_imply i, res_groups_users_rel r
                          WHERE r.gid = i.gid
                            AND i.gid = %(gid)s
                         EXCEPT
                         SELECT r.gid, r.uid
                           FROM res_groups_users_rel r
                           JOIN group_imply i ON (r.gid = i.hid)
                          WHERE i.gid = %(gid)s
                """, dict(gid=group.id))
            self._check_one_user_type()
        return res

    def _apply_group(self, implied_group):
        """ Add the given group to the groups implied by the current group
        :param implied_group: the implied group to add
        """
        groups = self.filtered(lambda g: implied_group not in g.implied_ids)
        groups.write({'implied_ids': [Command.link(implied_group.id)]})

    def _remove_group(self, implied_group):
        """ Remove the given group from the implied groups of the current group
        :param implied_group: the implied group to remove
        """
        groups = self.filtered(lambda g: implied_group in g.implied_ids)
        if groups:
            groups.write({'implied_ids': [Command.unlink(implied_group.id)]})
            # if user belongs to implied_group thanks to another group, don't remove him
            # this avoids readding the template user and triggering the mechanism at 121cd0d6084cb28
            users_to_unlink = [
                user
                for user in groups.with_context(active_test=False).users
                if implied_group not in (user.groups_id - implied_group).trans_implied_ids
            ]
            if users_to_unlink:
                # do not remove inactive users (e.g. default)
                implied_group.with_context(active_test=False).write(
                    {'users': [Command.unlink(user.id) for user in users_to_unlink]})

class UsersImplied(models.Model):
    _inherit = 'res.users'

    @api.model_create_multi
    def create(self, vals_list):
        for values in vals_list:
            if 'groups_id' in values:
                # complete 'groups_id' with implied groups
                user = self.new(values)
                gs = user.groups_id._origin
                gs = gs | gs.trans_implied_ids
                values['groups_id'] = self._fields['groups_id'].convert_to_write(gs, user)
        return super(UsersImplied, self).create(vals_list)

    def write(self, values):
        if not values.get('groups_id'):
            return super(UsersImplied, self).write(values)
        users_before = self.filtered(lambda u: u._is_internal())
        res = super(UsersImplied, self).write(values)
        demoted_users = users_before.filtered(lambda u: not u._is_internal())
        if demoted_users:
            # demoted users are restricted to the assigned groups only
            vals = {'groups_id': [Command.clear()] + values['groups_id']}
            super(UsersImplied, demoted_users).write(vals)
        # add implied groups for all users (in batches)
        users_batch = defaultdict(self.browse)
        for user in self:
            users_batch[user.groups_id] += user
        for groups, users in users_batch.items():
            gs = set(concat(g.trans_implied_ids for g in groups))
            vals = {'groups_id': [Command.link(g.id) for g in gs]}
            super(UsersImplied, users).write(vals)
        return res

#
# Virtual checkbox and selection for res.user form view
#
# Extension of res.groups and res.users for the special groups view in the users
# form.  This extension presents groups with selection and boolean widgets:
# - Groups are shown by application, with boolean and/or selection fields.
#   Selection fields typically defines a role "Name" for the given application.
# - Uncategorized groups are presented as boolean fields and grouped in a
#   section "Others".
#
# The user form view is modified by an inherited view (base.user_groups_view);
# the inherited view replaces the field 'groups_id' by a set of reified group
# fields (boolean or selection fields).  The arch of that view is regenerated
# each time groups are changed.
#
# Naming conventions for reified groups fields:
# - boolean field 'in_group_ID' is True iff
#       ID is in 'groups_id'
# - selection field 'sel_groups_ID1_..._IDk' is ID iff
#       ID is in 'groups_id' and ID is maximal in the set {ID1, ..., IDk}
#

class GroupsView(models.Model):
    _inherit = 'res.groups'

    @api.model_create_multi
    def create(self, vals_list):
        groups = super().create(vals_list)
        self._update_user_groups_view()
        # actions.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return groups

    def write(self, values):
        # determine which values the "user groups view" depends on
        VIEW_DEPS = ('category_id', 'implied_ids')
        view_values0 = [g[name] for name in VIEW_DEPS if name in values for g in self]
        res = super(GroupsView, self).write(values)
        # update the "user groups view" only if necessary
        view_values1 = [g[name] for name in VIEW_DEPS if name in values for g in self]
        if view_values0 != view_values1:
            self._update_user_groups_view()
        # actions.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return res

    def unlink(self):
        res = super(GroupsView, self).unlink()
        self._update_user_groups_view()
        # actions.get_bindings() depends on action records
        self.env.registry.clear_cache()
        return res

    def _get_hidden_extra_categories(self):
        return ['base.module_category_hidden', 'base.module_category_extra', 'base.module_category_usability']

    @api.model
    def _update_user_groups_view(self):
        """ Modify the view with xmlid ``base.user_groups_view``, which inherits
            the user form view, and introduces the reified group fields.
        """
        # remove the language to avoid translations, it will be handled at the view level
        self = self.with_context(lang=None)

        # We have to try-catch this, because at first init the view does not
        # exist but we are already creating some basic groups.
        view = self.env.ref('base.user_groups_view', raise_if_not_found=False)
        if not (view and view._name == 'ir.ui.view'):
            return

        if self._context.get('install_filename') or self._context.get(MODULE_UNINSTALL_FLAG):
            # use a dummy view during install/upgrade/uninstall
            xml = E.field(name="groups_id", position="after")

        else:
            group_no_one = view.env.ref('base.group_no_one')
            group_employee = view.env.ref('base.group_user')
            xml0, xml1, xml2, xml3, xml4 = [], [], [], [], []
            xml_by_category = {}
            xml1.append(E.separator(string='User Type', colspan="2", groups='base.group_no_one'))

            user_type_field_name = ''
            user_type_readonly = str({})
            sorted_tuples = sorted(self.get_groups_by_application(),
                                   key=lambda t: t[0].xml_id != 'base.module_category_user_type')
            for app, kind, gs, category_name in sorted_tuples:  # we process the user type first
                attrs = {}
                # hide groups in categories 'Hidden' and 'Extra' (except for group_no_one)
                if app.xml_id in self._get_hidden_extra_categories():
                    attrs['groups'] = 'base.group_no_one'

                # User type (employee, portal or public) is a separated group. This is the only 'selection'
                # group of res.groups without implied groups (with each other).
                if app.xml_id == 'base.module_category_user_type':
                    # application name with a selection field
                    field_name = name_selection_groups(gs.ids)
                    # test_reified_groups, put the user category type in invisible
                    # as it's used in domain of attrs of other fields,
                    # and the normal user category type field node is wrapped in a `groups="base.no_one"`,
                    # and is therefore removed when not in debug mode.
                    xml0.append(E.field(name=field_name, invisible="1", on_change="1"))
                    user_type_field_name = field_name
                    user_type_readonly = f'{user_type_field_name} != {group_employee.id}'
                    attrs['widget'] = 'radio'
                    # Trigger the on_change of this "virtual field"
                    attrs['on_change'] = '1'
                    xml1.append(E.field(name=field_name, **attrs))
                    xml1.append(E.newline())

                elif kind == 'selection':
                    # application name with a selection field
                    field_name = name_selection_groups(gs.ids)
                    attrs['readonly'] = user_type_readonly
                    attrs['on_change'] = '1'
                    if category_name not in xml_by_category:
                        xml_by_category[category_name] = []
                        xml_by_category[category_name].append(E.newline())
                    xml_by_category[category_name].append(E.field(name=field_name, **attrs))
                    xml_by_category[category_name].append(E.newline())
                    # add duplicate invisible field so default values are saved on create
                    if attrs.get('groups') == 'base.group_no_one':
                        xml0.append(E.field(name=field_name, **dict(attrs, invisible="1", groups='!base.group_no_one')))

                else:
                    # application separator with boolean fields
                    app_name = app.name or 'Other'
                    xml4.append(E.separator(string=app_name, **attrs))
                    left_group, right_group = [], []
                    attrs['readonly'] = user_type_readonly
                    # we can't use enumerate, as we sometime skip groups
                    group_count = 0
                    for g in gs:
                        field_name = name_boolean_group(g.id)
                        dest_group = left_group if group_count % 2 == 0 else right_group
                        if g == group_no_one:
                            # make the group_no_one invisible in the form view
                            dest_group.append(E.field(name=field_name, invisible="1", **attrs))
                        else:
                            dest_group.append(E.field(name=field_name, **attrs))
                        # add duplicate invisible field so default values are saved on create
                        xml0.append(E.field(name=field_name, **dict(attrs, invisible="1", groups='!base.group_no_one')))
                        group_count += 1
                    xml4.append(E.group(*left_group))
                    xml4.append(E.group(*right_group))

            xml4.append({'class': "o_label_nowrap"})
            user_type_invisible = f'{user_type_field_name} != {group_employee.id}' if user_type_field_name else None

            for xml_cat in sorted(xml_by_category.keys(), key=lambda it: it[0]):
                master_category_name = xml_cat[1]
                xml3.append(E.group(*(xml_by_category[xml_cat]), string=master_category_name))

            field_name = 'user_group_warning'
            user_group_warning_xml = E.div({
                'class': "alert alert-warning",
                'role': "alert",
                'colspan': "2",
                'invisible': f'not {field_name}',
            })
            user_group_warning_xml.append(E.label({
                'for': field_name,
                'string': "Access Rights Mismatch",
                'class': "text text-warning fw-bold",
            }))
            user_group_warning_xml.append(E.field(name=field_name))
            xml2.append(user_group_warning_xml)

            xml = E.field(
                *(xml0),
                E.group(*(xml1), groups="base.group_no_one"),
                E.group(*(xml2), invisible=user_type_invisible),
                E.group(*(xml3), invisible=user_type_invisible),
                E.group(*(xml4), invisible=user_type_invisible, groups="base.group_no_one"), name="groups_id", position="replace")
            xml.addprevious(etree.Comment("GENERATED AUTOMATICALLY BY GROUPS"))

        # serialize and update the view
        xml_content = etree.tostring(xml, pretty_print=True, encoding="unicode")
        if xml_content != view.arch:  # avoid useless xml validation if no change
            new_context = dict(view._context)
            new_context.pop('install_filename', None)  # don't set arch_fs for this computed view
            new_context['lang'] = None
            view.with_context(new_context).write({'arch': xml_content})

    def get_application_groups(self, domain):
        """ Return the non-share groups that satisfy ``domain``. """
        return self.search(domain + [('share', '=', False)])

    @api.model
    def get_groups_by_application(self):
        """ Return all groups classified by application (module category), as a list::

                [(app, kind, groups), ...],

            where ``app`` and ``groups`` are recordsets, and ``kind`` is either
            ``'boolean'`` or ``'selection'``. Applications are given in sequence
            order.  If ``kind`` is ``'selection'``, ``groups`` are given in
            reverse implication order.
        """
        def linearize(app, gs, category_name):
            # 'User Type' is an exception
            if app.xml_id == 'base.module_category_user_type':
                return (app, 'selection', gs.sorted('id'), category_name)
            # determine sequence order: a group appears after its implied groups
            order = {g: len(g.trans_implied_ids & gs) for g in gs}
            # We want a selection for Accounting too. Auditor and Invoice are both
            # children of Accountant, but the two of them make a full accountant
            # so it makes no sense to have checkboxes.
            if app.xml_id == 'base.module_category_accounting_accounting':
                return (app, 'selection', gs.sorted(key=order.get), category_name)
            # check whether order is total, i.e., sequence orders are distinct
            if len(set(order.values())) == len(gs):
                return (app, 'selection', gs.sorted(key=order.get), category_name)
            else:
                return (app, 'boolean', gs, (100, 'Other'))

        # classify all groups by application
        by_app, others = defaultdict(self.browse), self.browse()
        for g in self.get_application_groups([]):
            if g.category_id:
                by_app[g.category_id] += g
            else:
                others += g
        # build the result
        res = []
        for app, gs in sorted(by_app.items(), key=lambda it: it[0].sequence or 0):
            if app.parent_id:
                res.append(linearize(app, gs, (app.parent_id.sequence, app.parent_id.name)))
            else:
                res.append(linearize(app, gs, (100, 'Other')))

        if others:
            res.append((self.env['ir.module.category'], 'boolean', others, (100,'Other')))
        return res


class ModuleCategory(models.Model):
    _inherit = "ir.module.category"

    def write(self, values):
        res = super().write(values)
        if "name" in values:
            self.env["res.groups"]._update_user_groups_view()
        return res

    def unlink(self):
        res = super().unlink()
        self.env["res.groups"]._update_user_groups_view()
        return res


class UsersView(models.Model):
    _inherit = 'res.users'

    user_group_warning = fields.Text(string="User Group Warning", compute="_compute_user_group_warning")

    @api.depends('groups_id', 'share')
    @api.depends_context('show_user_group_warning')
    def _compute_user_group_warning(self):
        self.user_group_warning = False
        if self._context.get('show_user_group_warning'):
            for user in self.filtered_domain([('share', '=', False)]):
                group_inheritance_warnings = self._prepare_warning_for_group_inheritance(user)
                if group_inheritance_warnings:
                    user.user_group_warning = group_inheritance_warnings

    @api.model_create_multi
    def create(self, vals_list):
        new_vals_list = []
        for values in vals_list:
            new_vals_list.append(self._remove_reified_groups(values))
        users = super(UsersView, self).create(new_vals_list)
        group_multi_company_id = self.env['ir.model.data']._xmlid_to_res_id(
            'base.group_multi_company', raise_if_not_found=False)
        if group_multi_company_id:
            for user in users:
                if len(user.company_ids) <= 1 and group_multi_company_id in user.groups_id.ids:
                    user.write({'groups_id': [Command.unlink(group_multi_company_id)]})
                elif len(user.company_ids) > 1 and group_multi_company_id not in user.groups_id.ids:
                    user.write({'groups_id': [Command.link(group_multi_company_id)]})
        return users

    def write(self, values):
        values = self._remove_reified_groups(values)
        res = super(UsersView, self).write(values)
        if 'company_ids' not in values:
            return res
        group_multi_company = self.env.ref('base.group_multi_company', False)
        if group_multi_company:
            for user in self:
                if len(user.company_ids) <= 1 and user.id in group_multi_company.users.ids:
                    user.write({'groups_id': [Command.unlink(group_multi_company.id)]})
                elif len(user.company_ids) > 1 and user.id not in group_multi_company.users.ids:
                    user.write({'groups_id': [Command.link(group_multi_company.id)]})
        return res

    @api.model
    def new(self, values=None, origin=None, ref=None):
        if values is None:
            values = {}
        values = self._remove_reified_groups(values)
        user = super().new(values=values, origin=origin, ref=ref)
        group_multi_company = self.env.ref('base.group_multi_company', False)
        if group_multi_company and 'company_ids' in values:
            if len(user.company_ids) <= 1 and user.id in group_multi_company.users.ids:
                user.update({'groups_id': [Command.unlink(group_multi_company.id)]})
            elif len(user.company_ids) > 1 and user.id not in group_multi_company.users.ids:
                user.update({'groups_id': [Command.link(group_multi_company.id)]})
        return user

    def _prepare_warning_for_group_inheritance(self, user):
        """ Check (updated) groups configuration for user. If implieds groups
        will be added back due to inheritance and hierarchy in groups return
        a message explaining the missing groups.

        :param res.users user: target user

        :return: string to display in a warning
        """
        # Current groups of the user
        current_groups = user.groups_id.filtered('trans_implied_ids')
        current_groups_by_category = defaultdict(lambda: self.env['res.groups'])
        for group in current_groups:
            current_groups_by_category[group.category_id] |= group.trans_implied_ids.filtered(lambda grp: grp.category_id == group.category_id)

        missing_groups = {}
        # We don't want to show warning for "Technical" and "Extra Rights" groups
        categories_to_ignore = self.env.ref('base.module_category_hidden') + self.env.ref('base.module_category_usability')
        for group in current_groups:
            # Get the updated group from current groups
            missing_implied_groups = group.implied_ids - user.groups_id
            # Get the missing group needed in updated group's category (For example, someone changes
            # Sales: Admin to Sales: User, but Field Service is already set to Admin, so here in the
            # 'Sales' category, we will at the minimum need Admin group)
            missing_implied_groups = missing_implied_groups.filtered(
                lambda g:
                g.category_id not in (group.category_id | categories_to_ignore) and
                g not in current_groups_by_category[g.category_id] and
                (self.user_has_groups('base.group_no_one') or g.category_id)
            )
            if missing_implied_groups:
                # prepare missing group message, by categories
                missing_groups[group] = ", ".join(f'"{missing_group.category_id.name or _("Other")}: {missing_group.name}"'
                                                  for missing_group in missing_implied_groups)
        return "\n".join(
            _('Since %(user)s is a/an "%(category)s: %(group)s", they will at least obtain the right %(missing_group_message)s',
              user=user.name,
              category=group.category_id.name or _('Other'),
              group=group.name,
              missing_group_message=missing_group_message
             ) for group, missing_group_message in missing_groups.items()
        )

    def _remove_reified_groups(self, values):
        """ return `values` without reified group fields """
        add, rem = [], []
        values1 = {}

        for key, val in values.items():
            if is_boolean_group(key):
                (add if val else rem).append(get_boolean_group(key))
            elif is_selection_groups(key):
                rem += get_selection_groups(key)
                if val:
                    add.append(val)
            else:
                values1[key] = val

        if 'groups_id' not in values and (add or rem):
            added = self.env['res.groups'].sudo().browse(add)
            added |= added.mapped('trans_implied_ids')
            added_ids = added._ids
            # remove group ids in `rem` and add group ids in `add`
            # do not remove groups that are added by implied
            values1['groups_id'] = list(itertools.chain(
                zip(repeat(3), [gid for gid in rem if gid not in added_ids]),
                zip(repeat(4), add)
            ))

        return values1

    @api.model
    def default_get(self, fields):
        group_fields, fields = partition(is_reified_group, fields)
        fields1 = (fields + ['groups_id']) if group_fields else fields
        values = super(UsersView, self).default_get(fields1)
        self._add_reified_groups(group_fields, values)
        return values

    def _determine_fields_to_fetch(self, field_names, ignore_when_in_cache=False):
        valid_fields = partition(is_reified_group, field_names)[1]
        return super()._determine_fields_to_fetch(valid_fields, ignore_when_in_cache)

    def _read_format(self, fnames, load='_classic_read'):
        valid_fields = partition(is_reified_group, fnames)[1]
        return super()._read_format(valid_fields, load)

    def onchange(self, values, field_names, fields_spec):
        reified_fnames = [fname for fname in fields_spec if is_reified_group(fname)]
        if reified_fnames:
            values = {key: val for key, val in values.items() if key != 'groups_id'}
            values = self._remove_reified_groups(values)

            if any(is_reified_group(fname) for fname in field_names):
                field_names = [fname for fname in field_names if not is_reified_group(fname)]
                field_names.append('groups_id')

            fields_spec = {
                field_name: field_spec
                for field_name, field_spec in fields_spec.items()
                if not is_reified_group(field_name)
            }
            fields_spec['groups_id'] = {}

        result = super().onchange(values, field_names, fields_spec)

        if reified_fnames and 'groups_id' in result.get('value', {}):
            self._add_reified_groups(reified_fnames, result['value'])
            result['value'].pop('groups_id', None)

        return result

    def read(self, fields=None, load='_classic_read'):
        # determine whether reified groups fields are required, and which ones
        fields1 = fields or list(self.fields_get())
        group_fields, other_fields = partition(is_reified_group, fields1)

        # read regular fields (other_fields); add 'groups_id' if necessary
        drop_groups_id = False
        if group_fields and fields:
            if 'groups_id' not in other_fields:
                other_fields.append('groups_id')
                drop_groups_id = True
        else:
            other_fields = fields

        res = super(UsersView, self).read(other_fields, load=load)

        # post-process result to add reified group fields
        if group_fields:
            for values in res:
                self._add_reified_groups(group_fields, values)
                if drop_groups_id:
                    values.pop('groups_id', None)
        return res

    @api.model
    def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):
        if fields:
            # ignore reified fields
            fields = [fname for fname in fields if not is_reified_group(fname)]
        return super().read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)

    def _add_reified_groups(self, fields, values):
        """ add the given reified group fields into `values` """
        gids = set(parse_m2m(values.get('groups_id') or []))
        for f in fields:
            if is_boolean_group(f):
                values[f] = get_boolean_group(f) in gids
            elif is_selection_groups(f):
                # determine selection groups, in order
                sel_groups = self.env['res.groups'].sudo().browse(get_selection_groups(f))
                sel_order = {g: len(g.trans_implied_ids & sel_groups) for g in sel_groups}
                sel_groups = sel_groups.sorted(key=sel_order.get)
                # determine which ones are in gids
                selected = [gid for gid in sel_groups.ids if gid in gids]
                # if 'Internal User' is in the group, this is the "User Type" group
                # and we need to show 'Internal User' selected, not Public/Portal.
                if self.env.ref('base.group_user').id in selected:
                    values[f] = self.env.ref('base.group_user').id
                else:
                    values[f] = selected and selected[-1] or False

    @api.model
    def fields_get(self, allfields=None, attributes=None):
        res = super(UsersView, self).fields_get(allfields, attributes=attributes)
        # add reified groups fields
        for app, kind, gs, category_name in self.env['res.groups'].sudo().get_groups_by_application():
            if kind == 'selection':
                # 'User Type' should not be 'False'. A user is either 'employee', 'portal' or 'public' (required).
                selection_vals = [(False, '')]
                if app.xml_id == 'base.module_category_user_type':
                    selection_vals = []
                field_name = name_selection_groups(gs.ids)
                if allfields and field_name not in allfields:
                    continue
                # selection group field
                tips = []
                if app.description:
                    tips.append(app.description + '\n')
                tips.extend('%s: %s' % (g.name, g.comment) for g in gs if g.comment)
                res[field_name] = {
                    'type': 'selection',
                    'string': app.name or _('Other'),
                    'selection': selection_vals + [(g.id, g.name) for g in gs],
                    'help': '\n'.join(tips),
                    'exportable': False,
                    'selectable': False,
                }
            else:
                # boolean group fields
                for g in gs:
                    field_name = name_boolean_group(g.id)
                    if allfields and field_name not in allfields:
                        continue
                    res[field_name] = {
                        'type': 'boolean',
                        'string': g.name,
                        'help': g.comment,
                        'exportable': False,
                        'selectable': False,
                    }
        # add self readable/writable fields
        missing = set(self.SELF_WRITEABLE_FIELDS).union(self.SELF_READABLE_FIELDS).difference(res.keys())
        if allfields:
            missing = missing.intersection(allfields)
        if missing:
            res.update({
                key: dict(values, readonly=key not in self.SELF_WRITEABLE_FIELDS, searchable=False)
                for key, values in super(UsersView, self.sudo()).fields_get(missing, attributes).items()
            })
        return res

class CheckIdentity(models.TransientModel):
    """ Wizard used to re-check the user's credentials (password) and eventually
    revoke access to his account to every device he has an active session on.

    Might be useful before the more security-sensitive operations, users might be
    leaving their computer unlocked & unattended. Re-checking credentials mitigates
    some of the risk of a third party using such an unattended device to manipulate
    the account.
    """
    _name = 'res.users.identitycheck'
    _description = "Password Check Wizard"

    request = fields.Char(readonly=True, groups=fields.NO_ACCESS)
    password = fields.Char()

    def _check_identity(self):
        try:
            self.create_uid._check_credentials(self.password, {'interactive': True})
        except AccessDenied:
            raise UserError(_("Incorrect Password, try again or click on Forgot Password to reset your password."))

    def run_check(self):
        assert request, "This method can only be accessed over HTTP"
        self._check_identity()
        self.password = False

        request.session['identity-check-last'] = time.time()
        ctx, model, ids, method = json.loads(self.sudo().request)
        method = getattr(self.env(context=ctx)[model].browse(ids), method)
        assert getattr(method, '__has_check_identity', False)
        return method()

    def revoke_all_devices(self):
        self._check_identity()
        self.env.user._change_password(self.password)
        self.sudo().unlink()
        return {'type': 'ir.actions.client', 'tag': 'reload'}

#----------------------------------------------------------
# change password wizard
#----------------------------------------------------------

class ChangePasswordWizard(models.TransientModel):
    """ A wizard to manage the change of users' passwords. """
    _name = "change.password.wizard"
    _description = "Change Password Wizard"
    _transient_max_hours = 0.2

    def _default_user_ids(self):
        user_ids = self._context.get('active_model') == 'res.users' and self._context.get('active_ids') or []
        return [
            Command.create({'user_id': user.id, 'user_login': user.login})
            for user in self.env['res.users'].browse(user_ids)
        ]

    user_ids = fields.One2many('change.password.user', 'wizard_id', string='Users', default=_default_user_ids)

    def change_password_button(self):
        self.ensure_one()
        self.user_ids.change_password_button()
        if self.env.user in self.user_ids.user_id:
            return {'type': 'ir.actions.client', 'tag': 'reload'}
        return {'type': 'ir.actions.act_window_close'}


class ChangePasswordUser(models.TransientModel):
    """ A model to configure users in the change password wizard. """
    _name = 'change.password.user'
    _description = 'User, Change Password Wizard'

    wizard_id = fields.Many2one('change.password.wizard', string='Wizard', required=True, ondelete='cascade')
    user_id = fields.Many2one('res.users', string='User', required=True, ondelete='cascade')
    user_login = fields.Char(string='User Login', readonly=True)
    new_passwd = fields.Char(string='New Password', default='')

    def change_password_button(self):
        for line in self:
            if line.new_passwd:
                line.user_id._change_password(line.new_passwd)
        # don't keep temporary passwords in the database longer than necessary
        self.write({'new_passwd': False})

class ChangePasswordOwn(models.TransientModel):
    _name = "change.password.own"
    _description = "User, change own password wizard"
    _transient_max_hours = 0.1

    new_password = fields.Char(string="New Password")
    confirm_password = fields.Char(string="New Password (Confirmation)")

    @api.constrains('new_password', 'confirm_password')
    def _check_password_confirmation(self):
        if self.confirm_password != self.new_password:
            raise ValidationError(_("The new password and its confirmation must be identical."))

    @check_identity
    def change_password(self):
        self.env.user._change_password(self.new_password)
        self.unlink()
        # reload to avoid a session expired error
        # would be great to update the session id in-place, but it seems dicey
        return {'type': 'ir.actions.client', 'tag': 'reload'}

# API keys support
API_KEY_SIZE = 20 # in bytes
INDEX_SIZE = 8 # in hex digits, so 4 bytes, or 20% of the key
KEY_CRYPT_CONTEXT = CryptContext(
    # default is 29000 rounds which is 25~50ms, which is probably unnecessary
    # given in this case all the keys are completely random data: dictionary
    # attacks on API keys isn't much of a concern
    ['pbkdf2_sha512'], pbkdf2_sha512__rounds=6000,
)
class APIKeysUser(models.Model):
    _inherit = 'res.users'

    api_key_ids = fields.One2many('res.users.apikeys', 'user_id', string="API Keys")

    @property
    def SELF_READABLE_FIELDS(self):
        return super().SELF_READABLE_FIELDS + ['api_key_ids']

    @property
    def SELF_WRITEABLE_FIELDS(self):
        return super().SELF_WRITEABLE_FIELDS + ['api_key_ids']

    def _rpc_api_keys_only(self):
        """ To be overridden if RPC access needs to be restricted to API keys, e.g. for 2FA """
        return False

    def _check_credentials(self, password, user_agent_env):
        user_agent_env = user_agent_env or {}
        if user_agent_env.get('interactive', True):
            if 'interactive' not in user_agent_env:
                _logger.warning(
                    "_check_credentials without 'interactive' env key, assuming interactive login. \
                    Check calls and overrides to ensure the 'interactive' key is properly set in \
                    all _check_credentials environments"
                )
            return super()._check_credentials(password, user_agent_env)

        if not self.env.user._rpc_api_keys_only():
            try:
                return super()._check_credentials(password, user_agent_env)
            except AccessDenied:
                pass

        # 'rpc' scope does not really exist, we basically require a global key (scope NULL)
        if self.env['res.users.apikeys']._check_credentials(scope='rpc', key=password) == self.env.uid:
            return

        raise AccessDenied()

    @check_identity
    def api_key_wizard(self):
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'res.users.apikeys.description',
            'name': 'New API Key',
            'target': 'new',
            'views': [(False, 'form')],
        }

class APIKeys(models.Model):
    _name = 'res.users.apikeys'
    _description = 'Users API Keys'
    _auto = False # so we can have a secret column
    _allow_sudo_commands = False

    name = fields.Char("Description", required=True, readonly=True)
    user_id = fields.Many2one('res.users', index=True, required=True, readonly=True, ondelete="cascade")
    scope = fields.Char("Scope", readonly=True)
    create_date = fields.Datetime("Creation Date", readonly=True)

    def init(self):
        table = sql.Identifier(self._table)
        self.env.cr.execute(sql.SQL("""
        CREATE TABLE IF NOT EXISTS {table} (
            id serial primary key,
            name varchar not null,
            user_id integer not null REFERENCES res_users(id) ON DELETE CASCADE,
            scope varchar,
            index varchar({index_size}) not null CHECK (char_length(index) = {index_size}),
            key varchar not null,
            create_date timestamp without time zone DEFAULT (now() at time zone 'utc')
        )
        """).format(table=table, index_size=sql.Placeholder('index_size')), {
            'index_size': INDEX_SIZE
        })

        index_name = self._table + "_user_id_index_idx"
        if len(index_name) > 63:
            # unique determinist index name
            index_name = self._table[:50] + "_idx_" + sha256(self._table.encode()).hexdigest()[:8]
        self.env.cr.execute(sql.SQL("""
        CREATE INDEX IF NOT EXISTS {index_name} ON {table} (user_id, index);
        """).format(
            table=table,
            index_name=sql.Identifier(index_name)
        ))

    @check_identity
    def remove(self):
        return self._remove()

    def _remove(self):
        """Use the remove() method to remove an API Key. This method implement logic,
        but won't check the identity (mainly used to remove trusted devices)"""
        if not self:
            return {'type': 'ir.actions.act_window_close'}
        if self.env.is_system() or self.mapped('user_id') == self.env.user:
            ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
            _logger.info("API key(s) removed: scope: <%s> for '%s' (#%s) from %s",
               self.mapped('scope'), self.env.user.login, self.env.uid, ip)
            self.sudo().unlink()
            return {'type': 'ir.actions.act_window_close'}
        raise AccessError(_("You can not remove API keys unless they're yours or you are a system user"))

    def _check_credentials(self, *, scope, key):
        assert scope, "scope is required"
        index = key[:INDEX_SIZE]
        self.env.cr.execute('''
            SELECT user_id, key
            FROM {} INNER JOIN res_users u ON (u.id = user_id)
            WHERE u.active and index = %s AND (scope IS NULL OR scope = %s)
        '''.format(self._table),
        [index, scope])
        for user_id, current_key in self.env.cr.fetchall():
            if KEY_CRYPT_CONTEXT.verify(key, current_key):
                return user_id

    def _generate(self, scope, name):
        """Generates an api key.
        :param str scope: the scope of the key. If None, the key will give access to any rpc.
        :param str name: the name of the key, mainly intended to be displayed in the UI.
        :return: str: the key.

        """
        # no need to clear the LRU when *adding* a key, only when removing
        k = binascii.hexlify(os.urandom(API_KEY_SIZE)).decode()
        self.env.cr.execute("""
        INSERT INTO {table} (name, user_id, scope, key, index)
        VALUES (%s, %s, %s, %s, %s)
        RETURNING id
        """.format(table=self._table),
        [name, self.env.user.id, scope, KEY_CRYPT_CONTEXT.hash(k), k[:INDEX_SIZE]])

        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'
        _logger.info("%s generated: scope: <%s> for '%s' (#%s) from %s",
            self._description, scope, self.env.user.login, self.env.uid, ip)

        return k

class APIKeyDescription(models.TransientModel):
    _name = 'res.users.apikeys.description'
    _description = 'API Key Description'

    name = fields.Char("Description", required=True)

    @check_identity
    def make_key(self):
        # only create keys for users who can delete their keys
        self.check_access_make_key()

        description = self.sudo()
        k = self.env['res.users.apikeys']._generate(None, self.sudo().name)
        description.unlink()

        return {
            'type': 'ir.actions.act_window',
            'res_model': 'res.users.apikeys.show',
            'name': _('API Key Ready'),
            'views': [(False, 'form')],
            'target': 'new',
            'context': {
                'default_key': k,
            }
        }

    def check_access_make_key(self):
        if not self.user_has_groups('base.group_user'):
            raise AccessError(_("Only internal users can create API keys"))

class APIKeyShow(models.AbstractModel):
    _name = 'res.users.apikeys.show'
    _description = 'Show API Key'

    # the field 'id' is necessary for the onchange that returns the value of 'key'
    id = fields.Id()
    key = fields.Char(readonly=True)

```

  File: models/res_users_deletion.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import logging
import threading


from odoo import api, fields, models

_logger = logging.getLogger(__name__)


class ResUsersDeletion(models.Model):
    """User deletion requests.

    Those requests are logged in a different model to keep a trace of this action and the
    deletion is done in a CRON. Indeed, removing a user can be a heavy operation on
    large database (because of create_uid, write_uid on each model, which are not always
    indexed). This model just remove the users added in the deletion queue, remaining code
    must deal with other consideration (archiving, blacklist email...).
    """

    _name = 'res.users.deletion'
    _description = 'Users Deletion Request'
    _rec_name = 'user_id'

    # Integer field because the related user might be deleted from the database
    user_id = fields.Many2one('res.users', string='User', ondelete='set null')
    user_id_int = fields.Integer('User Id', compute='_compute_user_id_int', store=True)
    state = fields.Selection([('todo', 'To Do'), ('done', 'Done'), ('fail', 'Failed')],
                             string='State', required=True, default='todo')

    @api.depends('user_id')
    def _compute_user_id_int(self):
        for user_deletion in self:
            if user_deletion.user_id:
                user_deletion.user_id_int = user_deletion.user_id.id

    @api.model
    def _gc_portal_users(self, batch_size=10):
        """Remove the portal users that asked to deactivate their account.

        (see <res.users>::_deactivate_portal_user)

        Removing a user can be an heavy operation on large database (because of
        create_uid, write_uid on each models, which are not always indexed). Because of
        that, this operation is done in a CRON.
        """
        delete_requests = self.search([("state", "=", "todo")])

        # filter the requests related to a deleted user
        done_requests = delete_requests.filtered(lambda request: not request.user_id)
        done_requests.state = "done"

        todo_requests = delete_requests - done_requests
        batch_requests = todo_requests[:batch_size]

        auto_commit = not getattr(threading.current_thread(), "testing", False)

        for delete_request in batch_requests:
            user = delete_request.user_id
            user_name = user.name
            requester_name = delete_request.create_uid.name
            # Step 1: Delete User
            try:
                self.env.cr.execute("SAVEPOINT delete_user")
                partner = user.partner_id
                user.unlink()
                _logger.info("User #%i %r, deleted. Original request from %r.",
                             user.id, user_name, delete_request.create_uid.name)
                self.env.cr.execute("RELEASE SAVEPOINT delete_user")
                delete_request.state = 'done'
            except Exception as e:
                _logger.error("User #%i %r could not be deleted. Original request from %r. Related error: %s",
                             user.id, user_name, requester_name, e)
                self.env.cr.execute("ROLLBACK TO SAVEPOINT delete_user")
                delete_request.state = "fail"
            # make sure we never rollback the work we've done, this can take a long time
            if auto_commit:
                self.env.cr.commit()
            if delete_request.state == "fail":
                continue

            # Step 2: Delete Linked Partner
            #         Could be impossible if the partner is linked to a SO for example
            try:
                self.env.cr.execute("SAVEPOINT delete_partner")
                partner.unlink()
                _logger.info("Partner #%i %r, deleted. Original request from %r.",
                             partner.id, user_name, delete_request.create_uid.name)
                self.env.cr.execute("RELEASE SAVEPOINT delete_partner")
            except Exception as e:
                _logger.warning("Partner #%i %r could not be deleted. Original request from %r. Related error: %s",
                             partner.id, user_name, requester_name, e)
                self.env.cr.execute("ROLLBACK TO SAVEPOINT delete_partner")
            # make sure we never rollback the work we've done, this can take a long time
            if auto_commit:
                self.env.cr.commit()
        if len(todo_requests) > batch_size:
            self.env.ref("base.ir_cron_res_users_deletion")._trigger()

```

  File: models/res_users_settings.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models


class ResUsersSettings(models.Model):
    _name = 'res.users.settings'
    _description = 'User Settings'
    _rec_name = 'user_id'

    user_id = fields.Many2one('res.users', string="User", required=True, readonly=True, ondelete='cascade')

    _sql_constraints = [
        ('unique_user_id', 'UNIQUE(user_id)', 'One user should only have one user settings.')
    ]

    @api.model
    def _find_or_create_for_user(self, user):
        settings = user.sudo().res_users_settings_ids
        if not settings:
            settings = self.sudo().create({'user_id': user.id})
        return settings

    def _res_users_settings_format(self, fields_to_format=None):
        self.ensure_one()
        if not fields_to_format:
            fields_to_format = [name for name, field in self._fields.items() if name == 'id' or not field.automatic]
        res = self._format_settings(fields_to_format)
        return res

    def _format_settings(self, fields_to_format):
        res = self._read_format(fnames=fields_to_format)[0]
        if 'user_id' in fields_to_format:
            res = self._read_format(fnames=fields_to_format)[0]
            res['user_id'] = {'id': self.user_id.id}
        return res

    def set_res_users_settings(self, new_settings):
        self.ensure_one()
        changed_settings = {}
        for setting in new_settings.keys():
            if setting in self._fields and new_settings[setting] != self[setting]:
                changed_settings[setting] = new_settings[setting]
        self.write(changed_settings)
        formated = self._res_users_settings_format([*changed_settings.keys(), 'id'])
        return formated

```

Views:
  File: views/base_menus.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>

      <!-- Top menu item -->
      <menuitem name="Settings"
          id="menu_administration"
          web_icon="base,static/description/settings.png"
          sequence="550"
          groups="base.group_erp_manager">
          <menuitem id="menu_administration_shortcut" name="Custom Shortcuts" sequence="50"/>
          <!-- FYI The group no_one on 'User & Companies' and 'Translations' is a FP/APR request -->
          <menuitem id="menu_users" name="Users &amp; Companies" sequence="1"/>
          <menuitem id="menu_translation" name="Translations" sequence="2" groups="base.group_no_one">
              <menuitem id="menu_translation_app" name="Application Terms" sequence="4" groups="base.group_no_one"/>
              <menuitem id="menu_translation_export" name="Import / Export" sequence="3" groups="base.group_no_one"/>
          </menuitem>

          <menuitem id="menu_config" name="General Settings" sequence='3'/>

          <menuitem id="menu_custom" name="Technical" sequence="110" groups="base.group_no_one">
              <menuitem id="next_id_2" name="User Interface"/>
              <menuitem id="menu_email" name="Email" sequence="1"/>
              <menuitem id="next_id_9" name="Database Structure"/>
              <menuitem id="menu_automation" name="Automation"/>
              <menuitem id="menu_security" name="Security" sequence="25"/>
              <menuitem id="menu_ir_property" name="Parameters" sequence="24"/>
          </menuitem>
      </menuitem>

      <menuitem id="menu_management" name="Apps" sequence="500" web_icon="base,static/description/modules.png" groups="base.group_system"/>
      <menuitem id="base.menu_tests" name="Tests" sequence="1000" web_icon="test_exceptions,static/description/icon.png"/>

      <record model="ir.ui.menu" id="base.menu_administration">
          <field name="groups_id" eval="[Command.set([ref('group_system'), ref('group_erp_manager')])]"/>
      </record>

      <record id="action_client_base_menu" model="ir.actions.client">
          <field name="name">Open Settings Menu</field>
          <field name="tag">reload</field>
          <field name="params" eval="{'menu_id': ref('base.menu_administration')}"/>
      </record>
      <record id="open_menu" model="ir.actions.todo">
          <field name="name">Open Menu</field>
          <field name="action_id" ref="action_client_base_menu"/>
          <field name="sequence">100</field>
          <field name="state">done</field>
      </record>
      <record id="action_open_website" model="ir.actions.act_url">
          <field name="name">Home Menu</field>
          <field name="target">self</field>
          <field name="url">/web</field>
      </record>
</odoo>

```

  File: views/decimal_precision_views.xml
  Content:
```
<?xml version="1.0"?>
<odoo>
    <data>

        <record model="ir.ui.view" id="view_decimal_precision_form">
            <field name="name">Decimal Precision</field>
            <field name="model">decimal.precision</field>
            <field name="arch" type="xml">
                <form string="Decimal Precision">
                    <sheet>
                        <group col="4">
                            <field name="name" readonly="id"/>
                            <field name="digits"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>
        <record model="ir.ui.view" id="view_decimal_precision_tree">
            <field name="name">Decimal Precision List</field>
            <field name="model">decimal.precision</field>
            <field name="arch" type="xml">
                <tree string="Decimal Precision">
                    <field name="name"/>
                    <field name="digits"/>
                </tree>
            </field>
        </record>
        <record model="ir.actions.act_window" id="action_decimal_precision_form">
                <field name="name">Decimal Accuracy</field>
                <field name="res_model">decimal.precision</field>
        </record>
        <menuitem
            parent="base.next_id_9"
            id="menu_decimal_precision_form"
            action="action_decimal_precision_form"/>

    </data>
</odoo>

```

  File: views/ir_actions_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>

        <!-- ir.actions -->

        <record id="action_view" model="ir.ui.view">
            <field name="name">ir.actions.actions</field>
            <field name="model">ir.actions.actions</field>
            <field name="arch" type="xml">
                <form string="Action">
                <sheet>
                    <group>
                        <field name="name"/>
                        <field name="type"/>
                    </group>
                </sheet>
                </form>
            </field>
        </record>
        <record id="action_view_tree" model="ir.ui.view">
            <field name="name">ir.actions.actions.tree</field>
            <field name="model">ir.actions.actions</field>
            <field name="arch" type="xml">
                <tree string="Action">
                    <field name="name"/>
                    <field name="type"/>
                </tree>
            </field>
        </record>
        <record id="action_view_search" model="ir.ui.view">
            <field name="name">ir.actions.actions.search</field>
            <field name="model">ir.actions.actions</field>
            <field name="arch" type="xml">
                <search string="Action">
                    <field name="name" filter_domain="['|', ('name','ilike',self), ('type','ilike',self)]" string="Action"/>
                    <group>
                        <filter string="Action Type" name="type" context="{'group_by':'type'}"/>
                        <filter string="Binding Type" name="binding_type" context="{'group_by':'binding_type'}"/>
                        <filter string="Binding Model" name="binding_model_id" context="{'group_by':'binding_model_id'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="ir_sequence_actions" model="ir.actions.act_window">
            <field name="name">Actions</field>
            <field name="res_model">ir.actions.actions</field>
            <field name="view_id" ref="action_view_tree"/>
            <field name="search_view_id" ref="action_view_search"/>
        </record>
        <menuitem id="next_id_6" name="Actions" parent="base.menu_custom" sequence="5"/>
        <menuitem action="ir_sequence_actions" id="menu_ir_sequence_actions" parent="next_id_6"/>

        <!-- ir.actions.report -->

        <record id="act_report_xml_view" model="ir.ui.view">
            <field name="name">ir.actions.report</field>
            <field name="model">ir.actions.report</field>
            <field name="arch" type="xml">
                <form string="Report">
                    <field name="binding_model_id" invisible="1"/>
                    <sheet>
                        <div class="oe_button_box" name="button_box">
                            <button name="create_action" type="object"
                                    invisible="binding_model_id" icon="fa-plus-square"
                                    help="Display an option on related documents to print this report" class="oe_stat_button">
                                    <div class="o_field_widget o_stat_info">
                                        <span class="o_stat_text">Add to the 'Print' menu</span>
                                    </div>
                            </button>
                            <button name="unlink_action" type="object"
                                    invisible="not binding_model_id" icon="fa-minus-square"
                                    help="Remove the contextual action related to this report" class="oe_stat_button">
                                    <div class="o_field_widget o_stat_info">
                                        <span class="o_stat_text">Remove from the 'Print' menu</span>
                                    </div>
                            </button>
                            <button name="associated_view" type="object"
                                    invisible="report_type not in ['qweb-pdf', 'qweb-html', 'qweb-text']" icon='fa-code'
                                    class="oe_stat_button">
                                    <div class="o_field_widget o_stat_info">
                                        <span class="o_stat_text">Qweb Views</span>
                                    </div>
                            </button>
                        </div>
                        <group>
                            <group>
                                <field name="name"/>
                                <field name="report_type"/>
                                <field name="paperformat_id"
                                       invisible="report_type != 'qweb-pdf'"/>
                            </group>
                            <group>
                                <field name="model"/>
                                <field name="report_name"/>
                                <field name="print_report_name" />
                            </group>
                        </group>
                        <notebook>
                            <page name="security" string="Visibility">
                                <field name="groups_id"/>
                            </page>
                            <page name='advanced' string="Advanced Properties">
                                <group>
                                    <field name="attachment_use"/>
                                    <field name="attachment"/>
                                </group>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="act_report_xml_view_tree" model="ir.ui.view">
            <field name="name">ir.actions.report.tree</field>
            <field name="model">ir.actions.report</field>
            <field name="arch" type="xml">
                <tree string="Report xml">
                    <field name="name"/>
                    <field name="model"/>
                    <field name="type"/>
                    <field name="report_name"/>
                    <field name="report_type"/>
                    <field name="attachment"/>
                </tree>
            </field>
        </record>
        <record id="act_report_xml_search_view" model="ir.ui.view">
            <field name="name">ir.actions.report.search</field>
            <field name="model">ir.actions.report</field>
            <field name="arch" type="xml">
                <search string="Report Xml">
                    <field name="name"
                        filter_domain="['|', '|', '|', '|', ('name','ilike',self), ('model','ilike',self), ('type','ilike',self), ('report_name','ilike',self), ('report_type','ilike',self)]"
                        string="Report"/>
                    <field name="model" filter_domain="[('model','=', self)]" string="Model"/>
                    <group expand="0" string="Group By" colspan="4">
                        <filter string="Report Type" name="report_type" domain="[]" context="{'group_by':'report_type'}"/>
                        <filter string="Report Model" name="report_model" domain="[]" context="{'group_by':'model'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="ir_action_report" model="ir.actions.act_window">
            <field name="name">Reports</field>
            <field name="res_model">ir.actions.report</field>
            <field name="view_id" ref="act_report_xml_view_tree"/>
            <field name="search_view_id" ref="act_report_xml_search_view"/>
        </record>
        <menuitem action="ir_action_report" id="menu_ir_action_report" parent="base.next_id_6"/>

        <!-- ir.actions.client -->

        <record id="view_client_action_form" model="ir.ui.view">
            <field name="name">ir.actions.client.form</field>
            <field name="model">ir.actions.client</field>
            <field name="arch" type="xml">
                <form string="Client Action">
                    <sheet>
                        <group>
                            <group name="main_details">
                                <field name="name"/>
                                <field name="xml_id" string="External ID"/>
                                <field name="binding_type"/>
                                <field name="tag"/>
                            </group>
                            <group name="action_details">
                                <field name="type" readonly="1"/>
                                <field name="target"/>
                                <field name="context"/>
                            </group>
                        </group>
                        <group name="help" string="Help">
                            <field name="help" colspan="2" nolabel="1" class="oe-bordered-editor"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- ir.actions.act_window -->

        <record id="view_window_action_tree" model="ir.ui.view">
            <field name="name">ir.actions.windows.tree</field>
            <field name="model">ir.actions.act_window</field>
            <field name="arch" type="xml">
                <tree string="Open Window">
                    <field name="name"/>
                    <field name="res_model"/>
                    <field name="view_id"/>
                    <field name="domain"/>
                    <field name="context"/>
                </tree>
            </field>
        </record>
        <record id="view_window_action_form" model="ir.ui.view">
            <field name="name">ir.actions.windows.form</field>
            <field name="model">ir.actions.act_window</field>
            <field name="arch" type="xml">
                <form string="Open a Window">
                <sheet>
                    <group>
                        <group name="main_details">
                            <field name="name"/>
                            <field name="xml_id" string="External ID"/>
                            <field name="res_model" string="Object"/>
                        </group>
                        <group name="action_details">
                            <field name="usage"/>
                            <field name="type" readonly="1"/>
                            <field name="target"/>
                        </group>
                    </group>
                    <notebook>
                        <page name="general_settings" string="General Settings">
                            <group>
                                <group name="views" string="Views">
                                    <field name="view_mode"/>
                                    <field name="mobile_view_mode"/>
                                    <field name="view_id"/>
                                    <field name="search_view_id"/>
                                </group>
                                <group name="filters" string="Filters">
                                    <field name="domain"/>
                                    <field name="context"/>
                                    <field name="limit"/>
                                    <field name="filter"/>
                                </group>
                            </group>
                            <group name="help" string="Help">
                                <field colspan="2" name="help" options="{'codeview': true}" nolabel="1" class="oe-bordered-editor"/>
                            </group>
                            <group name="views_tree" string="Views">
                                <field colspan="2" name="view_ids" nolabel="1">
                                    <form string="Views">
                                        <group>
                                            <field name="sequence"/>
                                            <field name="view_mode"/>
                                            <field domain="[('type', '=', view_mode)]" name="view_id"/>
                                        </group>
                                    </form>
                                    <tree string="Views">
                                        <field name="sequence" widget="handle"/>
                                        <field name="view_mode"/>
                                        <field name="view_id"/>
                                    </tree>
                                </field>
                            </group>
                        </page>
                        <page string="Visibility" name="security">
                            <field name="groups_id"/>
                        </page>
                    </notebook>
                </sheet>
                </form>
            </field>
        </record>
        <record id="view_window_action_search" model="ir.ui.view">
            <field name="name">ir.actions.windows.search</field>
            <field name="model">ir.actions.act_window</field>
            <field name="arch" type="xml">
                <search string="Open a Window">
                    <field name="name" filter_domain="['|', ('name','ilike',self), ('res_model','ilike',self)]" string="Action"/>
                    <group>
                        <filter string="Binding Model" name="binding_model_id" context="{'group_by':'binding_model_id'}"/>
                        <filter string="Target Window" name="target" context="{'group_by':'target'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="ir_action_window" model="ir.actions.act_window">
            <field name="name">Window Actions</field>
            <field name="res_model">ir.actions.act_window</field>
            <field name="search_view_id" ref="view_window_action_search"/>
        </record>
        <record id="ir_action_window_view1" model="ir.actions.act_window.view">
            <field eval="1" name="sequence"/>
            <field name="view_mode">tree</field>
            <field name="view_id" ref="view_window_action_tree"/>
            <field name="act_window_id" ref="ir_action_window"/>
        </record>
        <record id="ir_action_window_view2" model="ir.actions.act_window.view">
            <field eval="2" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_window_action_form"/>
            <field name="act_window_id" ref="ir_action_window"/>
        </record>
        <menuitem action="ir_action_window" id="menu_ir_action_window" parent="base.next_id_6"/>

        <record id="view_client_action_tree" model="ir.ui.view">
            <field name="name">Client Actions</field>
            <field name="model">ir.actions.client</field>
            <field name="arch" type="xml">
                <tree string="Client Actions">
                    <field name="name"/>
                    <field name="tag"/>
                </tree>
            </field>
        </record>

        <record id="ir_client_actions_report" model="ir.actions.act_window">
            <field name="name">Client Actions</field>
            <field name="res_model">ir.actions.client</field>
            <field name="view_id" ref="view_client_action_tree"/>
        </record>
        <menuitem action="ir_client_actions_report" id="menu_ir_client_actions_report" parent="base.next_id_6"/>

        <!-- ir.actions.server -->

        <record id="view_server_action_form" model="ir.ui.view">
            <field name="name">Server Action</field>
            <field name="model">ir.actions.server</field>
            <field name="arch" type="xml">
                <form string="Server Action">
                    <header>
                        <field name="binding_model_id" invisible="1"/>
                        <button name="create_action" string="Create Contextual Action" type="object"
                                class="btn-primary"
                                invisible="binding_model_id"
                                help="Display an option in the 'More' top-menu in order to run this action."/>
                        <button name="unlink_action" string="Remove Contextual Action" type="object"
                                invisible="not binding_model_id"
                                help="Remove 'More' top-menu contextual action related to this action"/>
                        <button name="run" string="Run" type="object"
                                class="btn-primary"
                                invisible="model_name != 'ir.actions.server' or state != 'code'"
                                help="Run this action manually."/>
                    </header>
                    <sheet>
                        <h1 class="oe_title">
                            <field name="name" placeholder="e.g. Mass archive contacts"/>
                        </h1>
                        <div class="d-flex flex-column">
                            <label for="state"/>
                            <field name="state" widget="selection_badge" options="{'size': 'sm'}"/>
                        </div>
                        <group string="Technical Settings" groups="base.group_no_one">
                            <group>
                                <field name="model_id" options="{'no_create': True, 'no_open': True}" />
                                <field name="groups_id" widget="many2many_tags" />
                            </group>
                        </group>
                        <separator string="Action Details" groups="base.group_no_one" />
                        <div class="d-flex flex-row flex-wrap gap-2" invisible="state != 'object_write'">
                            <field name="evaluation_type" class="oe_inline"/>
                            <field name="update_path" widget="DynamicModelFieldSelectorChar" class="oe_inline" options="{'model': 'model_name'}"/>
                            <field name="update_field_id" invisible="1"/>
                            <field name="value_field_to_show" invisible="1"/>
                            <field name="update_related_model_id" invisible="1"/>
                            <field name="update_field_type" invisible="1"/>
                            <span invisible="evaluation_type != 'value' or not update_field_type == 'many2many'">by</span>
                            <field name="update_m2m_operation" class="oe_inline" invisible="evaluation_type != 'value' or not update_field_type == 'many2many'" required="update_field_type == 'many2many'"/>
                            <span invisible="evaluation_type != 'value' or update_field_type == 'many2many'">to</span>
                            <field name="value" class="oe_inline" placeholder="Set a value..." invisible="update_field_id == False or value_field_to_show != 'value' or evaluation_type != 'value'" string="Custom Value"/>
                            <field name="resource_ref" class="oe_inline" placeholder="Choose a value..." string="Custom Value" options="{'model_field': 'update_related_model_id', 'no_create': True, 'no_open': True}" invisible=" update_field_id == False or value_field_to_show != 'resource_ref' or evaluation_type == 'equation' or update_m2m_operation == 'clear'"/>
                            <field name="selection_value" class="oe_inline" placeholder="Choose a value..." options="{'no_create': True, 'no_open': True}" invisible=" update_field_id == False or value_field_to_show != 'selection_value' or evaluation_type == 'equation'"/>
                            <field name="update_boolean_value" class="oe_inline" invisible="evaluation_type != 'value' or value_field_to_show != 'update_boolean_value'" required="value_field_to_show == 'update_boolean_value'"/>
                            <span invisible="update_field_id != False or evaluation_type == 'equation'" class="text-muted">Set a value...</span>
                            <span invisible="evaluation_type != 'equation'">
                                to this Python expression:
                            </span>
                            <div class="w-100 d-flex flex-row gap-3" invisible="evaluation_type != 'equation'">
                                <field name="value" class="w-50" widget="code" options="{'mode': 'python'}" string="Expression"/>
                                <div class="w-50 opacity-75">
                                    <span colspan="2" class="text-muted"> Available variables: </span>
                                        <ul colspan="2" class="text-muted">
                                            <li><code>env</code>: environment on which the action is triggered</li>
                                            <li><code>model</code>: model of the record on which the action is triggered; is a void recordset</li>
                                            <li><code>record</code>: record on which the action is triggered</li>
                                            <li><code>records</code>: recordset of all records on which the action is triggered in multi mode</li>
                                            <li><code>time</code>, <code>datetime</code>, <code>dateutil</code>, <code>timezone</code>: useful Python libraries</li>
                                            <li><code>float_compare()</code>: utility function to compare floats based on a specific precision</li>
                                        </ul>
                                </div>
                            </div>
                        </div>
                        <group name="action_wrapper">
                            <group name="action_content">
                                <field name="model_name" invisible="1"/>
                                <field name="available_model_ids" invisible="1"/>
                                <field name="model_id" options="{'no_create': True, 'no_open': True}" groups="!base.group_no_one" invisible="context.get('default_model_id')"
                                       domain="[('id', 'in', available_model_ids)]"/>

                                <field name="type" invisible="1"/>
                                <field name="crud_model_id"
                                    options="{'no_create': True, 'no_open': True}"
                                    invisible="state != 'object_create'"
                                    required="state == 'object_create'"/>
                                <field name="crud_model_name" invisible="1"/>
                                <field name="value" widget="char" string="Name" invisible="state != 'object_create'"
                                       help="The name of the record to create" placeholder="e.g. Follow-up"/>
                                <field name="link_field_id"
                                    domain="[('model_id', '=', model_id), ('relation', '=', crud_model_name),
                                    ('ttype', 'in', ['many2one', 'one2many', 'many2many'])]"
                                    placeholder="Select a field to link the record to"
                                    options="{'no_create': True, 'no_open': True}"
                                    invisible="state != 'object_create'"
                                    context="{'default_model_id': model_id, 'default_relation': crud_model_name}"/>
                                    <field name="webhook_url" string="URL" invisible="state != 'webhook'" placeholder="e.g. https://maker.ifttt.com/use/..."/>
                                    <field name="webhook_field_ids" string="Fields" invisible="state != 'webhook'" widget="many2many_tags" context="{'hide_model': 1}" domain="[('model_id', '=', model_id)]" placeholder="Select fields to include in the request..."/>
                                </group>
                                <group invisible="state != 'webhook'">
                                    <label for="webhook_sample_payload" />
                                    <field name="webhook_sample_payload" string="Sample Payload" nolabel="1" colspan="2" readonly="1" widget="code" options="{'mode': 'js'}" />
                                </group>
                        </group>
                        <field name="child_ids" domain="[('model_id', '=', model_id)]" invisible="state != 'multi'"/>
                        <p class="oe_grey" invisible="state != 'multi'">
                            If several child actions return an action, only the last one will be executed.
                            This may happen when having server actions executing code that returns an action, or server actions returning a client action.
                        </p>
                        <notebook invisible="state != 'code'">
                            <page string="Code">
                                <field name="code" invisible="state != 'code'" widget="code" options="{'mode': 'python'}" placeholder="Enter Python code here. Help about Python expression is available in the help tab of this document."/>
                            </page>
                            <page string="Help">
                                <p>The following variables can be used:</p>
                                <ul>
                                    <li><code>env</code>: environment on which the action is triggered</li>
                                    <li><code>model</code>: model of the record on which the action is triggered; is a void recordset</li>
                                    <li><code>record</code>: record on which the action is triggered; may be be void</li>
                                    <li><code>records</code>: recordset of all records on which the action is triggered in multi mode; may be void</li>
                                    <li><code>time</code>, <code>datetime</code>, <code>dateutil</code>, <code>timezone</code>: useful Python libraries</li>
                                    <li><code>float_compare()</code>: utility function to compare floats based on a specific precision</li>
                                    <li><code>log(message, level='info')</code>: logging function to record debug information in <code>ir.logging</code> table</li>
                                    <li><code>_logger.info(message)</code>: logger to emit messages in server logs</li>
                                    <li><code>UserError</code>: exception class for raising user-facing warning messages</li>
                                    <li><code>Command</code>: x2many commands namespace</li>
                                    <li>To return an action, assign: <code>action = {...}</code></li>
                                </ul>
                                <div >
                                    <p>Example of Python code:</p>
<pre style='white-space: pre-wrap'>partner_name = record.name + '_code'
env['res.partner'].create({'name': partner_name})
    </pre>
                                </div>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_server_action_tree" model="ir.ui.view">
            <field name="name">Server Actions</field>
            <field name="model">ir.actions.server</field>
            <field name="arch" type="xml">
                <tree string="Server Actions">
                    <field name="name"/>
                    <field name="state"/>
                    <field name="model_id"/>
                    <field name="usage"/>
                </tree>
            </field>
        </record>
        <record id="view_server_action_search" model="ir.ui.view">
            <field name="name">ir.actions.server.search</field>
            <field name="model">ir.actions.server</field>
            <field name="arch" type="xml">
                <search string="Server Actions">
                    <field name="name" string="Server Action"/>
                    <field name="model_id"/>
                    <field name="state"/>
                    <group expand="0" string="Group By" colspan="4" col="4">
                        <filter string="Action Type" name="action_type" domain="[]" context="{'group_by':'state'}"/>
                        <filter string="Model" name="model" domain="[]" context="{'group_by':'model_id'}"/>
                        <filter string="Usage" name="usage" domain="[]" context="{'group_by':'usage'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="action_server_action" model="ir.actions.act_window">
            <field name="name">Server Actions</field>
            <field name="res_model">ir.actions.server</field>
            <field name="view_mode">tree,form</field>
            <field name="view_id" ref="view_server_action_tree"/>
            <field name="search_view_id" ref="view_server_action_search"/>
            <field name="context">{'key':'server_action'}</field>
        </record>
        <menuitem action="action_server_action" id="menu_server_action" parent="base.next_id_6"/>

        <!-- ir.actions.todo -->

        <record id="ir_actions_todo_tree" model="ir.ui.view">
            <field name="model">ir.actions.todo</field>
            <field name="name">Config Wizard Steps</field>
            <field name="arch" type="xml">
                <tree string="Config Wizard Steps">
                    <field name="sequence" widget='handle'/>
                    <field name="action_id"/>
                    <field name="state" readonly="1"/>
                    <button name="action_launch" invisible="state != 'open'" string="Launch" type="object" icon="fa-cogs" help="Launch Configuration Wizard"/>
                    <button name="action_open" invisible="state != 'done'"
                            string="Todo" type="object" help="Set as Todo"
                            icon="fa-exchange"/>
                </tree>
            </field>
        </record>
        <record id="config_wizard_step_view_form" model="ir.ui.view">
            <field name="model">ir.actions.todo</field>
            <field name="name">Config Wizard Steps</field>
            <field name="arch" type="xml">
                <form string="Config Wizard Steps">
                  <header>
                        <button name="action_launch"
                            invisible="state != 'open'" string="Launch"
                            type="object" icon="fa-cogs" class="oe_highlight"
                            help="Launch Configuration Wizard"/>
                        <button name="action_open" invisible="state != 'done'"
                            string="Set as Todo" type="object"
                            icon="fa-exchange" class="oe_highlight"/>
                        <field name="state" widget="statusbar" statusbar_visible="open,done" nolabel="1" readonly="1" />
                  </header>
                  <sheet>
                    <group col="4">
                        <field name="action_id"/>
                        <field name="sequence"/>
                    </group>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="config_wizard_step_view_search" model="ir.ui.view">
            <field name="model">ir.actions.todo</field>
            <field name="name">ir.actions.todo.select</field>
            <field name="arch" type="xml">
                <search string="Search Actions">
                    <filter string="To Do" name="todo" domain="[('state','=','open')]" help="Wizards to be Launched"/>
                    <field name="action_id"/>
                    <field name="state"/>
                </search>
            </field>
        </record>
        <record id="act_ir_actions_todo_form" model="ir.actions.act_window">
            <field name="name">Configuration Wizards</field>
            <field name="res_model">ir.actions.todo</field>
            <field name="view_id" ref="ir_actions_todo_tree"/>
            <field name="help">The configuration wizards are used to help you configure a new instance of Odoo. They are launched during the installation of new modules, but you can choose to restart some wizards manually from this menu.</field>
        </record>
        <menuitem id="menu_ir_actions_todo_form" action="act_ir_actions_todo_form" parent="base.next_id_6"/>
        <record id="action_run_ir_action_todo" model="ir.actions.server">
            <field name="name">Config: Run Remaining Action Todo</field>
            <field name="model_id" ref="model_res_config"/>
            <field name="state">code</field>
            <field name="code">
config = model.next() or {}
if config.get('type') not in ('ir.actions.act_window_close',):
    action = config
</field>
        </record>

</odoo>

```

  File: views/ir_asset_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="asset_view_form" model="ir.ui.view">
        <field name="model">ir.asset</field>
        <field name="arch" type="xml">
            <form string="Assets">
                <sheet>
                    <group>
                        <group>
                            <field name="name"/>
                            <field name="bundle"/>
                            <field name="directive"/>
                            <field name="sequence"/>
                            <field name="active" widget="boolean_toggle"/>
                        </group>
                        <group>
                            <field name="target" invisible="directive != 'replace'"/>
                            <field name="path"/>
                        </group>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="asset_view_tree" model="ir.ui.view">
        <field name="model">ir.asset</field>
        <field name="arch" type="xml">
            <tree string="Assets">
                <field name="name"/>
                <field name="bundle"/>
                <field name="sequence"/>
                <field name="active"/>
            </tree>
        </field>
    </record>

    <record id="asset_view_search" model="ir.ui.view">
        <field name="model">ir.asset</field>
        <field name="arch" type="xml">
            <search string="Assets">
                <field name="name"/>
                <field name="bundle"/>
                <field name="directive"/>
                <field name="sequence"/>
                <field name="path"/>
                <filter string="Active" name="active" domain="[('active', '=', True)]"/>
            </search>
        </field>
    </record>

    <record id="action_asset" model="ir.actions.act_window">
        <field name="name">Assets</field>
        <field name="res_model">ir.asset</field>
        <field name="view_id" ref="asset_view_tree"/>
        <field name="context">{'search_default_active': 1}</field>
    </record>

    <menuitem action="action_asset" id="menu_action_asset" parent="base.next_id_9"/>
</odoo>

```

  File: views/ir_attachment_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- Attachment -->
        <record id="view_attachment_form" model="ir.ui.view">
            <field name="model">ir.attachment</field>
            <field name="arch" type="xml">
                <form string="Attachments">
                   <sheet>
                    <label for="name"/>
                    <h1>
                        <field name="name"/>
                    </h1>
                    <group>
                        <group class="w-100">
                            <field name="type"/>
                            <label for="datas" class="mt-1"/>
                            <field name="datas" nolabel="1" class="w-100" filename="name" invisible="type == 'url'"/>
                            <field name="url" widget="url" invisible="type == 'binary'"/>
                            <field name="mimetype" groups="base.group_no_one"/>
                        </group>
                        <group string="Attached To" groups="base.group_no_one">
                            <field name="res_model"/>
                            <field name="res_field"/>
                            <field name="res_id"/>
                            <field name="res_name"/>
                            <field name="company_id" groups="base.group_multi_company" options="{'no_create': True}"/>
                            <field name="public"/>
                        </group>
                        <group string="History" groups="base.group_no_one" invisible="not create_date">
                            <label for="create_uid" string="Creation"/>
                            <div name="creation_div">
                                <field name="create_uid" readonly="1" class="oe_inline"/> on
                                <field name="create_date" readonly="1" class="oe_inline"/>
                            </div>
                        </group>
                        <group name="description_group" string="Description" groups="base.group_no_one" colspan="4">
                            <field name="description" nolabel="1" colspan="2"/>
                        </group>
                        <group groups="base.group_no_one" string="Indexed Content" colspan="4">
                            <field name="index_content" nolabel="1" colspan="2"/>
                        </group>
                    </group>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="view_attachment_tree" model="ir.ui.view">
            <field name="model">ir.attachment</field>
            <field name="arch" type="xml">
                <tree string="Attachments">
                    <field name="name"/>
                    <field name="res_model"/>
                    <field name="res_field"/>
                    <field name="res_id"/>
                    <field name="type"/>
                    <field name="file_size"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <field name="create_uid"/>
                    <field name="create_date"/>
                </tree>
            </field>
        </record>
        <record id="view_attachment_search" model="ir.ui.view">
            <field name="model">ir.attachment</field>
            <field name="arch" type="xml">
                <search string="Attachments">
                    <field name="name" filter_domain="[('name','ilike',self)]" string="Attachment"/>
                    <field name="create_date"/>
                    <filter name="my_documents_filter"
                        string="My Document(s)"
                        domain="[('create_uid','=',uid)]"
                        help="Filter on my documents"/>
                    <filter name="url_filter" string="URL" domain="[('type', '=', 'url')]"/>
                    <filter name="binary_filter" string="Stored" domain="[('type', '=', 'binary')]"/>
                    <separator/>
                    <field name="create_uid" string="Created by"/>
                    <field name="type"/>
                    <group expand="0" string="Group By">
                        <filter name="owner" string="Owner" domain="[]" context="{'group_by':'create_uid'}"/>
                        <filter string="Type" name="type" domain="[]" context="{'group_by':'type'}" groups="base.group_no_one"/>
                        <filter string="Company" name="company" domain="[]" context="{'group_by':'company_id'}" groups="base.group_multi_company"/>
                        <filter string="Creation Date" name="creation_month" domain="[]" context="{'group_by':'create_date'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="action_attachment" model="ir.actions.act_window">
            <field name="name">Attachments</field>
            <field name="res_model">ir.attachment</field>
            <field name="view_id" eval="False"/>
            <field name="search_view_id" ref="view_attachment_search"/>
            <field name="help" type="html">
                <p class="o_view_nocontent_smiling_face">
                    Create a new document
                </p>
                <p>
                    Also you will find here all the related documents and download it by clicking on any individual document.
                </p>
            </field>
        </record>
        <menuitem action="action_attachment" id="menu_action_attachment" parent="base.next_id_9"/>

</odoo>

```

  File: views/ir_config_parameter_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <record model="ir.ui.view" id="view_ir_config_search">
            <field name="model">ir.config_parameter</field>
            <field name="arch" type="xml">
                <search string="System Properties">
                    <field name="key" string="Key"/>
                    <field name="value"/>
                </search>
            </field>
        </record>
        <record model="ir.ui.view" id="view_ir_config_list">
            <field name="model">ir.config_parameter</field>
            <field name="arch" type="xml">
                <tree string="System Parameters">
                    <field name="key"/>
                    <field name="value"/>
                </tree>
            </field>
        </record>
        <record model="ir.ui.view" id="view_ir_config_form">
            <field name="model">ir.config_parameter</field>
            <field name="arch" type="xml">
                <form string="System Parameters">
                  <sheet>
                    <group>
                        <field name="key"/>
                        <field name="value"/>
                    </group>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="ir_config_list_action" model="ir.actions.act_window">
            <field name="name">System Parameters</field>
            <field name="res_model">ir.config_parameter</field>
        </record>
        <menuitem id="ir_config_menu" name="System Parameters" parent="menu_ir_property" action="ir_config_list_action"/>
</odoo>

```

  File: views/ir_cron_trigger_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="ir_cron_trigger_view_form" model="ir.ui.view">
        <field name="name">ir.cron.trigger.view.form</field>
        <field name="model">ir.cron.trigger</field>
        <field name="arch" type="xml">
            <form string="Cron Trigger">
                <sheet>
                    <group>
                        <field name="cron_id"/>
                        <field name="call_at"/>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="ir_cron_trigger_view_tree" model="ir.ui.view">
        <field name="name">ir.cron.trigger.view.tree</field>
        <field name="model">ir.cron.trigger</field>
        <field name="arch" type="xml">
            <tree string="Cron Triggers">
                <field name="cron_id"/>
                <field name="call_at"/>
            </tree>
        </field>
    </record>

    <record id="ir_cron_trigger_view_search" model="ir.ui.view">
        <field name="name">ir.cron.trigger.view.search</field>
        <field name="model">ir.cron.trigger</field>
        <field name="arch" type="xml">
            <search string="Cron Triggers">
                <field name="cron_id"/>
                <field name="call_at"/>
            </search>
        </field>
    </record>

    <record id="ir_cron_trigger_action" model="ir.actions.act_window">
        <field name="name">Scheduled Actions Triggers</field>
        <field name="res_model">ir.cron.trigger</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="ir_cron_trigger_menu"
        action="ir_cron_trigger_action"
        parent="base.menu_automation"
        sequence="3"/>

</odoo>

```

  File: views/ir_cron_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- ir.cron -->
        <record id="ir_cron_view_form" model="ir.ui.view">
            <field name="name">ir.cron.view.form</field>
            <field name="model">ir.cron</field>
            <field name="mode">primary</field>
            <field name="inherit_id" ref="base.view_server_action_form"/>
            <field name="arch" type="xml">
                <xpath expr="//button[@name='create_action']" position="replace">
                    <button name="method_direct_trigger" type="object" string="Run Manually" class="oe_highlight" invisible="state != 'code'"/>
                </xpath>
                <xpath expr="//button[@name='unlink_action']" position="replace">
                </xpath>
                <xpath expr="//button[@name='run']" position="replace">
                </xpath>
                <xpath expr="//group[@name='action_content']" position="inside">
                    <field name="user_id"/>
                    <label for="interval_number" string="Execute Every"/>
                    <div>
                        <field name="interval_number" class="oe_inline"/>
                        <field name="interval_type" class="oe_inline"/>
                    </div>
                    <field name="active" widget="boolean_toggle"/>
                    <field name="nextcall"/>
                    <field name="numbercall"/>
                    <field name="priority"/>
                    <field name="doall"/>
                </xpath>
                <field name="state" position="attributes">
                    <attribute name="invisible">1</attribute>
                </field>
            </field>
        </record>

        <record id="ir_cron_view_tree" model="ir.ui.view">
            <field name="model">ir.cron</field>
            <field name="arch" type="xml">
                <tree string="Scheduled Actions" decoration-muted="(not active)">
                    <field name="priority"/>
                    <field name="name"/>
                    <field name="model_id"/>
                    <field name="nextcall"/>
                    <field name="interval_number"/>
                    <field name="interval_type"/>
                    <field name="numbercall"/>
                    <field name="user_id" column_invisible="True"/>
                    <field name="active"/>
                </tree>
            </field>
        </record>

        <record model="ir.ui.view" id="ir_cron_view_calendar">
            <field name="model">ir.cron</field>
            <field name="priority" eval="2"/>
            <field name="arch" type="xml">
                <calendar string="Scheduled Actions" date_start="nextcall" color="user_id">
                    <field name="name"/>
                    <field name="user_id" filters="1" invisible="1"/>
                </calendar>
            </field>
        </record>

        <record id="ir_cron_view_search" model="ir.ui.view">
            <field name="model">ir.cron</field>
            <field name="arch" type="xml">
                <search string="Scheduled Actions">
                    <field name="name" string="Scheduled Action"/>
                    <field name="user_id"/>
                    <field name="model_id"/>
                    <field name="nextcall"/>
                    <field name="active"/>
                    <separator/>
                    <filter string="All" name="all" domain="['|', ('active', '=', False), ('active', '=', True)]" />
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="User" name="user" domain="[]" context="{'group_by': 'user_id'}"/>
                        <filter string="Execution" name="execution" domain="[]" context="{'group_by': 'nextcall'}" />
                        <filter string="Model" name="groupby_model_id" domain="[]" context="{'group_by': 'model_id'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="ir_cron_act" model="ir.actions.act_window">
            <field name="name">Scheduled Actions</field>
            <field name="res_model">ir.cron</field>
            <field name="view_mode">tree,form,calendar</field>
            <field name="context">{'search_default_all': 1}</field>
            <field name="view_id" ref="ir_cron_view_tree"/>
        </record>

        <menuitem id="menu_ir_cron_act"
            parent="base.menu_automation"
            action="ir_cron_act"
            sequence="2"/>

</odoo>

```

  File: views/ir_default_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>

    <record id="ir_default_form_view" model="ir.ui.view">
        <field name="name">ir.default form view</field>
        <field name="model">ir.default</field>
        <field name="arch" type="xml">
            <form string="User-defined Defaults">
            <sheet>
                <group>
                    <group name="field_value">
                        <field name="field_id" options="{'no_create': True}"/>
                        <field name="json_value"/>
                        <field name="condition"/>
                    </group>
                    <group name="user_company_details">
                        <field name="user_id"/>
                        <field name="company_id" groups="base.group_multi_company"/>
                    </group>
                </group>
            </sheet>
            </form>
        </field>
    </record>

    <record id="ir_default_tree_view" model="ir.ui.view">
        <field name="name">ir.default tree view</field>
        <field name="model">ir.default</field>
        <field name="arch" type="xml">
            <tree string="User-defined Defaults">
                <field name="field_id"/>
                <field name="json_value"/>
                <field name="condition" optional="hide"/>
                <field name="user_id"/>
                <field name="company_id" groups="base.group_multi_company"/>
            </tree>
        </field>
    </record>

    <record id="ir_default_search_view" model="ir.ui.view">
        <field name="name">ir.default search view</field>
        <field name="model">ir.default</field>
        <field name="arch" type="xml">
            <search string="User-defined Defaults">
                <field name="field_id"/>
                <field name="user_id"/>
                <field name="company_id" groups="base.group_multi_company"/>
                <group expand="0" string="Group By">
                    <filter string="User" name="groupby_user" domain="[]" context="{'group_by':'user_id'}"/>
                    <filter string="Company" name="groupby_company" domain="[]" context="{'group_by':'company_id'}"/>
                </group>
            </search>
        </field>
    </record>

    <record id="ir_default_menu_action" model="ir.actions.act_window">
        <field name="name">User-defined Defaults</field>
        <field name="res_model">ir.default</field>
        <field name="view_mode">tree,form</field>
        <field name="search_view_id" ref="ir_default_search_view"/>
    </record>
    <menuitem action="ir_default_menu_action" id="ir_default_menu" parent="next_id_6"/>

</odoo>

```

  File: views/ir_filters_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="ir_filters_view_form" model="ir.ui.view">
            <field name="model">ir.filters</field>
            <field name="arch" type="xml">
                <form string="Filters">
                  <sheet>
                    <group col="4">
                        <field name="name"/>
                        <field name="user_id" string="Available for User"/>
                        <field name="model_id"/>
                        <field name="is_default"/>
                        <field name="action_id"/>
                        <field name="active" widget="boolean_toggle"/>
                    </group>
                    <group>
                        <field name="domain" widget="domain" options="{'model': 'model_id'}"/>
                        <field name="context"/>
                        <field name="sort"/>
                    </group>
                   </sheet>
                </form>
            </field>
        </record>
        <record id="ir_filters_view_tree" model="ir.ui.view">
            <field name="model">ir.filters</field>
            <field name="arch" type="xml">
                <tree string="Filters">
                    <field name="name"/>
                    <field name="model_id"/>
                    <field name="user_id"/>
                    <field name="is_default"/>
                    <field name="action_id"/>
                    <field name="domain" groups="base.group_no_one"/>
                    <field name="context" groups="base.group_no_one"/>
                    <field name="sort" groups="base.group_no_one"/>
                </tree>
            </field>
        </record>
        <record id="ir_filters_view_search" model="ir.ui.view">
            <field name="model">ir.filters</field>
            <field name="arch" type="xml">
                <search string="Filters">
                    <field name="name" string="Filter Name"/>
                    <filter string="User" domain="[('user_id','!=',False)]" name="user" help="Filters visible only for one user"/>
                    <filter string="Shared" domain="[('user_id','=',False)]" name="shared" help="Filters shared with all users"/>
                    <filter string="My filters" domain="[('user_id','=',uid)]" name="my_filters" help="Filters created by myself"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="User" name="user" domain="[]" context="{'group_by':'user_id'}"/>
                        <filter string="Model" name="model" domain="[]" context="{'group_by':'model_id'}"/>
                    </group>
                    <field name="model_id"/>
                    <field name="user_id"/>
                </search>
            </field>
        </record>
        <record id="actions_ir_filters_view" model="ir.actions.act_window">
            <field name="name">User-defined Filters</field>
            <field name="res_model">ir.filters</field>
        </record>
        <menuitem parent="base.next_id_2" name="User-defined Filters"
            id="menu_ir_filters" action="actions_ir_filters_view" sequence="5"/>
    </data>
</odoo>

```

  File: views/ir_logging_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <record model="ir.ui.view" id="ir_logging_form_view">
            <field name="model">ir.logging</field>
            <field name="arch" type="xml">
                <form string="Log">
                <sheet>
                    <group name="creation_details" string="Creation details">
                        <field name="create_date" />
                        <field name="create_uid" />
                        <field name="dbname" />
                    </group>
                    <group name="log_details" string="Logging details">
                        <field name="type" />
                        <field name="name" />
                        <field name="level" />
                        <field name="path" />
                        <field name="line" />
                        <field name="func" />
                        <field name="message" />
                    </group>
                </sheet>
                </form>
            </field>
        </record>
        <record model="ir.ui.view" id="ir_logging_tree_view">
            <field name="model">ir.logging</field>
            <field name="arch" type="xml">
                <tree string="Logs">
                    <field name="create_date" />
                    <field name="create_uid" />
                    <field name="dbname" />
                    <field name="type" />
                    <field name="name" />
                    <field name="level" />
                    <field name="path" />
                    <field name="line" />
                    <field name="func" />
                </tree>
            </field>
        </record>
        <record model="ir.ui.view" id="ir_logging_search_view">
            <field name="model">ir.logging</field>
            <field name="arch" type="xml">
                <search string="Logs">
                    <field name="dbname" />
                    <field name="type" />
                    <field name="name" />
                    <field name="level" />
                    <field name="message" />
                    <group expand="0" string="Group By">
                        <filter string="Database" name="database" domain="[]" context="{'group_by': 'dbname'}" />
                        <filter string="Level" name="group_by_level" domain="[]" context="{'group_by': 'level'}" />
                        <filter string="Type" name="group_by_type" domain="[]" context="{'group_by': 'type'}" />
                        <filter string="Creation Date" name="group_by_month" domain="[]" context="{'group_by': 'create_date'}" />
                    </group>
                </search>
            </field>
        </record>
        <record model="ir.actions.act_window" id="ir_logging_all_act">
            <field name="name">Logging</field>
            <field name="res_model">ir.logging</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="ir_logging_search_view" />
        </record>
        <menuitem parent="base.next_id_9" id="ir_logging_all_menu" action="ir_logging_all_act" />
</odoo>

```

  File: views/ir_mail_server_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- ir.mail.server -->
        <record model="ir.ui.view" id="ir_mail_server_form">
            <field name="model">ir.mail_server</field>
            <field name="arch" type="xml">
                <form string="Outgoing Mail Servers">
                    <header>
                        <button string="Test Connection" type="object"
                            name="test_smtp_connection" class="btn-primary"/>
                    </header>
                    <sheet>
                        <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger"
                            invisible="active"/>
                        <group>
                            <group>
                                <field name="name" placeholder="e.g. My Outgoing Server"/>
                                <field name="from_filter" placeholder="e.g. email@domain.com, domain.com"/>
                            </group>
                            <group>
                                <field name="sequence"/>
                                <field name="active" invisible="1"/>
                            </group>
                        </group>
                        <group>
                            <group>
                                <field name="smtp_authentication" widget="radio"/>
                            </group>
                            <group>
                                <div class="text-muted fst-italic" role="alert" colspan="2"
                                    invisible="not smtp_authentication_info">
                                    <field name="smtp_authentication_info"/>
                                </div>
                            </group>
                        </group>
                        <notebook colspan="4"
                            invisible="smtp_authentication == 'cli'">
                            <page name="connection" string="Connection">
                                <group>
                                    <group>
                                        <field name="smtp_encryption" widget="radio"/>
                                        <field name="smtp_debug" groups="base.group_no_one"/>
                                        <field name="smtp_host"
                                            required="smtp_authentication != 'cli'"/>
                                        <field name="smtp_port" options="{'format': false}"
                                            required="smtp_authentication != 'cli'"/>
                                    </group>
                                    <group>
                                        <field name="smtp_user" invisible="smtp_authentication == 'certificate'" force_save="1"/>
                                        <field name="smtp_pass" invisible="smtp_authentication != 'login'" password="True" force_save="1"/>
                                        <field name="smtp_ssl_certificate" invisible="smtp_authentication != 'certificate'" force_save="1"/>
                                        <field name="smtp_ssl_private_key" invisible="smtp_authentication != 'certificate'" force_save="1"/>
                                    </group>
                                </group>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <record model="ir.ui.view" id="ir_mail_server_list">
            <field name="model">ir.mail_server</field>
            <field name="arch" type="xml">
                <tree string="Outgoing Mail Servers">
                    <field name="sequence" widget="handle"/>
                    <field name="name"/>
                    <field name="smtp_host"/>
                    <field name="smtp_user"/>
                    <field name="smtp_encryption"/>
                    <field name="from_filter" optional="hide"/>
                </tree>
            </field>
        </record>

        <record id="view_ir_mail_server_search" model="ir.ui.view">
            <field name="model">ir.mail_server</field>
            <field name="arch" type="xml">
                <search string="Outgoing Mail Servers">
                    <field name="name"
                        filter_domain="['|', '|',
                                        ('name', 'ilike', self),
                                        ('smtp_host', 'ilike', self),
                                        ('smtp_user', 'ilike', self)]"
                        string="Outgoing Mail Server"/>
                    <field name="smtp_encryption"/>
                    <field name="from_filter"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record model="ir.actions.act_window" id="action_ir_mail_server_list">
            <field name="name">Outgoing Mail Servers</field>
            <field name="res_model">ir.mail_server</field>
            <field name="view_mode">tree,form</field>
            <field name="view_id" ref="ir_mail_server_list" />
            <field name="search_view_id" ref="view_ir_mail_server_search"/>
        </record>

        <menuitem id="menu_mail_servers" parent="menu_email" action="action_ir_mail_server_list" sequence="5" groups="base.group_no_one"/>
</odoo>

```

  File: views/ir_model_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>

        <!-- menu_create from model form -->
        <record id="view_model_menu_create" model="ir.ui.view">
            <field name="name">Create Menu</field>
            <field name="model">wizard.ir.model.menu.create</field>
            <field name="arch" type="xml">
                <form string="Create Menu">
                    <group>
                        <field name="name"/>
                        <field name="menu_id"/>
                    </group>
                    <footer>
                        <button name="menu_create" string="Create Menu" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x" />
                    </footer>
                </form>
            </field>
        </record>
        <record id="act_menu_create" model="ir.actions.act_window">
            <field name="name">Create Menu</field>
            <field name="res_model">wizard.ir.model.menu.create</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
            <field name="context">{'model_id': active_id}</field>
        </record>

        <!-- model -->
        <record id="view_model_form" model="ir.ui.view">
            <field name="model">ir.model</field>
            <field name="arch" type="xml">
                <form string="Model Description">
                  <header><!-- used for override --></header>
                  <sheet>
                    <group>
                        <group>
                            <field name="id" invisible="1"/>
                            <field name="name"/>
                            <field name="model" readonly="id"/>
                            <field name="order"/>
                            <field name="transient" readonly="id" groups="base.group_no_one"/>
                        </group>
                        <group>
                            <field name="state" readonly="1" groups="base.group_no_one"/>
                            <field name="modules" groups="base.group_no_one"/>
                        </group>
                    </group>
                    <notebook>
                        <page string="Fields" name="fields">
                            <field name="field_id">
                                <tree string="Fields Description">
                                    <field name="name"/>
                                    <field name="field_description"/>
                                    <field name="ttype"/>
                                    <field name="required"/>
                                    <field name="readonly"/>
                                    <field name="index" groups="base.group_no_one"/>
                                    <field name="state" groups="base.group_no_one"/>
                                </tree>
                                <form string="Fields Description">
                                    <group>
                                        <group>
                                            <field name="name"/>
                                            <field name="field_description"/>
                                        </group>
                                        <group>
                                            <field name="ttype"/>
                                            <field name="help"/>
                                        </group>
                                    </group>
                                    <notebook>
                                        <page name="base" string="Properties">
                                            <group string="Base Properties">
                                                <group>
                                                    <field name="required"/>
                                                    <field name="readonly"/>
                                                    <field name="store" groups="base.group_no_one"/>
                                                    <field name="index" groups="base.group_no_one"/>
                                                    <field name="copied" groups="base.group_no_one"/>
                                                </group>
                                                <group>
                                                    <field name="translate"
                                                        invisible="ttype not in ['char', 'text', 'html']"
                                                        readonly="ttype not in ['char', 'text', 'html']"/>
                                                    <field name="size" groups="base.group_no_one"
                                                        invisible="ttype not in ['char', 'reference']"
                                                        readonly="ttype not in ['char', 'reference']"/>
                                                    <field name="relation"
                                                        invisible="ttype not in ['many2one', 'one2many', 'many2many']"
                                                        readonly="ttype not in ['many2one', 'one2many', 'many2many']"
                                                        required="ttype in ['many2one', 'one2many', 'many2many']"/>
                                                    <field name="on_delete" groups="base.group_no_one"
                                                        invisible="ttype != 'many2one'"
                                                        readonly="ttype != 'many2one'"/>
                                                    <field name="relation_field"
                                                        invisible="ttype != 'one2many'"
                                                        readonly="ttype != 'one2many'"
                                                        required="ttype == 'one2many'"/>
                                                    <field name="relation_table" groups="base.group_no_one"
                                                        invisible="ttype != 'many2many' or state != 'manual'"
                                                        readonly="ttype != 'many2many' or state != 'manual'"/>
                                                    <field name="column1" groups="base.group_no_one"
                                                        invisible="ttype != 'many2many' or state != 'manual'"
                                                        readonly="ttype != 'many2many' or state != 'manual'"/>
                                                    <field name="column2" groups="base.group_no_one"
                                                        invisible="ttype != 'many2many' or state != 'manual'"
                                                        readonly="ttype != 'many2many' or state != 'manual'"/>
                                                    <field name="domain" groups="base.group_no_one"
                                                        invisible="ttype not in ['many2one', 'one2many', 'many2many']"
                                                        readonly="ttype not in ['many2one', 'one2many', 'many2many']"/>
                                                </group>
                                            </group>
                                            <group invisible="ttype not in ['selection', 'reference']" readonly="ttype not in ['selection', 'reference']">
                                                <field name="selection_ids">
                                                    <tree editable="bottom">
                                                        <field name="sequence" widget="handle"/>
                                                        <field name="value"/>
                                                        <field name="name"/>
                                                    </tree>
                                                </field>
                                            </group>
                                            <group string="Advanced Properties" groups="base.group_no_one">
                                                <field name="related"/>
                                                <field name="depends" required="compute not in [False, '']"/>
                                                <field name="compute" widget="code" options="{'mode': 'python'}"/>
                                            </group>
                                            <div groups="base.group_no_one">
                                                <h3>How to define a computed field</h3>
                                                <p>Computed fields are defined with the fields
                                                <strong>Dependencies</strong> and <strong>Compute</strong>.</p>
                                                <p>The field <strong>Dependencies</strong> lists the fields that
                                                the current field depends on. It is a comma-separated list of
                                                field names, like <code>name, size</code>. You can also refer to
                                                fields accessible through other relational fields, for instance
                                                <code>partner_id.company_id.name</code>.</p>
                                                <p>The field <strong>Compute</strong> is the Python code to
                                                compute the value of the field on a set of records. The value of
                                                the field must be assigned to each record with a dictionary-like
                                                assignment.</p>
                                                <pre>
    for record in self:
        record['size'] = len(record.name)
</pre>
                                                <p>The only predefined variables are</p>
                                                <ul>
                                                    <li><code>self</code> (the set of records to compute)</li>
                                                    <li><code>datetime</code> (Python module)</li>
                                                    <li><code>dateutil</code> (Python module)</li>
                                                    <li><code>time</code> (Python module)</li>
                                                </ul>
                                                <p>Other features are accessible through <code>self</code>, like
                                                <code>self.env</code>, etc.</p>
                                            </div>
                                        </page>
                                        <page name="groups" string="Access Rights">
                                            <field name="groups"/>
                                        </page>
                                        <page name="misc" string="Miscellaneous" groups="base.group_no_one">
                                            <group>
                                                <field name="state"/>
                                                <field name="modules"/>
                                            </group>
                                        </page>
                                    </notebook>
                                </form>
                            </field>
                            <button groups="base.group_no_one"
                                icon="fa-align-justify"
                                name="%(act_menu_create)d"
                                string="Create a Menu" type="action"
                                target="new" />
                        </page>
                        <page string="Access Rights" name="access_rights">
                            <field name="access_ids">
                                <tree string="Access Rights" editable="top"
                                      decoration-warning="not group_id and
                                                         (perm_read or perm_write or
                                                          perm_create or perm_unlink)">
                                    <field name="name"/>
                                    <field name="group_id"/>
                                    <field name="perm_read"/>
                                    <field name="perm_write"/>
                                    <field name="perm_create"/>
                                    <field name="perm_unlink"/>
                                </tree>
                            </field>
                        </page>
                        <page string="Record Rules" name="record_rules">
                            <field name="rule_ids">
                                <tree string="Record Rules" editable="top" decoration-info="not groups">
                                    <field name="name"/>
                                    <field name="groups" widget="many2many_tags" options="{'no_create':True}"/>
                                    <field name="domain_force"/>
                                    <field name="perm_read"/>
                                    <field name="perm_write"/>
                                    <field name="perm_create"/>
                                    <field name="perm_unlink"/>
                                </tree>
                            </field>
                        </page>
                        <page string="Notes" name="notes" groups="base.group_no_one">
                            <field name="info"/>
                        </page>
                        <page string="Views" name="views" groups="base.group_no_one">
                            <field name="view_ids"/>
                        </page>
                    </notebook>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_tree" model="ir.ui.view">
            <field name="model">ir.model</field>
            <field name="arch" type="xml">
                <tree string="Model Description">
                    <field name="model"/>
                    <field name="name"/>
                    <field name="state"/>
                    <field name="transient"/>
                </tree>
            </field>
        </record>
        <record id="view_model_search" model="ir.ui.view">
            <field name="model">ir.model</field>
            <field name="arch" type="xml">
                <search string="Model Description">
                    <field name="name" filter_domain="['|', ('name','ilike',self), ('model','ilike',self)]" string="Model"/>
                    <field name="model" filter_domain="[('model','ilike',self)]" string="Technical Name"/>
                    <filter string="Transient" name="transient" domain="[('transient', '=', True)]"/>
                    <separator/>
                    <filter string="Custom" name="custom" domain="[('state', '=', 'manual')]"/>
                    <filter string="Base" name="base" domain="[('state', '=', 'base')]"/>
                </search>
            </field>
        </record>
        <record id="action_model_model" model="ir.actions.act_window">
            <field name="name">Models</field>
            <field name="res_model">ir.model</field>
            <field name="context">{}</field>
            <field name="view_id" ref="view_model_tree"/>
        </record>
        <menuitem action="action_model_model" id="ir_model_model_menu" parent="next_id_9"/>

        <!-- ir model fields -->
        <record id="view_model_fields_form" model="ir.ui.view">
            <field name="model">ir.model.fields</field>
            <field name="arch" type="xml">
                <form string="Fields" duplicate="false">
                    <field name="state" invisible="1"/>
                    <sheet>
                        <group>
                            <group>
                                <field name="name"/>
                                <field name="field_description"/>
                                <field name="model_id" readonly="state != 'manual'"/>
                            </group>
                            <group>
                                <field name="ttype"/>
                                <field name="help"/>
                            </group>
                        </group>
                        <notebook>
                            <page name="base" string="Properties">
                                <group string="Base Properties">
                                    <group>
                                        <field name="required"/>
                                        <field name="readonly"/>
                                        <field name="store" groups="base.group_no_one"/>
                                        <field name="index" groups="base.group_no_one"/>
                                        <field name="copied" groups="base.group_no_one"/>
                                    </group>
                                    <group>
                                        <field name="translate"
                                            invisible="ttype not in ['char', 'text', 'html']"
                                            readonly="ttype not in ['char', 'text', 'html']"/>
                                        <field name="size" groups="base.group_no_one"
                                            invisible="ttype not in ['char', 'reference']"
                                            readonly="ttype not in ['char', 'reference']"/>
                                        <field name="relation"
                                            invisible="ttype not in ['many2one', 'one2many', 'many2many']"
                                            readonly="ttype not in ['many2one', 'one2many', 'many2many']"
                                            required="ttype in ['many2one', 'one2many', 'many2many']"/>
                                        <field name="group_expand" groups="base.group_no_one"
                                            invisible="ttype not in ['many2one', 'selection']"
                                            readonly="ttype not in ['many2one', 'selection']"/>
                                        <field name="on_delete" groups="base.group_no_one"
                                            invisible="ttype != 'many2one'"
                                            readonly="ttype != 'many2one'"/>
                                        <field name="relation_field"
                                            invisible="ttype != 'one2many'"
                                            readonly="ttype != 'one2many'"
                                            required="ttype == 'one2many'"/>
                                        <field name="relation_table" groups="base.group_no_one"
                                            invisible="ttype != 'many2many' or state != 'manual'"
                                            readonly="ttype != 'many2many' or state != 'manual'"/>
                                        <field name="column1" groups="base.group_no_one"
                                            invisible="ttype != 'many2many' or state != 'manual'"
                                            readonly="ttype != 'many2many' or state != 'manual'"/>
                                        <field name="column2" groups="base.group_no_one"
                                            invisible="ttype != 'many2many' or state != 'manual'"
                                            readonly="ttype != 'many2many' or state != 'manual'"/>
                                        <field name="domain" groups="base.group_no_one"
                                            invisible="ttype not in ['many2one', 'one2many', 'many2many']"
                                            readonly="ttype not in ['many2one', 'one2many', 'many2many']"/>
                                        <field name="currency_field"
                                            invisible="ttype != 'monetary'"
                                            readonly="ttype != 'monetary'"/>
                                    </group>
                                </group>
                                <group string="HTML/Sanitization Properties">
                                    <group>
                                        <field name="sanitize"
                                            invisible="ttype != 'html'"
                                            readonly="ttype != 'html'" />
                                        <field name="sanitize_overridable"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                        <field name="sanitize_tags"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                        <field name="sanitize_attributes"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                    </group>
                                    <group>
                                        <field name="sanitize_style"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                        <field name="sanitize_form"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                        <field name="strip_style"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                        <field name="strip_classes"
                                            invisible="ttype != 'html' or sanitize == False"
                                            readonly="ttype != 'html' or sanitize == False" />
                                    </group>
                                </group>
                                <group invisible="ttype not in ['selection', 'reference']" readonly="ttype not in ['selection', 'reference']">
                                    <field name="selection_ids">
                                        <tree editable="bottom">
                                            <field name="sequence" widget="handle"/>
                                            <field name="value"/>
                                            <field name="name"/>
                                        </tree>
                                    </field>
                                </group>
                                <group string="Advanced Properties" groups="base.group_no_one">
                                    <field name="related"/>
                                    <field name="depends" required="compute not in [False, '']"/>
                                    <field name="compute" widget="code" options="{'mode': 'python'}"/>
                                </group>
                                <div groups="base.group_no_one">
                                    <h3>How to define a computed field</h3>
                                    <p>Computed fields are defined with the fields
                                    <strong>Dependencies</strong> and <strong>Compute</strong>.</p>
                                    <p>The field <strong>Dependencies</strong> lists the fields that
                                    the current field depends on. It is a comma-separated list of
                                    field names, like <code>name, size</code>. You can also refer to
                                    fields accessible through other relational fields, for instance
                                    <code>partner_id.company_id.name</code>.</p>
                                    <p>The field <strong>Compute</strong> is the Python code to
                                    compute the value of the field on a set of records. The value of
                                    the field must be assigned to each record with a dictionary-like
                                    assignment.</p>
                                    <pre>
    for record in self:
        record['size'] = len(record.name)
</pre>
                                    <p>The only predefined variables are</p>
                                    <ul>
                                        <li><code>self</code> (the set of records to compute)</li>
                                        <li><code>datetime</code> (Python module)</li>
                                        <li><code>dateutil</code> (Python module)</li>
                                        <li><code>time</code> (Python module)</li>
                                    </ul>
                                    <p>Other features are accessible through <code>self</code>, like
                                    <code>self.env</code>, etc.</p>
                                </div>
                            </page>
                            <page name="groups" string="Access Rights">
                                <field name="groups"/>
                            </page>
                            <page name="misc" string="Miscellaneous" groups="base.group_no_one">
                                <group>
                                    <field name="state"/>
                                    <field name="modules"/>
                                </group>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_fields_tree" model="ir.ui.view">
            <field name="model">ir.model.fields</field>
            <field name="arch" type="xml">
                <tree string="Fields" duplicate="false">
                    <field name="name"/>
                    <field name="field_description"/>
                    <field name="model_id"/>
                    <field name="ttype"/>
                    <field name="state"/>
                    <field name="index"/>
                    <field name="store"/>
                    <field name="readonly"/>
                    <field name="relation"/>
                </tree>
            </field>
        </record>
        <record id="view_model_fields_search" model="ir.ui.view">
            <field name="model">ir.model.fields</field>
            <field name="arch" type="xml">
                <search string="Fields">
                    <field name="name" filter_domain="['|', ('name','ilike',self), ('field_description','ilike',self)]" string="Field"/>
                    <filter string="Required" name="required" domain="[('required', '=', True)]"/>
                    <separator/>
                    <filter string="Readonly" name="readonly" domain="[('readonly', '=', True)]"/>
                    <separator/>
                    <filter string="Custom" name="custom" domain="[('state', '=', 'manual')]"/>
                    <filter string="Base" name="base" domain="[('state', '=', 'base')]"/>
                    <separator/>
                    <filter string="Translate" name="translate" domain="[('translate', '=', True)]"/>
                    <field name="model_id"/>
                    <field name="ttype"/>
                    <field name="required"/>
                    <field name="readonly"/>
                    <field name="relation"/>
                    <group expand="0" string="Group By">
                        <filter string="Model" name="group_by_object" domain="[]" context="{'group_by':'model_id'}"/>
                        <filter string="Field Type" name="group_by_ttype" domain="[]" context="{'group_by':'ttype'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="action_model_fields" model="ir.actions.act_window">
            <field name="name">Fields</field>
            <field name="res_model">ir.model.fields</field>
            <field name="context">{}</field>
            <field name="view_id" ref="view_model_fields_tree"/>
        </record>
        <menuitem action="action_model_fields" id="ir_model_model_fields" parent="base.next_id_9"/>

        <!-- ir model fields selection -->
        <record id="view_model_fields_selection_form" model="ir.ui.view">
            <field name="model">ir.model.fields.selection</field>
            <field name="arch" type="xml">
                <form string="Fields" duplicate="false">
                    <sheet>
                        <group>
                            <field name="field_id" options="{'no_create': True}"/>
                            <field name="value" groups="base.group_no_one"/>
                            <field name="name"/>
                            <field name="sequence" groups="base.group_no_one"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_fields_selection_tree" model="ir.ui.view">
            <field name="model">ir.model.fields.selection</field>
            <field name="arch" type="xml">
                <tree>
                    <field name="sequence" widget="handle"/>
                    <field name="field_id"/>
                    <field name="value"/>
                    <field name="name"/>
                </tree>
            </field>
        </record>
        <record id="view_model_fields_selection_search" model="ir.ui.view">
            <field name="model">ir.model.fields.selection</field>
            <field name="arch" type="xml">
                <search string="Fields">
                    <field name="field_id" string="Field"/>
                    <field name="name"
                           filter_domain="['|', ('name','ilike',self), ('value','ilike',self)]"
                           string="Selection" />
                    <filter name="group_by_field"
                            context="{'group_by':'field_id'}"
                            string="Field"/>
                </search>
            </field>
        </record>
        <record id="action_model_fields_selection" model="ir.actions.act_window">
            <field name="name">Fields Selection</field>
            <field name="res_model">ir.model.fields.selection</field>
            <field name="view_id" ref="view_model_fields_selection_tree"/>
        </record>
        <menuitem action="action_model_fields_selection" id="ir_model_model_fields_selection" parent="base.next_id_9"/>

        <!-- ir model data -->
        <record model="ir.ui.view" id="view_model_data_form">
            <field name="model">ir.model.data</field>
            <field name="arch" type="xml">
                <form string="External Identifiers">
                    <sheet>
                        <h1>
                            <field name="complete_name"/>
                        </h1>
                        <group>
                            <group>
                                <field name="module"/>
                                <field name="name"/>
                                <field name="noupdate"/>
                                <field name="write_date" />
                                <field name="create_date" />
                            </group>
                            <group>
                                <field name="display_name"/>
                                <field name="model"/>
                                <field name="res_id"/>
                                <field name="reference" widget="reference" string="Record"/>
                            </group>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_data_list" model="ir.ui.view">
            <field name="model">ir.model.data</field>
            <field name="arch" type="xml">
                <tree string="External Identifiers">
                    <field name="complete_name"/>
                    <field name="display_name"/>
                    <field name="model" groups="base.group_no_one"/>
                    <field name="module" column_invisible="True"/>
                    <field name="res_id"/>
                </tree>
            </field>
        </record>
        <record id="view_model_data_search" model="ir.ui.view">
            <field name="model">ir.model.data</field>
            <field name="arch" type="xml">
                <search string="External Identifiers">
                    <field name="name" filter_domain="[('name','ilike',self)]" string="External Identifier"/>
                    <filter string="Updatable" name="updatable" domain="[('noupdate', '=', False)]"/>
                    <field name="module"/>
                    <field name="model"/>
                    <field name="res_id"/>
                    <field name="noupdate"/>
                    <group expand="0" string="Group By">
                        <filter string="Module" name="group_by_module" domain="[]" context="{'group_by':'module'}"/>
                        <filter string="Model" name="group_by_object" domain="[]" context="{'group_by':'model'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="action_model_data" model="ir.actions.act_window">
            <field name="name">External Identifiers</field>
            <field name="res_model">ir.model.data</field>
            <field name="view_id" ref="view_model_data_list"/>
        </record>
        <menuitem id="next_id_5" name="Sequences &amp; Identifiers" parent="base.menu_custom" sequence="21" groups="base.group_no_one"/>
        <menuitem action="action_model_data" id="ir_model_data_menu" parent="base.next_id_5"
                  groups="base.group_no_one"/>

        <!-- ir model contraints -->
        <record model="ir.ui.view" id="view_model_constraint_form">
            <field name="model">ir.model.constraint</field>
            <field name="arch" type="xml">
                <form string="Model Constraints">
                <sheet>
                    <group col="4">
                        <field name="type"/>
                        <field name="name"/>
                        <field name="module" can_create="false"/>
                        <field name="model"/>
                    </group>
                    <group>
                        <field name="message"/>
                    </group>
                </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_constraint_list" model="ir.ui.view">
            <field name="model">ir.model.constraint</field>
            <field name="arch" type="xml">
                <tree string="Model Constraints">
                    <field name="type"/>
                    <field name="name"/>
                    <field name="module"/>
                    <field name="model"/>
                </tree>
            </field>
        </record>

        <record id="view_model_constraint_search" model="ir.ui.view">
            <field name="model">ir.model.constraint</field>
            <field name="arch" type="xml">
                <search string="Constraints">
                    <field name="model"/>
                    <field name="name"/>
                    <field name="message"/>
                    <group expand="1" string="Group By">
                        <filter name="module" string="Module" context="{'group_by' : 'module'}"/>
                        <filter name="model" string="Model" context="{'group_by': 'model'}"/>
                        <filter name="type" string="Constraint type" context="{'group_by' : 'type'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="action_model_constraint" model="ir.actions.act_window">
            <field name="name">Model Constraints</field>
            <field name="res_model">ir.model.constraint</field>
            <field name="view_id" ref="view_model_constraint_list"/>
            <field name="search_view_id" ref="view_model_constraint_search"/>
        </record>
        <menuitem action="action_model_constraint" id="ir_model_constraint_menu" parent="base.next_id_9"
                  groups="base.group_no_one"/>

        <!-- ir model relations -->
        <record model="ir.ui.view" id="view_model_relation_form">
            <field name="model">ir.model.relation</field>
            <field name="arch" type="xml">
                <form string="ManyToMany Relations">
                <sheet>
                    <group col="4">
                        <field name="name"/>
                        <field name="module" can_create="false"/>
                        <field name="model"/>
                    </group>
                </sheet>
                </form>
            </field>
        </record>
        <record id="view_model_relation_list" model="ir.ui.view">
            <field name="model">ir.model.relation</field>
            <field name="arch" type="xml">
                <tree string="ManyToMany Relations">
                    <field name="name"/>
                    <field name="module"/>
                    <field name="model"/>
                </tree>
            </field>
        </record>
        <record id="action_model_relation" model="ir.actions.act_window">
            <field name="name">ManyToMany Relations</field>
            <field name="res_model">ir.model.relation</field>
            <field name="view_id" ref="view_model_relation_list"/>
        </record>
        <menuitem action="action_model_relation" id="ir_model_relation_menu" parent="base.next_id_9"
                  groups="base.group_no_one"/>

        <!-- ir.model.access -->
        <record id="ir_access_view_tree" model="ir.ui.view">
            <field name="name">ir.model.access.view.tree</field>
            <field name="model">ir.model.access</field>
            <field name="arch" type="xml">
                <tree string="Access Rights"
                      decoration-warning="not group_id and
                                         (perm_read or perm_write or
                                          perm_create or perm_unlink)">
                    <field name="name"/>
                    <field name="model_id"/>
                    <field name="group_id"/>
                    <field name="perm_read"/>
                    <field name="perm_write"/>
                    <field name="perm_create"/>
                    <field name="perm_unlink"/>
                </tree>
            </field>
        </record>
        <record id="ir_access_view_tree_edition" model="ir.ui.view">
            <field name="name">ir.model.access.view.tree.edition</field>
            <field name="model">ir.model.access</field>
            <field name="arch" type="xml">
                <tree string="Access Rights" editable="top"
                      decoration-warning="not group_id and
                                         (perm_read or perm_write or
                                          perm_create or perm_unlink)">
                    <field name="name"/>
                    <field name="model_id"/>
                    <field name="group_id"/>
                    <field name="perm_read"/>
                    <field name="perm_write"/>
                    <field name="perm_create"/>
                    <field name="perm_unlink"/>
                </tree>
            </field>
        </record>
        <record id="ir_access_view_form" model="ir.ui.view">
            <field name="model">ir.model.access</field>
            <field name="arch" type="xml">
                <form string="Access Rights">
                   <sheet>
                    <div class="alert alert-warning text-center" role="alert">
                        Please note that modifications will be applied for all users of the specified group
                    </div>
                    <group col="4">
                        <field name="name"/>
                        <field name="model_id"/>
                        <field name="group_id"/>
                        <field name="active" widget='boolean_toggle'/>
                    </group>
                    <group string="Access" col="4">
                        <field name="perm_read"/>
                        <field name="perm_write"/>
                        <field name="perm_create"/>
                        <field name="perm_unlink"/>
                    </group>
                   </sheet>
                </form>
            </field>
        </record>
        <record id="ir_access_view_search" model="ir.ui.view">
            <field name="model">ir.model.access</field>
            <field name="arch" type="xml">
                <search string="Access Rights">
                    <field name="name" string="Access Rights"/>
                    <filter string="Global" name="global" domain="[('group_id', '=', False)]"/>
                    <separator/>
                    <filter string="Full Access" name="full_access" domain="[('perm_read', '=', True), ('perm_write', '=', True), ('perm_create', '=', True), ('perm_unlink', '=', True)]"/>
                    <filter string="Read Access" name="read_access" domain="[('perm_read', '=', True)]"/>
                    <filter string="Write Access" name="write_access" domain="[('perm_write', '=', True)]"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                    <field name="model_id"/>
                    <field name="group_id"/>
                    <group expand="0" string="Group By" colspan="11" col="11" groups="base.group_no_one">
                        <filter string="Group" name="group" domain="[]" context="{'group_by': 'group_id'}"/>
                        <filter string="Model" name="group_by_object" domain="[]" context="{'group_by': 'model_id'}"/>
                    </group>
                </search>
            </field>
        </record>
        <record id="ir_access_act" model="ir.actions.act_window">
            <field name="name">Access Rights</field>
            <field name="res_model">ir.model.access</field>
            <field name="view_id" ref="ir_access_view_tree_edition"/>
            <field name="search_view_id" ref="ir_access_view_search"/>
        </record>
        <menuitem action="ir_access_act" id="menu_ir_access_act" parent="base.menu_security"/>

</odoo>

```

  File: views/ir_module_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Modules Categories -->
        <record id="view_module_category_form" model="ir.ui.view">
            <field name="name">ir.module.category.form</field>
            <field name="model">ir.module.category</field>
            <field name="arch" type="xml">
                <form string="Module Category">
                    <group col="4">
                        <field name="name"/>
                        <field name="parent_id"/>
                        <field name="sequence"/>
                    </group>
                    <field name="description"/>
                </form>
            </field>
        </record>

        <!-- Click on a category -->
        <record id="view_module_filter" model="ir.ui.view">
            <field name="name">ir.module.module.list.select</field>
            <field name="model">ir.module.module</field>
            <field name="arch" type="xml">
                <search string="Search modules">
                    <field name="name" filter_domain="['|', '|', ('summary', 'ilike', self), ('shortdesc', 'ilike', self), ('name',
                        'ilike', self)]" string="Module"/>
                    <filter name="app" string="Apps" domain="[('application', '=', True)]"/>
                    <filter name="extra" string="Extra" domain="[('application', '=', False)]"/>
                    <separator/>
                    <filter name="installed" string="Installed" domain="[('state', 'in', ['installed', 'to upgrade', 'to remove'])]"/>
                    <filter name="not_installed" string="Not Installed" domain="[('state', 'in', ['uninstalled', 'uninstallable', 'to install'])]"/>
                    <field name="category_id"/>
                    <group expand="0" string="Group By">
                        <filter string="Author" name="author" domain="[]" context="{'group_by':'author'}"/>
                        <filter string="Category" name="category" domain="[]" context="{'group_by':'category_id'}"/>
                        <filter string="Status" name="state" domain="[]" context="{'group_by':'state'}"/>
                    </group>
                    <searchpanel>
                        <field name="category_id" string="Categories" enable_counters="1"/>
                    </searchpanel>
               </search>
            </field>
        </record>

        <!-- Modules -->
        <record id="module_form" model="ir.ui.view">
            <field name="name">ir.module.module.form</field>
            <field name="model">ir.module.module</field>
            <field name="arch" type="xml">
                <form create="0" edit="0" string="Module" class="o_module_form">
                    <link rel="stylesheet" href="/base/static/src/css/description.css"></link>
                    <sheet>
                    <field name="icon_image" widget="image" class="oe_avatar"/>
                    <div class="mb32">
                        <h1 class="d-flex flex-column">
                            <field name="shortdesc" placeholder="Module Name"/>
                            <field class="fs-2 text-muted" name="summary" invisible="not summary"/>
                        </h1>
                        <h4 class="text-muted d-flex flex-column">
                            <div>By <field name="author" class="oe_inline" placeholder="Author Name"/> </div>
                            <small><field name="website" widget="url" invisible="not website"/></small>
                        </h4>

                        <div>
                            <field name="state" invisible="1"/>
                            <field name="to_buy" invisible="1"/>
                            <field name="has_iap" invisible="1"/>
                            <button name="button_immediate_install" string="Activate" invisible="to_buy or state != 'uninstalled'" type="object" class="btn btn-primary me-1" groups="base.group_system"/>
                            <a href="https://odoo.com/pricing?utm_source=db&amp;utm_medium=module#hosting=on_premise" target="_blank" class="btn btn-primary me-1"
                               invisible="not to_buy or state not in ('uninstalled', 'uninstallable')" role="button">Upgrade</a>
                            <button name="button_immediate_upgrade" invisible="state != 'installed'" string="Upgrade" type="object" class="btn btn-primary me-1" groups="base.group_system"/>
                            <button name="button_uninstall_wizard" invisible="state != 'installed'" string="Uninstall" type="object"  class="btn btn-secondary me-1" groups="base.group_system"/>
                            <button name="button_uninstall_cancel" invisible="state != 'to remove'" string="Cancel Uninstall" type="object" class="btn btn-secondary me-1" groups="base.group_system"/>
                            <button name="button_upgrade_cancel" invisible="state != 'to upgrade'" string="Cancel Upgrade" type="object" class="btn btn-secondary me-1" groups="base.group_system"/>
                            <button name="button_install_cancel" invisible="state != 'to install'" string="Cancel Install" type="object" class="btn btn-secondary me-1" groups="base.group_system"/>
                        </div>
                        <h6 class="text-muted mt-2" invisible="not has_iap">Contains In-App Purchases</h6>
                    </div>
                    <div class="clearfix"/>
                    <notebook groups="base.group_no_one">
                        <page string="Information" name="information">
                            <group>
                                <group>
                                    <field name="category_id" options="{'no_open': True, 'no_create': True}"/>
                                    <field name="name" />
                                    <field name="license"/>
                                    <field name="installed_version"/>
                                </group>
                            </group>
                        </page>
                        <page string="Technical Data" name="technical_data">
                            <group col="4">
                                <field name="demo"/>
                                <field name="application"/>
                                <field name="state"/>
                            </group>
                            <group>
                                <group string="Dependencies">
                                    <field name="dependencies_id" colspan="2" nolabel="1">
                                        <tree string="Dependencies">
                                            <field name="name"/>
                                            <field name="state"/>
                                        </tree>
                                    </field>
                                </group>
                                <group string="Exclusions">
                                    <field name="exclusion_ids" colspan="2" nolabel="1">
                                        <tree string="Exclusions">
                                            <field name="name"/>
                                            <field name="state"/>
                                        </tree>
                                    </field>
                                </group>
                            </group>
                        </page>
                        <page string="Installed Features" name="installed_features" invisible="state != 'installed'">
                            <group string="Created Menus"/>
                            <field name="menus_by_module"/>
                            <group string="Created Views"/>
                            <field name="views_by_module"/>
                            <group string="Defined Reports"/>
                            <field name="reports_by_module"/>
                        </page>
                    </notebook>
                    <field name="description_html" class='oe_styling_v8' invisible="not description_html"/>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="module_tree" model="ir.ui.view">
            <field name="name">ir.module.module.tree</field>
            <field name="model">ir.module.module</field>
            <field name="arch" type="xml">
                <tree create="false" string="Apps" decoration-info="state == 'uninstalled'" decoration-muted="state == 'uninstallable'">
                    <header>
                        <button name="button_immediate_install" type="object" string="Activate" groups="base.group_system"/>
                        <button name="button_immediate_upgrade" type="object" string="Upgrade" groups="base.group_system"/>
                    </header>
                    <field name="shortdesc"/>
                    <field name="name" groups="base.group_no_one"/>
                    <field name="author"/>
                    <field name="website"/>
                    <field name="installed_version"/>
                    <field name="state" widget="badge"
                        decoration-muted="state == 'uninstallable'"
                        decoration-info="state  == 'uninstalled'"
                        decoration-success="state == 'installed'"/>
                    <field name="category_id" column_invisible="True"/>
                </tree>
            </field>
        </record>
        <record model="ir.ui.view" id="module_view_kanban">
            <field name="name">Apps Kanban</field>
            <field name="model">ir.module.module</field>
            <field name="arch" type="xml">
                <kanban create="false" class="o_modules_kanban">
                  <field name="icon"/>
                  <field name="icon_flag"/>
                  <field name="to_buy"/>
                  <field name="name"/>
                  <field name="state"/>
                  <field name="summary"/>
                  <field name="website"/>
                  <field name="application"/>
                  <templates>
                    <t t-name="kanban-menu">
                        <t t-set="installed" t-value="record.state.raw_value == 'installed'"/>
                        <a type="edit" class="dropdown-item">Module Info</a>
                        <a t-if="record.website.raw_value" role="menuitem" class="dropdown-item o-hidden-ios" t-att-href="record.website.raw_value" target="_blank">Learn More</a>
                        <a t-if="installed" name="button_immediate_upgrade" type="object" role="menuitem" class="dropdown-item" groups="base.group_system">Upgrade</a>
                        <a t-if="installed" name="button_uninstall_wizard" type="object" role="menuitem" class="dropdown-item" groups="base.group_system">Uninstall</a>
                    </t>
                    <t t-name="kanban-box">
                      <div class="oe_module_vignette">
                        <div class="oe_module_icon">
                            <img t-attf-src="#{record.icon.value}" class="w-100" alt="Icon"/>
                            <span t-if="record.icon_flag" class="oe_module_flag"><t t-out="record.icon_flag.raw_value"/></span>
                        </div>
                        <div class="oe_module_desc" t-att-title="record.shortdesc.value">
                          <h4 class="o_kanban_record_title">
                            <field name="shortdesc"/>&amp;nbsp;
                          </h4>
                          <p class="oe_module_name">
                            <field groups="!base.group_no_one" name="summary"/>
                            <code groups="base.group_no_one"><field name="name"/></code>
                          </p>
                          <div class="oe_module_action d-flex flex-wrap justify-content-between">
                            <button type="object" class="btn btn-primary btn-sm" name="button_immediate_install" invisible="state != 'uninstalled'" t-if="! record.to_buy.raw_value" groups="base.group_system">Activate</button>
                            <div t-if="installed" class="d-flex align-items-center text-muted float-start">Installed</div>
                            <a t-att-href="record.website.raw_value" target="_blank" invisible="website in (False, '')" class="btn btn-sm btn-secondary float-end o-hidden-ios" role="button">Learn More</a>
                            <a type="edit" class="btn btn-secondary btn-sm float-end" role="button" invisible="website != ''">Module Info</a>
                            <a href="https://odoo.com/pricing?utm_source=db&amp;utm_medium=module#hosting=on_premise" target="_blank" class="btn btn-info btn-sm" invisible="state not in ('uninstalled', 'uninstallable')" t-if="record.to_buy.raw_value" role="button" groups="base.group_system">Upgrade</a>
                            <button invisible="state != 'to remove'" type="object" class="btn btn-sm btn-primary" name="button_uninstall_cancel" groups="base.group_system">Cancel Uninstall</button>
                            <button invisible="state != 'to install'" type="object" class="btn btn-sm btn-primary" name="button_install_cancel" groups="base.group_system">Cancel Install</button>
                          </div>
                        </div>
                      </div>
                    </t>
                  </templates>
                </kanban>
            </field>
        </record>
        <record id="open_module_tree" model="ir.actions.act_window">
            <field name="name">Apps</field>
            <field name="res_model">ir.module.module</field>
            <field name="view_mode">kanban,tree,form</field>
            <field name="context">{'search_default_app':1}</field>
            <field name="search_view_id" ref="view_module_filter"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_empty_folder">
                No module found!
              </p><p>
                You should try other search criteria.
              </p>
            </field>
        </record>

        <!--top menu -->
        <menuitem id="menu_apps" name="Apps" parent="menu_management" sequence="5"/>

        <!--submenu -->
        <menuitem id="menu_module_tree" parent="menu_apps" name="Main Apps" sequence="5" action="open_module_tree" />

        <menuitem id="theme_store" parent="menu_apps" name="Theme Store" sequence="15"/>

        <!--link to stores-->
        <record model='ir.actions.act_url' id='action_third_party'>
            <field name='name'>Third-Party Apps</field>
            <field name='url'>https://apps.odoo.com/apps/modules</field>
        </record>
        <menuitem id="menu_third_party" parent="menu_apps" name="Third-Party Apps" sequence="20" action="action_third_party"/>

        <record model='ir.actions.act_url' id='action_theme_store'>
            <field name='name'>Theme Store</field>
            <field name='url'>https://apps.odoo.com/apps/themes</field>
        </record>
        <menuitem id="menu_theme_store" parent="menu_apps" name="Theme Store" sequence="10" action="action_theme_store"/>

    </data>
</odoo>

```

  File: views/ir_profile_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>

    <record id="ir_profile_view_search" model="ir.ui.view">
        <field name="name">IR Profile Search</field>
        <field name="model">ir.profile</field>
        <field name="arch" type="xml">
            <search>
                <field name="name" string="Name"/>
                <field name="session" string="Session"/>
                <filter name="group_session" string="Session" context="{'group_by':'session'}"/>
            </search>
        </field>
    </record>

    <record id="ir_profile_view_list" model="ir.ui.view">
        <field name="name">IR Profile List</field>
        <field name="model">ir.profile</field>
        <field name="arch" type="xml">
            <tree string="Profile Session" default_order="session desc, id desc">
                <field name="create_date"/>
                <field name="session"/>
                <field name="name"/>
                <field name="entry_count"/>
                <field name="sql_count" optional="hide"/>
                <field name="speedscope_url" widget="url"/>
                <field name="duration"/>
            </tree>
        </field>
    </record>

    <record id="ir_profile_view_form" model="ir.ui.view">
        <field name="name">IR Profile Form</field>
        <field name="model">ir.profile</field>
        <field name="arch" type="xml">
            <form string="IR Profile">
                <group>
                    <field name="name"/>
                    <field name="session"/>
                    <field name="entry_count"/>
                    <!-- Do not rely on sql field for the invisible attrs to avoid fetching whole trace from server. -->
                    <field name="sql_count" invisible="sql_count == 0"/>
                    <field name="speedscope_url" widget="url"/>
                </group>
                <group invisible="not qweb">
                    <field name="qweb" widget="profiling_qweb_view" nolabel="1" colspan="2"/>
                </group>
            </form>
        </field>
    </record>

    <record id="enable_profiling_wizard" model="ir.ui.view">
        <field name="name">Enable profiling</field>
        <field name="model">base.enable.profiling.wizard</field>
        <field name="arch" type="xml">
            <form string="Enable profiling">
                <div class="alert alert-warning" role="alert">
                    <h3>Profiling is currently disabled.</h3>
                    Profiling is a developer feature that should be used with caution on production database.
                    It may add some load on the server, and potentially make it less responsive.
                    Enabling the profiling here allows all users to activate profiling on their session.
                    Profiling can be disabled at any moment in the settings.
                </div>
                <group>
                    <field name="duration"/>
                    <field name="expiration"/>
                </group>
                <footer>
                    <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x"/>
                    <button string="Enable profiling" type="object" name="submit" class="btn btn-primary" data-hotkey="q"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_menu_ir_profile" model="ir.actions.act_window">
        <field name="name">Ir profile</field>
        <field name="res_model">ir.profile</field>
        <field name="view_mode">tree,form</field>
        <field name="context">{'search_default_group_session': 1}</field>
    </record>

    <menuitem
        name="Profiling"
        action="action_menu_ir_profile"
        id="menu_ir_profile"
        parent="base.next_id_9"/>

</odoo>

```

  File: views/ir_property_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- Properties -->
        <record id="ir_property_view_search" model="ir.ui.view">
            <field name="name">ir.property.search</field>
            <field name="model">ir.property</field>
            <field name="arch" type="xml">
                <search string="Parameters">
                    <field name="name" string="Name"/>
                    <filter string="Generic" name="generic"
                        help="Parameters that are used by all resources."
                        domain="[('res_id','=',False)]"/>
                    <field name="fields_id"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                </search>
            </field>
        </record>
        <record id="ir_property_view" model="ir.ui.view">
            <field name="name">ir.property.form</field>
            <field name="model">ir.property</field>
            <field name="arch" type="xml">
                <form string="Parameters">
                  <sheet>
                    <group col="4">
                        <field name="name"/>
                        <field name="company_id" groups="base.group_multi_company"/>
                        <newline/>
                        <field name="fields_id"/>
                        <field name="type"/>
                        <field name="res_id"/>
                    </group>
                    <group>
	                    <field name="value_integer" string="Value" invisible="type not in ('integer', 'boolean')"/>
	                    <field name="value_float" string="Value" invisible="type != 'float'"/>
	                    <field name="value_datetime" string="Value" invisible="type not in ('date', 'datetime')"/>
	                    <field name="value_text" string="Value" invisible="type not in ('char', 'text', 'selection')"/>
	                    <field name="value_reference" string="Value" invisible="type != 'many2one'"/>
	                    <field name="value_binary" string="Value" invisible="type != 'binary'"/>
                    </group>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="ir_property_view_tree" model="ir.ui.view">
            <field name="name">ir.property.tree</field>
            <field name="model">ir.property</field>
            <field name="arch" type="xml">
                <tree string="Parameters">
                    <field name="name"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <field name="fields_id"/>
                    <field name="res_id"/>
                    <field name="type"/>
                </tree>
            </field>
        </record>
        <record id="ir_property_form" model="ir.actions.act_window">
            <field name="name">Company Properties</field>
            <field name="res_model">ir.property</field>
            <field name="view_id" ref="ir_property_view_tree"/>
        </record>
        <menuitem id="menu_ir_property_form_all" parent="menu_ir_property" action="ir_property_form"/>
    </data>
</odoo>

```

  File: views/ir_qweb_widget_templates.xml
  Content:
```
<odoo>

<template id="contact_name">
    <div t-if="'name' in fields">
        <t t-if="object.name">
            <span itemprop="name" t-esc="name"/>
        </t>
        <t t-if="not object.name and object.parent_name">
            <span itemprop="name" t-esc="object.parent_name"/>
        </t>
        <t t-if="options.get('country_image') and 'country_id' in fields and object.country_id and object.country_id.image_url">
            <span t-field="object.country_id.image_url" t-options='{"widget": "image_url", "class": "country_flag"}'/>
        </t>
    </div>
</template>

<template id="contact">
    <address t-ignore="true" class="o_portal_address mb-0" itemscope="itemscope" itemtype="http://schema.org/Organization">
        <div t-if="not (('name' in fields) or (address and 'address' in fields) or (city and 'city' in fields) or (mobile and 'mobile' in fields) or (website and 'website' in fields) or (email and 'email' in fields))" class="css_non_editable_mode_hidden">
            --<span class="text-muted" t-esc="name"/>--
        </div>
        <t t-if="object.country_id.name_position != 'after'">
            <t t-call="base.contact_name"/>
        </t>
        <div class="gap-2" itemprop="address" itemscope="itemscope" itemtype="http://schema.org/PostalAddress">
            <div t-if="address and 'address' in fields" t-attf-class="d-flex align-items-baseline gap-1">
                <i t-if="not options.get('no_marker')" class="fa fa-map-marker fa-fw" role="img" aria-label="Address" title="Address"/>
                <span class="d-block w-100 lh-sm" itemprop="streetAddress" t-esc="address"/>
            </div>
            <div t-if="city and 'city' in fields" t-attf-class="d-flex align-items-baseline gap-1">
                <i t-if="not options.get('no_marker')" class="fa fa-map-marker fa-fw" role="img" aria-label="Address" title="Address"/>
                <span>
                    <div>
                        <span itemprop="addressLocality" t-esc="city"/>,
                        <span itemprop="addressCountry" t-esc="country_id"/>
                    </div>
                </span>
            </div>
            <div class="d-flex align-items-center gap-1" t-if="phone and 'phone' in fields">
                <i t-if="not options.get('no_marker') or options.get('phone_icons')" class='fa fa-phone fa-fw' role="img" aria-label="Phone" title="Phone"/> <span class="o_force_ltr" itemprop="telephone" t-esc="phone"/>
            </div>
            <div class="d-flex align-items-center gap-1" t-if="mobile and 'mobile' in fields">
                <i t-if="not options.get('no_marker') or options.get('phone_icons')" class='fa fa-mobile fa-fw' role="img" aria-label="Mobile" title="Mobile"/> <span class="o_force_ltr" itemprop="telephone" t-esc="mobile"/>
            </div>
            <div class="d-flex align-items-center gap-1" t-if="website and 'website' in fields">
                <i t-if="not options.get('no_marker')" class='fa fa-globe fa-fw' role="img" aria-label="Website" title="Website"/>
                <a t-att-href="website and '%s%s' % ('http://' if '://' not in website else '',website)"><span itemprop="website" t-esc="website"/></a>
            </div>
            <div class="d-flex align-items-center gap-1" t-if="email and 'email' in fields"><i t-if="not options.get('no_marker')" class='fa fa-envelope fa-fw' role="img" aria-label="Email" title="Email"/> <span class="text-break" itemprop="email" t-esc="email"/></div>
        </div>
        <div t-if="vat and 'vat' in fields"><span t-esc="vat_label"/>: <span itemprop="vatID" t-esc="vat"/></div>
        <t t-if="object.country_id and object.country_id.name_position == 'after'">
            <t t-call="base.contact_name"/>
        </t>
    </address>
</template>

<template id="no_contact">
    <address t-ignore="true" class="mb-0" itemscope="itemscope" itemtype="http://schema.org/Organization">
        <div itemprop="address" itemscope="itemscope" itemtype="http://schema.org/PostalAddress">
            <div class="d-flex align-items-baseline">
                <i t-if="not options.get('no_marker')" class="fa fa-map-marker fa-fw" role="img" aria-label="Address" title="Address"/>
                <span class="w-100 o_force_ltr d-block" t-out="options.get('null_text')"/>
            </div>
        </div>
    </address>
</template>

</odoo>

```

  File: views/ir_rule_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- Rules -->
        <record id="view_rule_form" model="ir.ui.view">
            <field name="model">ir.rule</field>
            <field name="arch" type="xml">
                <form string="Record rules">
                  <sheet>
                    <group>
                        <group string="General">
                            <field name="name"/>
                            <field name="model_id"/>
                            <field name="active" widget="boolean_toggle"/>
                        </group>
                        <group string="Access Rights">
                            <group>
                                <field name="perm_read"/>
                                <field name="perm_create"/>
                            </group>
                            <group>
                                <field name="perm_write"/>
                                <field name="perm_unlink"/>
                            </group>
                        </group>
                    </group>
                    <separator string="Rule Definition (Domain Filter)"/>
                    <field name="domain_force" colspan="2" nolabel="1"/>
                    <group string="Groups (no group = global)">
                        <field name="global"/>
                        <field name="groups" nolabel="1" colspan="2"/>
                    </group>
                    <i class="fa fa-info fa-3x text-info float-start" role="img" aria-label="Info" title="Info"/>
                    <h3>Interaction between rules</h3>
                    <div>
                      <p>
                         Global rules (non group-specific) are restrictions, and cannot be bypassed.
                         Group-specific rules grant additional permissions, but are constrained within the bounds of global ones.
                         The first group rules restrict further the global rules, but can be relaxed by additional group rules.
                      </p>
                      <p>
                        Detailed algorithm:
                        <ol>
                          <li>Global rules are combined together with a logical AND operator, and with the result of the following steps</li>
                          <li>Group-specific rules are combined together with a logical OR operator</li>
                          <li>If user belongs to several groups, the results from step 2 are combined with logical OR operator</li>
                        </ol>
                      </p>
                      <p>Example: GLOBAL_RULE_1 AND GLOBAL_RULE_2 AND ( (GROUP_A_RULE_1 OR GROUP_A_RULE_2) OR (GROUP_B_RULE_1 OR GROUP_B_RULE_2) )</p>
                    </div>
                   </sheet>
                </form>
            </field>
        </record>

        <record id="view_rule_tree" model="ir.ui.view">
            <field name="model">ir.rule</field>
            <field name="arch" type="xml">
                <tree string="Record Rules" decoration-info="not groups">
                    <field name="name"/>
                    <field name="model_id"/>
                    <field name="groups" widget="many2many_tags" options="{'no_create':True}"/>
                    <field name="domain_force"/>
                    <field name="perm_read" width="85px"/>
                    <field name="perm_write" width="85px"/>
                    <field name="perm_create" width="85px"/>
                    <field name="perm_unlink" width="85px"/>
                </tree>
            </field>
        </record>

        <record id="view_rule_search" model="ir.ui.view">
            <field name="model">ir.rule</field>
            <field name="arch" type="xml">
                <search string="Record Rules">
                    <field name="name" string="Record Rule"/>
                    <field name="domain_force"/>
                    <field name="model_id"/>
                    <field name="groups"/>
                    <filter string="Global" name="global" domain="[('global', '=', True)]"/>
                    <filter string="Group-based" name="group_based" domain="[('global', '=', False)]"/>
                    <separator/>
                    <filter string="Full Access" name="full_access_right" domain="[('perm_read', '=', True), ('perm_write', '=', True), ('perm_create', '=', True), ('perm_unlink', '=', True)]"/>
                    <filter string="Read" name="read_access_right" domain="[('perm_read', '=', True)]"/>
                    <filter string="Write" name="write_access_right" domain="[('perm_write', '=', True)]"/>
                    <filter string="Create" name="create_access_right" domain="[('perm_create', '=' ,True)]"/>
                    <filter string="Delete" name="delete_access_right" domain="[('perm_unlink', '=', True)]"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                    <group string="Group By">
                        <filter string="Model" name="group_by_object" domain="[]" context="{'group_by': 'model_id'}"/>
                        <separator/>
                        <filter string="Group" name="group_by_group" domain="[]" context="{'group_by': 'groups'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="action_rule" model="ir.actions.act_window">
            <field name="name">Record Rules</field>
            <field name="res_model">ir.rule</field>
            <field name="view_id" ref="view_rule_tree"/>
            <field name="search_view_id" ref="view_rule_search"/>
        </record>

        <menuitem action="action_rule" id="menu_action_rule" parent="base.menu_security" sequence="3"/>


        <record id="property_rule" model="ir.rule">
            <field name="name">Property multi-company</field>
            <field name="model_id" ref="model_ir_property"/>
            <field eval="True" name="global"/>
            <field name="domain_force">[('company_id', 'in', company_ids + [False])]</field>
        </record>


</odoo>

```

  File: views/ir_sequence_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- Sequences -->
        <record id="sequence_view" model="ir.ui.view">
            <field name="model">ir.sequence</field>
            <field name="arch" type="xml">
                <form string="Sequences">
                  <sheet>
                    <group>
                      <group>
                        <field name="name"/>
                        <field name="implementation"/>
                      </group>
                      <group>
                        <field name="code"/>
                        <field name="active" widget="boolean_toggle"/>
                        <field name="company_id" groups="base.group_multi_company"/>
                      </group>
                    </group>
                    <notebook>
                    <page string="Sequence" name="sequence">
                        <group>
                          <group>
                            <field name="prefix"/>
                            <field name="suffix"/>
                            <field name="use_date_range"/>
                          </group>
                          <group>
                            <field name="padding"/>
                            <field name="number_increment"/>
                            <field name="number_next_actual" string="Next Number" invisible="use_date_range"/>
                          </group>
                        </group>
                        <field name="date_range_ids" invisible="not use_date_range">
                            <tree string="Sequences" editable="top">
                                <field name="date_from"/>
                                <field name="date_to"/>
                                <field name="number_next_actual" string="Next Number"/>
                            </tree>
                        </field>
                        <group col="3" string="Legend (for prefix, suffix)">
                            <group>
                                <span colspan="2">Current Year with Century: %%(year)s</span>
                                <span colspan="2">Current Year without Century: %%(y)s</span>
                                <span colspan="2">Month: %%(month)s</span>
                                <span colspan="2">Day: %%(day)s</span>
                            </group>
                            <group>
                                <span colspan="2">Day of the Year: %%(doy)s</span>
                                <span colspan="2">Week of the Year: %%(woy)s</span>
                                <span colspan="2">Day of the Week (0:Monday): %%(weekday)s</span>
                            </group>
                            <group>
                                <span colspan="2">Hour 00->24: %%(h24)s</span>
                                <span colspan="2">Hour 00->12: %%(h12)s</span>
                                <span colspan="2">Minute: %%(min)s</span>
                                <span colspan="2">Second: %%(sec)s</span>
                            </group>
                        </group>
                        <group invisible="not use_date_range">
                            <div colspan="2">
                                When subsequences per date range are used, you can prefix variables with 'range_'
                                to use the beginning of the range instead of the current date, e.g. %%(range_year)s instead of %%(year)s.
                            </div>
                        </group>
                    </page>
                    </notebook>
                   </sheet>
                </form>
            </field>
        </record>

        <record id="sequence_view_tree" model="ir.ui.view">
            <field name="model">ir.sequence</field>
            <field name="arch" type="xml">
                <tree string="Sequences">
                    <field name="code"/>
                    <field name="name"/>
                    <field name="prefix"/>
                    <field name="padding"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <field name="number_next_actual" string="Next Number"/>
                    <field name="number_increment"/>
                    <field name="implementation"/>
                </tree>
            </field>
        </record>

        <record id="view_sequence_search" model="ir.ui.view">
            <field name="model">ir.sequence</field>
            <field name="arch" type="xml">
                <search string="Sequences">
                    <field name="name" string="Sequence"/>
                    <field name="code"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record id="ir_sequence_form" model="ir.actions.act_window">
            <field name="name">Sequences</field>
            <field name="res_model">ir.sequence</field>
            <field name="view_id" ref="sequence_view_tree"/>
            <field name="context">{'active_test': False}</field>
        </record>

        <menuitem action="ir_sequence_form" id="menu_ir_sequence_form" parent="next_id_5"/>

</odoo>

```

  File: views/ir_ui_menu_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <record id="edit_menu_access" model="ir.ui.view">
            <field name="model">ir.ui.menu</field>
            <field name="arch" type="xml">
                <form string="Menu">
                    <sheet>
                        <field name="active" invisible="1"/>
                        <group>
                            <group>
                                <field name="name"/>
                                <field name="parent_id" groups="base.group_no_one"/>
                                <field name="sequence" groups="base.group_no_one"/>
                            </group>
                            <group groups="base.group_no_one">
                                <field name="complete_name"/>
                                <field name="action"/>
                                <field name="web_icon"/>
                                <field name="web_icon_data"/>
                            </group>
                        </group>
                        <notebook>
                            <page string="Visibility" name="access_rights">
                                <field name="groups_id"/>
                            </page>
                            <page string="Submenus" name="submenus" groups="base.group_no_one">
                                <!-- Note: make sure you have 'ir.ui.menu.full_list'
                                    in the context to see all submenus! -->
                                <field name="child_id" context="{'default_parent_id': id}">
                                    <tree string="Menu">
                                        <field name="sequence"/>
                                        <field icon="icon" name="name" string="Menu"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                   </sheet>
                </form>
            </field>
        </record>

        <record id="edit_menu" model="ir.ui.view">
            <field name="model">ir.ui.menu</field>
            <field name="priority" eval="8"/>
            <field name="arch" type="xml">
                <tree string="Menu">
                    <field name="sequence" widget='handle'/>
                    <field icon="icon" name="complete_name" string="Menu"/>
                </tree>
            </field>
        </record>

        <record id="edit_menu_access_search" model="ir.ui.view">
            <field name="name">ir.ui.menu.search</field>
            <field name="model">ir.ui.menu</field>
            <field name="arch" type="xml">
                <search string="Menu">
                    <field name="name" string="Menu"/>
                    <field name="parent_id"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record id="grant_menu_access" model="ir.actions.act_window">
            <field name="name">Menu Items</field>
            <field name="res_model">ir.ui.menu</field>
            <field name="view_id" ref="edit_menu"/>
            <field name="context">{'ir.ui.menu.full_list':True}</field>
            <field name="search_view_id" ref="edit_menu_access_search"/>
            <field name="help">Manage and customize the items available and displayed in your Odoo system menu. You can delete an item by clicking on the box at the beginning of each line and then delete it through the button that appeared. Items can be assigned to specific groups in order to make them accessible to some users within the system.</field>
        </record>

        <menuitem action="grant_menu_access" id="menu_grant_menu_access" parent="base.next_id_2" sequence="1"/>

</odoo>

```

  File: views/ir_ui_view_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <!-- View -->
        <record id="view_view_form" model="ir.ui.view">
            <field name="model">ir.ui.view</field>
            <field name="arch" type="xml">
                <form string="Views">
                  <sheet>
                    <group>
                        <group>
                            <field name="name"/>
                            <field name="type"/>
                            <field name="model" invisible="True"/>
                            <field name="model_id"/>
                            <field name="priority"/>
                            <field name="active" widget="boolean_toggle"/>
                        </group>
                        <group groups="base.group_no_one">
                            <field name="inherit_id"/>
                            <field name="mode"/>
                            <field name="model_data_id"/>
                            <field name="xml_id" class="text-break"/>
                        </group>
                    </group>
                    <div class="oe_edit_only alert alert-info" role="alert">
                        Be aware that editing the architecture of a standard view is not advised, since the changes will be overwritten during future module updates.<br/>
                        We recommend applying modifications to standard views through inherited views or customization with Odoo Studio.
                    </div>
                    <notebook>
                        <page string="Architecture" name="architecture">
                            <field name="arch_db" class="oe_edit_only oe_no_translation_content"/>
                            <field name="arch_base" string="View Architecture" widget="code" options="{'mode': 'xml'}" required="1"/>
                        </page>
                        <page string="Access Rights" name="access_rights">
                            <field name="groups_id"/>
                        </page>
                        <page name="inherit_children" string="Inherited Views">
                            <field name="inherit_children_ids" context="{'default_model':model,'default_type':type,'default_inherit_id':id,'default_mode':'extension', 'active_test': False}">
                                <tree default_order="priority,id" decoration-muted="not active">
                                    <field name="active" column_invisible="True"/>
                                    <field name="id"/>
                                    <field name="priority"/>
                                    <field name="name"/>
                                    <field name="xml_id"/>
                                </tree>
                            </field>
                        </page>
                    </notebook>
                  </sheet>
                </form>
            </field>
        </record>

        <record id="view_view_tree" model="ir.ui.view">
            <field name="model">ir.ui.view</field>
            <field name="arch" type="xml">
                <tree string="Views">
                    <field name="priority" string="Sequence" widget="handle"/>
                    <field name="name"/>
                    <field name="type"/>
                    <field name="model"/>
                    <field name="xml_id" groups="base.group_no_one"/>
                    <field name="inherit_id"/>
                </tree>
            </field>
        </record>

        <record id="view_view_search" model="ir.ui.view">
            <field name="model">ir.ui.view</field>
            <field name="arch" type="xml">
                <search string="Views">
                    <field name="name" filter_domain="['|', '|', ('name','ilike',self), ('model','ilike',self), ('model_data_id','ilike',self)]" string="View"/>
                    <field name="key"/>
                    <field name="model"/>
                    <field name="inherit_id"/>
                    <field name="type"/>
                    <field name="arch_db" string="View Architecture"/>
                    <filter string="Form" name="form" domain="[('type', '=','form')]"/>
                    <filter string="Tree" name="tree" domain="[('type', '=', 'tree')]"/>
                    <filter string="Kanban" name="kanban" domain="[('type', '=', 'kanban')]"/>
                    <filter string="Search" name="search" domain="[('type', '=', 'search')]"/>
                    <filter string="QWeb" name="qweb" domain="[('type', '=', 'qweb')]"/>
                    <separator/>
                    <filter string="Modified Architecture" name="arch_updated" domain="[('arch_updated', '=',True)]"/>
                    <separator/>
                    <filter string="Active" name="active" domain="[('active', '=',True)]"/>
                    <filter string="Inactive" name="inactive" domain="[('active', '=',False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Model" name="object" domain="[]" context="{'group_by':'model'}"/>
                        <filter string="Type" name="type" domain="[]" context="{'group_by':'type'}"/>
                        <filter string="Inherit" name="inherit" domain="[]" context="{'group_by':'inherit_id'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="action_ui_view" model="ir.actions.act_window">
            <field name="name">Views</field>
            <field name="res_model">ir.ui.view</field>
            <field name="view_id" ref="view_view_tree"/>
            <field name="context">{'search_default_active': 1}</field>
            <field name="help">Views allows you to personalize each view of Odoo. You can add new fields, move fields, rename them or delete the ones that you do not need.</field>
        </record>

        <menuitem action="action_ui_view" id="menu_action_ui_view" parent="base.next_id_2" sequence="2"/>

        <!-- Reset view wizard -->
        <record id="reset_view_arch_wizard_view" model="ir.ui.view">
            <field name="name">Reset View Architecture</field>
            <field name="model">reset.view.arch.wizard</field>
            <field name="arch" type="xml">
                <form string="Reset View Architecture">
                    <group>
                        <group>
                            <field name="has_diff" invisible="1"/>
                            <field name="view_id" invisible="1"/>
                            <field name="view_name"/>
                            <field name="compare_view_id" invisible="reset_mode != 'other_view'" options="{'no_create': True, 'no_open': True}"/>
                        </group>
                        <group>
                            <field name="reset_mode" widget="radio"/>
                        </group>
                    </group>
                    <field name="arch_diff" invisible="not arch_diff"/>
                    <div class="alert alert-warning my-2" role="alert" invisible="arch_diff">
                        <span invisible="reset_mode != 'soft'">This view has no previous version.</span>
                        <span invisible="reset_mode != 'hard'">This view is not coming from a file.</span>
                        <span invisible="reset_mode != 'other_view'">You need two views to compare.</span>
                    </div>
                    <footer>
                        <button string="Reset View" name="reset_view_button" type="object" class="btn-primary" invisible="not has_diff" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x" />
                    </footer>
                </form>
            </field>
        </record>

        <record id="reset_view_arch_wizard_action" model="ir.actions.act_window">
            <field name="name">Compare/Reset</field>
            <field name="res_model">reset.view.arch.wizard</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
            <field name="binding_model_id" ref="model_ir_ui_view"/>
            <field name="binding_view_types">form,list</field>
        </record>

        <!-- View customizations -->
        <record id="view_view_custom_form" model="ir.ui.view">
            <field name="model">ir.ui.view.custom</field>
            <field name="arch" type="xml">
                <form string="Customized Views">
                  <sheet>
                    <group col="4">
                        <field name="user_id"/>
                        <field name="ref_id"/>
                        <separator string="View Architecture" colspan="4" />
                        <field name="arch" colspan="4" nolabel="1"/>
                    </group>
                   </sheet>
                </form>
            </field>
        </record>

        <record id="view_view_custom_tree" model="ir.ui.view">
            <field name="model">ir.ui.view.custom</field>
            <field name="arch" type="xml">
                <tree string="Customized Views">
                    <field name="user_id"/>
                    <field name="ref_id"/>
                </tree>
            </field>
        </record>

        <record id="view_view_custom_search" model="ir.ui.view">
            <field name="model">ir.ui.view.custom</field>
            <field name="arch" type="xml">
                <search string="Customized Views">
                    <field name="user_id"/>
                    <field name="ref_id"/>
                </search>
            </field>
        </record>

        <record id="action_ui_view_custom" model="ir.actions.act_window">
            <field name="name">Customized Views</field>
            <field name="res_model">ir.ui.view.custom</field>
            <field name="help" type="html"><p class="o_view_nocontent_smiling_face">Create a customized view</p><p>Customized views are used when users reorganize the content of their dashboard views (via web client)</p></field>
        </record>

        <menuitem id="menu_action_ui_view_custom" action="action_ui_view_custom" parent="base.next_id_2" sequence="3"/>

</odoo>

```

  File: views/report_paperformat_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!-- report.paperformat -->
        <record id="paperformat_view_tree" model="ir.ui.view">
            <field name="name">paper_format_view_tree</field>
            <field name="model">report.paperformat</field>
            <field name="arch" type="xml">
                <tree string="Paper format configuration">
                    <field name="name" />
                </tree>
            </field>
        </record>
        <record id="paperformat_view_form" model="ir.ui.view">
            <field name="name">paper_format_view_form</field>
            <field name="model">report.paperformat</field>
            <field name="arch" type="xml">
                <form string="Paper format configuration">
                <sheet>
                    <group>
                        <field name="name" />
                        <field name="format" />
                        <field name="page_height" invisible="format != 'custom'" />
                        <field name="page_width" invisible="format != 'custom'" />
                        <field name="orientation" />
                        <field name="margin_top" />
                        <field name="margin_bottom" />
                        <field name="margin_left" />
                        <field name="margin_right" />
                        <field name="header_line" />
                        <field name="header_spacing" />
                        <field name="disable_shrinking" />
                        <field name="dpi" />
                        <field name="report_ids" widget="many2many_tags" options="{'not_delete': True}"/>
                    </group>
                </sheet>
                </form>
            </field>
        </record>
        <record id="paper_format_action" model="ir.actions.act_window">
            <field name="name">Paper Format General Configuration</field>
            <field name="res_model">report.paperformat</field>
            <field name="view_mode">tree,form</field>
        </record>
        <record id='reports_action' model='ir.actions.act_window'>
            <field name="name">Reports</field>
            <field name="res_model">ir.actions.report</field>
            <field name="view_mode">tree,form</field>
        </record>
        <menuitem
            id="reporting_menuitem"
            name="Reporting"
            parent="base.menu_custom"
            sequence="15"
            groups="base.group_no_one"
            />
        <menuitem
            id="paper_format_menuitem"
            name="Paper Format"
            parent="reporting_menuitem"
            action="paper_format_action"
            sequence="2"
            groups="base.group_no_one"
            />
        <menuitem
            id="reports_menuitem"
            name="Reports"
            parent="reporting_menuitem"
            action="reports_action"
            sequence="3"
            groups="base.group_no_one"
            />
    </data>
</odoo>

```

  File: views/res_bank_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="view_res_bank_form" model="ir.ui.view">
            <field name="name">res.bank.form</field>
            <field name="model">res.bank</field>
            <field name="arch" type="xml">
                <form string="Bank">
                    <sheet>
                        <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger" invisible="active"/>
                        <group name="bank_details" col="4">
                            <field name="name"/>
                            <field name="bic"/>
                        </group>
                        <group>
                            <group name="address_details">
                                <label for="street" string="Bank Address"/>
                                <div class="o_address_format">
                                    <field name="street" placeholder="Street..." class="o_address_street"/>
                                    <field name="street2" placeholder="Street 2..." class="o_address_street"/>
                                    <field name="city" placeholder="City" class="o_address_city"/>
                                    <field name="state" class="o_address_state" placeholder="State" options='{"no_open": True}'/>
                                    <field name="zip" placeholder="ZIP" class="o_address_zip"/>
                                    <field name="country" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'/>
                                </div>
                            </group>
                            <group name="communication_details">
                                <field name="phone" class="o_force_ltr"/>
                                <field name="email" widget="email"/>
                                <field name="active" invisible="1"/>
                            </group>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_res_bank_tree" model="ir.ui.view">
            <field name="name">res.bank.tree</field>
            <field name="model">res.bank</field>
            <field name="arch" type="xml">
                <tree string="Banks">
                    <field name="name"/>
                    <field name="bic"/>
                    <field name="country"/>
                </tree>
            </field>
        </record>

        <record id="res_bank_view_search" model="ir.ui.view">
            <field name="name">res.bank.view.search</field>
            <field name="model">res.bank</field>
            <field name="arch" type="xml">
                <search string="Search Bank">
                    <field name="name"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record id="action_res_bank_form" model="ir.actions.act_window">
            <field name="name">Banks</field>
            <field name="res_model">res.bank</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="res_bank_view_search"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a Bank
              </p><p>
                Banks are the financial institutions at which you and your contacts have their accounts.
              </p>
            </field>
        </record>

        <record id="view_partner_bank_form" model="ir.ui.view">
            <field name="name">res.partner.bank.form</field>
            <field name="model">res.partner.bank</field>
            <field name="priority">15</field>
            <field name="arch" type="xml">
                <form string="Bank account" name="bank_account_form">
                <sheet>
                    <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger" invisible="active"/>
                    <group>
                        <group>
                            <field name="sequence" invisible="1"/>
                            <field name="acc_type" invisible="1"/>
                            <field name="acc_number"/>
                            <field name="bank_id"/>
                            <field name="acc_holder_name"/>
                            <field name="partner_id"/>
                        </group>
                        <group>
                            <field name="company_id" groups="base.group_multi_company" options="{'no_create': True}"/>
                            <field name="currency_id" groups="base.group_multi_currency" options="{'no_create': True}"/>
                            <field name="allow_out_payment" widget="boolean_toggle"/>
                            <field name="active" invisible="1"/>
                        </group>
                    </group>
                </sheet>
                </form>
            </field>
        </record>

        <record id="view_partner_bank_tree" model="ir.ui.view">
            <field name="name">res.partner.bank.tree</field>
            <field name="model">res.partner.bank</field>
            <field name="arch" type="xml">
                <tree string="Bank Accounts" multi_edit="1">
                    <field name="sequence" widget="handle"/>
                    <field name="acc_number"/>
                    <field name="bank_name" string="Bank"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <field name="partner_id"/>
                    <field name="acc_holder_name" column_invisible="True"/>
                    <field name="allow_out_payment" widget="boolean_toggle"/>
                </tree>
            </field>
        </record>

        <record id="view_partner_bank_search" model="ir.ui.view">
            <field name="name">res.partner.bank.search</field>
            <field name="model">res.partner.bank</field>
            <field name="arch" type="xml">
                <search string="Bank Accounts">
                    <field name="bank_name" filter_domain="['|', ('bank_name','ilike',self), ('acc_number','ilike',self)]" string="Bank Name"/>
                    <field name="company_id" invisible="context.get('company_hide', True)"/>
                    <field name="partner_id"/>
                </search>
            </field>
        </record>

        <record id="action_res_partner_bank_account_form" model="ir.actions.act_window">
            <field name="name">Bank Accounts</field>
            <field name="res_model">res.partner.bank</field>
            <field name="view_mode">tree,form</field>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a Bank Account
              </p><p>
                From here you can manage all bank accounts linked to you and your contacts.
              </p>
            </field>
        </record>

    </data>
</odoo>

```

  File: views/res_company_views.xml
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <record id="view_company_form" model="ir.ui.view">
            <field name="name">res.company.form</field>
            <field name="model">res.company</field>
            <field name="arch" type="xml">
                <form string="Company" duplicate="0">
                  <field name="all_child_ids" invisible="1"/>
                  <sheet>
                    <div class="oe_button_box" name="button_box">
                        <button class="oe_stat_button"
                                name="action_all_company_branches"
                                type="object"
                                invisible="not all_child_ids"
                                icon="fa-sitemap"
                                string="Branches"/>
                    </div>
                    <field name="logo" widget="image" class="oe_avatar"/>
                    <div class="oe_title">
                        <label for="name"/>
                        <h1>
                            <field name="name" placeholder="e.g. My Company"/>
                        </h1>
                    </div>
                    <notebook colspan="4">
                        <page string="General Information" name="general_info">
                            <group>
                                <group>
                                    <field name="partner_id" string="Contact" readonly="1" required="0" groups="base.group_no_one"/>
                                    <label for="street" string="Address"/>
                                    <div class="o_address_format">
                                        <field name="street" placeholder="Street..." class="o_address_street"/>
                                        <field name="street2" placeholder="Street 2..." class="o_address_street"/>
                                        <field name="city" placeholder="City" class="o_address_city"/>
                                        <field name="state_id" class="o_address_state" placeholder="State" options='{"no_open": True}'/>
                                        <field name="zip" placeholder="ZIP" class="o_address_zip"/>
                                        <field name="country_id" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'/>
                                    </div>
                                    <field name="vat"/>
                                    <field name="company_registry"/>
                                    <field name="currency_id" options="{'no_create': True, 'no_open': True}" id="company_currency" context="{'active_test': False}"/>
                                </group>
                                <group>
                                    <field name="phone" class="o_force_ltr"/>
                                    <field name="mobile" class="o_force_ltr"/>
                                    <field name="email"/>
                                    <field name="website" string="Website" widget="url" placeholder="e.g. https://www.odoo.com"/>
                                    <field name="parent_id" groups="base.group_no_one"/>
                                    <field name="parent_id" invisible="1"/>
                                    <field name="sequence" invisible="1"/>
                                    <field name="color" widget="color_picker"/>
                                </group>
                                <group name="social_media"/>
                            </group>
                        </page>
                        <page string="Branches" name="branches">
                            <field name="child_ids" nolabel="1" context="{'default_parent_id': id}"/>
                        </page>
                    </notebook>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_company_tree" model="ir.ui.view">
            <field name="name">res.company.tree</field>
            <field name="model">res.company</field>
            <field name="arch" type="xml">
                <tree string="Companies" decoration-muted="not active">
                    <field name="sequence" widget="handle"/>
                    <field name="name"/>
                    <field name="partner_id" required="0"/>
                    <field name="child_ids" widget="many2many_tags" options="{'color_field': 'color'}"/>
                    <field name="active" column_invisible="True"/>
                </tree>
            </field>
        </record>
        <record id="view_res_company_kanban" model="ir.ui.view">
            <field name="name">res.company.kanban</field>
            <field name="model">res.company</field>
            <field name="arch" type="xml">
                <kanban>
                    <field name="name"/>
                    <field name="email"/>
                    <field name="phone"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div t-attf-class="oe_kanban_global_click">
                                <div t-attf-class="#{!selection_mode ? 'text-center' : ''}">
                                    <i class="fa fa-building" role="img" aria-label="Enterprise" title="Enterprise"></i> <strong><field name="name"/></strong>
                                </div>
                                <hr class="mt4 mb4"/>
                                <div class="row" t-if="!selection_mode">
                                    <div t-if="record.email.value" class="col-6 text-center">
                                        <strong>Email:</strong>
                                    </div>
                                    <div t-if="record.phone.value" class="col-6 text-center">
                                        <strong>Phone</strong>
                                    </div>
                                    <div t-if="record.email.value" class="col-6 text-center">
                                        <field name="email"/>
                                    </div>
                                    <div t-if="record.phone.value" class="col-6 text-center o_force_ltr">
                                        <field name="phone"/>
                                    </div>
                                </div>
                                <div t-else="">
                                    <div t-if="record.email.value">
                                        <strong>Email:</strong>
                                        <field name="email"/>
                                    </div>
                                    <div t-if="record.phone.value" class="o_force_ltr">
                                        <strong>Phone:</strong>
                                        <field name="phone"/>
                                    </div>
                                </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>
        <record id="action_res_company_form" model="ir.actions.act_window">
            <field name="name">Companies</field>
            <field name="res_model">res.company</field>
            <field name="view_mode">tree,kanban,form</field>
            <field name="domain">[('parent_id', '=', False)]</field>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a new company
              </p><p>
                Create and manage the companies that will be managed by Odoo from here. Shops or subsidiaries can be created and maintained from here.
              </p>
            </field>
        </record>
        <menuitem action="action_res_company_form" id="menu_action_res_company_form" parent="base.menu_users"/>
    </data>
</odoo>

```

  File: views/res_config_settings_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="res_config_settings_view_form" model="ir.ui.view">
            <field name="name">res.config.settings.view.form</field>
            <field name="model">res.config.settings</field>
            <field name="arch" type="xml">
                <form string="Settings" class="oe_form_configuration" js_class="base_settings">
                </form>
            </field>
        </record>
        <record id="res_config_setting_act_window" model="ir.actions.act_window">
            <field name="name">Settings</field>
            <field name="res_model">res.config.settings</field>
            <field name="view_mode">form</field>
            <field name="target">inline</field>
        </record>
    </data>
</odoo>

```

  File: views/res_config_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        
        <record id="res_config_view_base" model="ir.ui.view">
            <field name="name">res.config.view.base</field>
            <field name="model">res.config</field>
            <field name="arch" type="xml">
                <form string="Configuration">
                    <group name="res_config_contents"/>
                    <footer>
                        <button name="action_next" type="object" string="Apply" class="btn-primary" data-hotkey="q"/>
                        <button name="action_skip" type="object" special="cancel" data-hotkey="x" string="Cancel" class="btn-secondary"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="res_config_installer" model="ir.ui.view">
            <field name="name">Inheritable view for installer objects</field>
            <field name="model">res.config.installer</field>
            <field name="arch" type="xml">
                <form string="Configuration Installer">
                    <separator string="title" colspan="4"/>
                    <footer>
                        <button name="action_next" type="object" string="Install Apps" class="btn-primary" data-hotkey="q"/>
                        <button string="Skip" class="btn-secondary" special="cancel" data-hotkey="x"/>
                    </footer>
                </form>
            </field>
        </record>

    </data>
</odoo>

```

  File: views/res_country_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <!--
        Country
        -->
        <record id="view_country_tree" model="ir.ui.view">
            <field name="name">res.country.tree</field>
            <field name="model">res.country</field>
            <field name="arch" type="xml">
                <tree string="Country" create="0" delete="0">
                    <field name="name"/>
                    <field name="code"/>
                </tree>
            </field>
        </record>

        <record id="view_country_form" model="ir.ui.view">
            <field name="name">res.country.form</field>
            <field name="model">res.country</field>
            <field name="arch" type="xml">
                <form create="0" delete="0">
                    <sheet>
                        <div class="oe_button_box" name="button_box">
                        </div>
                        <field name="image_url" widget="image_url" class="oe_avatar" options="{'size': [128,128]}"/>
                        <group name="main_group">
                            <group name="country_details">
                                <field name="name"/>
                                <field name="currency_id"/>
                                <field name="code"/>
                            </group>
                            <group name="phone_vat_settings">
                                <field name="phone_code" options="{'format': false}"/>
                                <field name="vat_label"/>
                                <field name="zip_required"/>
                                <field name="state_required"/>
                            </group>
                        </group>
                        <group name="advanced_address_formatting" string="Advanced Address Formatting" groups="base.group_no_one">
                            <label for="address_view_id"/>
                            <div class="o_row">
                                <field name="address_view_id"/>
                                <div class="text-muted ms-2">Choose a subview of partners that includes only address fields, to change the way users can input addresses.</div>
                            </div>
                            <label for="address_format"/>
                            <div class="o_row">
                                <field name="address_format" placeholder="Address format..."/>
                                <div name="div_address_format ms-2" class="text-muted">Change the way addresses are displayed in reports</div>
                            </div>
                            <field name="name_position" class="oe_inline"/>
                        </group>
                        <label for="state_ids"/>
                        <field name="state_ids">
                            <tree editable="bottom">
                                <field name="name"/>
                                <field name="code"/>
                            </tree>
                        </field>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_country_search" model="ir.ui.view">
            <field name="name">res.country.search</field>
            <field name="model">res.country</field>
            <field name="arch" type="xml">
                <search string="Countries">
                    <field name="name" filter_domain="['|', ('name', 'ilike', self), ('code', 'ilike', self)]"/>
                    <field name="phone_code"/>
                </search>
            </field>
        </record>

        <record id="action_country" model="ir.actions.act_window">
            <field name="name">Countries</field>
            <field name="res_model">res.country</field>
            <field name="help" type="html">
                <p class="o_view_nocontent_smiling_face">
                    No Country Found!
                </p><p>
                    Manage the list of countries that can be set on your contacts.
                </p>
            </field>
        </record>

        <record id="view_country_group_tree" model="ir.ui.view">
            <field name="name">res.country.group.tree</field>
            <field name="model">res.country.group</field>
            <field name="arch" type="xml">
                <tree string="Country Group">
                    <field name="name"/>
                </tree>
            </field>
        </record>

        <record id="view_country_group_form" model="ir.ui.view">
            <field name="name">res.country.group.form</field>
            <field name="model">res.country.group</field>
            <field name="arch" type="xml">
                <form string="Country Group">
                    <sheet>
                        <div class="oe_title">
                            <label for="name" string="Group Name"/>
                            <h1><field name="name" placeholder="e.g. Europe"/></h1>
                        </div>
                        <group name="country_group">
                            <field name="country_ids" widget="many2many_tags" options="{'no_open': True, 'no_create': True}"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="action_country_group" model="ir.actions.act_window">
            <field name="name">Country Group</field>
            <field name="res_model">res.country.group</field>
            <field name="help" type="html">
                <p class="o_view_nocontent_smiling_face">
                    Create a Country Group
                </p><p>
                    Use groups to organize countries that are frequently selected together (e.g. "LATAM", "BeNeLux", "ASEAN").
                </p>
            </field>
        </record>

        <!-- State -->
        <record id="view_country_state_tree" model="ir.ui.view">
            <field name="name">res.country.state.tree</field>
            <field name="model">res.country.state</field>
            <field name="arch" type="xml">
                <tree string="State" editable="bottom">
                    <field name="name"/>
                    <field name="code"/>
                    <field name="country_id" options="{'no_create': True, 'no_open': True}"/>
                </tree>
            </field>
        </record>

        <record id="view_country_state_form" model="ir.ui.view">
            <field name="name">res.country.state.form</field>
            <field name="model">res.country.state</field>
            <field name="arch" type="xml">
                <form string="State">
                    <sheet>
                        <group>
                            <field name="name"/>
                            <field name="code"/>
                            <field name="country_id" options='{"no_open": True, "no_create": True}'/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_country_state_search" model="ir.ui.view">
            <field name="name">res.country.state.search</field>
            <field name="model">res.country.state</field>
            <field name="arch" type="xml">
                <search string="Country">
                    <field name="name"/>
                    <field name="country_id"/>
                    <group string="Group By">
                        <filter name="groupby_country" string="Country" context="{'group_by': 'country_id'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="action_country_state" model="ir.actions.act_window">
            <field name="name">Fed. States</field>
            <field name="res_model">res.country.state</field>
            <field name="view_id" ref="view_country_state_tree"/>
            <field name="help" type="html">
                <p class="o_view_nocontent_smiling_face">
                    Create a State
                </p><p>
                    Federal States belong to countries and are part of your contacts' addresses.
                </p>
            </field>
        </record>

    </data>
</odoo>

```

  File: views/res_currency_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="view_currency_rate_search" model="ir.ui.view">
            <field name="name">res.currency.rate.search</field>
            <field name="model">res.currency.rate</field>
            <field name="arch" type="xml">
                <search string="Currency Rates">
                    <field name="name" string="Date"/>
                </search>
            </field>
        </record>

        <record id="view_currency_rate_tree" model="ir.ui.view">
            <field name="name">res.currency.rate.tree</field>
            <field name="model">res.currency.rate</field>
            <field name="arch" type="xml">
                <tree string="Currency Rates" editable="bottom">
                    <field name="name"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                    <field name="company_rate" digits="[12,12]"/>
                    <field name="inverse_company_rate" digits="[12,12]"/>
                    <field name="rate" digits="[12,12]" optional="hide"/>
                    <field name="write_date" optional="hide"/>
                </tree>
            </field>
        </record>

        <record id="view_currency_rate_form" model="ir.ui.view">
            <field name="name">res.currency.rate.form</field>
            <field name="model">res.currency.rate</field>
            <field name="arch" type="xml">
                <form string="Currency Rate">
                    <sheet>
                        <group>
                            <group>
                                <field name="name"/>
                                <field name="rate" digits="[12,12]" groups="base.group_no_one"/>
                                <field name="company_rate" digits="[12,12]"/>
                                <field name="inverse_company_rate" digits="[12,12]"/>
                            </group>
                            <group>
                                <field name="currency_id"/>
                                <field name="company_id" groups="base.group_multi_company"/>
                            </group>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="act_view_currency_rates" model="ir.actions.act_window">
            <field name="name">Show Currency Rates</field>
            <field name="res_model">res.currency.rate</field>
            <field name='view_mode'>tree,form</field>
            <field name='view_id' ref='view_currency_rate_tree'/>
            <field name="domain">[('currency_id','=', active_id)]</field>
            <field name="context">{'default_currency_id': active_id}</field>
            <!-- <field name="target">fullscreen</field> -->
            <field name="binding_model_id" ref="model_res_currency"/>
            <field name="binding_view_types">form</field>
        </record>

        <record id="view_currency_search" model="ir.ui.view">
            <field name="name">res.currency.search</field>
            <field name="model">res.currency</field>
            <field name="arch" type="xml">
                <search string="Currencies">
                    <field name="name" string="Currency" filter_domain="('|','|','|','|',
                                                                        ('name', 'ilike', self),
                                                                        ('full_name', 'ilike', self),
                                                                        ('symbol', 'ilike', self),
                                                                        ('currency_unit_label', 'ilike', self),
                                                                        ('currency_subunit_label', 'ilike', self),
                                                                        )"/>
                    <filter name="active" string="Active" domain="[('active','=',True)]" help="Show active currencies"/>
                    <filter name="inactive" string="Inactive" domain="[('active','=',False)]" help="Show inactive currencies"/>
                </search>
            </field>
        </record>

        <record id="view_currency_tree" model="ir.ui.view">
            <field name="name">res.currency.tree</field>
            <field name="model">res.currency</field>
            <field name="arch" type="xml">
                <tree string="Currencies" decoration-muted="(not active)">
                    <field name="name"/>
                    <field name="symbol"/>
                    <field name="full_name" string="Name" optional="show"/>
                    <field name="date" string="Last Update"/>
                    <field name="rate" digits="[12,6]"/>
                    <field name="inverse_rate" digits="[12,6]" optional="hide"/>
                    <field name="active" widget="boolean_toggle"/>
                </tree>
            </field>
        </record>

        <record id="view_currency_kanban" model="ir.ui.view">
            <field name="name">res.currency.kanban</field>
            <field name="model">res.currency</field>
            <field name="arch" type="xml">
                <kanban class="o_kanban_mobile">
                    <field name="name"/>
                    <field name="symbol"/>
                    <field name="full_name"/>
                    <field name="active"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div t-attf-class="oe_kanban_global_click">
                                <div class="row mb4">
                                    <div class="col-2">
                                        <h3><t t-esc="record.name.value"/></h3>
                                    </div>
                                    <div class="col-5">
                                        <span class="badge rounded-pill"><t t-esc="record.symbol.value"/></span>
                                    </div>
                                    <div class="col-5 text-end">
                                        <t t-if="! record.active.raw_value"><span class="badge rounded-pill bg-light border">inactive</span></t>
                                    </div>
                                </div>
                                <div class="row">
                                    <div class="col-12">
                                        <div><field name="rate_string"/></div>
                                        <t t-if="record.date.raw_value"><div>Last update: <field name="date"/></div></t>
                                    </div>
                                </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>

        <record id="view_currency_form" model="ir.ui.view">
            <field name="name">res.currency.form</field>
            <field name="model">res.currency</field>
            <field name="arch" type="xml">
                <form string="Currency">
                    <field name="is_current_company_currency" invisible="1"/>
                    <div class="alert alert-info text-center" role="alert" groups="base.group_no_one">
                        You cannot reduce the number of decimal places of a currency already used on an accounting entry.
                    </div>
                    <div class="alert alert-info text-center" role="alert" invisible="not is_current_company_currency">
                        This is your company's currency.
                    </div>
                    <sheet>
                        <group>
                            <group>
                                <field name="name"/>
                                <field name="full_name" string="Name"/>
                                <field name="active" widget="boolean_toggle"/>
                            </group>
                            <group>
                                <field name="symbol"/>
                                <field name="currency_unit_label"/>
                                <field name="currency_subunit_label"/>
                            </group>
                        </group>

                        <group groups="base.group_no_one">
                            <group string="Price Accuracy">
                                <field name="rounding"/>
                                <field name="decimal_places"/>
                            </group>

                            <group string="Display">
                                <field name="position"/>
                            </group>
                        </group>
                        <notebook class="o_currency_rate_list" invisible="is_current_company_currency">
                            <page string="Rates" name="rates">
                                <field name="rate_ids" widget="one2many">
                                    <tree string="Rates"  editable="top" limit="25">
                                        <field name="name"/>
                                        <field name="company_id" groups="base.group_multi_company"/>
                                        <field name="company_rate" digits="[12,12]"/>
                                        <field name="inverse_company_rate" digits="[12,12]"/>
                                        <field name="rate" digits="[12,12]" optional="hide"/>
                                        <field name="write_date" optional="hide"/>
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="action_currency_form" model="ir.actions.act_window">
            <field name="name">Currencies</field>
            <field name="res_model">res.currency</field>
            <field name="view_mode">tree,kanban,form</field>
            <field name="search_view_id" ref="view_currency_search"/>
            <field name="context">{'active_test': False}</field>
        </record>

    </data>
</odoo>

```

  File: views/res_lang_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="res_lang_tree" model="ir.ui.view">
            <field name="name">res.lang.tree</field>
            <field name="model">res.lang</field>
            <field name="arch" type="xml">
                <tree string="Languages" limit="200">
                    <header>
                        <button name="action_activate_langs" type="object" string="Activate"/>
                    </header>
                    <field name="name"/>
                    <field name="code" groups="base.group_no_one"/>
                    <field name="iso_code" groups="base.group_no_one"/>
                    <field name="url_code" groups="base.group_no_one" column_invisible="True"/>
                    <field name="direction" groups="base.group_no_one"/>
                    <field name="active"/>
                    <button name="%(base.action_view_base_language_install)d"
                        string="Activate"
                        type="action"
                        icon="fa-check"
                        invisible="active"/>
                    <button name="%(base.action_view_base_language_install)d"
                        string="Update"
                        type="action"
                        icon="fa-refresh"
                        invisible="not active"/>
                    <button name="action_archive"
                        string="Disable"
                        type="object"
                        icon="fa-times"
                        invisible="not active"/>
                </tree>
            </field>
        </record>

        <record id="res_lang_form" model="ir.ui.view">
            <field name="name">res.lang.form</field>
            <field name="model">res.lang</field>
            <field name="arch" type="xml">
                <form string="Languages">
                    <sheet>
                        <div class="oe_button_box" name="button_box">
                            <button name="%(base.action_view_base_language_install)d"
                                type="action"
                                class="oe_stat_button"
                                icon="fa-refresh">
                                <div class="o_field_widget o_stat_info">
                                    <span class="o_stat_text">Activate and Translate</span>
                                </div>
                            </button>
                        </div>
                        <field name="flag_image" widget="image" class="oe_avatar"/>
                        <div class="oe_title">
                            <label for="name"/>
                            <h1><field name="name" placeholder="e.g. French"/></h1>
                        </div>
                        <group >
                            <group>
                                <field name="code"/>
                                <field name="iso_code"/>
                                <field name="url_code" invisible="1" required="0"/>
                                <field name="active" widget="boolean_toggle"/>
                            </group>
                            <group>
                                <field name="direction"/>
                                <field name="grouping"/>
                                <field name="decimal_point"/>
                                <field name="thousands_sep"/>
                                <field name="date_format"/>
                                <field name="time_format"/>
                                <field name="week_start"/>
                            </group>
                        </group>

                        <div class="row">
                            <div class="col-md-8 row">
                                <div class="col-12">
                                    <div class="o_horizontal_separator mb-3 mt-4 text-uppercase fw-bolder small">Legends for supported Date and Time Formats</div>
                                </div>
                                <div class="col-sm">
                                    <div>%a - Abbreviated day of the week.</div>
                                    <div>%A - Full day of the week.</div>
                                    <div>%b - Abbreviated month name.</div>
                                    <div>%B - Full month name."</div>
                                    <div>%d - Day of the month [01,31]."</div>
                                    <div>%j - Day of the year [001,366]."</div>
                                    <div>%H - Hour (24-hour clock) [00,23]."</div>
                                    <div>%I - Hour (12-hour clock) [01,12]."</div>
                                </div>
                                <div class="col-sm">
                                    <div>%M - Minute [00,59]."</div>
                                    <div>%p - Equivalent of either AM or PM."</div>
                                    <div>%S - Seconds [00,61]."</div>
                                    <div>%w - Day of the week number [0(Sunday),6]."</div>
                                    <div>%y - Year without century [00,99]."</div>
                                    <div>%Y - Year with century."</div>
                                    <div>%m - Month number [01,12]."</div>
                                </div>
                            </div>
                            <div class="col-md-4 text-info">
                                <div class="o_horizontal_separator mb-3 mt-4 text-uppercase fw-bolder small">Examples</div>
                                <div>1. %b, %B         ==> Dec, December</div>
                                <div>2. %a ,%A         ==> Fri, Friday</div>
                                <div>3. %y, %Y         ==> 08, 2008</div>
                                <div>4. %d, %m         ==> 05, 12</div>
                                <div>5. %H:%M:%S      ==> 18:25:20</div>
                                <div>6. %I:%M:%S %p  ==> 06:25:20 PM</div>
                                <div>7. %j              ==> 340</div>
                                <div>8. %S              ==> 20</div>
                                <div>9. %w              ==> 5 ( Friday is the 6th day)</div>
                            </div>
                        </div>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="res_lang_search" model="ir.ui.view">
            <field name="name">res.lang.search</field>
            <field name="model">res.lang</field>
            <field name="arch" type="xml">
                <search string="Languages">
                    <field name="name"
                        filter_domain="['|', '|', ('name', 'ilike', self), ('code', 'ilike', self), ('iso_code', 'ilike', self)]"
                        string="Language"/>
                    <field name="direction"/>
                    <separator/>
                    <filter string="Active" name="active" domain="[('active', '=', True)]"/>
                </search>
            </field>
        </record>

        <record id="res_lang_act_window" model="ir.actions.act_window">
            <field name="name">Languages</field>
            <field name="res_model">res.lang</field>
            <field name="context">{'active_test': False}</field>
            <field name="search_view_id" ref="res_lang_search"/>
        </record>

        <menuitem action="res_lang_act_window" id="menu_res_lang_act_window" parent="menu_translation" sequence="1"/>
    </data>
</odoo>

```

  File: views/res_partner_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <!-- Partner Titles -->
        <record id="view_partner_title_tree" model="ir.ui.view">
            <field name="name">res.partner.title.tree</field>
            <field name="model">res.partner.title</field>
            <field name="arch" type="xml">
                <tree string="Partner Titles" editable="bottom">
                    <field name="name"/>
                    <field name="shortcut"/>
                </tree>
            </field>
        </record>
        <record id="view_partner_title_form" model="ir.ui.view">
            <field name="name">res.partner.title.form</field>
            <field name="model">res.partner.title</field>
            <field name="arch" type="xml">
                <form string="Partner Titles">
                    <sheet>
                        <group col="4">
                            <field name="name"/>
                            <field name="shortcut"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="action_partner_title_contact" model="ir.actions.act_window">
            <field name="name">Contact Titles</field>
            <field name="res_model">res.partner.title</field>
            <field name="domain">[]</field>
            <field name="context">{}</field>
            <field name="help" type="html">
                <p class="o_view_nocontent_smiling_face">
                    Create a Title
                </p><p>
                    Manage Contact Titles as well as their abbreviations (e.g. "Mr.", "Mrs.", etc).
                </p>
            </field>
        </record>

        <!-- PARTNER TREE VIEW + MUTI_EDIT: VISIBLE FIELDS WITH ONCHANGE ON BASE/PARTNER
             VIEW WON'T BE EDITABLE ON "MULTI_EDIT" MODE:
                - parent_id
                - country_id
                - state_id
                - company_type
                - company_id
        -->
        <!-- Partner -->
        <record id="view_partner_tree" model="ir.ui.view">
            <field name="name">res.partner.tree</field>
            <field name="model">res.partner</field>
            <field eval="8" name="priority"/>
            <field name="arch" type="xml">
                <tree string="Contacts" sample="1" multi_edit="1">
                    <field name="display_name" string="Name"/>
                    <field name="function" column_invisible="True"/>
                    <field name="phone" class="o_force_ltr" optional="show"/>
                    <field name="mobile" optional="hide"/>
                    <field name="email" optional="show"/>
                    <field name="user_id" optional="show" widget="many2one_avatar_user" domain="[('share', '=', False)]"/>
                    <field name="city" optional="show"/>
                    <field name="state_id" optional="hide" readonly="1"/>
                    <field name="country_id" optional="show" readonly="1"/>
                    <field name="vat" optional="hide" readonly="1"/>
                    <field name="category_id" optional="hide" widget="many2many_tags" options="{'color_field': 'color'}"/>
                    <field name="company_id" groups="base.group_multi_company" readonly="1"/>
                    <field name="is_company" column_invisible="True"/>
                    <field name="parent_id" readonly="1" column_invisible="True"/>
                    <field name="active" column_invisible="True"/>
                </tree>
            </field>
        </record>

        <record id="view_partner_simple_form" model="ir.ui.view">
            <field name="name">res.partner.simplified.form</field>
            <field name="model">res.partner</field>
            <field name="arch" type="xml">
                <form string="Contact">
                    <!-- Invisible fields allows other modules to populate partner (ex.: creation from a lead) -->
                    <field name="avatar_128" invisible="1"/>
                    <field name="city" invisible="1"/>
                    <field name="comment" invisible="1"/>
                    <field name="country_id" invisible="1"/>
                    <field name="is_company" invisible="1"/>
                    <field name="name" invisible="1"/>
                    <field name="state_id" invisible="1"/>
                    <field name="street" invisible="1"/>
                    <field name="street2" invisible="1"/>
                    <field name="title" invisible="1"/>
                    <field name="type" invisible="1"/>
                    <field name="user_id" invisible="1"/>
                    <field name="website" invisible="1"/>
                    <field name="zip" invisible="1"/>

                    <field name="image_1920" widget='image' class="oe_avatar" options='{"preview_image": "avatar_128"}'/>
                    <div class="oe_title">
                        <field name="company_type" options="{'horizontal': true}" widget="radio" groups="base.group_no_one"/>
                        <h1>
                            <field id="company" name="name" default_focus="1" placeholder="e.g. Lumber Inc" invisible="not is_company" required="type == 'contact' and is_company"/>
                            <field id="individual" name="name" default_focus="1" placeholder="e.g. Brandom Freeman" invisible="is_company" required="type == 'contact' and not is_company"/>
                        </h1>
                        <field name="parent_id"
                            widget="res_partner_many2one"
                            placeholder="Company Name..."
                            domain="[('is_company', '=', True)]" context="{'default_is_company': True, 'show_vat': True, 'default_user_id': user_id}"
                            invisible="is_company"/>
                    </div>
                    <group>
                        <field name="function" placeholder="e.g. Sales Director" invisible="is_company"/>
                        <field name="user_ids" invisible="1"/>
                        <field name="email" widget="email" context="{'gravatar_image': True}" required="True"/>
                        <field name="phone" widget="phone" options="{'enable_sms': false}"/>
                        <field name="mobile" widget="phone" options="{'enable_sms': false}"/>
                    </group>
                </form>
            </field>
        </record>

        <!-- Open partner address -->
        <record id="view_partner_address_form" model="ir.ui.view">
            <field name="name">res.partner.form.address</field>
            <field name="model">res.partner</field>
            <field name="priority" eval="20"/>
            <field name="arch" type="xml">
                <form string="Partner">
                    <field name="avatar_128" invisible="1"/>
                    <field name="image_1920" widget='image' class="oe_avatar" options='{"preview_image": "avatar_128"}' readonly="1"/>
                    <div class="oe_title">
                        <h1>
                            <field name="name" readonly="1"/>
                        </h1>
                    </div>
                    <field name="parent_id" invisible="1"/>
                    <group>
                        <group>
                            <label for="type" invisible="not parent_id" groups="base.group_no_one"/>
                            <div invisible="not parent_id" name="div_type" groups="base.group_no_one">
                                <field name="type" class="oe_inline"/>
                            </div>
                            <label for="street" string="Address"/>
                            <div class="o_address_format">
                                <field name="street" placeholder="Street..." class="o_address_street"/>
                                <field name="street2" placeholder="Street 2..." class="o_address_street"/>
                                <field name="city" placeholder="City" class="o_address_city"/>
                                <field name="state_id" class="o_address_state" placeholder="State" options="{'no_open': True, 'no_quick_create': True}" context="{'default_country_id': country_id}"/>
                                <field name="zip" placeholder="ZIP" class="o_address_zip"/>
                                <field name="country_id" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'/>
                            </div>
                            <field name="website" string="Website" widget="url" placeholder="e.g. https://www.odoo.com"/>
                        </group>
                        <group>
                        </group>
                    </group>
                </form>
            </field>
        </record>

        <record id="view_partner_form" model="ir.ui.view">
            <field name="name">res.partner.form</field>
            <field name="model">res.partner</field>
            <field name="priority" eval="1"/>
            <field name="arch" type="xml">
                <form string="Partners">
                <div class="alert alert-warning oe_edit_only" role="alert" name="warning_tax" invisible="not same_vat_partner_id">
                  A partner with the same <span><span class="o_vat_label">Tax ID</span></span> already exists (<field name="same_vat_partner_id" context="{'show_address': False, 'show_vat': False}"/>), are you sure to create a new one?
                </div>
                <div class="alert alert-warning oe_edit_only" role="alert" name="warning_company" invisible="not same_company_registry_partner_id">
                  A partner with the same <span><span class="o_vat_label">Company Registry</span></span> already exists (<field name="same_company_registry_partner_id" context="{'show_address': False, 'show_vat': False}"/>), are you sure to create a new one?
                </div>
                <sheet>
                    <div class="oe_button_box" name="button_box"/>
                    <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger" invisible="active"/>
                    <field name="avatar_128" invisible="1"/>
                    <field name="image_1920" widget='image' class="oe_avatar" options='{"preview_image": "avatar_128"}'/>
                    <div class="oe_title mb24">
                        <field name="is_company" invisible="1"/>
                        <field name="commercial_partner_id" invisible="1"/>
                        <field name="active" invisible="1"/>
                        <field name="company_id" invisible="1"/>
                        <field name="country_code" invisible="1"/>
                        <field name="company_type" widget="radio" options="{'horizontal': true}"/>
                        <h1>
                            <field id="company" options="{'line_breaks': False}" widget="text" class="text-break" name="name" default_focus="1" placeholder="e.g. Lumber Inc" invisible="not is_company" required="type == 'contact'"/>
                            <field id="individual" options="{'line_breaks': False}" widget="text" class="text-break" name="name" default_focus="1" placeholder="e.g. Brandom Freeman" invisible="is_company" required="type == 'contact'"/>
                        </h1>
                        <div class="o_row">
                            <field name="parent_id"
                                widget="res_partner_many2one"
                                placeholder="Company Name..."
                                domain="[('is_company', '=', True)]" context="{'default_is_company': True, 'show_vat': True, 'default_user_id': user_id}"
                                invisible="((is_company and not parent_id) or company_name) and company_name != ''"/>
                                <field name="company_name" invisible="not company_name or company_name == '' or is_company"/>
                                <button name="create_company" icon="fa-plus-square" string="Create company"
                                    type="object" class="oe_edit_only btn-link"
                                    invisible="is_company or company_name == '' or not company_name"/>
                        </div>
                    </div>

                    <group>
                        <group>
                            <span class="o_form_label o_td_label" name="address_name">
                                <field name="type" invisible="is_company" readonly="user_ids" required="not is_company" class="fw-bold"/>
                                <b invisible="not is_company">Address</b>
                            </span>
                            <div class="o_address_format">
                                <field name="street" placeholder="Street..." class="o_address_street"
                                    readonly="type == 'contact' and parent_id"/>
                                <field name="street2" placeholder="Street 2..." class="o_address_street"
                                    readonly="type == 'contact' and parent_id"/>
                                <field name="city" placeholder="City" class="o_address_city"
                                    readonly="type == 'contact' and parent_id"/>
                                <field name="state_id" class="o_address_state" placeholder="State" options="{'no_open': True, 'no_quick_create': True}"
                                    readonly="type == 'contact' and parent_id" context="{'country_id': country_id, 'default_country_id': country_id, 'zip': zip}"/>
                                <field name="zip" placeholder="ZIP" class="o_address_zip"
                                    readonly="type == 'contact' and parent_id"/>
                                <div name="partner_address_country" class="d-flex justify-content-between">
                                    <field name="country_id" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'
                                        readonly="type == 'contact' and parent_id"/>
                                </div>
                            </div>
                            <field name="vat" placeholder="e.g. BE0477472701" readonly="parent_id"/>
                        </group>
                        <group>
                            <field name="function" placeholder="e.g. Sales Director"
                                invisible="is_company"/>
                            <field name="phone" widget="phone"/>
                            <field name="mobile" widget="phone"/>
                            <field name="user_ids" invisible="1"/>
                            <field name="email" widget="email" context="{'gravatar_image': True}" required="user_ids"/>
                            <field name="website" string="Website" widget="url" placeholder="e.g. https://www.odoo.com"/>
                            <field name="title" options='{"no_open": True}' placeholder="e.g. Mister"
                                invisible="is_company"/>
                            <field name="active_lang_count" invisible="1"/>
                            <field name="lang" invisible="active_lang_count &lt;= 1"/>
                            <field name="category_id" widget="many2many_tags" options="{'color_field': 'color', 'no_create_edit': True}"
                                   placeholder='e.g. "B2B", "VIP", "Consulting", ...'/>
                        </group>
                    </group>

                    <notebook colspan="4">
                        <page string="Contacts &amp; Addresses" name="contact_addresses" autofocus="autofocus">
                            <field name="child_ids" mode="kanban" context="{'default_parent_id': id, 'default_street': street, 'default_street2': street2, 'default_city': city, 'default_state_id': state_id, 'default_zip': zip, 'default_country_id': country_id, 'default_lang': lang, 'default_user_id': user_id, 'default_type': 'other'}">
                                <kanban>
                                    <field name="id"/>
                                    <field name="color"/>
                                    <field name="name"/>
                                    <field name="title"/>
                                    <field name="type"/>
                                    <field name="email"/>
                                    <field name="parent_id"/>
                                    <field name="is_company"/>
                                    <field name="function"/>
                                    <field name="phone"/>
                                    <field name="street"/>
                                    <field name="street2"/>
                                    <field name="zip"/>
                                    <field name="city"/>
                                    <field name="country_id"/>
                                    <field name="mobile"/>
                                    <field name="state_id"/>
                                    <field name="image_128"/>
                                    <field name="avatar_128"/>
                                    <field name="lang"/>
                                    <!-- fields in form x2many view to diminish requests -->
                                    <field name="comment"/>
                                    <field name="display_name"/>
                                    <templates>
                                        <t t-name="kanban-box">
                                            <t t-set="color" t-value="kanban_color(record.color.raw_value)"/>
                                            <div t-att-class="color + (record.title.raw_value == 1 ? ' oe_kanban_color_alert' : '') + ' oe_kanban_global_click'">
                                                <div class="o_kanban_image">
                                                    <img alt="Contact image" t-att-src="kanban_image('res.partner', 'avatar_128', record.id.raw_value)"/>
                                                </div>
                                                <div class="oe_kanban_details">
                                                    <field name="name"/>
                                                    <div t-if="record.function.raw_value"><field name="function"/></div>
                                                    <div t-if="record.email.raw_value"><field name="email" widget="email"/></div>
                                                    <div t-if="record.type.raw_value != 'contact'">
                                                        <div>
                                                            <field name="zip"/><t t-if="record.city"> </t>
                                                            <field name="city"/>
                                                        </div>
                                                        <field t-if="record.state_id.raw_value" name="state_id"/><t t-if="record.country_id"> </t>
                                                        <field name="country_id"/>
                                                    </div>
                                                    <div t-if="record.phone.raw_value">Phone: <t t-esc="record.phone.value"/></div>
                                                    <div t-if="record.mobile.raw_value">Mobile: <t t-esc="record.mobile.value"/></div>
                                                </div>
                                            </div>
                                        </t>
                                    </templates>
                                </kanban>
                                <form string="Contact / Address">
                                    <sheet>
                                        <field name="type" required="1" widget="radio" options="{'horizontal': true}"/>
                                        <field name="parent_id" invisible="1"/>
                                        <div class="text-muted oe_edit_only">
                                            <p class="mb-0" invisible="type != 'contact'">
                                                <span>Use this to organize the contact details of employees of a given company (e.g. CEO, CFO, ...).</span>
                                            </p>
                                            <p class="mb-0" invisible="type != 'invoice'">
                                                <span>Preferred address for all invoices. Selected by default when you invoice an order that belongs to this company.</span>
                                            </p>
                                            <p class="mb-0" invisible="type != 'delivery'">
                                                <span>Preferred address for all deliveries. Selected by default when you deliver an order that belongs to this company.</span>
                                            </p>
                                            <p class="mb-0" invisible="type != 'other'">
                                                <span>Other address for the company (e.g. subsidiary, ...)</span>
                                            </p>
                                        </div>
                                        <hr/>
                                        <group>
                                            <group>
                                                <field name="name" string="Contact Name" required="type == 'contact'"/>
                                                <field name="title" options="{'no_open': True}" placeholder="e.g. Mr."
                                                    invisible="type != 'contact'"/>
                                                <field name="function" placeholder="e.g. Sales Director"
                                                    invisible="type != 'contact'"/>
                                                <label for="street" string="Address" invisible="type == 'contact'"/>
                                                <div invisible="type == 'contact'">
                                                    <div class="o_address_format" name="div_address">
                                                        <field name="street" placeholder="Street..." class="o_address_street"/>
                                                        <field name="street2" placeholder="Street 2..." class="o_address_street"/>
                                                        <field name="city" placeholder="City" class="o_address_city"/>
                                                        <field name="state_id" class="o_address_state" placeholder="State" options="{'no_open': True, 'no_quick_create': True}" context="{'country_id': country_id, 'default_country_id': country_id, 'zip': zip}"/>
                                                        <field name="zip" placeholder="ZIP" class="o_address_zip"/>
                                                        <field name="country_id" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'/>
                                                    </div>
                                                </div>
                                            </group>
                                            <group>
                                                <field name="email" widget="email"/>
                                                <field name="phone" widget="phone"/>
                                                <field name="mobile" widget="phone"/>
                                                <field name="company_id" invisible="1"/>
                                            </group>
                                        </group>
                                        <group>
                                            <field name="comment" placeholder="Internal notes..." nolabel="1" colspan="2"/>
                                        </group>
                                        <field name="lang" invisible="True"/>
                                        <field name="user_id" invisible="True"/>
                                    </sheet>
                                </form>
                            </field>
                        </page>
                        <page name='sales_purchases' string="Sales &amp; Purchase">
                            <group name="container_row_2">
                                <group string="Sales" name="sale" priority="1">
                                    <field name="user_id" widget="many2one_avatar_user" domain="[('share', '=', False)]"/>
                                </group>
                                <group string="Purchase" name="purchase" priority="2">
                                </group>
                                <group name="misc" string="Misc">
                                    <field name="company_registry" invisible="parent_id"/>
                                    <field name="ref" string="Reference"/>
                                    <field name="company_id" groups="base.group_multi_company" options="{'no_create': True}" readonly="parent_id" force_save="1"/>
                                    <field name="industry_id" invisible="not is_company" options="{'no_create': True}"/>
                                </group>
                            </group>
                        </page>
                        <page name='internal_notes' string="Internal Notes">
                            <field name="comment" placeholder="Internal notes..."/>
                        </page>
                    </notebook>
                </sheet>
                </form>
            </field>
        </record>

      <!-- Special restricted view for private address, with limited "named" info that
           can be traced back to the employee -->
        <record id="res_partner_view_form_private" model="ir.ui.view">
            <field name="name">res.partner.view.form.private</field>
            <field name="model">res.partner</field>
            <field name="priority" eval="300"/>
            <field name="arch" type="xml">
                <form string="Private Address Form">
                    <sheet>
                        <field name="type" invisible="1"/>
                        <field name="parent_id" invisible="1"/>
                        <label for="name" class="oe_edit_only"/>
                        <field name="name" required="0"/>
                        <group>
                            <group>
                                <label for="street" string="Address"/>
                                <div>
                                    <div class="o_address_format" name="div_address">
                                        <field name="street" placeholder="Street..." class="o_address_street"/>
                                        <field name="street2" placeholder="Street 2..." class="o_address_street"/>
                                        <field name="city" placeholder="City" class="o_address_city"/>
                                        <field name="state_id" class="o_address_state" placeholder="State" options="{'no_open': True, 'no_quick_create': True}" context="{'country_id': country_id, 'default_country_id': country_id, 'zip': zip}"/>
                                        <field name="zip" placeholder="ZIP" class="o_address_zip"/>
                                        <field name="country_id" placeholder="Country" class="o_address_country" options='{"no_open": True, "no_create": True}'/>
                                    </div>
                                </div>
                            </group>
                            <group>
                                <field name="phone" widget="phone" options="{'enable_sms': false}"/>
                                <field name="mobile" widget="phone" options="{'enable_sms': false}"/>
                                <field name="email"/>
                                <field name="lang"/>
                            </group>
                        </group>
                        <group string="Bank Accounts">
                            <field name="bank_ids">
                                <tree editable="bottom">
                                    <field name="bank_id"/>
                                    <field name="acc_number"/>
                                    <field name="acc_holder_name" column_invisible="True"/>
                                </tree>
                            </field>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

       <record id="view_res_partner_filter" model="ir.ui.view">
            <field name="name">res.partner.select</field>
            <field name="model">res.partner</field>
            <field name="arch" type="xml">
                <search string="Search Partner">
                    <field name="name"
                       filter_domain="['|', '|', '|', '|', ('complete_name', 'ilike', self), ('ref', '=', self), ('email', 'ilike', self), ('vat', 'ilike', self), ('company_registry', 'ilike', self)]"/>
                    <field name="parent_id" domain="[('is_company', '=', True)]" operator="child_of"/>
                    <field name="email" filter_domain="[('email', 'ilike', self)]"/>
                    <field name="phone" filter_domain="['|', ('phone', 'ilike', self), ('mobile', 'ilike', self)]"/>
                    <field name="category_id" string="Tag" operator="child_of"/>
                    <field name="user_id"/>
                    <separator/>
                    <filter string="Individuals" name="type_person" domain="[('is_company', '=', False)]"/>
                    <filter string="Companies" name="type_company" domain="[('is_company', '=', True)]"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                    <separator/>
                    <group expand="0" name="group_by" string="Group By">
                        <filter name="salesperson" string="Salesperson" domain="[]" context="{'group_by' : 'user_id'}" />
                        <filter name="group_company" string="Company" context="{'group_by': 'parent_id'}"/>
                        <filter name="group_country" string="Country" context="{'group_by': 'country_id'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Partner Kanban View -->
        <record model="ir.ui.view" id="res_partner_kanban_view">
            <field name="name">res.partner.kanban</field>
            <field name="model">res.partner</field>
            <field name="arch" type="xml">
                <kanban sample="1">
                    <field name="id"/>
                    <field name="color"/>
                    <field name="display_name"/>
                    <field name="title"/>
                    <field name="email"/>
                    <field name="parent_id"/>
                    <field name="is_company"/>
                    <field name="function"/>
                    <field name="phone"/>
                    <field name="street"/>
                    <field name="street2"/>
                    <field name="zip"/>
                    <field name="city"/>
                    <field name="country_id"/>
                    <field name="mobile"/>
                    <field name="state_id"/>
                    <field name="category_id"/>
                    <field name="avatar_128"/>
                    <field name="type"/>
                    <field name="active"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div class="oe_kanban_global_click o_kanban_record_has_image_fill o_res_partner_kanban">
                                <t t-if="!record.is_company.raw_value">
                                    <t t-set="avatar_image" t-value="kanban_image('res.partner', 'avatar_128', record.id.raw_value)"/>
                                    <div class="o_kanban_image_fill_left d-none d-md-block">
                                        <img t-attf-src="#{avatar_image}" t-att-alt="record.id.value"/>
                                        <img class="o_kanban_image_inner_pic" t-if="record.parent_id.raw_value" t-att-alt="record.parent_id.value" t-att-src="kanban_image('res.partner', 'avatar_128', record.parent_id.raw_value)"/>
                                    </div>
                                    <div class="o_kanban_image d-md-none d-block">
                                        <img t-attf-src="#{avatar_image}" t-att-alt="record.id.value"/>
                                        <img class="o_kanban_image_inner_pic" t-if="record.parent_id.raw_value" t-att-alt="record.parent_id.value" t-att-src="kanban_image('res.partner', 'avatar_128', record.parent_id.raw_value)"/>
                                    </div>
                                </t>
                                <t t-else="">
                                    <div class="o_kanban_image_fill_left d-none d-md-block o_kanban_image_full">
                                        <img t-attf-src="#{kanban_image('res.partner', 'avatar_128', record.id.raw_value)}" role="img" t-att-alt="record.id.value"/>
                                    </div>
                                    <div class="o_kanban_image d-md-none d-block o_kanban_image_full">
                                        <img  t-attf-src="#{kanban_image('res.partner', 'avatar_128', record.id.raw_value)}" role="img" t-att-alt="record.id.value"/>
                                    </div>
                                </t>
                                <div class="ribbon ribbon-top-right" invisible="active">
                                    <span class="text-bg-danger">Archived</span>
                                </div>
                                <div class="oe_kanban_details d-flex flex-column justify-content-between">
                                    <div>
                                        <strong class="o_kanban_record_title oe_partner_heading"><field name="display_name"/></strong>
                                        <div class="o_kanban_tags_section oe_kanban_partner_categories"/>
                                        <ul>
                                            <li t-if="record.parent_id.raw_value and !record.function.raw_value"><field name="parent_id"/></li>
                                            <li t-elif="!record.parent_id.raw_value and record.function.raw_value"><field name="function"/></li>
                                            <li t-elif="record.parent_id.raw_value and record.function.raw_value"><field name="function"/> at <field name="parent_id"/></li>
                                            <li t-if="record.city.raw_value or record.country_id.raw_value">
                                                <t t-if="record.city.raw_value"><field name="city"/><t t-if="record.country_id.raw_value">, </t></t>
                                                <t t-if="record.country_id.raw_value"><field name="country_id"/></t>
                                            </li>
                                            <li t-if="record.email.raw_value" class="o_text_overflow"><field name="email"/></li>
                                        </ul>
                                    </div>
                                    <div class="o_kanban_record_bottom">
                                        <div class="oe_kanban_bottom_left"/>
                                        <div class="oe_kanban_bottom_right"/>
                                    </div>
                                </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>

        <record id="action_partner_form" model="ir.actions.act_window">
            <field name="name">Customers</field>
            <field name="res_model">res.partner</field>
            <field name="view_mode">kanban,tree,form</field>
            <field name="context">{'res_partner_search_mode': 'customer'}</field>
            <field name="search_view_id" ref="view_res_partner_filter"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a Contact in your address book
              </p><p>
                Odoo helps you track all activities related to your contacts.
              </p>
            </field>
        </record>
        <record id="action_partner_form_view1" model="ir.actions.act_window.view">
            <field eval="0" name="sequence"/>
            <field name="view_mode">kanban</field>
            <field name="view_id" ref="res_partner_kanban_view"/>
            <field name="act_window_id" ref="action_partner_form"/>
        </record>
        <record id="action_partner_form_view2" model="ir.actions.act_window.view">
            <field eval="2" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_partner_form"/>
            <field name="act_window_id" ref="action_partner_form"/>
        </record>
        <record id="action_partner_tree_view1" model="ir.actions.act_window.view">
            <field name="sequence" eval="1"/>
            <field name="view_mode">tree</field>
            <field name="view_id" ref="view_partner_tree"/>
            <field name="act_window_id" ref="action_partner_form"/>
        </record>

        <record id="action_partner_customer_form" model="ir.actions.act_window">
            <field name="name">Customers</field>
            <field name="res_model">res.partner</field>
            <field name="view_mode">kanban,tree,form</field>
            <field name="domain">[]</field>
            <field name="context">{'res_partner_search_mode': 'customer', 'default_is_company': True}</field>
            <field name="filter" eval="True"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a new customer in your address book
              </p><p>
                Odoo helps you easily track all activities related to a customer.
              </p>
            </field>
        </record>
        <record id="action_partner_customer_form_view1" model="ir.actions.act_window.view">
            <field eval="1" name="sequence"/>
            <field name="view_mode">kanban</field>
            <field name="view_id" ref="res_partner_kanban_view"/>
            <field name="act_window_id" ref="action_partner_customer_form"/>
        </record>
        <record id="action_partner_customer_form_view2" model="ir.actions.act_window.view">
            <field eval="2" name="sequence"/>
            <field name="view_mode">tree</field>
            <field name="view_id" ref="view_partner_tree"/>
            <field name="act_window_id" ref="action_partner_customer_form"/>
        </record>
        <record id="action_partner_customer_form_view3" model="ir.actions.act_window.view">
            <field eval="3" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_partner_form"/>
            <field name="act_window_id" ref="action_partner_customer_form"/>
        </record>

        <record id="action_partner_supplier_form" model="ir.actions.act_window">
            <field name="name">Vendors</field>
            <field name="res_model">res.partner</field>
            <field name="domain">[]</field>
            <field name="view_mode">kanban,tree,form</field>
            <field name="context">{'res_partner_search_mode': 'supplier', 'default_is_company': True}</field>
            <field name="filter" eval="True"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a new vendor in your address book
              </p><p>
                Odoo helps you easily track all activities related to a vendor.
              </p>
            </field>
        </record>
        <record id="action_partner_vendor_form_view1" model="ir.actions.act_window.view">
            <field eval="1" name="sequence"/>
            <field name="view_mode">kanban</field>
            <field name="view_id" ref="res_partner_kanban_view"/>
            <field name="act_window_id" ref="action_partner_supplier_form"/>
        </record>
        <record id="action_partner_vendor_form_view2" model="ir.actions.act_window.view">
            <field eval="2" name="sequence"/>
            <field name="view_mode">tree</field>
            <field name="view_id" ref="view_partner_tree"/>
            <field name="act_window_id" ref="action_partner_supplier_form"/>
        </record>
        <record id="action_partner_vendor_form_view3" model="ir.actions.act_window.view">
            <field eval="3" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_partner_form"/>
            <field name="act_window_id" ref="action_partner_supplier_form"/>
        </record>

        <!-- Categories -->
        <record id="view_partner_category_form" model="ir.ui.view">
            <field name="name">Contact Tags</field>
            <field name="model">res.partner.category</field>
            <field name="arch" type="xml">
                <form string="Contact Tag">
                    <sheet>
                        <group col="4">
                            <field name="name" placeholder='e.g. "Consulting Services"'/>
                            <field name="color" widget="color_picker"/>
                            <field name="parent_id"/>
                            <field name="active" widget="boolean_toggle"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_partner_category_list" model="ir.ui.view">
            <field name="name">Contact Tags</field>
            <field name="model">res.partner.category</field>
            <field eval="6" name="priority"/>
            <field name="arch" type="xml">
                <tree string="Contact Tags">
                    <field name="display_name"/>
                    <field name="color" widget="color_picker"/>
                </tree>
            </field>
        </record>

        <record id="res_partner_category_view_search" model="ir.ui.view">
            <field name="name">res.partner.category.view.search</field>
            <field name="model">res.partner.category</field>
            <field name="arch" type="xml">
                <search string="Search Partner Category">
                    <field name="name"/>
                    <field name="display_name"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record id="action_partner_category_form" model="ir.actions.act_window">
            <field name="name">Contact Tags</field>
            <field name="res_model">res.partner.category</field>
            <field name="search_view_id" ref="res_partner_category_view_search"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create a Contact Tag
              </p><p>
                Assign tags to your contacts to organize, filter and track them.
              </p>
            </field>
        </record>

        <!-- Industry -->
        <record id="res_partner_industry_view_form" model="ir.ui.view">
            <field name="name">Industry</field>
            <field name="model">res.partner.industry</field>
            <field name="arch" type="xml">
                <form string="Industry">
                    <sheet>
                        <group col="4">
                            <field name="name"/>
                            <field name="full_name"/>
                            <field name="active" widget="boolean_toggle"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="res_partner_industry_view_tree" model="ir.ui.view">
            <field name="name">Industry</field>
            <field name="model">res.partner.industry</field>
            <field eval="6" name="priority"/>
            <field name="arch" type="xml">
                <tree string="Industry" editable="bottom">
                    <field name="name"/>
                    <field name="full_name"/>
                    <field name="active" column_invisible="True"/>
                </tree>
            </field>
        </record>

        <record id="res_partner_industry_view_search" model="ir.ui.view">
            <field name="name">res.partner.industry.view.search</field>
            <field name="model">res.partner.industry</field>
            <field name="arch" type="xml">
                <search string="Search Partner Industry">
                    <field name="name"/>
                    <field name="full_name"/>
                    <separator/>
                    <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
                </search>
            </field>
        </record>

        <record id="res_partner_industry_action" model="ir.actions.act_window">
            <field name="name">Industries</field>
            <field name="res_model">res.partner.industry</field>
            <field name="view_mode">tree,form</field>
            <field name="search_view_id" ref="res_partner_industry_view_search"/>
            <field name="help" type="html">
              <p class="o_view_nocontent_smiling_face">
                Create an Industry
              </p><p>
                Specify industries to classify your contacts and draw up reports.
              </p>
            </field>
        </record>
    </data>
</odoo>

```

  File: views/res_users_identitycheck_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="res_users_identitycheck_view_form" model="ir.ui.view">
            <field name="model">res.users.identitycheck</field>
            <field name="arch" type="xml">
                <form string="Password Confirmation">
                    <sheet>
                        <h3><strong>Please enter your password to confirm you own this account</strong></h3>
                        <div>
                            <field class="o_field_highlight col-10 col-md-6 px-0" name="password" autocomplete="current-password"
                                required="True" password="True" placeholder="************"/>
                        </div>
                        <a href="/web/reset_password/" class="btn btn-link" role="button">Forgot password?</a>
                    </sheet>
                    <footer>
                        <button string="Confirm Password" type="object" name="run_check" class="btn btn-primary" data-hotkey="q"/>
                        <button string="Cancel" special="cancel" data-hotkey="z" class="btn btn-secondary"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="res_users_identitycheck_view_form_revokedevices" model="ir.ui.view">
            <field name="name">Revoke All Devices</field>
            <field name="model">res.users.identitycheck</field>
            <field name="priority">40</field>
            <field name="arch" type="xml">
                <form string="Log out from all devices">
                    <div>
                        You are about to log out from all devices that currently have access to your account.<br/><br/>
                        <strong>Type in your password to confirm :</strong>
                        <field class="oe_inline o_field_highlight" name="password" password="True" required="True"/>
                    </div>
                    <footer>
                        <button string="Log out from all devices" name="revoke_all_devices" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="z" />
                    </footer>
                </form>
            </field>
        </record>

    </data>
</odoo>

```

  File: views/res_users_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="change_password_own_form" model="ir.ui.view">
            <field name="name">Change Own Password</field>
            <field name="model">change.password.own</field>
            <field name="arch" type="xml">
                <form string="Change Password">
                    <group>
                        <field name="new_password" password="True" required="1"/>
                        <field name="confirm_password" password="True" required="1"/>
                    </group>
                    <footer>
                        <button string="Change Password" name="change_password" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x" />
                    </footer>
                </form>
            </field>
        </record>

        <!-- change password wizard -->
        <record id="change_password_wizard_view" model="ir.ui.view">
            <field name="name">Change Password</field>
            <field name="model">change.password.wizard</field>
            <field name="arch" type="xml">
                <form string="Change Password">
                    <field mode="tree" name="user_ids"/>
                    <footer>
                        <button string="Change Password" name="change_password_button" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x" />
                    </footer>
                </form>
            </field>
        </record>
        <record id="change_password_wizard_user_tree_view" model="ir.ui.view">
            <field name="name">Change Password Users</field>
            <field name="model">change.password.user</field>
            <field name="arch" type="xml">
                <!-- the user list is editable, but one cannot add or delete rows -->
                <tree string="Users" editable="bottom" create="false" delete="false">
                    <field name="user_id" invisible="1"/>
                    <field name="user_login" force_save="1"/>
                    <field name="new_passwd" password="True" width="20px"/>
                </tree>
            </field>
        </record>
        <record id="change_password_wizard_action" model="ir.actions.act_window">
            <field name="name">Change Password</field>
            <field name="res_model">change.password.wizard</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
            <field name="binding_model_id" ref="base.model_res_users"/>
        </record>

        <!-- res.groups -->
        <record id="view_groups_search" model="ir.ui.view">
            <field name="name">res.groups.search</field>
            <field name="model">res.groups</field>
            <field name="arch" type="xml">
                <search string="Groups">
                    <field name="name" filter_domain="['|', ('full_name','ilike',self), ('category_id','ilike',self)]" string="Group"/>
                    <separator orientation="vertical"/>
                    <field name="share"/>
                    <filter name="filter_no_share" string="Internal Groups" domain="[('share','=',False)]"/>
                </search>
            </field>
        </record>
        <record id="view_groups_form" model="ir.ui.view">
            <field name="name">res.groups.form</field>
            <field name="model">res.groups</field>
            <field name="arch" type="xml">
                <form string="Groups">
                  <sheet>
                    <group col="4">
                        <field name="category_id"/>
                        <field name="name"/>
                        <field name="share"/>
                    </group>
                    <notebook>
                        <page string="Users" name="users">
                            <field name="users" context="{'search_default_filter_no_share':1}"/>
                        </page>
                        <page string="Inherited" name="inherit_groups">
                            <label for="implied_ids" string="Users added to this group are automatically added in the following groups."/>
                            <field name="implied_ids"/>
                        </page>
                        <page string="Menus" name="menus">
                            <field name="menu_access"/>
                        </page>
                        <page string="Views" name="views">
                            <field name="view_access" groups="base.group_system"/>
                        </page>
                        <page string="Access Rights" name="access_rights">
                            <field name="model_access">
                                <tree string="Access Rights" editable="top">
                                    <field name="name"/>
                                    <field name="model_id"/>
                                    <field name="perm_read"/>
                                    <field name="perm_write"/>
                                    <field name="perm_create"/>
                                    <field name="perm_unlink"/>
                                </tree>
                            </field>
                        </page>
                        <page string="Record Rules" name="record_rules">
                            <field name="rule_groups">
                                <tree string="Record Rules" editable="top">
                                    <field name="name"/>
                                    <field name="model_id"/>
                                    <field name="domain_force"/>
                                    <field name="perm_read"/>
                                    <field name="perm_write"/>
                                    <field name="perm_create"/>
                                    <field name="perm_unlink"/>
                                </tree>
                            </field>
                        </page><page string="Notes" name="notes">
                            <field name="comment"/>
                        </page>
                    </notebook>
                  </sheet>
                </form>
            </field>
        </record>
        <record id="action_res_groups" model="ir.actions.act_window">
            <field name="name">Groups</field>
            <field name="res_model">res.groups</field>
            <field name="context">{'search_default_filter_no_share': 1}</field>
            <field name="help">A group is a set of functional areas that will be assigned to the user in order to give them access and rights to specific applications and tasks in the system. You can create custom groups or edit the ones existing by default in order to customize the view of the menu that users will be able to see. Whether they can have a read, write, create and delete access right can be managed from here.</field>
        </record>
        <menuitem action="action_res_groups" id="menu_action_res_groups" parent="base.menu_users" groups="base.group_no_one" sequence="3"/>

        <!-- res.users -->
        <record id="view_users_simple_form" model="ir.ui.view">
            <field name="name">res.users.simplified.form</field>
            <field name="model">res.users</field>
            <field name="priority">1</field>
            <field name="arch" type="xml">
                <form string="Users">
                    <sheet>
                        <field name="id" invisible="1"/>
                        <div class="alert alert-info text-center mb-3" invisible="id &gt; 0" role="alert">
                            You are inviting a new user.
                        </div>
                        <field name="avatar_128" invisible="1"/>
                        <field name="image_1920" widget='image' class="oe_avatar" options='{"zoom": true, "preview_image": "avatar_128"}'/>
                        <div class="oe_title">
                            <label for="name"/>
                            <h1><field name="name" placeholder="e.g. John Doe" required="1"/></h1>
                            <field name="email" invisible="1"/>
                            <label for="login" string="Email Address"/>
                            <h2>
                                <field name="login"
                                        placeholder="e.g. email@yourcompany.com"/>
                            </h2>
                        </div>
                        <group name="phone_numbers">
                            <field name="company_id" context="{'user_preference': 0}" groups="base.group_multi_company"/>
                            <label for="groups_id" string="Access Rights"
                                    invisible="id &gt; 0" groups="base.group_no_one"/>
                            <div invisible="id &gt; 0" groups="base.group_no_one">
                                <field name="groups_id" readonly="1" widget="many2many_tags" options="{'color_field': 'color'}" style="display: inline;"/> You will be able to define additional access rights by editing the newly created user under the Settings / Users menu.
                            </div>
                            <field name="phone" widget="phone"/>
                            <field name="mobile" widget="phone"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>
        <record id="view_users_form" model="ir.ui.view">
            <field name="name">res.users.form</field>
            <field name="model">res.users</field>
            <field name="arch" type="xml">
                <form string="Users">
                    <header>
                    </header>
                    <sheet>
                        <field name="id" invisible="1"/>
                        <div class="oe_button_box" name="button_box">
                            <button name="action_show_groups" type="object" groups="base.group_no_one" class="oe_stat_button" icon="fa-users">
                                <field string="Groups" name="groups_count" widget="statinfo"/>
                            </button>
                            <button name="action_show_accesses" type="object" groups="base.group_no_one" class="oe_stat_button" icon="fa-list">
                                <field string="Access Rights" name="accesses_count" widget="statinfo"/>
                            </button>
                            <button name="action_show_rules" type="object" groups="base.group_no_one" class="oe_stat_button" icon="fa-list-ul">
                                <field string="Record Rules" name="rules_count" widget="statinfo"/>
                            </button>
                        </div>
                        <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger" invisible="active"/>
                        <field name="active_partner" required="0" readonly="1" invisible="1"/>
                        <div class="alert alert-info text-center o_form_header"
                            invisible="active and active_partner or not active and not active_partner or active and not active_partner"
                            role="alert">
                          <a class="close" data-bs-dismiss="alert" href="#">x</a>
                          <div>
                            <strong>The contact linked to this user is still active</strong>
                          </div>
                          <div>You can archive the contact
                            <field name="partner_id" required="0" readonly="1"/>
                          </div>
                        </div>
                        <field name="avatar_128" invisible="1"/>
                        <field name="image_1920" widget='image' class="oe_avatar" options='{"preview_image": "avatar_128"}'/>
                        <div class="oe_title">
                            <label for="name"/>
                            <h1><field name="name" placeholder="e.g. John Doe" required="1"/></h1>
                            <field name="email" invisible="1"/>
                            <label for="login" string="Email Address"/>
                            <h2><field name="login" placeholder="e.g. email@yourcompany.com"/></h2>
                            <group>
                                <field name="partner_id" groups="base.group_no_one"
                                        readonly="1"
                                        required="0"
                                        invisible="not id"/>
                                <field name="share" invisible="1"/>
                            </group>
                        </div>
                        <notebook colspan="4">
                            <page name="access_rights" string="Access Rights">
                                <group string="Multi Companies" invisible="companies_count &lt;= 1">
                                    <field string="Allowed Companies" name="company_ids" widget="many2many_tags" options="{'no_create': True, 'color_field': 'color'}"/>
                                    <field string="Default Company" name="company_id" context="{'user_preference': 0}"/>
                                    <field string="Companies count" name="companies_count" invisible="1"/>
                                </group>
                                <field name="groups_id"/>
                            </page>
                            <page string="Preferences" name="preferences">
                                <group>
                                    <group string="Localization" name="preferences">
                                        <field name="active" invisible="1"/>
                                        <label for="lang" />
                                        <div class="o_row">
                                            <field name="lang" required="1"/>
                                            <button
                                                type="action"
                                                name="%(base.action_view_base_language_install)d"
                                                class="oe_edit_only btn-sm btn-link mb4 fa fa-globe"
                                                aria-label="Add a language"
                                                title="Add a language"/>
                                        </div>
                                        <field name="tz" widget="timezone_mismatch" options="{'tz_offset_field': 'tz_offset'}" />
                                        <field name="tz_offset" invisible="1"/>
                                    </group>
                                    <group string="Menus Customization" groups="base.group_no_one"
                                        invisible="share">
                                        <field name="action_id"/>
                                    </group>
                                </group>
                                <group name="messaging">
                                    <field name="signature" options="{'style-inline': true, 'codeview': true}"/>
                                </group>
                            </page>
                        </notebook>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_users_tree" model="ir.ui.view">
            <field name="name">res.users.tree</field>
            <field name="model">res.users</field>
            <field name="arch" type="xml">
                <tree string="Users" multi_edit="1">
                    <field name="name" readonly="1"/>
                    <field name="login" readonly="1"/>
                    <field name="lang"/>
                    <field name="login_date" readonly="1"/>
                    <field name="company_id" groups="base.group_multi_company"/>
                </tree>
            </field>
        </record>
        <record id="view_res_users_kanban" model="ir.ui.view">
            <field name="name">res.users.kanban</field>
            <field name="model">res.users</field>
            <field name="arch" type="xml">
                <kanban class="o_kanban_mobile">
                    <field name="id"/>
                    <field name="name"/>
                    <field name="login"/>
                    <field name="lang"/>
                    <field name="active"/>
                    <field name="login_date"/>
                    <templates>
                        <t t-name="kanban-box">
                            <div t-attf-class="oe_kanban_global_click">
                                <div class="o_kanban_image">
                                    <img alt="Avatar" t-att-src="kanban_image('res.users', 'avatar_128', record.id.raw_value)"/>
                                </div>
                                <div class="oe_kanban_details">
                                    <ul>
                                        <li class="text-success float-end mb4" t-if="record.active.raw_value"><i class="fa fa-circle" role="img" aria-label="Ok" title="Ok"></i></li>
                                        <li class="text-danger float-end mb4" t-if="!record.active.raw_value"><i class="fa fa-circle" role="img" aria-label="Invalid" title="Invalid"></i></li>
                                        <li class="mb4">
                                            <strong><field name="name"/></strong>
                                        </li>
                                        <li class="d-flex flex-wrap">
                                            <span class="mb4 text-truncate" title="Login">
                                                <i class="fa fa-envelope me-1" role="img" aria-label="Login"/>
                                                <field name="login"/>
                                            </span>
                                            <field class="badge rounded-pill mb4 ms-auto" name="lang"/>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </t>
                    </templates>
                </kanban>
            </field>
        </record>
        <record id="view_users_search" model="ir.ui.view">
            <field name="name">res.users.search</field>
            <field name="model">res.users</field>
            <field name="arch" type="xml">
                <search string="Users">
                    <field name="name" filter_domain="['|', '|', ('name','ilike',self), ('login','ilike',self), ('email','ilike',self)]" string="User"/>
                    <field name="company_ids" string="Company" groups="base.group_multi_company"/>
                    <field name="share"/>
                    <filter name="filter_no_share" string="Internal Users" domain="[('share', '=', False)]"/>
                    <filter name="filter_share" string="Portal Users" domain="[('share', '=', True)]"/>
                    <separator/>
                    <filter name="Inactive" string="Inactive Users" domain="[('active','=',False)]"/>
                </search>
            </field>
        </record>
        <record id="user_groups_view" model="ir.ui.view">
            <field name="name">res.users.groups</field>
            <field name="model">res.users</field>
            <field name="inherit_id" ref="view_users_form"/>
            <field name="arch" type="xml">
                <!-- dummy, will be modified by groups -->
                <field name="groups_id" position="after"/>
            </field>
        </record>
        <!-- dummy update on group, to force the view above to be update -->
        <record model="res.groups" id="group_no_one"/>
        <record id="action_res_users" model="ir.actions.act_window">
            <field name="name">Users</field>
            <field name="res_model">res.users</field>
            <field name="view_mode">tree,kanban,form</field>
            <field name="view_id" ref="view_users_tree"/>
            <field name="search_view_id" ref="view_users_search"/>
            <field name="context">{'search_default_filter_no_share': 1, 'show_user_group_warning': True}</field>
            <field name="help">Create and manage users that will connect to the system. Users can be deactivated should there be a period of time during which they will/should not connect to the system. You can assign them groups in order to give them specific access to the applications they need to use in the system.</field>
        </record>
        <record id="action_res_users_view1" model="ir.actions.act_window.view">
            <field eval="10" name="sequence"/>
            <field name="view_mode">tree</field>
            <field name="view_id" ref="view_users_tree"/>
            <field name="act_window_id" ref="action_res_users"/>
        </record>
        <record id="action_res_users_view2" model="ir.actions.act_window.view">
            <field eval="20" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_users_form"/>
            <field name="act_window_id" ref="action_res_users"/>
        </record>
        <menuitem action="action_res_users" id="menu_action_res_users" parent="base.menu_users" sequence="0"/>


        <record id="action_res_users_keys_description" model="ir.actions.act_window">
            <field name="name">API Key: description input wizard</field>
            <field name="res_model">res.users.apikeys.description</field>
            <field name="target">new</field>
            <field name="view_mode">form</field>
        </record>
        <record id="form_res_users_key_description" model="ir.ui.view">
            <field name="name">API Key: description input form</field>
            <field name="model">res.users.apikeys.description</field>
            <field name="arch" type="xml">
                <form>
                    <sheet>
                    <h3 class="fw-bold">
                        Name your key
                    </h3>
                    <p>Enter a description of and purpose for the key.</p>
                    <field name="name" placeholder="What's this key for?"/>
                    <p>
                        It is very important that this description be clear
                        and complete, <strong>it will be the only way to
                        identify the key once created</strong>.
                    </p>
                    <footer>
                        <button name="make_key" type="object" string="Generate key" class="btn-primary" data-hotkey="q"/>
                        <button special="cancel" data-hotkey="x" string="Cancel" class="btn-secondary"/>
                    </footer>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="form_res_users_key_show" model="ir.ui.view">
            <field name="name">API Key: show</field>
            <field name="model">res.users.apikeys.show</field>
            <field name="arch" type="xml">
                <form>
                    <sheet>
                        <h3 class="fw-bold">
                            Write down your key
                        </h3>
                        <p>
                            Here is your new API key, use it instead of a password for RPC access.
                            Your login is still necessary for interactive usage.
                        </p>
                        <p><code><field name="key" readonly="True"/></code></p>
                        <p class="alert alert-warning" role="alert">
                            <strong>Important:</strong>
                            The key cannot be retrieved later and provides <b>full access</b>
                            to your user account, it is very important to store it securely.
                        </p>
                        <footer>
                            <button special="cancel" data-hotkey="x" string="Done!"/>
                        </footer>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_users_form_simple_modif" model="ir.ui.view">
            <field name="name">res.users.preferences.form</field>
            <field name="model">res.users</field>
            <field eval="18" name="priority"/>
            <field name="arch" type="xml">
                <form string="Users" edit="1">
                    <widget name="notification_alert"/>
                    <field name="avatar_128" invisible="1"/>
                    <field name="image_1920" readonly="0" widget='image' class="oe_avatar" options='{"preview_image": "avatar_128"}'/>
                    <h1>
                        <field name="name" readonly="1" class="oe_inline"/>
                    </h1>
                    <notebook>
                        <page string="Preferences" name="preferences_page">
                            <group name="preferences">
                                <group>
                                    <field name="email" widget="email" readonly="0"/>
                                </group>
                                <group>
                                    <label for="lang"/>
                                    <div class="o_row">
                                        <field name="lang" required="1" readonly="0"/>
                                        <button
                                            type="action"
                                            name="%(base.action_view_base_language_install)d"
                                            class="oe_edit_only btn-sm btn-link mb4 fa fa-globe"
                                            aria-label="Add a language"
                                            groups="base.group_system"
                                            title="Add a language"
                                        />
                                    </div>
                                    <field name="tz" widget="timezone_mismatch" options="{'tz_offset_field': 'tz_offset'}" readonly="0"/>
                                    <field name="tz_offset" invisible="1"/>
                                </group>
                                <field name="share" invisible="1"/>
                            </group>
                            <group name="signature">
                                <field name="signature" readonly="0" options="{'style-inline': true, 'codeview': true}"/>
                            </group>
                            <group name="status" string="Status" invisible="1">
                                <field name="company_id" options="{'no_create': True}" readonly="0"
                                    groups="base.group_multi_company"/>
                            </group>
                            <group name="preference_contact"></group>
                        </page>
                        <page string="Account Security" name="page_account_security">
                            <group name="auth" string="Password Management">
                                <div colspan="2">
                                    <button name="preference_change_password" type="object" string="Change password" class="btn btn-secondary"/>
                                </div>
                            </group>
                            <group name="access" string="Other Devices">
                                <div colspan="2">
                                    <button name="action_revoke_all_devices" type="object" string="Log out from all devices" class="btn btn-secondary"/>
                                </div>
                            </group>
                            <group string="API Keys">
                                <div class="text-muted" colspan="2">
                                    API Keys are used to connect to Odoo from external tools without the need for a password or Two-factor Authentication.
                                    <a href="https://www.odoo.com/documentation/17.0/developer/misc/api/external_api.html#api-keys" target="_blank">
                                        <i title="Documentation" class="fa fa-fw o_button_icon fa-info-circle"></i>
                                        Learn more
                                    </a>
                                </div>
                                <div colspan="2" invisible="not api_key_ids">
                                    <field name="api_key_ids" nolabel="1" colspan="4" readonly="0">
                                        <tree editable="bottom" create="false" delete="false">
                                            <field name="name"/>
                                            <field name="scope"/>
                                            <field name="create_date"/>
                                            <button type="object" name="remove"
                                                    string="Delete API key." icon="fa-trash"/>
                                        </tree>
                                    </field>
                                </div>
                                <div colspan="2">
                                    <button name="api_key_wizard" string="New API Key" type="object" class="btn btn-secondary"/>
                                </div>
                            </group>
                        </page>
                    </notebook>
                    <footer>
                        <button name="preference_save" type="object" string="Save" class="btn-primary" data-hotkey="q"/>
                        <button name="preference_cancel" string="Cancel" special="cancel" data-hotkey="x" class="btn-secondary"/>
                    </footer>
                </form>
            </field>
        </record>
        <record id="action_res_users_my" model="ir.actions.act_window">
            <field name="name">Change My Preferences</field>
            <field name="res_model">res.users</field>
            <field name="target">new</field>
            <field name="view_mode">form</field>
        </record>
        <record id="action_res_users_my_view2" model="ir.actions.act_window.view">
            <field eval="10" name="sequence"/>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_users_form_simple_modif"/>
            <field name="act_window_id" ref="action_res_users_my"/>
        </record>

        <record model="ir.ui.view" id="view_apikeys">
            <field name="name">API Keys Listing</field>
            <field name="model">res.users.apikeys</field>
            <field name="groups_id" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="arch" type="xml">
                <tree create="false" edit="false" delete="false" editable="bottom">
                    <field name="user_id"/>
                    <field name="name"/>
                    <field name="scope"/>
                    <field name="create_date"/>
                    <button type="object" name="remove" title="Delete API key." icon="fa-trash"/>
                </tree>
            </field>
        </record>
        <record model="ir.actions.act_window" id="action_apikeys_admin">
            <field name="name">API Keys Listing</field>
            <field name="res_model">res.users.apikeys</field>
            <field name="view_mode">tree</field>
            <field name="groups_id" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="view_id" ref="base.view_apikeys"/>
        </record>

    </data>
</odoo>

```

Controllers:
  File: controllers/__init__.py
  Content:
```
from . import rpc

```

  File: controllers/rpc.py
  Content:
```
import re
import sys
import traceback
import xmlrpc.client
from datetime import date, datetime

from collections import defaultdict
from markupsafe import Markup

import odoo
from odoo.http import Controller, route, dispatch_rpc, request, Response
from odoo.fields import Date, Datetime, Command
from odoo.tools import lazy, ustr
from odoo.tools.misc import frozendict

# ==========================================================
# XML-RPC helpers
# ==========================================================

# XML-RPC fault codes. Some care must be taken when changing these: the
# constants are also defined client-side and must remain in sync.
# User code must use the exceptions defined in ``odoo.exceptions`` (not
# create directly ``xmlrpc.client.Fault`` objects).
RPC_FAULT_CODE_CLIENT_ERROR = 1 # indistinguishable from app. error.
RPC_FAULT_CODE_APPLICATION_ERROR = 1
RPC_FAULT_CODE_WARNING = 2
RPC_FAULT_CODE_ACCESS_DENIED = 3
RPC_FAULT_CODE_ACCESS_ERROR = 4

# 0 to 31, excluding tab, newline, and carriage return
CONTROL_CHARACTERS = dict.fromkeys(set(range(32)) - {9, 10, 13})


def xmlrpc_handle_exception_int(e):
    if isinstance(e, odoo.exceptions.RedirectWarning):
        fault = xmlrpc.client.Fault(RPC_FAULT_CODE_WARNING, str(e))
    elif isinstance(e, odoo.exceptions.AccessError):
        fault = xmlrpc.client.Fault(RPC_FAULT_CODE_ACCESS_ERROR, str(e))
    elif isinstance(e, odoo.exceptions.AccessDenied):
        fault = xmlrpc.client.Fault(RPC_FAULT_CODE_ACCESS_DENIED, str(e))
    elif isinstance(e, odoo.exceptions.UserError):
        fault = xmlrpc.client.Fault(RPC_FAULT_CODE_WARNING, str(e))
    else:
        info = sys.exc_info()
        formatted_info = "".join(traceback.format_exception(*info))
        fault = xmlrpc.client.Fault(RPC_FAULT_CODE_APPLICATION_ERROR, formatted_info)

    return xmlrpc.client.dumps(fault, allow_none=None)


def xmlrpc_handle_exception_string(e):
    if isinstance(e, odoo.exceptions.RedirectWarning):
        fault = xmlrpc.client.Fault('warning -- Warning\n\n' + str(e), '')
    elif isinstance(e, odoo.exceptions.MissingError):
        fault = xmlrpc.client.Fault('warning -- MissingError\n\n' + str(e), '')
    elif isinstance(e, odoo.exceptions.AccessError):
        fault = xmlrpc.client.Fault('warning -- AccessError\n\n' + str(e), '')
    elif isinstance(e, odoo.exceptions.AccessDenied):
        fault = xmlrpc.client.Fault('AccessDenied', str(e))
    elif isinstance(e, odoo.exceptions.UserError):
        fault = xmlrpc.client.Fault('warning -- UserError\n\n' + str(e), '')
    #InternalError
    else:
        info = sys.exc_info()
        formatted_info = "".join(traceback.format_exception(*info))
        fault = xmlrpc.client.Fault(odoo.tools.exception_to_unicode(e), formatted_info)

    return xmlrpc.client.dumps(fault, allow_none=None, encoding=None)


class OdooMarshaller(xmlrpc.client.Marshaller):
    dispatch = dict(xmlrpc.client.Marshaller.dispatch)

    def dump_frozen_dict(self, value, write):
        value = dict(value)
        self.dump_struct(value, write)

    # By default, in xmlrpc, bytes are converted to xmlrpc.client.Binary object.
    # Historically, odoo is sending binary as base64 string.
    # In python 3, base64.b64{de,en}code() methods now works on bytes.
    # Convert them to str to have a consistent behavior between python 2 and python 3.
    def dump_bytes(self, value, write):
        self.dump_unicode(ustr(value), write)

    def dump_datetime(self, value, write):
        # override to marshall as a string for backwards compatibility
        value = Datetime.to_string(value)
        self.dump_unicode(value, write)

    # convert date objects to strings in iso8061 format.
    def dump_date(self, value, write):
        value = Date.to_string(value)
        self.dump_unicode(value, write)

    def dump_lazy(self, value, write):
        v = value._value
        return self.dispatch[type(v)](self, v, write)

    def dump_unicode(self, value, write):
        # XML 1.0 disallows control characters, remove them otherwise they break clients
        return super().dump_unicode(value.translate(CONTROL_CHARACTERS), write)

    dispatch[frozendict] = dump_frozen_dict
    dispatch[bytes] = dump_bytes
    dispatch[datetime] = dump_datetime
    dispatch[date] = dump_date
    dispatch[lazy] = dump_lazy
    dispatch[str] = dump_unicode
    dispatch[Command] = dispatch[int]
    dispatch[defaultdict] = dispatch[dict]
    dispatch[Markup] = lambda self, value, write: self.dispatch[str](self, str(value), write)


# monkey-patch xmlrpc.client's marshaller
xmlrpc.client.Marshaller = OdooMarshaller

# ==========================================================
# RPC Controller
# ==========================================================
class RPC(Controller):
    """Handle RPC connections."""

    def _xmlrpc(self, service):
        """Common method to handle an XML-RPC request."""
        data = request.httprequest.get_data()
        params, method = xmlrpc.client.loads(data)
        result = dispatch_rpc(service, method, params)
        return xmlrpc.client.dumps((result,), methodresponse=1, allow_none=False)

    @route("/xmlrpc/<service>", auth="none", methods=["POST"], csrf=False, save_session=False)
    def xmlrpc_1(self, service):
        """XML-RPC service that returns faultCode as strings.

        This entrypoint is historical and non-compliant, but kept for
        backwards-compatibility.
        """
        try:
            response = self._xmlrpc(service)
        except Exception as error:
            response = xmlrpc_handle_exception_string(error)
        return Response(response=response, mimetype='text/xml')

    @route("/xmlrpc/2/<service>", auth="none", methods=["POST"], csrf=False, save_session=False)
    def xmlrpc_2(self, service):
        """XML-RPC service that returns faultCode as int."""
        try:
            response = self._xmlrpc(service)
        except Exception as error:
            response = xmlrpc_handle_exception_int(error)
        return Response(response=response, mimetype='text/xml')

    @route('/jsonrpc', type='json', auth="none", save_session=False)
    def jsonrpc(self, service, method, args):
        """ Method used by client APIs to contact OpenERP. """
        return dispatch_rpc(service, method, args)

```

Security:
  File: security/base_groups.xml
  Content:
```
<?xml version="1.0"?>
<odoo>
    <data>

        <!--
            Users Groups
            Note that the field 'category_id' is set later in
            base/data/ir_module_category_data.xml
        -->
        <record model="res.groups" id="group_erp_manager">
            <field name="name">Access Rights</field>
            <field name="implied_ids" eval="[Command.link(ref('group_user'))]"/>
        </record>

        <record id="group_sanitize_override" model="res.groups">
            <field name="name">Bypass HTML Field Sanitize</field>
        </record>

        <record model="res.groups" id="group_system">
            <field name="name">Settings</field>
            <field name="implied_ids" eval="[Command.link(ref('group_erp_manager')), Command.link(ref('group_sanitize_override'))]"/>
            <field name="users" eval="[Command.link(ref('base.user_root')), Command.link(ref('base.user_admin'))]"/>
        </record>

        <record model="res.groups" id="group_user">
            <field name="name">Internal User</field>
        </record>

        <record id="default_user" model="res.users">
            <field name="groups_id" eval="[Command.link(ref('base.group_user'))]"/>
        </record>

        <record model="res.groups" id="group_multi_company">
            <field name="name">Multi Companies</field>
        </record>

        <record model="res.groups" id="group_multi_currency">
            <field name="name">Multi Currencies</field>
        </record>

        <record model="res.groups" id="group_no_one">
            <field name="name">Technical Features</field>
        </record>
        <record id="group_allow_export" model="res.groups">
            <field name="name">Access to export feature</field>
            <field name="category_id" ref="base.module_category_hidden"/>
            <field name="users" eval="[Command.link(ref('base.user_root')), Command.link(ref('base.user_admin'))]"/>
        </record>
        <record model="res.groups" id="group_user">
            <field name="implied_ids" eval="[Command.link(ref('group_no_one'))]"/>
            <field name="users" eval="[Command.link(ref('base.user_root')), Command.link(ref('base.user_admin'))]"/>
        </record>

        <record model="res.groups" id="group_partner_manager">
            <field name="name">Contact Creation</field>
            <field name="users" eval="[Command.link(ref('base.user_root')), Command.link(ref('base.user_admin'))]"/>
        </record>

        <record id="default_user" model="res.users">
            <field name="groups_id" eval="[Command.link(ref('base.group_partner_manager')), Command.link(ref('base.group_allow_export'))]"/>
        </record>

        <!--
            A group dedicated to the portal users, making groups
            restrictions more convenient.
        -->
        <record id="group_portal" model="res.groups">
            <field name="name">Portal</field>
            <field name="comment">Portal members have specific access rights (such as record rules and restricted menus).
                They usually do not belong to the usual Odoo groups.</field>
        </record>
        <!--
            A group dedicated to the public user only, making groups
            restrictions more convenient.
        -->
        <record id="group_public" model="res.groups">
            <field name="name">Public</field>
            <field name="comment">Public users have specific access rights (such as record rules and restricted menus).
                They usually do not belong to the usual Odoo groups.</field>
        </record>

        <record id="public_user" model="res.users">
            <field name="groups_id" eval="[Command.link(ref('base.group_public'))]"/>
        </record>

        <!-- Default template user for new users signing in -->
        <record id="template_portal_user_id" model="res.users">
            <field name="name">Portal User Template</field>
            <field name="login">portaltemplate</field>
            <field name="active" eval="False"/>
            <field name="groups_id" eval="[Command.set([ref('base.group_portal')])]"/>
        </record>

        <record id="default_template_user_config" model="ir.config_parameter">
            <field name="key">base.template_portal_user_id</field>
            <field name="value" ref="template_portal_user_id"/>
        </record>

    </data>
</odoo>

```

  File: security/base_security.xml
  Content:
```
<?xml version="1.0"?>
<odoo>
    <data noupdate="1">
        <!-- TODO Remove me? Ony group system -->
        <record model="ir.rule" id="res_users_log_rule">
            <field name="name">res.users.log per user</field>
            <field name="model_id" ref="model_res_users_log"/>
            <field name="domain_force">[('create_uid','=', user.id)]</field>
            <field name="perm_read" eval="False"/>
        </record>

        <record model="ir.rule" id="res_partner_rule">
            <field name="name">res.partner company</field>
            <field name="model_id" ref="base.model_res_partner"/>
            <!-- We exclude partners that have internal users (`partner_share` field) from
            the multi-company rule because it might interfere with the user's company rule
            and make some users unselectable in relational fields. This means that partners
            of internal users are always visible, not matter the company setting. -->
            <field name="domain_force">['|', '|', ('partner_share', '=', False), ('company_id', 'parent_of', company_ids), ('company_id', '=', False)]</field>
        </record>

        <record model="ir.rule" id="res_partner_portal_public_rule">
            <field name="name">res_partner: portal/public: read access on my commercial partner</field>
            <field name="model_id" ref="base.model_res_partner"/>
            <field name="domain_force">[('id', 'child_of', user.commercial_partner_id.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_portal')), Command.link(ref('base.group_public'))]"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
            <field name="perm_write" eval="False"/>
        </record>

        <record model="ir.rule" id="ir_default_user_rule">
            <field name="name">Defaults: alter personal defaults</field>
            <field name="model_id" ref="model_ir_default"/>
            <field name="domain_force">[('user_id','=',user.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/>
        </record>

        <record model="ir.rule" id="ir_default_system_rule">
            <field name="name">Defaults: alter all defaults</field>
            <field name="model_id" ref="model_ir_default"/>
            <field name="domain_force">[(1,'=',1)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="perm_read" eval="False"/>
        </record>

        <!-- Used for dashboard customizations, users should only be able to edit their own dashboards -->
        <!-- Remove me? users never create those directly -->
        <record model="ir.rule" id="ir_ui_view_custom_personal">
            <field name="name">ir.ui.view_custom rule</field>
            <field name="model_id" ref="model_ir_ui_view_custom"/>
            <field name="domain_force">[('user_id','=',user.id)]</field>
        </record>

        <record id="res_partner_bank_rule" model="ir.rule">
            <field name="name">Partner bank company rule</field>
            <field name="model_id" ref="model_res_partner_bank"/>
            <field name="domain_force">[('company_id', 'in', company_ids + [False])]</field>
        </record>

        <record id="res_currency_rate_rule" model="ir.rule">
            <field name="name">multi-company currency rate rule</field>
            <field name="model_id" ref="model_res_currency_rate"/>
            <field name="domain_force">[('company_id', 'in', company_ids + [False])]</field>
        </record>

        <record id="change_password_rule" model="ir.rule">
            <field name="name">change user password rule</field>
            <field name="model_id" ref="model_change_password_user"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
        </record>

        <!-- Restrict modifications on ir.filters to owner only -->
        <record id="ir_filters_admin_all_rights_rule" model="ir.rule">
            <field name="name">ir.filters.admin.all.rights</field>
            <field name="model_id" ref="model_ir_filters"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_erp_manager'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="ir_filters_employee_rule" model="ir.rule">
            <field name="name">ir.filters.owner</field>
            <field name="model_id" ref="model_ir_filters"/>
            <field name="domain_force">[('user_id','in',[False,user.id])]</field>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="ir_filters_delete_own_rule" model="ir.rule">
            <field name="name">ir.filters.own.rule.delete</field>
            <field name="model_id" ref="model_ir_filters"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
        </record>

        <record id="ir_filters_portal_public_rule" model="ir.rule">
            <field name="name">ir.filter: portal/public</field>
            <field name="model_id" ref="model_ir_filters"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_portal')), Command.link(ref('base.group_public'))]"/>
        </record>

        <!-- Record Rules For Company -->
        <record id="res_company_rule_portal" model="ir.rule">
            <field name="name">company rule portal</field>
            <field name="model_id" ref="model_res_company"/>
            <field eval="False" name="global"/>
            <field name="groups" eval="[Command.set([ref('base.group_portal')])]"/>
            <field name="domain_force">[('id','in', company_ids)]</field>
        </record>
        <record id="res_company_rule_employee" model="ir.rule">
            <field name="name">company rule employee</field>
            <field name="model_id" ref="model_res_company"/>
            <field eval="False" name="global"/>
            <field name="groups" eval="[Command.set([ref('base.group_user')])]"/>
            <field name="domain_force">[('id','in', company_ids)]</field>
        </record>
        <record id="res_company_rule_public" model="ir.rule">
            <field name="name">company rule public</field>
            <field name="model_id" ref="model_res_company"/>
            <field eval="False" name="global"/>
            <field name="groups" eval="[Command.set([ref('base.group_public')])]"/>
            <field name="domain_force">[('id','in', company_ids)]</field>
        </record>
        <record id="res_company_rule_erp_manager" model="ir.rule">
            <field name="name">company rule erp manager</field>
            <field name="model_id" ref="model_res_company"/>
            <field eval="False" name="global"/>
            <field name="groups" eval="[Command.set([ref('base.group_erp_manager')])]"/>
            <field name="domain_force">[(1,'=',1)]</field>
        </record>

        <record id="res_users_identity_check" model="ir.rule">
            <field name="name">users can only access their own id check</field>
            <field name="model_id" ref="model_res_users_identitycheck"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
        </record>

        <!-- Record Rule For User -->
        <record id="res_users_rule" model="ir.rule">
            <field name="name">user rule</field>
            <field name="model_id" ref="model_res_users"/>
            <field eval="True" name="global"/>
            <field name="domain_force">['|', ('share', '=', False), ('company_ids', 'in', company_ids)]</field>
        </record>

        <record id="change_password_own_rule" model="ir.rule">
            <field name="name">change own password</field>
            <field name="model_id" ref="model_change_password_own"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
        </record>

        <!-- Record Rule For User settings -->
        <record id="res_users_settings_rule_admin" model="ir.rule">
            <field name="name">Administrators can access all User Settings.</field>
            <field name="model_id" ref="model_res_users_settings"/>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="res_users_settings_rule_user" model="ir.rule">
            <field name="name">res.users.settings: access their own entries</field>
            <field name="model_id" ref="model_res_users_settings"/>
            <field name="groups" eval="[Command.link(ref('base.group_user'))]"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <!-- rules for API token -->
        <record id="api_key_public" model="ir.rule">
            <field name="name">Public users can't interact with keys at all</field>
            <field name="model_id" ref="model_res_users_apikeys"/>
            <field name="domain_force">[(0, '=', 1)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_public'))]"/>
        </record>
        <record id="api_key_user" model="ir.rule">
            <field name="name">Users can read and delete their own keys</field>
            <field name="model_id" ref="model_res_users_apikeys"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field>
            <field name="groups" eval="[
                Command.link(ref('base.group_portal')),
                Command.link(ref('base.group_user')),
            ]"/>
        </record>
        <record id="api_key_admin" model="ir.rule">
            <field name="name">Administrators can view user keys to revoke them</field>
            <field name="model_id" ref="model_res_users_apikeys"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[Command.link(ref('base.group_system'))]"/>
        </record>
    </data>
</odoo>

```

Data:
  File: data/base_data.sql
  Content:
```
-------------------------------------------------------------------------
-- Pure SQL
-------------------------------------------------------------------------

CREATE TABLE ir_actions (
  id serial,
  primary key(id)
);
CREATE TABLE ir_act_window (primary key(id)) INHERITS (ir_actions);
CREATE TABLE ir_act_report_xml (primary key(id)) INHERITS (ir_actions);
CREATE TABLE ir_act_url (primary key(id)) INHERITS (ir_actions);
CREATE TABLE ir_act_server (primary key(id)) INHERITS (ir_actions);
CREATE TABLE ir_act_client (primary key(id)) INHERITS (ir_actions);

CREATE TABLE res_users (
    id serial NOT NULL,
    -- No FK references below, will be added later by ORM
    -- (when the destination rows exist)
    company_id integer, -- references res_company,
    partner_id integer, -- references res_partner,
    active boolean default True,
    create_date timestamp without time zone,
    login varchar(64) NOT NULL UNIQUE,
    password varchar default null,
    primary key(id)
);

CREATE TABLE res_groups (
    id serial NOT NULL,
    name jsonb NOT NULL,
    primary key(id)
);

CREATE TABLE ir_module_category (
    id serial NOT NULL,
    create_uid integer, -- references res_users on delete set null,
    create_date timestamp without time zone,
    write_date timestamp without time zone,
    write_uid integer, -- references res_users on delete set null,
    parent_id integer REFERENCES ir_module_category ON DELETE SET NULL,
    name jsonb NOT NULL,
    primary key(id)
);

CREATE TABLE ir_module_module (
    id serial NOT NULL,
    create_uid integer, -- references res_users on delete set null,
    create_date timestamp without time zone,
    write_date timestamp without time zone,
    write_uid integer, -- references res_users on delete set null,
    website character varying,
    summary jsonb,
    name character varying NOT NULL,
    author character varying,
    icon varchar,
    state character varying(16),
    latest_version character varying,
    shortdesc jsonb,
    category_id integer REFERENCES ir_module_category ON DELETE SET NULL,
    description jsonb,
    application boolean default False,
    demo boolean default False,
    web boolean DEFAULT FALSE,
    license character varying(32),
    sequence integer DEFAULT 100,
    auto_install boolean default False,
    to_buy boolean default False,
    primary key(id)
);

CREATE TABLE ir_module_module_dependency (
    id serial NOT NULL,
    name character varying,
    module_id integer REFERENCES ir_module_module ON DELETE cascade,
    auto_install_required boolean DEFAULT true,
    primary key(id)
);

CREATE TABLE ir_model_data (
    id serial NOT NULL,
    create_uid integer,
    create_date timestamp without time zone DEFAULT (now() at time zone 'UTC'),
    write_date timestamp without time zone DEFAULT (now() at time zone 'UTC'),
    write_uid integer,
    res_id integer,
    noupdate boolean DEFAULT False,
    name varchar NOT NULL,
    module varchar NOT NULL,
    model varchar NOT NULL,
    primary key(id)
);

CREATE TABLE res_currency (
    id serial,
    name varchar NOT NULL,
    symbol varchar NOT NULL,
    primary key(id)
);

CREATE TABLE res_company (
    id serial,
    name varchar NOT NULL,
    partner_id integer,
    currency_id integer,
    sequence integer,
    create_date timestamp without time zone,
    primary key(id)
);

CREATE TABLE res_partner (
    id serial,
    company_id integer,
    create_date timestamp without time zone,
    name varchar,
    primary key(id)
);


---------------------------------
-- Default data
---------------------------------
insert into res_currency (id, name, symbol) VALUES (1, 'USD', '$');
insert into ir_model_data (name, module, model, noupdate, res_id) VALUES ('USD', 'base', 'res.currency', true, 1);
select setval('res_currency_id_seq', 1);

insert into res_company (id, name, partner_id, currency_id, create_date) VALUES (1, 'My Company', 1, 1, now() at time zone 'UTC');
insert into ir_model_data (name, module, model, noupdate, res_id) VALUES ('main_company', 'base', 'res.company', true, 1);
select setval('res_company_id_seq', 1);

insert into res_partner (id, name, company_id, create_date) VALUES (1, 'My Company', 1, now() at time zone 'UTC');
insert into ir_model_data (name, module, model, noupdate, res_id) VALUES ('main_partner', 'base', 'res.partner', true, 1);
select setval('res_partner_id_seq', 1);

insert into res_users (id, login, password, active, partner_id, company_id, create_date) VALUES (1, '__system__', NULL, false, 1, 1, now() at time zone 'UTC');
insert into ir_model_data (name, module, model, noupdate, res_id) VALUES ('user_root', 'base', 'res.users', true, 1);
select setval('res_users_id_seq', 1);

insert into res_groups (id, name) VALUES (1, '{"en_US": "Employee"}');
insert into ir_model_data (name, module, model, noupdate, res_id) VALUES ('group_user', 'base', 'res.groups', true, 1);
select setval('res_groups_id_seq', 1);

```

  File: data/ir_cron_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="autovacuum_job" model="ir.cron">
        <field name="name">Base: Auto-vacuum internal data</field>
        <field name="model_id" ref="model_ir_autovacuum"/>
        <field name="state">code</field>
        <field name="code">model._run_vacuum_cleaner()</field>
        <field name='interval_number'>1</field>
        <field name='interval_type'>days</field>
        <field name="numbercall">-1</field>
        <field name="priority">3</field>
    </record>

    <record id="ir_cron_res_users_deletion" model="ir.cron">
        <field name="name">Base: Portal Users Deletion</field>
        <field name="model_id" ref="base.model_res_users_deletion"/>
        <field name="state">code</field>
        <field name="code">model._gc_portal_users()</field>
        <field name='interval_number'>1</field>
        <field name='interval_type'>days</field>
        <field name="numbercall">-1</field>
    </record>
</odoo>

```

  File: data/ir_demo_data.xml
  Content:
```
<odoo>
    <record model="ir.actions.act_window" id="demo_force_install_action">
        <field name="name">Load demo data</field>
        <field name="res_model">ir.demo</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <record model="ir.ui.view" id="demo_force_install_form">
        <field name="name">ir.demo.form</field>
        <field name="model">ir.demo</field>
        <field name="arch" type="xml">
            <form>
                <div class="row container">
                    <div class="col-12 text-center">
                      <div class="card text-white bg-danger mb-3 w-75 ml64">
                        <div class="card-header">
                                <span class="fa fa-2x fa-warning" t-translation="off">&amp;nbsp;</span>
                                <span class="text-white text-uppercase">Danger Zone</span>
                        </div>
                        <div class="card-body bg-transparent text-center">
                          <p>Demo data should only be used on test databases!
                             Once they are loaded, they cannot be removed!</p>
                          <p>Please confirm that you want to <b>irreversibly</b> make this database a demo database.</p>
                        </div>
                      </div>
                    </div>
                </div>

                <footer>
                    <button special="cancel" data-hotkey="x" string="Oops, no!" class="btn-primary"/>
                    <button name="install_demo" string="Yes, I understand the risks" type="object" class="btn-secondary" data-hotkey="q"/>
                </footer>
            </form>
        </field>
    </record>
</odoo>

```

  File: data/ir_demo_failure_data.xml
  Content:
```
<odoo>
    <record model="ir.actions.server" id="demo_failure_action">
        <field name="name">Failed to install demo data for some modules, demo disabled</field>
        <field name="model_id" ref="base.model_ir_demo_failure_wizard"/>
        <field name="state">code</field>
        <field name="code">
failures = env['ir.demo_failure'].search([
    ('wizard_id', '=', False),
])
record = model.create({
    'failure_ids': [Command.set(failures.ids)],
})
action = {
    'type': 'ir.actions.act_window',
    'res_id': record.id,
    'res_model': 'ir.demo_failure.wizard',
    'target': 'new',
    'views': [(env.ref('base.demo_failures_dialog').id, 'form')],
}
        </field>
    </record>

    <record model="ir.ui.view" id="demo_failures_dialog">
        <field name="name">Demo Failure Dialog</field>
        <field name="model">ir.demo_failure.wizard</field>
        <field name="arch" type="xml">
            <form>
                <h3>
                    The demonstration data of <field name="failures_count"/>
                    module(s) failed to install and were disabled
                </h3>
                <field name="failure_ids">
                    <tree>
                        <field name="module_id"/>
                        <field name="error"/>
                    </tree>
                </field>
                <footer>
                    <button string="Ok" class="oe_highlight" type="object" name="done" data-hotkey="q"/>
                </footer>
            </form>
        </field>
    </record>

    <record model="ir.ui.view" id="demo_wizard_form_view">
        <field name="name">Demo Failure Form</field>
        <field name="model">ir.demo_failure</field>
        <field name="arch" type="xml">
            <form>
                <sheet>
                    <group>
                        <group>
                            <field name="module_id"/>
                            <field name="wizard_id"/>
                        </group>
                        <group>
                            <field name="error"/>
                        </group>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record model="ir.actions.todo" id="demo_failure_todo">
        <field name="name">Demo Failure Notification</field>
        <field name="sequence">1</field>
        <field name="state">done</field>
        <field name="action_id" ref="base.demo_failure_action"/>
    </record>
</odoo>

```

  File: data/ir_module_category_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record model="ir.module.category" id="module_category_hidden">
            <field name="name">Technical</field>
            <field name="sequence">60</field>
            <field name="visible" eval="0" />
        </record>

        <record model="ir.module.category" id="module_category_accounting">
            <field name="name">Accounting</field>
            <field name="sequence">15</field>
        </record>

        <record model="ir.module.category" id="module_category_accounting_localizations">
            <field name="name">Localization</field>
            <field name="sequence">65</field>
            <field name="visible" eval="0" />
            <field name="parent_id" ref="module_category_accounting"/>
        </record>

        <record model="ir.module.category" id="module_category_payroll_localization">
            <field name="name">Payroll Localization</field>
            <field name="visible" eval="0" />
        </record>

        <record model="ir.module.category" id="module_category_accounting_localizations_account_charts">
            <field name="parent_id" ref="module_category_accounting_localizations" />
            <field name="name">Account Charts</field>
            <field name="visible" eval="0" />
        </record>

        <record model="ir.module.category" id="module_category_user_type">
            <field name="name">User types</field>
            <field name="description">Helps you manage users.</field>
            <field name="sequence">9</field>
        </record>

        <record model="ir.module.category" id="module_category_accounting_accounting">
            <field name="name">Invoicing</field>
            <field name="sequence">4</field>
        </record>

        <record model="ir.module.category" id="module_category_sales">
            <field name="name">Sales</field>
            <field name="sequence">5</field>
        </record>

        <record model="ir.module.category" id="module_category_human_resources">
            <field name="name">Human Resources</field>
            <field name="sequence">45</field>
        </record>

        <record model="ir.module.category" id="module_category_marketing">
            <field name="name">Marketing</field>
            <field name="sequence">40</field>
        </record>

        <record model="ir.module.category" id="module_category_manufacturing">
            <field name="name">Manufacturing</field>
            <field name="sequence">30</field>
        </record>

        <record model="ir.module.category" id="module_category_website">
            <field name="name">Website</field>
            <field name="sequence">35</field>
        </record>

        <record model="ir.module.category" id="module_category_theme">
            <field name="name">Theme</field>
            <field name="exclusive" eval="0"/>
            <field name="sequence">50</field>
        </record>

        <record model="ir.module.category" id="module_category_administration">
            <field name="name">Administration</field>
            <field name="sequence">100</field>
            <field name="parent_id" eval="False"/>
        </record>

        <record model="ir.module.category" id="module_category_human_resources_appraisals">
            <field name="name">Appraisals</field>
            <field name="description">A user without any rights on Appraisals will be able to see the application, create and manage appraisals for himself and the people he's manager of.</field>
            <field name="sequence">15</field>
        </record>

        <record model="ir.module.category" id="module_category_sales_sign">
            <field name="name">Sign</field>
            <field name="description">Helps you sign and complete your documents easily.</field>
            <field name="sequence">25</field>
        </record>

        <record model="ir.module.category" id="module_category_services">
            <field name="name">Services</field>
            <field name="sequence">10</field>
        </record>

        <record model="ir.module.category" id="module_category_services_helpdesk">
            <field name="name">Helpdesk</field>
            <field name="description">After-sales services</field>
            <field name="sequence">14</field>
        </record>

        <record model="ir.module.category" id="module_category_services_appointment">
            <field name="name">Appointment</field>
            <field name="parent_id" ref="module_category_services"/>
        </record>

        <record model="ir.module.category" id="module_category_services_field_service">
            <field name="name">Field Service</field>
            <field name="parent_id" ref="module_category_services"/>
        </record>

        <record model="ir.module.category" id="module_category_inventory">
            <field name="name">Inventory</field>
            <field name="sequence">25</field>
        </record>

        <record model="ir.module.category" id="module_category_productivity">
            <field name="name">Productivity</field>
            <field name="sequence">50</field>
        </record>

        <record model="ir.module.category" id="module_category_customizations">
            <field name="name">Customizations</field>
            <field name="sequence">55</field>
        </record>

        <record model="ir.module.category" id="module_category_administration_administration">
            <field name="name">Administration</field>
            <field name="parent_id" ref="module_category_administration"/>
        </record>

        <record model="ir.module.category" id="module_category_usability">
            <field name="name">Extra Rights</field>
            <field name="sequence">101</field>
        </record>

        <record model="ir.module.category" id="module_category_extra">
            <field name="name">Other Extra Rights</field>
            <field name="sequence">102</field>
        </record>

        <!-- add applications to base groups -->
        <record model="res.groups" id="group_erp_manager">
            <field name="category_id" ref="module_category_administration_administration"/>
        </record>
        <record model="res.groups" id="group_system">
            <field name="category_id" ref="module_category_administration_administration"/>
        </record>

        <record model="res.groups" id="group_user">
            <field name="category_id" ref="module_category_user_type"/>
        </record>

        <record model="res.groups" id="group_multi_company">
            <field name="category_id" ref="module_category_usability"/>
        </record>

        <record model="res.groups" id="group_multi_currency">
            <field name="category_id" ref="module_category_usability"/>
        </record>

        <record model="res.groups" id="group_no_one">
            <field name="category_id" ref="module_category_usability"/>
        </record>

        <record id="group_portal" model="res.groups">
            <field name="category_id" ref="module_category_user_type"/>
        </record>

        <record id="group_public" model="res.groups">
            <field name="category_id" ref="module_category_user_type"/>
        </record>

        <record id="group_partner_manager" model="res.groups">
            <field name="category_id" ref="module_category_usability"/>
        </record>

    </data>
</odoo>

```

  File: data/ir_module_module.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record model="ir.module.module" id="base.module_web_studio">
            <field name="name">web_studio</field>
            <field name="shortdesc">Studio</field>
            <field name="sequence">75</field>
            <field name="category_id" ref="base.module_category_administration_administration"/>
            <field name="application" eval="True"/>
            <field name="summary">Create and Customize Applications</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/web_studio.png</field>
            <field name="website">https://odoo.com/app/studio?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_timesheet_grid">
            <field name="name">timesheet_grid</field>
            <field name="shortdesc">Timesheets</field>
            <field name="sequence">65</field>
            <field name="category_id" ref="base.module_category_services_timesheets"/>
            <field name="application" eval="True"/>
            <field name="summary">Track time &amp; costs</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/timesheet_grid.png</field>
            <field name="website">https://www.odoo.com/app/timesheet?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_account_accountant">
            <field name="name">account_accountant</field>
            <field name="sequence">30</field>
            <field name="shortdesc">Accounting</field>
            <field name="category_id" ref="base.module_category_accounting_accounting"/>
            <field name="application" eval="True"/>
            <field name="summary">Accounting, Taxes, Budgets, Assets...</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/account_accountant.png</field>
            <field name="website">https://www.odoo.com/app/accounting?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_knowledge">
            <field name="name">knowledge</field>
            <field name="sequence">30</field>
            <field name="shortdesc">Knowledge</field>
            <field name="category_id" ref="base.module_category_productivity"/>
            <field name="application" eval="True"/>
            <field name="summary">Centralize, manage, share and grow your knowledge library</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/knowledge.png</field>
            <field name="website">https://www.odoo.com/app/knowledge?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_industry_fsm">
            <field name="name">industry_fsm</field>
            <field name="shortdesc">Field Service</field>
            <field name="sequence">90</field>
            <field name="category_id" ref="base.module_category_services_field_service"/>
            <field name="application" eval="True"/>
            <field name="summary">Schedule and track onsite operations, time and material</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/industry_fsm.png</field>
            <field name="website">https://www.odoo.com/app/field-service?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_helpdesk">
            <field name="name">helpdesk</field>
            <field name="shortdesc">Helpdesk</field>
            <field name="sequence">110</field>
            <field name="category_id" ref="base.module_category_services_helpdesk"/>
            <field name="application" eval="True"/>
            <field name="summary">Track support tickets</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/helpdesk.png</field>
            <field name="website">https://www.odoo.com/app/helpdesk?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_hr_appraisal">
            <field name="name">hr_appraisal</field>
            <field name="shortdesc">Appraisal</field>
            <field name="sequence">180</field>
            <field name="category_id" ref="base.module_category_human_resources_appraisals"/>
            <field name="application" eval="True"/>
            <field name="summary">Assess your employees</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/hr_appraisal.png</field>
            <field name="website">https://www.odoo.com/app/appraisals?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_marketing_automation">
            <field name="name">marketing_automation</field>
            <field name="shortdesc">Marketing Automation</field>
            <field name="sequence">195</field>
            <field name="category_id" ref="base.module_category_marketing_email_marketing"/>
            <field name="application" eval="True"/>
            <field name="summary">Build automated mailing campaigns</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/marketing_automation.png</field>
            <field name="website">https://www.odoo.com/app/marketing-automation?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_mrp_plm">
            <field name="name">mrp_plm</field>
            <field name="shortdesc">Product Lifecycle Management (PLM)</field>
            <field name="category_id" ref="base.module_category_manufacturing_manufacturing"/>
            <field name="sequence">155</field>
            <field name="application" eval="True"/>
            <field name="summary">PLM, ECOs, Versions</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/mrp_plm.png</field>
            <field name="website">https://www.odoo.com/app/plm?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_quality_control">
            <field name="name">quality_control</field>
            <field name="shortdesc">Quality</field>
            <field name="sequence">120</field>
            <field name="category_id" ref="base.module_category_manufacturing_manufacturing"/>
            <field name="application" eval="True"/>
            <field name="summary">Quality Alerts, Control Points</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/quality_control.png</field>
            <field name="website">https://www.odoo.com/app/quality?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_sale_amazon">
            <field name="name">sale_amazon</field>
            <field name="shortdesc">Amazon Connector</field>
            <field name="sequence">320</field>
            <field name="category_id" ref="base.module_category_sales_sales"/>
            <field name="application" eval="True"/>
            <field name="summary">Import Amazon orders and sync deliveries</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/sale_amazon.png</field>
            <field name="website">https://www.odoo.com/app/amazon-connector?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_sale_ebay">
            <field name="name">sale_ebay</field>
            <field name="shortdesc">eBay Connector</field>
            <field name="sequence">325</field>
            <field name="category_id" ref="base.module_category_sales_sales"/>
            <field name="application" eval="True"/>
            <field name="summary">Sell on eBay easily</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/sale_ebay.png</field>
            <field name="website">https://www.odoo.com/app/sales?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_planning">
            <field name="name">planning</field>
            <field name="shortdesc">Planning</field>
            <field name="sequence">130</field>
            <field name="category_id" ref="base.module_category_services_project"/>
            <field name="application" eval="True"/>
            <field name="summary">Manage your employees' schedule</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/planning.png</field>
            <field name="website">https://www.odoo.com/app/planning?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_sale_subscription">
            <field name="name">sale_subscription</field>
            <field name="shortdesc">Subscriptions</field>
            <field name="sequence">115</field>
            <field name="category_id" ref="base.module_category_sales_sales"/>
            <field name="application" eval="True"/>
            <field name="summary">MRR, Churn, Recurring payments</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/sale_subscription.png</field>
            <field name="website">https://www.odoo.com/app/subscriptions?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_sign">
            <field name="name">sign</field>
            <field name="shortdesc">Sign</field>
            <field name="sequence">105</field>
            <field name="category_id" ref="base.module_category_sales_sign"/>
            <field name="application" eval="True"/>
            <field name="summary">Send documents to sign online</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/sign.png</field>
            <field name="website">https://www.odoo.com/app/sign?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_stock_barcode">
            <field name="name">stock_barcode</field>
            <field name="shortdesc">Barcode</field>
            <field name="sequence">255</field>
            <field name="category_id" ref="base.module_category_inventory_inventory"/>
            <field name="application" eval="True"/>
            <field name="summary">Barcode scanner for warehouses</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/stock_barcode.png</field>
            <field name="website">https://www.odoo.com/app/inventory?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_voip">
            <field name="name">voip</field>
            <field name="shortdesc">VoIP</field>
            <field name="sequence">280</field>
            <field name="category_id" ref="base.module_category_sales_sales"/>
            <field name="application" eval="True"/>
            <field name="summary">Call using VoIP</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/voip.png</field>
            <field name="website">https://www.odoo.com/app/crm?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_appointment">
            <field name="name">appointment</field>
            <field name="shortdesc">Appointments</field>
            <field name="sequence">215</field>
            <field name="category_id" ref="base.module_category_marketing"/>
            <field name="application" eval="True"/>
            <field name="summary">Online appointments scheduler</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/appointment.png</field>
            <field name="website">https://www.odoo.com/app/appointments?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_social">
            <field name="name">social</field>
            <field name="shortdesc">Social Marketing</field>
            <field name="sequence">175</field>
            <field name="category_id" ref="base.module_category_marketing"/>
            <field name="application" eval="True"/>
            <field name="summary">Manage your social media and website visitors</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/social.png</field>
            <field name="website">https://www.odoo.com/app/social-marketing</field>
        </record>

        <record model="ir.module.module" id="base.module_mrp_workorder">
            <field name="name">mrp_workorder</field>
            <field name="sequence">16</field>
            <field name="shortdesc">MRP II</field>
            <field name="category_id" ref="base.module_category_manufacturing_manufacturing"/>
            <field name="application" eval="True"/>
            <field name="summary">Work Orders, Planning, Routing</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/mrp_workorder.png</field>
            <field name="website">https://www.odoo.com/page/manufacturing?utm_source=db&amp;utm_medium=module</field>
        </record>

        <record model="ir.module.module" id="base.module_web_mobile">
            <field name="name">web_mobile</field>
            <field name="sequence">220</field>
            <field name="shortdesc">Android &amp; iPhone</field>
            <field name="category_id" ref="base.module_category_administration_administration"/>
            <field name="application" eval="True"/>
            <field name="summary">Support for Android &amp; iOS Apps</field>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/web_mobile.png</field>
            <field name="website">https://play.google.com/store/apps/details?id=com.odoo.mobile</field>
        </record>

        <record model="ir.module.module" id="base.module_website_twitter_wall">
            <field name="name">website_twitter_wall</field>
            <field name="shortdesc">Twitter Wall</field>
            <field name="summary">Interactive twitter wall for events</field>
            <field name="category_id" ref="base.module_category_website_website"/>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/website_twitter_wall.png</field>
        </record>

        <record model="ir.module.module" id="base.module_payment_sepa_direct_debit">
            <field name="name">payment_sepa_direct_debit</field>
            <field name="shortdesc">Sepa Direct Debit Payment Provider</field>
            <field name="summary">Checkout with SEPA Direct Debit</field>
            <field name="category_id" ref="base.module_category_accounting_accounting"/>
            <field name="license">OEEL-1</field>
            <field name="author">Odoo S.A.</field>
            <field name="to_buy" eval="True"/>
            <field name="icon">/base/static/img/icons/payment_sepa_direct_debit.png</field>
        </record>
    </data>
</odoo>

```

  File: data/neutralize.sql
  Content:
```
-- deactivate mail servers
UPDATE ir_mail_server
   SET active = false;

-- insert dummy mail server to prevent using fallback servers specified using command line
INSERT INTO ir_mail_server(name, smtp_port, smtp_host, smtp_encryption, active, smtp_authentication)
VALUES ('neutralization - disable emails', 1025, 'invalid', 'none', true, 'login');

-- deactivate crons
UPDATE ir_cron
   SET active = false
 WHERE id NOT IN (
       SELECT res_id
         FROM ir_model_data
        WHERE model = 'ir.cron'
          AND name = 'autovacuum_job'
          AND module = 'base'
);

-- neutralization flag for the database
INSERT INTO ir_config_parameter (key, value)
VALUES ('database.is_neutralized', true)
    ON CONFLICT (key) DO
       UPDATE SET value = true;

-- deactivate webhooks
UPDATE ir_act_server
   SET webhook_url = 'neutralization - disable webhook'
 WHERE state = 'webhook';

```

  File: data/report_paperformat_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="paperformat_euro" model="report.paperformat">
            <field name="name">A4</field>
            <field name="default" eval="True" />
            <field name="format">A4</field>
            <field name="page_height">0</field>
            <field name="page_width">0</field>
            <field name="orientation">Portrait</field>
            <field name="margin_top">40</field>
            <field name="margin_bottom">32</field>
            <field name="margin_left">7</field>
            <field name="margin_right">7</field>
            <field name="header_line" eval="False" />
            <field name="header_spacing">35</field>
            <field name="dpi">90</field>
        </record>

        <record id="paperformat_us" model="report.paperformat">
            <field name="name">US Letter</field>
            <field name="default" eval="True" />
            <field name="format">Letter</field>
            <field name="page_height">0</field>
            <field name="page_width">0</field>
            <field name="orientation">Portrait</field>
            <field name="margin_top">40</field>
            <field name="margin_bottom">30</field>
            <field name="margin_left">7</field>
            <field name="margin_right">7</field>
            <field name="header_line" eval="False" />
            <field name="header_spacing">35</field>
            <field name="dpi">90</field>
        </record>

        <record id="paperformat_batch_deposit" model="report.paperformat">
            <field name="name">US Batch Deposit</field>
            <field name="default" eval="False" />
            <field name="format">Letter</field>
            <field name="page_height">0</field>
            <field name="page_width">0</field>
            <field name="orientation">Portrait</field>
            <field name="margin_top">15</field>
            <field name="margin_bottom">30</field>
            <field name="margin_left">10</field>
            <field name="margin_right">10</field>
            <field name="header_line" eval="False" />
            <field name="header_spacing">15</field>
            <field name="dpi">90</field>
        </record>
    </data>
</odoo>
```

  File: data/res_bank.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record id="res_bank_1" model="res.bank">
            <field name="name">Reserve</field>
            <field name="active" eval="False"/>
        </record>

    </data>
</odoo>

```

  File: data/res_bank_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record model="res.bank" id="bank_ing">
            <field name="name">ING</field>
            <field name="bic">BBRUBEBB</field>
        </record>

        <record model="res.bank" id="bank_bnp">
            <field name="name">BNP Paribas</field>
            <field name="bic">GEBABEBB</field>
        </record>

    </data>
</odoo>

```

  File: data/res_company_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="main_company" model="res.company">
            <field name="name">My Company</field>
            <field name="partner_id" ref="main_partner"/>
            <field name="currency_id" ref="base.USD"/>
        </record>
    </data> 
</odoo>

```

  File: data/res_country_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record id="ad" model="res.country">
            <field name="name">Andorra</field>
            <field name="code">ad</field>
            <field name="currency_id" ref="EUR" />
            <field eval="376" name="phone_code" />
        </record>
        <record id="ae" model="res.country">
            <field name="name">United Arab Emirates</field>
            <field name="code">ae</field>
            <field name="currency_id" ref="AED" />
            <field eval="971" name="phone_code" />
        </record>
        <record id="af" model="res.country">
            <field name="name">Afghanistan</field>
            <field name="code">af</field>
            <field name="currency_id" ref="AFN" />
            <field eval="93" name="phone_code" />
        </record>
        <record id="ag" model="res.country">
            <field name="name">Antigua and Barbuda</field>
            <field name="code">ag</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1268" name="phone_code" />
        </record>
        <record id="ai" model="res.country">
            <field name="name">Anguilla</field>
            <field name="code">ai</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1264" name="phone_code" />
        </record>
        <record id="al" model="res.country">
            <field name="name">Albania</field>
            <field name="code">al</field>
            <field name="currency_id" ref="ALL" />
            <field eval="355" name="phone_code" />
        </record>
        <record id="am" model="res.country">
            <field name="name">Armenia</field>
            <field name="code">am</field>
            <field name="currency_id" ref="AMD" />
            <field eval="374" name="phone_code" />
        </record>
        <record id="ao" model="res.country">
            <field name="name">Angola</field>
            <field name="code">ao</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="AOA" />
            <field eval="244" name="phone_code" />
        </record>
        <record id="aq" model="res.country">
            <field name="name">Antarctica</field>
            <field name="code">aq</field>
            <field name="currency_id" ref="XCD" />
            <field eval="672" name="phone_code" />
        </record>
        <record id="ar" model="res.country">
            <field name="name">Argentina</field>
            <field name="code">ar</field>
            <field name='state_required'>1</field>
            <field name="currency_id" ref="ARS" />
            <field eval="54" name="phone_code" />
            <field name="vat_label">CUIT</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_name)s %(zip)s\n%(country_name)s'" name="address_format"/>
        </record>
        <record id="as" model="res.country">
            <field name="name">American Samoa</field>
            <field name="code">as</field>
            <field name="currency_id" ref="USD" />
            <field eval="1684" name="phone_code" />
        </record>
        <record id="at" model="res.country">
            <field name="name">Austria</field>
            <field name="code">at</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="43" name="phone_code" />
            <field name="vat_label">USt</field>
        </record>
        <record id="au" model="res.country">
            <field name="name">Australia</field>
            <field name="code">au</field>
            <field name='state_required'>1</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="AUD" />
            <field eval="61" name="phone_code" />
            <field name="vat_label">ABN</field>
        </record>
        <record id="aw" model="res.country">
            <field name="name">Aruba</field>
            <field name="code">aw</field>
            <field name="currency_id" ref="AWG" />
            <field eval="297" name="phone_code" />
        </record>
        <record id="ax" model="res.country">
            <field name="name">Åland Islands</field>
            <field name="code">ax</field>
            <field name="currency_id" ref="EUR" />
            <field eval="358" name="phone_code" />
        </record>
        <record id="az" model="res.country">
            <field name="name">Azerbaijan</field>
            <field name="code">az</field>
            <field name="currency_id" ref="AZN" />
            <field eval="994" name="phone_code" />
        </record>
        <record id="ba" model="res.country">
            <field name="name">Bosnia and Herzegovina</field>
            <field name="code">ba</field>
            <field name="currency_id" ref="BAM" />
            <field eval="387" name="phone_code" />
        </record>
        <record id="bb" model="res.country">
            <field name="name">Barbados</field>
            <field name="code">bb</field>
            <field name="currency_id" ref="BBD" />
            <field eval="1246" name="phone_code" />
        </record>
        <record id="bd" model="res.country">
            <field name="name">Bangladesh</field>
            <field name="code">bd</field>
            <field name="currency_id" ref="BDT" />
            <field eval="880" name="phone_code" />
        </record>
        <record id="be" model="res.country">
            <field name="name">Belgium</field>
            <field name="code">be</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="32" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="bf" model="res.country">
            <field name="name">Burkina Faso</field>
            <field name="code">bf</field>
            <field name="currency_id" ref="XOF" />
            <field eval="226" name="phone_code" />
        </record>
        <record id="bg" model="res.country">
            <field name="name">Bulgaria</field>
            <field name="code">bg</field>
            <field name="currency_id" ref="BGN" />
            <field eval="359" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="bh" model="res.country">
            <field name="name">Bahrain</field>
            <field name="code">bh</field>
            <field name="currency_id" ref="BHD" />
            <field eval="973" name="phone_code" />
        </record>
        <record id="bi" model="res.country">
            <field name="name">Burundi</field>
            <field name="code">bi</field>
            <field name="currency_id" ref="BIF" />
            <field eval="257" name="phone_code" />
        </record>
        <record id="bj" model="res.country">
            <field name="name">Benin</field>
            <field name="code">bj</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="XOF" />
            <field eval="229" name="phone_code" />
        </record>
        <record id="bl" model="res.country">
            <field name="name">Saint Barthélémy</field>
            <field name="code">bl</field>
            <field name="currency_id" ref="EUR" />
            <field eval="590" name="phone_code" />
        </record>
        <record id="bm" model="res.country">
            <field name="name">Bermuda</field>
            <field name="code">bm</field>
            <field name="currency_id" ref="BMD" />
            <field eval="1441" name="phone_code" />
        </record>
        <record id="bn" model="res.country">
            <field name="name">Brunei Darussalam</field>
            <field name="code">bn</field>
            <field name="currency_id" ref="BND" />
            <field eval="673" name="phone_code" />
        </record>
        <record id="bo" model="res.country">
            <field name="name">Bolivia</field>
            <field name="code">bo</field>
            <field name="currency_id" ref="BOB" />
            <field eval="591" name="phone_code" />
        </record>
        <record id="bq" model="res.country">
            <field name="name">Bonaire, Sint Eustatius and Saba</field>
            <field name="code">bq</field>
            <field name="currency_id" ref="USD" />
            <field eval="599" name="phone_code" />
        </record>
        <record id="br" model="res.country">
            <field name="name">Brazil</field>
            <field name="code">br</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_code)s\n%(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="BRL" />
            <field eval="55" name="phone_code" />
        </record>
        <record id="bs" model="res.country">
            <field name="name">Bahamas</field>
            <field name="code">bs</field>
            <field name="currency_id" ref="BSD" />
            <field eval="1242" name="phone_code" />
        </record>
        <record id="bt" model="res.country">
            <field name="name">Bhutan</field>
            <field name="code">bt</field>
            <field name="currency_id" ref="BTN" />
            <field eval="975" name="phone_code" />
        </record>
        <record id="bv" model="res.country">
            <field name="name">Bouvet Island</field>
            <field name="code">bv</field>
            <field name="currency_id" ref="NOK" />
            <field eval="55" name="phone_code" />
        </record>
        <record id="bw" model="res.country">
            <field name="name">Botswana</field>
            <field name="code">bw</field>
            <field name="currency_id" ref="BWP" />
            <field eval="267" name="phone_code" />
        </record>
        <record id="by" model="res.country">
            <field name="name">Belarus</field>
            <field name="code">by</field>
            <field name="currency_id" ref="BYN" />
            <field eval="375" name="phone_code" />
        </record>
        <record id="bz" model="res.country">
            <field name="name">Belize</field>
            <field name="code">bz</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="BZD" />
            <field eval="501" name="phone_code" />
        </record>
        <record id="ca" model="res.country">
            <field name="name">Canada</field>
            <field name="code">ca</field>
            <field name='state_required'>1</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="CAD" />
            <field eval="1" name="phone_code" />
            <field name="vat_label">GST/HST number</field>
        </record>
        <record id="cc" model="res.country">
            <field name="name">Cocos (Keeling) Islands</field>
            <field name="code">cc</field>
            <field name="currency_id" ref="AUD" />
            <field eval="61" name="phone_code" />
        </record>
        <record id="cf" model="res.country">
            <field name="name">Central African Republic</field>
            <field name="code">cf</field>
            <field name="currency_id" ref="XAF" />
            <field eval="236" name="phone_code" />
        </record>
        <record id="cd" model="res.country">
            <field name="name">Democratic Republic of the Congo</field>
            <field name="code">cd</field>
            <field name="currency_id" ref="CDF" />
            <field eval="243" name="phone_code" />
        </record>
        <record id="cg" model="res.country">
            <field name="name">Congo</field>
            <field name="code">cg</field>
            <field name="currency_id" ref="XAF" />
            <field eval="242" name="phone_code" />
        </record>
        <record id="ch" model="res.country">
            <field name="name">Switzerland</field>
            <field name="code">ch</field>
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" />
            <field name="currency_id" ref="CHF" />
            <field eval="41" name="phone_code" />
        </record>
        <record id="ci" model="res.country">
            <field name="name">Côte d'Ivoire</field>
            <field name="code">ci</field>
            <field name="currency_id" ref="XOF" />
            <field eval="225" name="phone_code" />
        </record>
        <record id="ck" model="res.country">
            <field name="name">Cook Islands</field>
            <field name="code">ck</field>
            <field name="currency_id" ref="NZD" />
            <field eval="682" name="phone_code" />
        </record>
        <record id="cl" model="res.country">
            <field name="name">Chile</field>
            <field name="code">cl</field>
            <field name="currency_id" ref="CLP" />
            <field eval="56" name="phone_code" />
            <field name="vat_label">RUT</field>
            <field name='zip_required'>0</field>
        </record>
        <record id="cm" model="res.country">
            <field name="name">Cameroon</field>
            <field name="code">cm</field>
            <field name="currency_id" ref="XAF" />
            <field eval="237" name="phone_code" />
        </record>
        <record id="cn" model="res.country">
            <field name="name">China</field>
            <field name="code">cn</field>
            <field eval="'%(country_name)s, %(zip)s\n%(state_name)s %(city)s %(street)s %(street2)s'" name="address_format" />
            <field name="currency_id" ref="CNY" />
            <field eval="86" name="phone_code" />
        </record>
        <record id="co" model="res.country">
            <field name="name">Colombia</field>
            <field name="code">co</field>
            <field name="vat_label">NIT</field>
            <field name="currency_id" ref="COP" />
            <field eval="57" name="phone_code" />
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(city)s %(state_name)s %(zip)s\n%(country_name)s'" />
        </record>
        <record id="cr" model="res.country">
            <field name="name">Costa Rica</field>
            <field name="code">cr</field>
            <field name="currency_id" ref="CRC" />
            <field eval="506" name="phone_code" />
        </record>
        <record id="cu" model="res.country">
            <field name="name">Cuba</field>
            <field name="code">cu</field>
            <field name="currency_id" ref="CUP" />
            <field eval="53" name="phone_code" />
        </record>
        <record id="cv" model="res.country">
            <field name="name">Cape Verde</field>
            <field name="code">cv</field>
            <field name="currency_id" ref="CVE" />
            <field eval="238" name="phone_code" />
        </record>
        <record id="cw" model="res.country">
            <field name="name">Curaçao</field>
            <field name="code">cw</field>
            <field name="currency_id" ref="ANG" />
            <field eval="599" name="phone_code" />
        </record>
        <record id="cx" model="res.country">
            <field name="name">Christmas Island</field>
            <field name="code">cx</field>
            <field name="currency_id" ref="AUD" />
            <field eval="61" name="phone_code" />
        </record>
        <record id="cy" model="res.country">
            <field name="name">Cyprus</field>
            <field name="code">cy</field>
            <field name="currency_id" ref="EUR" />
            <field eval="357" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="cz" model="res.country">
            <field name="name">Czech Republic</field>
            <field name="code">cz</field>
            <field name="currency_id" ref="CZK" />
            <field eval="420" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="de" model="res.country">
            <field name="name">Germany</field>
            <field name="code">de</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="49" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="dj" model="res.country">
            <field name="name">Djibouti</field>
            <field name="code">dj</field>
            <field name="currency_id" ref="DJF" />
            <field eval="253" name="phone_code" />
        </record>
        <record id="dk" model="res.country">
            <field name="name">Denmark</field>
            <field name="code">dk</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="DKK" />
            <field eval="45" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="dm" model="res.country">
            <field name="name">Dominica</field>
            <field name="code">dm</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1767" name="phone_code" />
        </record>
        <record id="do" model="res.country">
            <field name="name">Dominican Republic</field>
            <field name="code">do</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_name)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="DOP" />
            <field eval="1849" name="phone_code" />
            <field name="vat_label">RNC</field>
        </record>
        <record id="dz" model="res.country">
            <field name="name">Algeria</field>
            <field name="code">dz</field>
            <field name="currency_id" ref="DZD" />
            <field eval="213" name="phone_code" />
        </record>
        <record id="ec" model="res.country">
            <field name="name">Ecuador</field>
            <field name="code">ec</field>
            <field name="currency_id" ref="USD" />
            <field eval="593" name="phone_code" />
            <field name="vat_label">RUC</field>
            <field name='zip_required'>0</field>
        </record>
        <record id="ee" model="res.country">
            <field name="name">Estonia</field>
            <field name="code">ee</field>
            <field name="currency_id" ref="EUR" />
            <field eval="372" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="eg" model="res.country">
            <field name="name">Egypt</field>
            <field name="code">eg</field>
            <field name="currency_id" ref="EGP" />
            <field eval="20" name="phone_code" />
        </record>
        <record id="eh" model="res.country">
            <field name="name">Western Sahara</field>
            <field name="code">eh</field>
            <field name="currency_id" ref="MAD" />
            <field eval="212" name="phone_code" />
        </record>
        <record id="er" model="res.country">
            <field name="name">Eritrea</field>
            <field name="code">er</field>
            <field name="currency_id" ref="ERN" />
            <field eval="291" name="phone_code" />
        </record>
        <record id="es" model="res.country">
            <field name="name">Spain</field>
            <field name="code">es</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(state_name)s\n%(country_name)s'" name="address_format"/>
            <field name="currency_id" ref="EUR" />
            <field eval="34" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="et" model="res.country">
            <field name="name">Ethiopia</field>
            <field name="code">et</field>
            <field name="currency_id" ref="ETB" />
            <field eval="251" name="phone_code" />
        </record>
        <record id="fi" model="res.country">
            <field name="name">Finland</field>
            <field name="code">fi</field>
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" />
            <field name="currency_id" ref="EUR" />
            <field eval="358" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="fj" model="res.country">
            <field name="name">Fiji</field>
            <field name="code">fj</field>
            <field name="currency_id" ref="FJD" />
            <field eval="679" name="phone_code" />
        </record>
        <record id="fk" model="res.country">
            <field name="name">Falkland Islands</field>
            <field name="code">fk</field>
            <field name="currency_id" ref="FKP" />
            <field eval="500" name="phone_code" />
        </record>
        <record id="fm" model="res.country">
            <field name="name">Micronesia</field>
            <field name="code">fm</field>
            <field name="currency_id" ref="USD" />
            <field eval="691" name="phone_code" />
        </record>
        <record id="fo" model="res.country">
            <field name="name">Faroe Islands</field>
            <field name="code">fo</field>
            <field name="currency_id" ref="DKK" />
            <field eval="298" name="phone_code" />
        </record>
        <record id="fr" model="res.country">
            <field name="name">France</field>
            <field name="code">fr</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="33" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="ga" model="res.country">
            <field name="name">Gabon</field>
            <field name="code">ga</field>
            <field name="currency_id" ref="XAF" />
            <field eval="241" name="phone_code" />
        </record>
        <record id="gd" model="res.country">
            <field name="name">Grenada</field>
            <field name="code">gd</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1473" name="phone_code" />
        </record>
        <record id="ge" model="res.country">
            <field name="name">Georgia</field>
            <field name="code">ge</field>
            <field name="currency_id" ref="GEL" />
            <field eval="995" name="phone_code" />
        </record>
        <record id="gf" model="res.country">
            <field name="name">French Guiana</field>
            <field name="code">gf</field>
            <field name="currency_id" ref="EUR" />
            <field eval="594" name="phone_code" />
        </record>
        <record id="gh" model="res.country">
            <field name="name">Ghana</field>
            <field name="code">gh</field>
            <field name="currency_id" ref="GHS" />
            <field eval="233" name="phone_code" />
        </record>
        <record id="gi" model="res.country">
            <field name="name">Gibraltar</field>
            <field name="code">gi</field>
            <field name="currency_id" ref="GIP" />
            <field eval="350" name="phone_code" />
        </record>
        <record id="gg" model="res.country">
            <field name="name">Guernsey</field>
            <field name="code">gg</field>
            <field name="currency_id" ref="GBP" />
            <field eval="44" name="phone_code" />
        </record>
        <record id="gl" model="res.country">
            <field name="name">Greenland</field>
            <field name="code">gl</field>
            <field name="currency_id" ref="DKK" />
            <field eval="299" name="phone_code" />
        </record>
        <record id="gm" model="res.country">
            <field name="name">Gambia</field>
            <field name="code">gm</field>
            <field name="currency_id" ref="GMD" />
            <field eval="220" name="phone_code" />
        </record>
        <record id="gn" model="res.country">
            <field name="name">Guinea</field>
            <field name="code">gn</field>
            <field name="currency_id" ref="GNF" />
            <field eval="224" name="phone_code" />
        </record>
        <record id="gp" model="res.country">
            <field name="name">Guadeloupe</field>
            <field name="code">gp</field>
            <field name="currency_id" ref="EUR" />
            <field eval="590" name="phone_code" />
        </record>
        <record id="gq" model="res.country">
            <field name="name">Equatorial Guinea</field>
            <field name="code">gq</field>
            <field name="currency_id" ref="XAF" />
            <field eval="240" name="phone_code" />
        </record>
        <record id="gr" model="res.country">
            <field name="name">Greece</field>
            <field name="code">gr</field>
            <field name="currency_id" ref="EUR" />
            <field eval="30" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="gs" model="res.country">
            <field name="name">South Georgia and the South Sandwich Islands</field>
            <field name="code">gs</field>
            <field name="currency_id" ref="GBP" />
            <field eval="500" name="phone_code" />
        </record>
        <record id="gt" model="res.country">
            <field name="name">Guatemala</field>
            <field name="code">gt</field>
            <field name="currency_id" ref="GTQ" />
            <field eval="502" name="phone_code" />
            <field name="vat_label">NIT</field>
        </record>
        <record id="gu" model="res.country">
            <field name="name">Guam</field>
            <field name="code">gu</field>
            <field name="currency_id" ref="USD" />
            <field eval="1671" name="phone_code" />
        </record>
        <record id="gw" model="res.country">
            <field name="name">Guinea-Bissau</field>
            <field name="code">gw</field>
            <field name="currency_id" ref="XOF" />
            <field eval="245" name="phone_code" />
        </record>
        <record id="gy" model="res.country">
            <field name="name">Guyana</field>
            <field name="code">gy</field>
            <field name="currency_id" ref="GYD" />
            <field eval="592" name="phone_code" />
        </record>
        <record id="hk" model="res.country">
            <field name="name">Hong Kong</field>
            <field name="code">hk</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="HKD" />
            <field eval="852" name="phone_code" />
        </record>
        <record id="hm" model="res.country">
            <field name="name">Heard Island and McDonald Islands</field>
            <field name="code">hm</field>
            <field name="currency_id" ref="AUD" />
            <field eval="672" name="phone_code" />
        </record>
        <record id="hn" model="res.country">
            <field name="name">Honduras</field>
            <field name="code">hn</field>
            <field name="currency_id" ref="HNL" />
            <field eval="504" name="phone_code" />
            <field name="vat_label">RTN</field>
        </record>
        <record id="hr" model="res.country">
            <field name="name">Croatia</field>
            <field name="code">hr</field>
            <field name="currency_id" ref="EUR" />
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s \n%(country_name)s'" name="address_format" />
            <field eval="385" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="ht" model="res.country">
            <field name="name">Haiti</field>
            <field name="code">ht</field>
            <field name="currency_id" ref="HTG" />
            <field eval="509" name="phone_code" />
        </record>
        <record id="hu" model="res.country">
            <field name="name">Hungary</field>
            <field name="code">hu</field>
            <field name="currency_id" ref="HUF" />
            <field eval="36" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="id" model="res.country">
            <field name="name">Indonesia</field>
            <field name="code">id</field>
            <field name='state_required'>1</field>
            <field name="currency_id" ref="IDR" />
            <field eval="62" name="phone_code" />
            <field name="vat_label">NPWP</field>
        </record>
        <record id="ie" model="res.country">
            <field name="name">Ireland</field>
            <field name="code">ie</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="EUR" />
            <field eval="353" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="il" model="res.country">
            <field name="name">Israel</field>
            <field name="code">il</field>
            <field name="currency_id" ref="ILS" />
            <field eval="972" name="phone_code" />
        </record>
        <record id="im" model="res.country">
            <field name="name">Isle of Man</field>
            <field name="code">im</field>
            <field name="currency_id" ref="GBP" />
            <field eval="44" name="phone_code" />
        </record>
        <record id="in" model="res.country">
            <field name="name">India</field>
            <field name="code">in</field>
            <field name='state_required'>1</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(zip)s\n%(state_name)s %(state_code)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="INR" />
            <field eval="91" name="phone_code" />
            <field name="vat_label">GSTIN</field>
        </record>
        <record id="io" model="res.country">
            <field name="name">British Indian Ocean Territory</field>
            <field name="code">io</field>
            <field name="currency_id" ref="USD" />
            <field eval="246" name="phone_code" />
        </record>
        <record id="iq" model="res.country">
            <field name="name">Iraq</field>
            <field name="code">iq</field>
            <field name="currency_id" ref="IQD" />
            <field eval="964" name="phone_code" />
        </record>
        <record id="ir" model="res.country">
            <field name="name">Iran</field>
            <field name="code">ir</field>
            <field name="currency_id" ref="IRR" />
            <field eval="98" name="phone_code" />
        </record>
        <record id="is" model="res.country">
            <field name="name">Iceland</field>
            <field name="code">is</field>
            <field name="currency_id" ref="ISK" />
            <field eval="354" name="phone_code" />
        </record>
        <record id="it" model="res.country">
            <field name="name">Italy</field>
            <field name="code">it</field>
            <field name='state_required'>1</field>
            <field name="currency_id" ref="EUR" />
            <field eval="39" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="je" model="res.country">
            <field name="name">Jersey</field>
            <field name="code">je</field>
            <field name="currency_id" ref="GBP" />
            <field eval="44" name="phone_code" />
        </record>
        <record id="jm" model="res.country">
            <field name="name">Jamaica</field>
            <field name="code">jm</field>
            <field name="currency_id" ref="JMD" />
            <field eval="1876" name="phone_code" />
        </record>
        <record id="jo" model="res.country">
            <field name="name">Jordan</field>
            <field name="code">jo</field>
            <field name="currency_id" ref="JOD" />
            <field eval="962" name="phone_code" />
        </record>
        <record id="jp" model="res.country">
            <field name="name">Japan</field>
            <field name="code">jp</field>
            <field name='state_required'>1</field>
            <field name="currency_id" ref="JPY" />
            <field name="address_format" eval="'%(zip)s\n%(state_name)s %(city)s\n%(street)s\n%(street2)s\n%(country_name)s'"/>
            <field name="name_position">after</field>
            <field eval="81" name="phone_code" />
        </record>
        <record id="ke" model="res.country">
            <field name="name">Kenya</field>
            <field name="code">ke</field>
            <field name="currency_id" ref="KES" />
            <field eval="254" name="phone_code" />
        </record>
        <record id="kg" model="res.country">
            <field name="name">Kyrgyzstan</field>
            <field name="code">kg</field>
            <field name="currency_id" ref="KGS" />
            <field eval="996" name="phone_code" />
        </record>
        <record id="kh" model="res.country">
            <field name="name">Cambodia</field>
            <field name="code">kh</field>
            <field name="currency_id" ref="KHR" />
            <field eval="855" name="phone_code" />
        </record>
        <record id="ki" model="res.country">
            <field name="name">Kiribati</field>
            <field name="code">ki</field>
            <field name="currency_id" ref="AUD" />
            <field eval="686" name="phone_code" />
        </record>
        <record id="km" model="res.country">
            <field name="name">Comoros</field>
            <field name="code">km</field>
            <field name="currency_id" ref="KMF" />
            <field eval="269" name="phone_code" />
        </record>
        <record id="kn" model="res.country">
            <field name="name">Saint Kitts and Nevis</field>
            <field name="code">kn</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1869" name="phone_code" />
        </record>
        <record id="kp" model="res.country">
            <field name="name">North Korea</field>
            <field name="code">kp</field>
            <field name="currency_id" ref="KPW" />
            <field eval="850" name="phone_code" />
        </record>
        <record id="kr" model="res.country">
            <field name="name">South Korea</field>
            <field name="code">kr</field>
            <field name="currency_id" ref="KRW" />
            <field eval="82" name="phone_code" />
        </record>
        <record id="kw" model="res.country">
            <field name="name">Kuwait</field>
            <field name="code">kw</field>
            <field name="currency_id" ref="KWD" />
            <field eval="965" name="phone_code" />
        </record>
        <record id="ky" model="res.country">
            <field name="name">Cayman Islands</field>
            <field name="code">ky</field>
            <field name="currency_id" ref="KYD" />
            <field eval="1345" name="phone_code" />
        </record>
        <record id="kz" model="res.country">
            <field name="name">Kazakhstan</field>
            <field name="code">kz</field>
            <field name="currency_id" ref="KZT" />
            <field eval="7" name="phone_code" />
        </record>
        <record id="la" model="res.country">
            <field name="name">Laos</field>
            <field name="code">la</field>
            <field name="currency_id" ref="LAK" />
            <field eval="856" name="phone_code" />
        </record>
        <record id="lb" model="res.country">
            <field name="name">Lebanon</field>
            <field name="code">lb</field>
            <field name="currency_id" ref="LBP" />
            <field eval="961" name="phone_code" />
        </record>
        <record id="lc" model="res.country">
            <field name="name">Saint Lucia</field>
            <field name="code">lc</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1758" name="phone_code" />
        </record>
        <record id="li" model="res.country">
            <field name="name">Liechtenstein</field>
            <field name="code">li</field>
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" />
            <field name="currency_id" ref="CHF" />
            <field eval="423" name="phone_code" />
        </record>
        <record id="lk" model="res.country">
            <field name="name">Sri Lanka</field>
            <field name="code">lk</field>
            <field name="currency_id" ref="LKR" />
            <field eval="94" name="phone_code" />
        </record>
        <record id="lr" model="res.country">
            <field name="name">Liberia</field>
            <field name="code">lr</field>
            <field name="currency_id" ref="LRD" />
            <field eval="231" name="phone_code" />
        </record>
        <record id="ls" model="res.country">
            <field name="name">Lesotho</field>
            <field name="code">ls</field>
            <field name="currency_id" ref="LSL" />
            <field eval="266" name="phone_code" />
        </record>
        <record id="lt" model="res.country">
            <field name="name">Lithuania</field>
            <field name="code">lt</field>
            <field name="currency_id" ref="EUR"/>
            <field eval="370" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="lu" model="res.country">
            <field name="name">Luxembourg</field>
            <field name="code">lu</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s \n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="352" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="lv" model="res.country">
            <field name="name">Latvia</field>
            <field name="code">lv</field>
            <field name="currency_id" ref="EUR"/>
            <field eval="371" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="ly" model="res.country">
            <field name="name">Libya</field>
            <field name="code">ly</field>
            <field name="currency_id" ref="LYD" />
            <field eval="218" name="phone_code" />
        </record>
        <record id="ma" model="res.country">
            <field name="name">Morocco</field>
            <field name="code">ma</field>
            <field name="currency_id" ref="MAD" />
            <field eval="212" name="phone_code" />
        </record>
        <record id="mc" model="res.country">
            <field name="name">Monaco</field>
            <field name="currency_id" ref="EUR" />
            <field name="code">mc</field>
            <field eval="377" name="phone_code" />
        </record>
        <record id="md" model="res.country">
            <field name="name">Moldova</field>
            <field name="code">md</field>
            <field name="currency_id" ref="MDL" />
            <field eval="373" name="phone_code" />
        </record>
        <record id="me" model="res.country">
            <field name="name">Montenegro</field>
            <field name="code">me</field>
            <field name="currency_id" ref="EUR" />
            <field eval="382" name="phone_code" />
        </record>
        <record id="mf" model="res.country">
            <field name="name">Saint Martin (French part)</field>
            <field name="code">mf</field>
            <field name="currency_id" ref="EUR" />
            <field eval="590" name="phone_code" />
        </record>
        <record id="mg" model="res.country">
            <field name="name">Madagascar</field>
            <field name="code">mg</field>
            <field name="currency_id" ref="MGA" />
            <field eval="261" name="phone_code" />
        </record>
        <record id="mh" model="res.country">
            <field name="name">Marshall Islands</field>
            <field name="code">mh</field>
            <field name="currency_id" ref="USD" />
            <field eval="692" name="phone_code" />
        </record>
        <record id="mk" model="res.country">
            <field name="name">North Macedonia</field>
            <field name="code">mk</field>
            <field name="currency_id" ref="MKD" />
            <field eval="389" name="phone_code" />
        </record>
        <record id="ml" model="res.country">
            <field name="name">Mali</field>
            <field name="code">ml</field>
            <field name="currency_id" ref="XOF" />
            <field eval="223" name="phone_code" />
        </record>
        <record id="mm" model="res.country">
            <field name="name">Myanmar</field>
            <field name="code">mm</field>
            <field name="currency_id" ref="MMK" />
            <field eval="95" name="phone_code" />
        </record>
        <record id="mn" model="res.country">
            <field name="name">Mongolia</field>
            <field name="code">mn</field>
            <field name="currency_id" ref="MNT" />
            <field eval="976" name="phone_code" />
        </record>
        <record id="mo" model="res.country">
            <field name="name">Macau</field>
            <field name="code">mo</field>
            <field name='zip_required'>0</field>
            <field name="currency_id" ref="MOP" />
            <field eval="853" name="phone_code" />
        </record>
        <record id="mp" model="res.country">
            <field name="name">Northern Mariana Islands</field>
            <field name="code">mp</field>
            <field name="currency_id" ref="USD" />
            <field eval="1670" name="phone_code" />
        </record>
        <record id="mq" model="res.country">
            <field name="name">Martinique</field>
            <field name="code">mq</field>
            <field name="currency_id" ref="EUR" />
            <field eval="596" name="phone_code" />
        </record>
        <record id="mr" model="res.country">
            <field name="name">Mauritania</field>
            <field name="code">mr</field>
            <field name="currency_id" ref="MRU" />
            <field eval="222" name="phone_code" />
        </record>
        <record id="ms" model="res.country">
            <field name="name">Montserrat</field>
            <field name="code">ms</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1664" name="phone_code" />
        </record>
        <record id="mt" model="res.country">
            <field name="name">Malta</field>
            <field name="code">mt</field>
            <field name="currency_id" ref="EUR" />
            <field eval="356" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="mu" model="res.country">
            <field name="name">Mauritius</field>
            <field name="code">mu</field>
            <field name="currency_id" ref="MUR" />
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field eval="230" name="phone_code" />
        </record>
        <record id="mv" model="res.country">
            <field name="name">Maldives</field>
            <field name="code">mv</field>
            <field name="currency_id" ref="MVR" />
            <field eval="960" name="phone_code" />
        </record>
        <record id="mw" model="res.country">
            <field name="name">Malawi</field>
            <field name="code">mw</field>
            <field name="currency_id" ref="MWK" />
            <field eval="265" name="phone_code" />
        </record>
        <record id="mx" model="res.country">
            <field name="name">Mexico</field>
            <field name="code">mx</field>
            <field name='state_required'>1</field>
            <field name="currency_id" ref="MXN" />
            <field eval="52" name="phone_code" />
            <field name="vat_label">RFC</field>
            <field eval="'%(street)s %(street2)s\n%(zip)s %(city)s, %(state_code)s\n%(country_name)s'"  name="address_format" />
        </record>
        <record id="my" model="res.country">
            <field name="name">Malaysia</field>
            <field name="code">my</field>
            <field name="currency_id" ref="MYR" />
            <field eval="60" name="phone_code" />
        </record>
        <record id="mz" model="res.country">
            <field name="name">Mozambique</field>
            <field name="code">mz</field>
            <field name="currency_id" ref="MZN" />
            <field eval="258" name="phone_code" />
        </record>
        <record id="na" model="res.country">
            <field name="name">Namibia</field>
            <field name="code">na</field>
            <field name="currency_id" ref="NAD" />
            <field eval="264" name="phone_code" />
        </record>
        <record id="nc" model="res.country">
            <field name="name">New Caledonia</field>
            <field name="code">nc</field>
            <field name="currency_id" ref="XPF" />
            <field eval="687" name="phone_code" />
        </record>
        <record id="ne" model="res.country">
            <field name="name">Niger</field>
            <field name="code">ne</field>
            <field name="currency_id" ref="XOF" />
            <field eval="227" name="phone_code" />
        </record>
        <record id="nf" model="res.country">
            <field name="name">Norfolk Island</field>
            <field name="code">nf</field>
            <field name="currency_id" ref="AUD" />
            <field eval="672" name="phone_code" />
        </record>
        <record id="ng" model="res.country">
            <field name="name">Nigeria</field>
            <field name="code">ng</field>
            <field name="currency_id" ref="NGN" />
            <field eval="234" name="phone_code" />
        </record>
        <record id="ni" model="res.country">
            <field name="name">Nicaragua</field>
            <field name="code">ni</field>
            <field name="currency_id" ref="NIO" />
            <field eval="505" name="phone_code" />
        </record>
        <record id="nl" model="res.country">
            <field name="name">Netherlands</field>
            <field name="code">nl</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="EUR" />
            <field eval="31" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="no" model="res.country">
            <field name="name">Norway</field>
            <field name="code">no</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="NOK" />
            <field eval="47" name="phone_code" />
        </record>
        <record id="np" model="res.country">
            <field name="name">Nepal</field>
            <field name="code">np</field>
            <field name="currency_id" ref="NPR" />
            <field eval="977" name="phone_code" />
        </record>
        <record id="nr" model="res.country">
            <field name="name">Nauru</field>
            <field name="code">nr</field>
            <field name="currency_id" ref="AUD" />
            <field eval="674" name="phone_code" />
        </record>
        <record id="nu" model="res.country">
            <field name="name">Niue</field>
            <field name="code">nu</field>
            <field name="currency_id" ref="NZD" />
            <field eval="683" name="phone_code" />
        </record>
        <record id="nz" model="res.country">
            <field name="name">New Zealand</field>
            <field name="code">nz</field>
            <field name="currency_id" ref="NZD" />
            <field eval="64" name="phone_code" />
            <field name="vat_label">GST</field>
        </record>
        <record id="om" model="res.country">
            <field name="name">Oman</field>
            <field name="code">om</field>
            <field name="currency_id" ref="OMR" />
            <field eval="968" name="phone_code" />
        </record>
        <record id="pa" model="res.country">
            <field name="name">Panama</field>
            <field name="code">pa</field>
            <field name="currency_id" ref="PAB" />
            <field eval="507" name="phone_code" />
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(city)s %(state_name)s %(zip)s\n%(country_name)s'" />
        </record>
        <record id="pe" model="res.country">
            <field name="name">Peru</field>
            <field name="code">pe</field>
            <field name="currency_id" ref="PEN" />
            <field eval="51" name="phone_code" />
            <field name="vat_label">RUC</field>
        </record>
        <record id="pf" model="res.country">
            <field name="name">French Polynesia</field>
            <field name="code">pf</field>
            <field name="currency_id" ref="XPF" />
            <field eval="689" name="phone_code" />
            <field name="vat_label">N° Tahiti</field>
        </record>
        <record id="pg" model="res.country">
            <field name="name">Papua New Guinea</field>
            <field name="code">pg</field>
            <field name="currency_id" ref="PGK" />
            <field eval="675" name="phone_code" />
        </record>
        <record id="ph" model="res.country">
            <field name="name">Philippines</field>
            <field name="code">ph</field>
            <field name="currency_id" ref="PHP" />
            <field eval="63" name="phone_code" />
        </record>
        <record id="pk" model="res.country">
            <field name="name">Pakistan</field>
            <field name="code">pk</field>
            <field name="currency_id" ref="PKR" />
            <field eval="92" name="phone_code" />
        </record>
        <record id="pl" model="res.country">
            <field name="name">Poland</field>
            <field name="code">pl</field>
            <field name="address_format" eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" />
            <field name="currency_id" ref="PLN" />
            <field eval="48" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="pm" model="res.country">
            <field name="name">Saint Pierre and Miquelon</field>
            <field name="code">pm</field>
            <field name="currency_id" ref="EUR" />
            <field eval="508" name="phone_code" />
        </record>
        <record id="pn" model="res.country">
            <field name="name">Pitcairn Islands</field>
            <field name="code">pn</field>
            <field name="currency_id" ref="NZD" />
            <field eval="64" name="phone_code" />
        </record>
        <record id="pr" model="res.country">
            <field name="name">Puerto Rico</field>
            <field name="code">pr</field>
            <field name="currency_id" ref="USD" />
            <field eval="1939" name="phone_code" />
        </record>
        <record id="ps" model="res.country">
            <field name="name">State of Palestine</field>
            <field name="code">ps</field>
            <field name="currency_id" ref="ILS" />
            <field eval="970" name="phone_code" />
        </record>
        <record id="pt" model="res.country">
            <field name="name">Portugal</field>
            <field name="code">pt</field>
            <field name="currency_id" ref="EUR" />
            <field eval="351" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="pw" model="res.country">
            <field name="name">Palau</field>
            <field name="code">pw</field>
            <field name="currency_id" ref="USD" />
            <field eval="680" name="phone_code" />
        </record>
        <record id="py" model="res.country">
            <field name="name">Paraguay</field>
            <field name="code">py</field>
            <field name="currency_id" ref="PYG" />
            <field eval="595" name="phone_code" />
        </record>
        <record id="qa" model="res.country">
            <field name="name">Qatar</field>
            <field name="code">qa</field>
            <field name="currency_id" ref="QAR" />
            <field eval="974" name="phone_code" />
        </record>
        <record id="re" model="res.country">
            <field name="name">Réunion</field>
            <field name="code">re</field>
            <field name="currency_id" ref="EUR" />
            <field eval="262" name="phone_code" />
        </record>
        <record id="ro" model="res.country">
            <field name="name">Romania</field>
            <field name="code">ro</field>
            <field name="currency_id" ref="RON" />
            <field eval="40" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="rs" model="res.country">
            <field name="name">Serbia</field>
            <field name="code">rs</field>
            <field name="currency_id" ref="RSD" />
            <field eval="381" name="phone_code" />
        </record>
        <record id="ru" model="res.country">
            <field name="name">Russian Federation</field>
            <field name="code">ru</field>
            <field name="currency_id" ref="RUB" />
            <field eval="7" name="phone_code" />
        </record>
        <record id="rw" model="res.country">
            <field name="name">Rwanda</field>
            <field name="code">rw</field>
            <field name="currency_id" ref="RWF" />
            <field eval="250" name="phone_code" />
        </record>
        <record id="sa" model="res.country">
            <field name="name">Saudi Arabia</field>
            <field name="code">sa</field>
            <field name="currency_id" ref="SAR" />
            <field eval="966" name="phone_code" />
        </record>
        <record id="sb" model="res.country">
            <field name="name">Solomon Islands</field>
            <field name="code">sb</field>
            <field name="currency_id" ref="SBD" />
            <field eval="677" name="phone_code" />
        </record>
        <record id="sc" model="res.country">
            <field name="name">Seychelles</field>
            <field name="code">sc</field>
            <field name="currency_id" ref="SCR" />
            <field eval="248" name="phone_code" />
        </record>
        <record id="sd" model="res.country">
            <field name="name">Sudan</field>
            <field name="code">sd</field>
            <field name="currency_id" ref="SDG" />
            <field eval="249" name="phone_code" />
        </record>
        <record id="se" model="res.country">
            <field name="name">Sweden</field>
            <field name="code">se</field>
            <field eval="'%(street)s\n%(street2)s\n%(zip)s %(city)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="SEK" />
            <field eval="46" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="sg" model="res.country">
            <field name="name">Singapore</field>
            <field name="code">sg</field>
            <field name="currency_id" ref="SGD" />
            <field eval="65" name="phone_code" />
            <field name="vat_label">GST No.</field>
        </record>
        <record id="sh" model="res.country">
            <field name="name">Saint Helena, Ascension and Tristan da Cunha</field>
            <field name="code">sh</field>
            <field name="currency_id" ref="SHP" />
            <field eval="290" name="phone_code" />
        </record>
        <record id="si" model="res.country">
            <field name="name">Slovenia</field>
            <field name="code">si</field>
            <field name="currency_id" ref="EUR" />
            <field eval="386" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="sj" model="res.country">
            <field name="name">Svalbard and Jan Mayen</field>
            <field name="code">sj</field>
            <field name="currency_id" ref="NOK" />
            <field eval="47" name="phone_code" />
        </record>
        <record id="sk" model="res.country">
            <field name="name">Slovakia</field>
            <field name="code">sk</field>
            <field name="currency_id" ref="EUR" />
            <field eval="421" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="sl" model="res.country">
            <field name="name">Sierra Leone</field>
            <field name="code">sl</field>
            <field name="currency_id" ref="SLE" />
            <field eval="232" name="phone_code" />
        </record>
        <record id="sm" model="res.country">
            <field name="name">San Marino</field>
            <field name="code">sm</field>
            <field name="currency_id" ref="EUR" />
            <field eval="378" name="phone_code" />
        </record>
        <record id="sn" model="res.country">
            <field name="name">Senegal</field>
            <field name="code">sn</field>
            <field name="currency_id" ref="XOF" />
            <field eval="221" name="phone_code" />
        </record>
        <record id="so" model="res.country">
            <field name="name">Somalia</field>
            <field name="code">so</field>
            <field name="currency_id" ref="SOS" />
            <field eval="252" name="phone_code" />
        </record>
        <record id="sr" model="res.country">
            <field name="name">Suriname</field>
            <field name="code">sr</field>
            <field name="currency_id" ref="SRD" />
            <field eval="597" name="phone_code" />
        </record>
        <record id="ss" model="res.country">
            <field name="name">South Sudan</field>
            <field name="code">ss</field>
            <field name="currency_id" ref="SSP" />
            <field eval="211" name="phone_code" />
        </record>
        <record id="st" model="res.country">
            <field name="name">São Tomé and Príncipe</field>
            <field name="code">st</field>
            <field name="currency_id" ref="STD" />
            <field eval="239" name="phone_code" />
        </record>
        <record id="sv" model="res.country">
            <field name="name">El Salvador</field>
            <field name="code">sv</field>
            <field name="currency_id" ref="SVC" />
            <field eval="503" name="phone_code" />
        </record>
        <record id="sx" model="res.country">
            <field name="name">Sint Maarten (Dutch part)</field>
            <field name="code">sx</field>
            <field name="currency_id" ref="ANG" />
            <field eval="1721" name="phone_code" />
        </record>
        <record id="sy" model="res.country">
            <field name="name">Syria</field>
            <field name="code">sy</field>
            <field name="currency_id" ref="SYP" />
            <field eval="963" name="phone_code" />
        </record>
        <record id="sz" model="res.country">
            <field name="name">Eswatini</field>
            <field name="code">sz</field>
            <field name="currency_id" ref="SZL" />
            <field eval="268" name="phone_code" />
        </record>
        <record id="tc" model="res.country">
            <field name="name">Turks and Caicos Islands</field>
            <field name="code">tc</field>
            <field name="currency_id" ref="USD" />
            <field eval="1649" name="phone_code" />
        </record>
        <record id="td" model="res.country">
            <field name="name">Chad</field>
            <field name="code">td</field>
            <field name="currency_id" ref="XAF" />
            <field eval="235" name="phone_code" />
        </record>
        <record id="tf" model="res.country">
            <field name="name">French Southern Territories</field>
            <field name="code">tf</field>
            <field name="currency_id" ref="EUR" />
            <field eval="262" name="phone_code" />
        </record>
        <record id="tg" model="res.country">
            <field name="name">Togo</field>
            <field name="code">tg</field>
            <field name="currency_id" ref="XOF" />
            <field eval="228" name="phone_code" />
        </record>
        <record id="th" model="res.country">
            <field name="name">Thailand</field>
            <field name="code">th</field>
            <field name="currency_id" ref="THB" />
            <field eval="66" name="phone_code" />
            <field eval="'%(street)s\n%(street2)s\n%(city)s\n%(state_name)s %(zip)s\n%(country_name)s'" name="address_format" />
        </record>
        <record id="tj" model="res.country">
            <field name="name">Tajikistan</field>
            <field name="code">tj</field>
            <field name="currency_id" ref="TJS" />
            <field eval="992" name="phone_code" />
        </record>
        <record id="tk" model="res.country">
            <field name="name">Tokelau</field>
            <field name="code">tk</field>
            <field name="currency_id" ref="NZD" />
            <field eval="690" name="phone_code" />
        </record>
        <record id="tm" model="res.country">
            <field name="name">Turkmenistan</field>
            <field name="code">tm</field>
            <field name="currency_id" ref="TMT" />
            <field eval="993" name="phone_code" />
        </record>
        <record id="tn" model="res.country">
            <field name="name">Tunisia</field>
            <field name="code">tn</field>
            <field name="currency_id" ref="TND" />
            <field eval="216" name="phone_code" />
        </record>
        <record id="to" model="res.country">
            <field name="name">Tonga</field>
            <field name="code">to</field>
            <field name="currency_id" ref="TOP" />
            <field eval="676" name="phone_code" />
        </record>
        <record id="tl" model="res.country">
            <field name="name">Timor-Leste</field>
            <field name="code">tl</field>
            <field name="currency_id" ref="USD" />
            <field eval="670" name="phone_code" />
        </record>
        <record id="tr" model="res.country">
            <field name="name">Turkey</field>
            <field name="code">tr</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_name)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="TRY" />
            <field eval="90" name="phone_code" />
        </record>
        <record id="tt" model="res.country">
            <field name="name">Trinidad and Tobago</field>
            <field name="code">tt</field>
            <field name="currency_id" ref="TTD" />
            <field eval="1868" name="phone_code" />
        </record>
        <record id="tv" model="res.country">
            <field name="name">Tuvalu</field>
            <field name="code">tv</field>
            <field name="currency_id" ref="AUD" />
            <field eval="688" name="phone_code" />
        </record>
        <record id="tw" model="res.country">
            <field name="name">Taiwan</field>
            <field name="code">tw</field>
            <field name="currency_id" ref="TWD" />
            <field eval="886" name="phone_code" />
        </record>
        <record id="tz" model="res.country">
            <field name="name">Tanzania</field>
            <field name="code">tz</field>
            <field name="currency_id" ref="TZS" />
            <field eval="255" name="phone_code" />
        </record>
        <record id="ua" model="res.country">
            <field name="name">Ukraine</field>
            <field name="code">ua</field>
            <field name="currency_id" ref="UAH" />
            <field eval="380" name="phone_code" />
        </record>
        <record id="ug" model="res.country">
            <field name="name">Uganda</field>
            <field name="code">ug</field>
            <field name="currency_id" ref="UGX" />
            <field eval="256" name="phone_code" />
            <field name="vat_label">TIN</field>
        </record>
        <record id="uk" model="res.country">
            <field name="name">United Kingdom</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s\n%(state_name)s\n%(zip)s\n%(country_name)s'" name="address_format" />
            <field name="code">gb</field>
            <field name="currency_id" ref="GBP" />
            <field eval="44" name="phone_code" />
            <field name="vat_label">VAT</field>
        </record>
        <record id="um" model="res.country">
            <field name="name">USA Minor Outlying Islands</field>
            <field name="code">um</field>
            <field name="currency_id" ref="USD" />
            <field eval="699" name="phone_code" />
        </record>
        <record id="us" model="res.country">
            <field name="name">United States</field>
            <field name="code">us</field>
            <field name='state_required'>1</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s'" name="address_format" />
            <field name="currency_id" ref="USD" />
            <field eval="1" name="phone_code" />
            <field name="vat_label"/> <!-- Empty to reset on existing DBs-->
        </record>
        <record id="uy" model="res.country">
            <field name="name">Uruguay</field>
            <field name="code">uy</field>
            <field name="currency_id" ref="UYU" />
            <field eval="598" name="phone_code" />
            <field name="vat_label">RUT</field>
        </record>
        <record id="uz" model="res.country">
            <field name="name">Uzbekistan</field>
            <field name="code">uz</field>
            <field name="currency_id" ref="UZS" />
            <field eval="998" name="phone_code" />
        </record>
        <record id="va" model="res.country">
            <field name="name">Holy See (Vatican City State)</field>
            <field name="code">va</field>
            <field name="currency_id" ref="EUR" />
            <field eval="379" name="phone_code" />
        </record>
        <record id="vc" model="res.country">
            <field name="name">Saint Vincent and the Grenadines</field>
            <field name="code">vc</field>
            <field name="currency_id" ref="XCD" />
            <field eval="1784" name="phone_code" />
        </record>
        <record id="ve" model="res.country">
            <field name="name">Venezuela</field>
            <field name="code">ve</field>
            <field name="currency_id" ref="VEF" />
            <field eval="58" name="phone_code" />
        </record>
        <record id="vg" model="res.country">
            <field name="name">Virgin Islands (British)</field>
            <field name="code">vg</field>
            <field name="currency_id" ref="USD" />
            <field eval="1284" name="phone_code" />
        </record>
        <record id="vi" model="res.country">
            <field name="name">Virgin Islands (USA)</field>
            <field name="code">vi</field>
            <field name="currency_id" ref="USD" />
            <field eval="1340" name="phone_code" />
        </record>
        <record id="vn" model="res.country">
            <field name="name">Vietnam</field>
            <field name="code">vn</field>
            <field name="currency_id" ref="VND" />
            <field eval="84" name="phone_code" />
            <field name='zip_required'>0</field>
            <field eval="'%(street)s\n%(street2)s\n%(city)s\n%(state_name)s %(country_name)s'" name="address_format" />
        </record>
        <record id="vu" model="res.country">
            <field name="name">Vanuatu</field>
            <field name="code">vu</field>
            <field name="currency_id" ref="VUV" />
            <field eval="678" name="phone_code" />
        </record>
        <record id="wf" model="res.country">
            <field name="name">Wallis and Futuna</field>
            <field name="code">wf</field>
            <field name="currency_id" ref="XPF" />
            <field eval="681" name="phone_code" />
        </record>
        <record id="ws" model="res.country">
            <field name="name">Samoa</field>
            <field name="code">ws</field>
            <field name="currency_id" ref="WST" />
            <field eval="685" name="phone_code" />
        </record>
        <record id="ye" model="res.country">
            <field name="name">Yemen</field>
            <field name="code">ye</field>
            <field name="currency_id" ref="YER" />
            <field eval="967" name="phone_code" />
        </record>
        <record id="yt" model="res.country">
            <field name="name">Mayotte</field>
            <field name="code">yt</field>
            <field name="currency_id" ref="EUR" />
            <field eval="262" name="phone_code" />
        </record>
        <record id="za" model="res.country">
            <field name="name">South Africa</field>
            <field name="code">za</field>
            <field name="currency_id" ref="ZAR" />
            <field eval="27" name="phone_code" />
        </record>
        <record id="zm" model="res.country">
            <field name="name">Zambia</field>
            <field name="code">zm</field>
            <field name="currency_id" ref="ZMW" />
            <field eval="260" name="phone_code" />
            <field name="vat_label">TPIN</field>
        </record>
        <record id="zw" model="res.country">
            <field name="name">Zimbabwe</field>
            <field name="code">zw</field>
            <field name="currency_id" ref="ZIG" />
            <field eval="263" name="phone_code" />
        </record>
        <record id="xk" model="res.country">
            <field name="name">Kosovo</field>
            <field name="code">xk</field>
            <field name="currency_id" ref="EUR" />
            <field eval="383" name="phone_code" />
        </record>

        <record id="europe" model="res.country.group">
            <field name="name">European Union</field>
            <field name="country_ids" eval="[Command.set([
                ref('at'),ref('be'),ref('bg'),ref('hr'),ref('cy'),
                ref('cz'),ref('dk'),ref('ee'),ref('fi'),ref('fr'),
                ref('de'),ref('gr'),ref('hu'),ref('ie'),ref('it'),
                ref('lv'),ref('lt'),ref('lu'),ref('mt'),ref('nl'),
                ref('pl'),ref('pt'),ref('ro'),ref('sk'),ref('si'),
                ref('es'),ref('se')])]"/>
        </record>

        <record id="south_america" model="res.country.group">
            <field name="name">South America</field>
            <field name="country_ids" eval="[Command.set([
                ref('ar'),ref('bo'),ref('br'),ref('cl'),ref('co'),
                ref('ec'),ref('fk'),ref('gs'),ref('gf'),ref('gy'),
                ref('py'),ref('pe'),ref('sr'),ref('uy'),ref('ve')])]"/>
        </record>

        <record id="sepa_zone" model="res.country.group">
            <field name="name">SEPA Countries</field>
            <field name="country_ids" eval="[Command.set([
                ref('ad'),ref('at'),ref('ax'),ref('be'),ref('bg'),
                ref('bl'),ref('ch'),ref('cy'),ref('cz'),ref('de'),
                ref('dk'),ref('ee'),ref('es'),ref('fi'),ref('fr'),
                ref('uk'),ref('gf'),ref('gg'),ref('gi'),ref('gp'),
                ref('gr'),ref('hr'),ref('hu'),ref('ie'),ref('im'),
                ref('is'),ref('it'),ref('je'),ref('li'),ref('lt'),
                ref('lu'),ref('lv'),ref('mc'),ref('mf'),ref('mq'),
                ref('mt'),ref('nl'),ref('no'),ref('pl'),ref('pm'),
                ref('pt'),ref('re'),ref('ro'),ref('se'),ref('si'),
                ref('sk'),ref('sm'),ref('va'),ref('yt')])]"/>
        </record>

        <record id="gulf_cooperation_council" model="res.country.group">
            <field name="name">Gulf Cooperation Council (GCC)</field>
            <field name="country_ids" eval="[(6,0, [ref('base.sa'), ref('base.ae'), ref('base.bh'), ref('base.om'), ref('base.qa'), ref('base.kw')])]"/>
        </record>

        <record id="eurasian_economic_union" model="res.country.group">
            <field name="name">Eurasian Economic Union</field>
            <field name="country_ids" eval="[(6, 0, [ref('ru'),ref('by'),ref('am'),ref('kg'),ref('kz')])]"/>
        </record>

        <record id="ch_and_li" model="res.country.group">
            <field name="name">Switzerland and Liechtenstein</field>
            <field name="country_ids" eval="[Command.set([ref('ch'), ref('li')])]"/>
        </record>
    </data>
</odoo>

```

  File: data/res_currency_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Currencies -->
        <record id="USD" model="res.currency">
            <field name="name">USD</field>
            <field name="full_name">United States dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="VEF" model="res.currency">
            <field name="name">VEF</field>
            <field name="full_name">Venezuelan bolívar fuerte</field>
            <field name="symbol">Bs.F</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Bolivar</field>
            <field name="currency_subunit_label">Centimos</field>
        </record>

        <record id="CAD" model="res.currency">
            <field name="name">CAD</field>
            <field name="full_name">Canadian dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="CHF" model="res.currency">
            <field name="name">CHF</field>
            <field name="full_name">Swiss franc</field>
            <field name="symbol">CHF</field>
            <field name="position">before</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="BRL" model="res.currency">
            <field name="name">BRL</field>
            <field name="full_name">Brazilian real</field>
            <field name="symbol">R$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Real</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="CNY" model="res.currency">
            <field name="name">CNY</field>
            <field name="full_name">Chinese yuan</field>
            <field name="symbol">¥</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Yuan</field>
            <field name="currency_subunit_label">Fen</field>
            <field name="position">before</field>
        </record>

        <record id="CNH" model="res.currency">
            <field name="name">CNH</field>
            <field name="full_name">Chinese yuan - Offshore</field>
            <field name="symbol">¥</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Yuan</field>
            <field name="currency_subunit_label">Fen</field>
            <field name="position">before</field>
        </record>

        <record id="COP" model="res.currency">
            <field name="name">COP</field>
            <field name="full_name">Colombian peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="CZK" model="res.currency">
            <field name="name">CZK</field>
            <field name="full_name">Czech koruna</field>
            <field name="symbol">Kč</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Koruna</field>
            <field name="currency_subunit_label">Halers</field>
        </record>

        <record id="DKK" model="res.currency">
            <field name="name">DKK</field>
            <field name="full_name">Danish krone</field>
            <field name="symbol">kr</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Krone</field>
            <field name="currency_subunit_label">Ore</field>
        </record>

        <record id="HUF" model="res.currency">
            <field name="name">HUF</field>
            <field name="full_name">Hungarian forint</field>
            <field name="symbol">Ft</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Forint</field>
            <field name="currency_subunit_label">Filler</field>
        </record>

        <record id="IDR" model="res.currency">
            <field name="name">IDR</field>
            <field name="full_name">Indonesian rupiah</field>
            <field name="symbol">Rp</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupiah</field>
            <field name="currency_subunit_label">Sen</field>
        </record>

        <record id="LVL" model="res.currency">
            <field name="name">LVL</field>
            <field name="full_name">Latvian lats</field>
            <field name="symbol">Ls</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lats</field>
            <field name="currency_subunit_label">Santims</field>
        </record>

        <record id="NOK" model="res.currency">
            <field name="name">NOK</field>
            <field name="full_name">Norwegian krone</field>
            <field name="symbol">kr</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Krone</field>
            <field name="currency_subunit_label">Ore</field>
        </record>

        <record id="XPF" model="res.currency">
            <field name="name">XPF</field>
            <field name="full_name">CFP franc</field>
            <field name="symbol">XPF</field>
            <field name="rounding">1.00</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="PAB" model="res.currency">
            <field name="name">PAB</field>
            <field name="full_name">Panamanian balboa</field>
            <field name="symbol">B/.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Balboa</field>
            <field name="currency_subunit_label">Centesimo</field>
        </record>

        <record id="PLN" model="res.currency">
            <field name="name">PLN</field>
            <field name="full_name">Polish złoty</field>
            <field name="symbol">zł</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Zloty</field>
            <field name="currency_subunit_label">Groszy</field>
        </record>

        <record id="SEK" model="res.currency">
            <field name="name">SEK</field>
            <field name="full_name">Swedish krona</field>
            <field name="symbol">kr</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Krona</field>
            <field name="currency_subunit_label">Ore</field>
        </record>

        <record id="ARS" model="res.currency">
            <field name="name">ARS</field>
            <field name="full_name">Argentine peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="INR" model="res.currency">
            <field name="name">INR</field>
            <field name="full_name">Indian rupee</field>
            <field name="symbol">₹</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupees</field>
            <field name="currency_subunit_label">Paise</field>
        </record>

        <record id="AUD" model="res.currency">
            <field name="name">AUD</field>
            <field name="full_name">Australian dollar</field>
            <field name="symbol">$</field>
            <field name="position">before</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="UAH" model="res.currency">
            <field name="name">UAH</field>
            <field name="full_name">Ukraine Hryvnia</field>
            <field name="symbol">₴</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Hryvnia</field>
            <field name="currency_subunit_label">Kopiyka</field>
        </record>

        <record id="VND" model="res.currency">
            <field name="name">VND</field>
            <field name="full_name">Vietnamese đồng</field>
            <field name="symbol">₫</field>
            <field name="rounding">1.00</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dong</field>
            <field name="currency_subunit_label">Xu</field>
        </record>

        <record id="HKD" model="res.currency">
            <field name="name">HKD</field>
            <field name="full_name">Hong Kong dollar</field>
            <field name="symbol">$</field>
            <field name="position">before</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="JPY" model="res.currency">
            <field name="name">JPY</field>
            <field name="full_name">Japanese yen</field>
            <field name="symbol">¥</field>
            <field name="rounding">1.00</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Yen</field>
            <field name="currency_subunit_label">Cen</field>
        </record>

        <record id="BGN" model="res.currency">
            <field name="name">BGN</field>
            <field name="full_name">Bulgarian lev</field>
            <field name="symbol">лв</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lev</field>
            <field name="currency_subunit_label">Stotinki</field>
        </record>

        <record id="LTL" model="res.currency">
            <field name="name">LTL</field>
            <field name="full_name">Lithuanian litas</field>
            <field name="symbol">Lt</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Litas</field>
            <field name="currency_subunit_label">Centas</field>
        </record>

        <record id="RON" model="res.currency">
            <field name="name">RON</field>
            <field name="full_name">Romanian leu</field>
            <field name="symbol">lei</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Leu</field>
            <field name="currency_subunit_label">Bani</field>
        </record>

        <record id="HRK" model="res.currency">
            <field name="name">HRK</field>
            <field name="full_name">Croatian kuna</field>
            <field name="symbol">kn</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kuna</field>
            <field name="currency_subunit_label">Lipa</field>
        </record>

        <record id="RUB" model="res.currency">
            <field name="name">RUB</field>
            <field name="full_name">Russian ruble</field>
            <field name="symbol">руб</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ruble</field>
            <field name="currency_subunit_label">Kopek</field>
        </record>

        <record id="TRY" model="res.currency">
            <field name="name">TRY</field>
            <field name="full_name">Turkish lira</field>
            <field name="symbol">₺</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lira</field>
            <field name="currency_subunit_label">Kurus</field>
        </record>

        <record id="KRW" model="res.currency">
            <field name="name">KRW</field>
            <field name="full_name">South Korean won</field>
            <field name="symbol">₩</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Won</field>
            <field name="currency_subunit_label">Chon</field>
        </record>

        <record id="MXN" model="res.currency">
            <field name="name">MXN</field>
            <field name="full_name">Mexican peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Pesos</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="MYR" model="res.currency">
            <field name="name">MYR</field>
            <field name="full_name">Malaysian ringgit</field>
            <field name="symbol">RM</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Ringgit</field>
            <field name="currency_subunit_label">Sen</field>
        </record>

        <record id="NZD" model="res.currency">
            <field name="name">NZD</field>
            <field name="full_name">New Zealand dollar</field>
            <field name="symbol">$</field>
            <field name="position">before</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="PHP" model="res.currency">
            <field name="name">PHP</field>
            <field name="full_name">Philippine peso</field>
            <field name="symbol">₱</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="SGD" model="res.currency">
            <field name="name">SGD</field>
            <field name="full_name">Singapore dollar</field>
            <field name="symbol">S$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="ZAR" model="res.currency">
            <field name="name">ZAR</field>
            <field name="full_name">South African rand</field>
            <field name="symbol">R</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rand</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="CRC" model="res.currency">
            <field name="name">CRC</field>
            <field name="full_name">Costa Rican colón</field>
            <field name="rounding">0.01</field>
            <field name="symbol">₡</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Colon</field>
            <field name="currency_subunit_label">Centimos</field>
        </record>

        <record id="MUR" model="res.currency">
            <field name="name">MUR</field>
            <field name="full_name">Mauritian rupee</field>
            <field name="symbol">Rs</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupee</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="XOF" model="res.currency">
            <field name="name">XOF</field>
            <field name="full_name">CFA franc BCEAO</field>
            <field name="symbol">CFA</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="XAF" model="res.currency">
            <field name="name">XAF</field>
            <field name="full_name">CFA franc BEAC</field>
            <field name="symbol">FCFA</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="UGX" model="res.currency">
            <field name="name">UGX</field>
            <field name="full_name">Ugandan shilling</field>
            <field name="symbol">USh</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Shilling</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="HNL" model="res.currency">
            <field name="name">HNL</field>
            <field name="full_name">Honduran lempira</field>
            <field name="symbol">L</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Lempiras</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="CLP" model="res.currency">
            <field name="name">CLP</field>
            <field name="full_name">Chilean peso</field>
            <field name="symbol">$</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="UYU" model="res.currency">
            <field name="name">UYU</field>
            <field name="full_name">Uruguayan peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centesimos</field>
        </record>

        <record id="AFN" model="res.currency">
            <field name="name">AFN</field>
            <field name="full_name">Afghan afghani</field>
            <field name="symbol">Afs</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Afghani</field>
            <field name="currency_subunit_label">Puls</field>
        </record>

        <record id="AOA" model="res.currency">
            <field name="name">AOA</field>
            <field name="full_name">Angolan kwanza</field>
            <field name="symbol">Kz</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kwanza</field>
            <field name="currency_subunit_label">Centimos</field>
        </record>

        <record id="XCD" model="res.currency">
            <field name="name">XCD</field>
            <field name="full_name">East Caribbean dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="AMD" model="res.currency">
            <field name="name">AMD</field>
            <field name="full_name">Armenian dram</field>
            <field name="symbol">դր.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dram</field>
            <field name="currency_subunit_label">Luma</field>
        </record>

        <record id="AWG" model="res.currency">
            <field name="name">AWG</field>
            <field name="full_name">Aruban florin</field>
            <field name="symbol">Afl.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Guilder</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="AZN" model="res.currency">
            <field name="name">AZN</field>
            <field name="full_name">Azerbaijani manat</field>
            <field name="symbol">m</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Manat</field>
            <field name="currency_subunit_label">Qapik</field>
        </record>

        <record id="BSD" model="res.currency">
            <field name="name">BSD</field>
            <field name="full_name">Bahamian dollar</field>
            <field name="symbol">B$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="BHD" model="res.currency">
            <field name="name">BHD</field>
            <field name="full_name">Bahraini dinar</field>
            <field name="symbol">BD</field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="BDT" model="res.currency">
            <field name="name">BDT</field>
            <field name="full_name">Bangladeshi taka</field>
            <field name="symbol">৳</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Taka</field>
            <field name="currency_subunit_label">Paisa</field>
        </record>

        <record id="BBD" model="res.currency">
            <field name="name">BBD</field>
            <field name="full_name">Barbados dollar</field>
            <field name="symbol">Bds$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="BYR" model="res.currency">
            <field name="name">BYR</field>
            <field name="full_name">Belarusian ruble</field>
            <field name="symbol">BR</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ruble BYR</field>
            <field name="currency_subunit_label">Kapeyka</field>
        </record>

        <record id="BYN" model="res.currency">
            <field name="name">BYN</field>
            <field name="full_name">Belarusian ruble</field>
            <field name="symbol">Br</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rubles</field>
            <field name="currency_subunit_label">Kopeks</field>            
        </record>

        <record id="BZD" model="res.currency">
            <field name="name">BZD</field>
            <field name="full_name">Belize dollar</field>
            <field name="symbol">BZ$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="BMD" model="res.currency">
            <field name="name">BMD</field>
            <field name="full_name">Bermudian dollar</field>
            <field name="symbol">BD$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="BTN" model="res.currency">
            <field name="name">BTN</field>
            <field name="full_name">Bhutanese ngultrum</field>
            <field name="symbol">Nu.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ngultrum</field>
            <field name="currency_subunit_label">Chhertum</field>
        </record>

        <record id="BOB" model="res.currency">
            <field name="name">BOB</field>
            <field name="full_name">Boliviano</field>
            <field name="symbol">Bs.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Boliviano</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="BAM" model="res.currency">
            <field name="name">BAM</field>
            <field name="full_name">Bosnia and Herzegovina convertible mark</field>
            <field name="symbol">KM</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Mark</field>
            <field name="currency_subunit_label">Fening</field>
        </record>

        <record id="BWP" model="res.currency">
            <field name="name">BWP</field>
            <field name="full_name">Botswana pula</field>
            <field name="symbol">P</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pula</field>
            <field name="currency_subunit_label">Thebe</field>
        </record>

        <record id="BIF" model="res.currency">
            <field name="name">BIF</field>
            <field name="full_name">Burundian franc</field>
            <field name="symbol">FBu</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="KHR" model="res.currency">
            <field name="name">KHR</field>
            <field name="full_name">Cambodian riel</field>
            <field name="symbol">៛</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Riel</field>
            <field name="currency_subunit_label">Sen</field>
        </record>

        <record id="KYD" model="res.currency">
            <field name="name">KYD</field>
            <field name="full_name">Cayman Islands dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="KMF" model="res.currency">
            <field name="name">KMF</field>
            <field name="full_name">Comorian franc</field>
            <field name="symbol">CF</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="CDF" model="res.currency">
            <field name="name">CDF</field>
            <field name="full_name">Congolese franc</field>
            <field name="symbol">Fr</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="CUP" model="res.currency">
            <field name="name">CUP</field>
            <field name="full_name">Cuban peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="ANG" model="res.currency">
            <field name="name">ANG</field>
            <field name="full_name">Netherlands Antillean guilder</field>
            <field name="symbol">ƒ</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Guilder</field>
            <field name="currency_subunit_label">Cents</field>
            <field name="position">before</field>
        </record>

        <record id="DJF" model="res.currency">
            <field name="name">DJF</field>
            <field name="full_name">Djiboutian franc</field>
            <field name="symbol">Fdj</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="DOP" model="res.currency">
            <field name="name">DOP</field>
            <field name="full_name">Dominican peso</field>
            <field name="symbol">RD$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pesos</field>
            <field name="currency_subunit_label">Centavos</field>
            <field name="position">before</field>
        </record>

        <record id="EGP" model="res.currency">
            <field name="name">EGP</field>
            <field name="full_name">Egyptian pound</field>
            <field name="symbol">LE</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Piastres</field>
        </record>

        <record id="SVC" model="res.currency">
            <field name="name">SVC</field>
            <field name="full_name">Salvadoran Colon</field>
            <field name="symbol">¢</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Colones</field>
            <field name="currency_subunit_label">Centavo</field>
        </record>

        <record id="ERN" model="res.currency">
            <field name="name">ERN</field>
            <field name="full_name">Eritrean nakfa</field>
            <field name="symbol">Nfk</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Nakfa</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="ETB" model="res.currency">
            <field name="name">ETB</field>
            <field name="full_name">Ethiopian birr</field>
            <field name="symbol">Br</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Birr</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="FKP" model="res.currency">
            <field name="name">FKP</field>
            <field name="full_name">Falkland Islands pound</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Penny</field>
        </record>

        <record id="FJD" model="res.currency">
            <field name="name">FJD</field>
            <field name="full_name">Fiji dollar</field>
            <field name="symbol">FJ$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="GEL" model="res.currency">
            <field name="name">GEL</field>
            <field name="full_name">Georgian lari</field>
            <field name="symbol">ლ</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lari</field>
            <field name="currency_subunit_label">Tetri</field>
        </record>

        <record id="GIP" model="res.currency">
            <field name="name">GIP</field>
            <field name="full_name">Gibraltar pound</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Penny</field>
        </record>

        <record id="GNF" model="res.currency">
            <field name="name">GNF</field>
            <field name="full_name">Guinean franc</field>
            <field name="symbol">FG</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="GYD" model="res.currency">
            <field name="name">GYD</field>
            <field name="full_name">Guyanese dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="HTG" model="res.currency">
            <field name="name">HTG</field>
            <field name="full_name">Haitian gourde</field>
            <field name="symbol">G</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Gourde</field>
            <field name="currency_subunit_label">Centime</field>
        </record>

        <record id="ISK" model="res.currency">
            <field name="name">ISK</field>
            <field name="full_name">Icelandic króna</field>
            <field name="symbol">kr</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Krona</field>
            <field name="currency_subunit_label">Aurar</field>
        </record>

        <record id="IRR" model="res.currency">
            <field name="name">IRR</field>
            <field name="full_name">Iranian rial</field>
            <field name="symbol">﷼</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="IQD" model="res.currency">
            <field name="name">IQD</field>
            <field name="full_name">Iraqi dinar</field>
            <field name="symbol"> ع.د</field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="ILS" model="res.currency">
            <field name="name">ILS</field>
            <field name="full_name">Israeli new shekel</field>
            <field name="symbol">₪</field>
            <field name="position">before</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Shekel</field>
            <field name="currency_subunit_label">Agorot</field>
        </record>

        <record id="JMD" model="res.currency">
            <field name="name">JMD</field>
            <field name="full_name">Jamaican dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="JOD" model="res.currency">
            <field name="name">JOD</field>
            <field name="full_name">Jordanian dinar</field>
            <field name="symbol"> د.ا </field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="KZT" model="res.currency">
            <field name="name">KZT</field>
            <field name="full_name">Kazakhstani tenge</field>
            <field name="symbol">₸</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Tenge</field>
            <field name="currency_subunit_label">Tiin</field>
        </record>

        <record id="KES" model="res.currency">
            <field name="name">KES</field>
            <field name="full_name">Kenyan shilling</field>
            <field name="symbol">KSh</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Shilling</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="KWD" model="res.currency">
            <field name="name">KWD</field>
            <field name="full_name">Kuwaiti dinar</field>
            <field name="symbol"> د.ك </field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="KGS" model="res.currency">
            <field name="name">KGS</field>
            <field name="full_name">Kyrgyzstani som</field>
            <field name="symbol">лв</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Som</field>
            <field name="currency_subunit_label">Tyiyn</field>
        </record>

        <record id="LAK" model="res.currency">
            <field name="name">LAK</field>
            <field name="full_name">Lao kip</field>
            <field name="symbol">₭</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kip</field>
            <field name="currency_subunit_label">Att</field>
        </record>

        <record id="LBP" model="res.currency">
            <field name="name">LBP</field>
            <field name="full_name">Lebanese pound</field>
            <field name="symbol">ل.ل</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Piastres</field>
        </record>

        <record id="LSL" model="res.currency">
            <field name="name">LSL</field>
            <field name="full_name">Lesotho loti</field>
            <field name="symbol">M</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Loti</field>
            <field name="currency_subunit_label">Sente</field>
        </record>

        <record id="LRD" model="res.currency">
            <field name="name">LRD</field>
            <field name="full_name">Liberian dollar</field>
            <field name="symbol">L$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="LYD" model="res.currency">
            <field name="name">LYD</field>
            <field name="full_name">Libyan dinar</field>
            <field name="symbol"> ل.د </field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Dirham</field>
        </record>

        <record id="MOP" model="res.currency">
            <field name="name">MOP</field>
            <field name="full_name">Macanese pataca</field>
            <field name="symbol">MOP$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pataca</field>
            <field name="currency_subunit_label">Sin</field>
        </record>

        <record id="MKD" model="res.currency">
            <field name="name">MKD</field>
            <field name="full_name">Macedonian denar</field>
            <field name="symbol">ден</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Denar</field>
            <field name="currency_subunit_label">Deni</field>
        </record>

        <record id="MGA" model="res.currency">
            <field name="name">MGA</field>
            <field name="full_name">Malagasy ariary</field>
            <field name="symbol">Ar</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ariary</field>
            <field name="currency_subunit_label">Iraimbilanja</field>
        </record>

        <record id="MWK" model="res.currency">
            <field name="name">MWK</field>
            <field name="full_name">Malawian kwacha</field>
            <field name="symbol">MK</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kwacha</field>
            <field name="currency_subunit_label">Tambala</field>
        </record>

        <record id="MVR" model="res.currency">
            <field name="name">MVR</field>
            <field name="full_name">Maldivian rufiyaa</field>
            <field name="symbol">.ރ</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Rufiyaa</field>
            <field name="currency_subunit_label">Laari</field>
        </record>

        <record id="MRO" model="res.currency">
            <field name="name">MRO</field>
            <field name="full_name">Mauritanian ouguiya (old)</field>
            <field name="symbol">UM</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ouguiya</field>
            <field name="currency_subunit_label">Khoums</field>
        </record>

        <record id="MRU" model="res.currency">
            <field name="name">MRU</field>
            <field name="full_name">Mauritanian ouguiya</field>
            <field name="symbol">UM</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Ouguiya</field>
            <field name="currency_subunit_label">Khoums</field>
        </record>

        <record id="MDL" model="res.currency">
            <field name="name">MDL</field>
            <field name="full_name">Moldovan leu</field>
            <field name="symbol">L</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Leu</field>
            <field name="currency_subunit_label">Ban</field>
        </record>

        <record id="MNT" model="res.currency">
            <field name="name">MNT</field>
            <field name="full_name">Mongolian tögrög</field>
            <field name="symbol">₮</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Tugrik</field>
            <field name="currency_subunit_label">Mongo</field>
        </record>

        <record id="MAD" model="res.currency">
            <field name="name">MAD</field>
            <field name="full_name">Moroccan dirham</field>
            <field name="symbol">DH</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dirham</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="BND" model="res.currency">
            <field name="name">BND</field>
            <field name="full_name">Brunei dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="DZD" model="res.currency">
            <field name="name">DZD</field>
            <field name="full_name">Algerian dinar</field>
            <field name="symbol">DA</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Centimes</field>
        </record>

        <record id="GHS" model="res.currency">
            <field name="name">GHS</field>
            <field name="full_name">Ghanaian cedi</field>
            <field name="symbol">GH¢</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Cedi</field>
            <field name="currency_subunit_label">Pesewas</field>
        </record>

        <record id="GMD" model="res.currency">
            <field name="name">GMD</field>
            <field name="full_name">Gambian dalasi</field>
            <field name="symbol">D</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dalasi</field>
            <field name="currency_subunit_label">Butut</field>
        </record>

        <record id="MZN" model="res.currency">
            <field name="name">MZN</field>
            <field name="full_name">Mozambican metical</field>
            <field name="symbol">MT</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Metical</field>
            <field name="currency_subunit_label">Centavo</field>
        </record>

        <record id="MMK" model="res.currency">
            <field name="name">MMK</field>
            <field name="full_name">Myanmar kyat</field>
            <field name="symbol">K</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kyat</field>
            <field name="currency_subunit_label">Pya</field>
        </record>

        <record id="NAD" model="res.currency">
            <field name="name">NAD</field>
            <field name="full_name">Namibian dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="NPR" model="res.currency">
            <field name="name">NPR</field>
            <field name="full_name">Nepalese rupee</field>
            <field name="symbol">₨</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupee</field>
            <field name="currency_subunit_label">Paisa</field>
        </record>

        <record id="ALL" model="res.currency">
            <field name="name">ALL</field>
            <field name="full_name">Albanian lek</field>
            <field name="symbol">L</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lek</field>
            <field name="currency_subunit_label">Qindarke</field>
        </record>

        <record id="NIO" model="res.currency">
            <field name="name">NIO</field>
            <field name="full_name">Nicaraguan córdoba</field>
            <field name="symbol">C$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Cordoba</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="NGN" model="res.currency">
            <field name="name">NGN</field>
            <field name="full_name">Nigerian naira</field>
            <field name="symbol">₦</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Naira</field>
            <field name="currency_subunit_label">Kobo</field>
        </record>

        <record id="KPW" model="res.currency">
            <field name="name">KPW</field>
            <field name="full_name">North Korean won</field>
            <field name="symbol">₩</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Won</field>
            <field name="currency_subunit_label">Chon</field>
        </record>

        <record id="ZWL" model="res.currency">
            <field name="name">ZWL</field>
            <field name="full_name">Zimbabwean dollar</field>
            <field name="symbol">Z$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="ZIG" model="res.currency">
            <field name="name">ZIG</field>
            <field name="full_name">Zimbabwe Gold</field>
            <field name="symbol">ZiG</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">ZiGs</field>
        </record>

        <record id="ZMW" model="res.currency">
            <field name="name">ZMW</field>
            <field name="full_name">Zambian kwacha</field>
            <field name="symbol">ZK</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kwacha</field>
            <field name="currency_subunit_label">Ngwee</field>
        </record>

        <record id="YER" model="res.currency">
            <field name="name">YER</field>
            <field name="full_name">Yemeni rial</field>
            <field name="symbol">﷼</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rial</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="EUR" model="res.currency">
            <field name="name">EUR</field>
            <field name="full_name">Euro</field>
            <field name="symbol">€</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Euros</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="VUV" model="res.currency">
            <field name="name">VUV</field>
            <field name="full_name">Vanuatu vatu</field>
            <field name="symbol">VT</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Vatu</field>
        </record>

        <record id="UZS" model="res.currency">
            <field name="name">UZS</field>
            <field name="full_name">Uzbekistan som</field>
            <field name="symbol">лв</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Som</field>
            <field name="currency_subunit_label">Tiyin</field>
        </record>

        <record id="AED" model="res.currency">
            <field name="name">AED</field>
            <field name="full_name">United Arab Emirates dirham</field>
            <field name="symbol">د.إ</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dirham</field>
            <field name="currency_subunit_label">Fils</field>
        </record>

        <record id="TMT" model="res.currency">
            <field name="name">TMT</field>
            <field name="full_name">Turkmenistan manat</field>
            <field name="symbol">T</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Manat</field>
            <field name="currency_subunit_label">Tenge</field>
        </record>

        <record id="TND" model="res.currency">
            <field name="name">TND</field>
            <field name="full_name">Tunisian dinar</field>
            <field name="symbol">DT</field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Millimes</field>
        </record>

        <record id="TTD" model="res.currency">
            <field name="name">TTD</field>
            <field name="full_name">Trinidad and Tobago dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="TOP" model="res.currency">
            <field name="name">TOP</field>
            <field name="full_name">Tongan paʻanga</field>
            <field name="symbol">T$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Paanga</field>
            <field name="currency_subunit_label">Seniti</field>
        </record>

        <record id="THB" model="res.currency">
            <field name="name">THB</field>
            <field name="full_name">Thai baht</field>
            <field name="symbol">฿</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Baht</field>
            <field name="currency_subunit_label">Satang</field>
        </record>

        <record id="TZS" model="res.currency">
            <field name="name">TZS</field>
            <field name="full_name">Tanzanian shilling</field>
            <field name="symbol">TSh</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Shilling</field>
            <field name="currency_subunit_label">Senti</field>
        </record>

        <record id="TJS" model="res.currency">
            <field name="name">TJS</field>
            <field name="full_name">Tajikistani somoni</field>
            <field name="symbol">TJS</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Somoni</field>
            <field name="currency_subunit_label">Diram</field>
        </record>

        <record id="TWD" model="res.currency">
            <field name="name">TWD</field>
            <field name="full_name">New Taiwan dollar</field>
            <field name="symbol">NT$</field>
            <field name="rounding">1.00</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SYP" model="res.currency">
            <field name="name">SYP</field>
            <field name="full_name">Syrian pound</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Piastrp</field>
        </record>

        <record id="SZL" model="res.currency">
            <field name="name">SZL</field>
            <field name="full_name">Swazi lilangeni</field>
            <field name="symbol">E</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Lilangeni</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SRD" model="res.currency">
            <field name="name">SRD</field>
            <field name="full_name">Surinamese dollar</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SDG" model="res.currency">
            <field name="name">SDG</field>
            <field name="full_name">Sudanese pound</field>
            <field name="symbol">ج.س.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
        </record>

        <record id="LKR" model="res.currency">
            <field name="name">LKR</field>
            <field name="full_name">Sri Lankan rupee</field>
            <field name="symbol">Rs</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupee</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SSP" model="res.currency">
            <field name="name">SSP</field>
            <field name="full_name">South Sudanese pound</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pounds</field>
            <field name="currency_subunit_label">Piasters</field>
        </record>

        <record id="GBP" model="res.currency">
            <field name="name">GBP</field>
            <field name="full_name">Pound sterling</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="position">before</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Sterling</field>
            <field name="currency_subunit_label">Penny</field>
        </record>

        <record id="SOS" model="res.currency">
            <field name="name">SOS</field>
            <field name="full_name">Somali shilling</field>
            <field name="symbol">Sh.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Shillings</field>
            <field name="currency_subunit_label">Senti</field>
        </record>

        <record id="SBD" model="res.currency">
            <field name="name">SBD</field>
            <field name="full_name">Solomon Islands dollar</field>
            <field name="symbol">SI$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dollars</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SLL" model="res.currency">
            <field name="name">SLL</field>
            <field name="full_name">Sierra Leonean leone</field>
            <field name="symbol">Le</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Leone</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SLE" model="res.currency">
            <field name="name">SLE</field>
            <field name="full_name">Sierra Leonean leone</field>
            <field name="symbol">Le</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Leone</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="SCR" model="res.currency">
            <field name="name">SCR</field>
            <field name="full_name">Seychellois rupee</field>
            <field name="symbol">SR</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupee</field>
            <field name="currency_subunit_label">Cents</field>
        </record>

        <record id="RSD" model="res.currency">
            <field name="name">RSD</field>
            <field name="full_name">Serbian dinar</field>
            <field name="symbol">din.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dinar</field>
            <field name="currency_subunit_label">Para</field>
        </record>

        <record id="SAR" model="res.currency">
            <field name="name">SAR</field>
            <field name="full_name">Saudi riyal</field>
            <field name="symbol">SR</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Riyal</field>
            <field name="currency_subunit_label">Halala</field>
        </record>

        <record id="STD" model="res.currency">
            <field name="name">STD</field>
            <field name="full_name">São Tomé and Príncipe dobra</field>
            <field name="symbol">Db</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dobra</field>
            <field name="currency_subunit_label">Centimo</field>
        </record>

        <record id="WST" model="res.currency">
            <field name="name">WST</field>
            <field name="full_name">Samoan tālā</field>
            <field name="symbol">WS$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Tala</field>
            <field name="currency_subunit_label">Sene</field>
        </record>

        <record id="SHP" model="res.currency">
            <field name="name">SHP</field>
            <field name="full_name">Saint Helena pound</field>
            <field name="symbol">£</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Pound</field>
            <field name="currency_subunit_label">Penny</field>
        </record>

        <record id="RWF" model="res.currency">
            <field name="name">RWF</field>
            <field name="full_name">Rwandan franc</field>
            <field name="symbol">RF</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Franc</field>
            <field name="currency_subunit_label">Santime</field>
        </record>

        <record id="QAR" model="res.currency">
            <field name="name">QAR</field>
            <field name="full_name">Qatari riyal</field>
            <field name="symbol">QR</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rial</field>
            <field name="currency_subunit_label">Dirham</field>
        </record>

        <record id="PEN" model="res.currency">
            <field name="name">PEN</field>
            <field name="full_name">Peruvian sol</field>
            <field name="symbol">S/</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Soles</field>
            <field name="currency_subunit_label">Centimos</field>
        </record>

        <record id="PYG" model="res.currency">
            <field name="name">PYG</field>
            <field name="full_name">Paraguayan guaraní</field>
            <field name="symbol">₲</field>
            <field name="rounding">1</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Guarani</field>
            <field name="currency_subunit_label">Centimos</field>
        </record>

        <record id="PGK" model="res.currency">
            <field name="name">PGK</field>
            <field name="full_name">Papua New Guinean kina</field>
            <field name="symbol">K</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Kina</field>
            <field name="currency_subunit_label">Toea</field>
        </record>

        <record id="PKR" model="res.currency">
            <field name="name">PKR</field>
            <field name="full_name">Pakistani rupee</field>
            <field name="symbol">Rs.</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rupee</field>
            <field name="currency_subunit_label">Paisa</field>
        </record>

        <record id="OMR" model="res.currency">
            <field name="name">OMR</field>
            <field name="full_name">Omani rial</field>
            <field name="symbol">ر.ع.</field>
            <field name="rounding">0.001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Rial</field>
            <field name="currency_subunit_label">Baisa</field>
        </record>

        <record id="CVE" model="res.currency">
            <field name="name">CVE</field>
            <field name="full_name">Cape Verdean escudo</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Escudo</field>
            <field name="currency_subunit_label">Centavo</field>
        </record>

        <record id="COU" model="res.currency">
            <field name="name">COU</field>
            <field name="full_name">Unidad de Valor Real</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">centavo</field>
        </record>

        <record id="CLF" model="res.currency">
            <field name="name">CLF</field>
            <field name="full_name">Unidad de Fomento</field>
            <field name="symbol">$</field>
            <field name="rounding">0.0001</field>
            <field name="active" eval="False"/>
            <field name="position">before</field>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">Centavos</field>
        </record>

        <record id="CUC" model="res.currency">
            <field name="name">CUC</field>
            <field name="full_name">Cuban convertible peso</field>
            <field name="symbol">$</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Cuban convertible peso</field>
        </record>

        <record id="GTQ" model="res.currency">
            <field name="name">GTQ</field>
            <field name="full_name">Guatemalan Quetzal</field>
            <field name="symbol">Q</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Quetzales</field>
            <field name="currency_subunit_label">Centavo</field>
        </record>

        <record id="VES" model="res.currency">
            <field name="name">VES</field>
            <field name="full_name">Venezuelan bolívar soberano</field>
            <field name="symbol">Bs</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
        </record>

        <record id="UYW" model="res.currency">
            <field name="name">UYW</field>
            <field name="full_name">Unidad previsional</field>
            <field name="symbol">$</field>
            <field name="rounding">0.0001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">peso</field>
            <field name="currency_subunit_label">centésimo</field>
        </record>

        <record id="UYI" model="res.currency">
            <field name="name">UYI</field>
            <field name="full_name">Uruguay Peso en Unidades Indexadas</field>
            <field name="symbol">$</field>
            <field name="rounding">0.0001</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Peso</field>
            <field name="currency_subunit_label">centésimo</field>
        </record>

        <record id="STN" model="res.currency">
            <field name="name">STN</field>
            <field name="full_name">São Tomé and Príncipe dobra</field>
            <field name="symbol">Db</field>
            <field name="rounding">0.01</field>
            <field name="active" eval="False"/>
            <field name="currency_unit_label">Dobra</field>
            <field name="currency_subunit_label">cêntimo</field>
        </record>

    </data>
</odoo>

```

  File: data/res_currency_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <!--
            In demo only, enable the USD currency.
            The rationale is that, without demo, you shouldn't enable any currency by default,
            so you do not land in a multi-currency database by default.
            e.g. if USD was enabled by default even without demo, and you install the accounting for Belgium,
            installing the Belgian Chart Of Account, it would enable the EUR currency,
            therefore leaving you with the USD and EUR currency enabled,
            and therefore in a multi-currency environment.
            But, with demo, you need to enable the currency used by the company by default,
            so the monetary fields display the currency symbol even when invoicing (account) is not installed.
            e.g. install a demo database with just CRM, you want the $ to appear next to the expected revenue field.
        -->
        <record id="USD" model="res.currency">
            <field name="active" eval="True"/>
        </record>

    </data>
</odoo>

```

  File: data/res_currency_rate_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record forcecreate="0" id="rateUSD" model="res.currency.rate">
            <field name="rate">1.0</field>
            <field name="currency_id" ref="USD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateVEF" model="res.currency.rate">
            <field name="rate">5.864</field>
            <field name="currency_id" ref="VEF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCAD" model="res.currency.rate">
            <field name="rate">1.3388</field>
            <field name="currency_id" ref="CAD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCHF" model="res.currency.rate">
            <field name="rate">1.3086</field>
            <field name="currency_id" ref="CHF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateBRL" model="res.currency.rate">
            <field name="rate">2.2344</field>
            <field name="currency_id" ref="BRL"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCNY" model="res.currency.rate">
            <field name="rate">8.7556</field>
            <field name="currency_id" ref="CNY"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCOP" model="res.currency.rate">
            <field name="rate">2933.8378</field>
            <field name="currency_id" ref="COP"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCZK" model="res.currency.rate">
            <field name="rate">26.5634</field>
            <field name="currency_id" ref="CZK"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateDKK" model="res.currency.rate">
            <field name="rate">7.4445</field>
            <field name="currency_id" ref="DKK"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateHUF" model="res.currency.rate">
            <field name="rate">271.5621</field>
            <field name="currency_id" ref="HUF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateIDR1" model="res.currency.rate">
            <field name="rate">14352.00</field>
            <field name="currency_id" ref="IDR"/>
            <field name="name">2009-01-01</field>
        </record>
        <record forcecreate="0" id="rateIDR" model="res.currency.rate">
            <field name="rate">11796.39</field>
            <field name="currency_id" ref="IDR"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateLVL" model="res.currency.rate">
            <field name="rate">0.7086</field>
            <field name="currency_id" ref="LVL"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateNOK" model="res.currency.rate">
            <field name="rate">7.8668</field>
            <field name="currency_id" ref="NOK"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateXPF" model="res.currency.rate">
            <field name="rate">119.331742</field>
            <field name="currency_id" ref="XPF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="ratePAB" model="res.currency.rate">
            <field name="rate">1.2676</field>
            <field name="currency_id" ref="PAB"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="ratePLN" model="res.currency.rate">
            <field name="rate">4.1005</field>
            <field name="currency_id" ref="PLN"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateSEK" model="res.currency.rate">
            <field name="rate">10.3004</field>
            <field name="currency_id" ref="SEK"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateARS" model="res.currency.rate">
            <field name="rate">5.0881</field>
            <field name="currency_id" ref="ARS"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateINR" model="res.currency.rate">
            <field name="rate">59.9739</field>
            <field name="currency_id" ref="INR"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateAUD" model="res.currency.rate">
            <field name="rate">1.4070</field>
            <field name="currency_id" ref="AUD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateUAH" model="res.currency.rate">
            <field name="rate">10.1969</field>
            <field name="currency_id" ref="UAH"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateVND" model="res.currency.rate">
            <field name="rate">26330.01</field>
            <field name="currency_id" ref="VND"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateHKD" model="res.currency.rate">
            <field name="rate">11.1608</field>
            <field name="currency_id" ref="HKD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateJPY" model="res.currency.rate">
            <field name="rate">133.62</field>
            <field name="currency_id" ref="JPY"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateBGN" model="res.currency.rate">
            <field name="rate">1.9558</field>
            <field name="currency_id" ref="BGN"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateLTL" model="res.currency.rate">
            <field name="rate">3.4528</field>
            <field name="currency_id" ref="LTL"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateRON" model="res.currency.rate">
            <field name="rate">4.2253</field>
            <field name="currency_id" ref="RON"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateHRK" model="res.currency.rate">
            <field name="rate">7.2936</field>
            <field name="currency_id" ref="HRK"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateRUB" model="res.currency.rate">
            <field name="rate">43.16</field>
            <field name="currency_id" ref="RUB"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateTRY" model="res.currency.rate">
            <field name="rate">2.1411</field>
            <field name="currency_id" ref="TRY"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateKRW" model="res.currency.rate">
            <field name="rate">1662.37</field>
            <field name="currency_id" ref="KRW"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateMXN" model="res.currency.rate">
            <field name="rate">18.6664</field>
            <field name="currency_id" ref="MXN"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateMYR" model="res.currency.rate">
            <field name="rate">4.8887</field>
            <field name="currency_id" ref="MYR"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateNZD" model="res.currency.rate">
            <field name="rate">1.9764</field>
            <field name="currency_id" ref="NZD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="ratePHP" model="res.currency.rate">
            <field name="rate">66.1</field>
            <field name="currency_id" ref="PHP"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateSGD" model="res.currency.rate">
            <field name="rate">2.0126</field>
            <field name="currency_id" ref="SGD"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateZAR" model="res.currency.rate">
            <field name="rate">10.5618</field>
            <field name="currency_id" ref="ZAR"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCRC" model="res.currency.rate">
            <field name="rate">691.3153</field>
            <field name="currency_id" ref="CRC"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateMUR" model="res.currency.rate">
            <field name="rate">40.28</field>
            <field name="currency_id" ref="MUR"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateXOF" model="res.currency.rate">
            <field name="rate">655.957</field>
            <field name="currency_id" ref="XOF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateXAF" model="res.currency.rate">
            <field name="rate">655.957</field>
            <field name="currency_id" ref="XAF"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateUGX" model="res.currency.rate">
            <field name="rate">3401.91388</field>
            <field name="currency_id" ref="UGX"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateHNL" model="res.currency.rate">
            <field name="rate">25</field>
            <field name="currency_id" ref="HNL"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateCLP" model="res.currency.rate">
            <field name="rate">710</field>
            <field name="currency_id" ref="CLP"/>
            <field name="name">2010-01-01</field>
        </record>

        <record forcecreate="0" id="rateUYU" model="res.currency.rate">
            <field name="currency_id" ref="UYU" />
            <field name="name">2010-01-01</field>
            <field name="rate">28.36</field>
        </record>

        <record forcecreate="0" id="rateUYI" model="res.currency.rate">
            <field name="currency_id" ref="UYI"/>
            <field name="name">2023-09-13</field>
            <field name="rate">5.7778</field>
        </record>

        <record forcecreate="0" id="rateAFN" model="res.currency.rate">
            <field name="currency_id" ref="AFN" />
            <field name="name">2010-01-01</field>
            <field name="rate">59.33</field>
        </record>

        <record forcecreate="0" id="rateAOA" model="res.currency.rate">
            <field name="currency_id" ref="AOA" />
            <field name="name">2010-01-01</field>
            <field name="rate">117.080</field>
        </record>

        <record forcecreate="0" id="rateXCD" model="res.currency.rate">
            <field name="currency_id" ref="XCD" />
            <field name="name">2010-01-01</field>
            <field name="rate">3.32</field>
        </record>

        <record forcecreate="0" id="rateAMD" model="res.currency.rate">
            <field name="currency_id" ref="AMD" />
            <field name="name">2010-01-01</field>
            <field name="rate">506.02</field>
        </record>

        <record forcecreate="0" id="rateAWG" model="res.currency.rate">
            <field name="currency_id" ref="AWG" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.45</field>
        </record>

        <record forcecreate="0" id="rateAZN" model="res.currency.rate">
            <field name="currency_id" ref="AZN" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.96</field>
        </record>

        <record forcecreate="0" id="rateBSD" model="res.currency.rate">
            <field name="currency_id" ref="BSD" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.23</field>
        </record>

        <record forcecreate="0" id="rateBHD" model="res.currency.rate">
            <field name="currency_id" ref="BHD" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.46</field>
        </record>

        <record forcecreate="0" id="rateBDT" model="res.currency.rate">
            <field name="currency_id" ref="BDT" />
            <field name="name">2010-01-01</field>
            <field name="rate">100.59</field>
        </record>

        <record forcecreate="0" id="rateBBD" model="res.currency.rate">
            <field name="currency_id" ref="BBD" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.46</field>
        </record>

        <record forcecreate="0" id="rateBYR" model="res.currency.rate">
            <field name="currency_id" ref="BYR" />
            <field name="name">2010-01-01</field>
            <field name="rate">10228.19</field>
        </record>

        <record forcecreate="0" id="rateBYN" model="res.currency.rate">
            <field name="currency_id" ref="BYN" />
            <field name="name">2016-07-01</field>
            <field name="rate">2.23151</field>
        </record>

        <record forcecreate="0" id="rateBZD" model="res.currency.rate">
            <field name="currency_id" ref="BZD" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.33</field>
        </record>

        <record forcecreate="0" id="rateBMD" model="res.currency.rate">
            <field name="currency_id" ref="BMD" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.23</field>
        </record>

        <record forcecreate="0" id="rateBTN" model="res.currency.rate">
            <field name="currency_id" ref="BTN" />
            <field name="name">2010-01-01</field>
            <field name="rate"> 67.81</field>
        </record>

        <record forcecreate="0" id="rateBOB" model="res.currency.rate">
            <field name="currency_id" ref="BOB" />
            <field name="name">2010-01-01</field>
            <field name="rate">8.50</field>
        </record>

        <record forcecreate="0" id="rateBAM" model="res.currency.rate">
            <field name="currency_id" ref="BAM" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.96</field>
        </record>

        <record forcecreate="0" id="rateBWP" model="res.currency.rate">
            <field name="currency_id" ref="BWP" />
            <field name="name">2010-01-01</field>
            <field name="rate">9.45</field>
        </record>

        <record forcecreate="0" id="rateBIF" model="res.currency.rate">
            <field name="currency_id" ref="BIF" />
            <field name="name">2010-01-01</field>
            <field name="rate">1736.73</field>
        </record>

        <record forcecreate="0" id="rateKHR" model="res.currency.rate">
            <field name="currency_id" ref="KHR" />
            <field name="name">2010-01-01</field>
            <field name="rate">5054.53</field>
        </record>

        <record forcecreate="0" id="rateKYD" model="res.currency.rate">
            <field name="currency_id" ref="KYD" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.007</field>
        </record>

        <record forcecreate="0" id="rateKMF" model="res.currency.rate">
            <field name="currency_id" ref="KMF" />
            <field name="name">2010-01-01</field>
            <field name="rate">492.23</field>
        </record>

        <record forcecreate="0" id="rateCDF" model="res.currency.rate">
            <field name="currency_id" ref="CDF" />
            <field name="name">2010-01-01</field>
            <field name="rate">1112.80</field>
        </record>

        <record forcecreate="0" id="rateCUP" model="res.currency.rate">
            <field name="currency_id" ref="CUP" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.226</field>
        </record>

        <record forcecreate="0" id="rateANG" model="res.currency.rate">
            <field name="currency_id" ref="ANG" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.11</field>
        </record>

        <record forcecreate="0" id="rateDJF" model="res.currency.rate">
            <field name="currency_id" ref="DJF" />
            <field name="name">2010-01-01</field>
            <field name="rate">222.22</field>
        </record>

        <record forcecreate="0" id="rateDOP" model="res.currency.rate">
            <field name="currency_id" ref="DOP" />
            <field name="name">2010-01-01</field>
            <field name="rate">48.09</field>
        </record>

        <record forcecreate="0" id="rateEGP" model="res.currency.rate">
            <field name="currency_id" ref="EGP" />
            <field name="name">2010-01-01</field>
            <field name="rate">7.46</field>
        </record>

        <record forcecreate="0" id="rateSVC" model="res.currency.rate">
            <field name="currency_id" ref="SVC" />
            <field name="name">2010-01-01</field>
            <field name="rate">10.74</field>
        </record>

        <record forcecreate="0" id="rateERN" model="res.currency.rate">
            <field name="currency_id" ref="ERN" />
            <field name="name">2010-01-01</field>
            <field name="rate">18.89</field>
        </record>

        <record forcecreate="0" id="rateEEB" model="res.currency.rate">
            <field name="currency_id" ref="ETB" />
            <field name="name">2010-01-01</field>
            <field name="rate">21.94</field>
        </record>

        <record forcecreate="0" id="rateFKP" model="res.currency.rate">
            <field name="currency_id" ref="FKP" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.78</field>
        </record>

        <record forcecreate="0" id="rateFJD" model="res.currency.rate">
            <field name="currency_id" ref="FJD" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.22</field>
        </record>

        <record forcecreate="0" id="rateGEL" model="res.currency.rate">
            <field name="currency_id" ref="GEL" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.018</field>
        </record>

        <record forcecreate="0" id="rateGIP" model="res.currency.rate">
            <field name="currency_id" ref="GIP" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.786</field>
        </record>

        <record forcecreate="0" id="rateGNF" model="res.currency.rate">
            <field name="currency_id" ref="GNF" />
            <field name="name">2010-01-01</field>
            <field name="rate">8835.85</field>
        </record>

        <record forcecreate="0" id="rateGYD" model="res.currency.rate">
            <field name="currency_id" ref="GYD" />
            <field name="name">2010-01-01</field>
            <field name="rate">247.31</field>
        </record>

        <record forcecreate="0" id="rateHTG" model="res.currency.rate">
            <field name="currency_id" ref="HTG" />
            <field name="name">2010-01-01</field>
            <field name="rate">51.69</field>
        </record>

        <record forcecreate="0" id="rateISK" model="res.currency.rate">
            <field name="currency_id" ref="ISK" />
            <field name="name">2010-01-01</field>
            <field name="rate">158.70</field>
        </record>

        <record forcecreate="0" id="rateIRR" model="res.currency.rate">
            <field name="currency_id" ref="IRR" />
            <field name="name">2010-01-01</field>
            <field name="rate">15059.97</field>
        </record>

        <record forcecreate="0" id="rateIQD" model="res.currency.rate">
            <field name="currency_id" ref="IQD" />
            <field name="name">2010-01-01</field>
            <field name="rate">1432.27</field>
        </record>

        <record forcecreate="0" id="rateILS" model="res.currency.rate">
            <field name="currency_id" ref="ILS" />
            <field name="name">2010-01-01</field>
            <field name="rate">4.89</field>
        </record>

        <record forcecreate="0" id="rateJMD" model="res.currency.rate">
            <field name="currency_id" ref="JMD" />
            <field name="name">2010-01-01</field>
            <field name="rate">108.94 </field>
        </record>

        <record forcecreate="0" id="rateJOD" model="res.currency.rate">
            <field name="currency_id" ref="JOD" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.87</field>
        </record>

        <record forcecreate="0" id="rateKZT" model="res.currency.rate">
            <field name="currency_id" ref="KZT" />
            <field name="name">2010-01-01</field>
            <field name="rate">184.09</field>
        </record>

        <record forcecreate="0" id="rateKES" model="res.currency.rate">
            <field name="currency_id" ref="KES" />
            <field name="name">2010-01-01</field>
            <field name="rate">103.43</field>
        </record>

        <record forcecreate="0" id="rateKWD" model="res.currency.rate">
            <field name="currency_id" ref="KWD" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.35</field>
        </record>

        <record forcecreate="0" id="rateKGS" model="res.currency.rate">
            <field name="currency_id" ref="KGS" />
            <field name="name">2010-01-01</field>
            <field name="rate">57.93</field>
        </record>

        <record forcecreate="0" id="rateLAK" model="res.currency.rate">
            <field name="currency_id" ref="LAK" />
            <field name="name">2010-01-01</field>
            <field name="rate">9847.72</field>
        </record>

        <record forcecreate="0" id="rateLBP" model="res.currency.rate">
            <field name="currency_id" ref="LBP" />
            <field name="name">2010-01-01</field>
            <field name="rate">1853.94</field>
        </record>

        <record forcecreate="0" id="rateLSL" model="res.currency.rate">
            <field name="currency_id" ref="LSL" />
            <field name="name">2010-01-01</field>
            <field name="rate">10.06</field>
        </record>

        <record forcecreate="0" id="rateLRD" model="res.currency.rate">
            <field name="currency_id" ref="LRD" />
            <field name="name">2010-01-01</field>
            <field name="rate">90.28</field>
        </record>

        <record forcecreate="0" id="rateLYD" model="res.currency.rate">
            <field name="currency_id" ref="LYD" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.54</field>
        </record>

        <record forcecreate="0" id="rateMOP" model="res.currency.rate">
            <field name="currency_id" ref="MOP" />
            <field name="name">2010-01-01</field>
            <field name="rate">9.81</field>
        </record>

        <record forcecreate="0" id="rateMKD" model="res.currency.rate">
            <field name="currency_id" ref="MKD" />
            <field name="name">2010-01-01</field>
            <field name="rate">60.29</field>
        </record>

        <record forcecreate="0" id="rateMGA" model="res.currency.rate">
            <field name="currency_id" ref="MGA" />
            <field name="name">2010-01-01</field>
            <field name="rate">2775.86</field>
        </record>

        <record forcecreate="0" id="rateMWK" model="res.currency.rate">
            <field name="currency_id" ref="MWK" />
            <field name="name">2010-01-01</field>
            <field name="rate">329.79</field>
        </record>

        <record forcecreate="0" id="rateMVR" model="res.currency.rate">
            <field name="currency_id" ref="MVR" />
            <field name="name">2010-01-01</field>
            <field name="rate">18.89</field>
        </record>

        <record forcecreate="0" id="rateMRO" model="res.currency.rate">
            <field name="currency_id" ref="MRO" />
            <field name="name">2010-01-01</field>
            <field name="rate">362.23</field>
        </record>

        <record forcecreate="0" id="rateMDL" model="res.currency.rate">
            <field name="currency_id" ref="MDL" />
            <field name="name">2010-01-01</field>
            <field name="rate">15.27</field>
        </record>

        <record forcecreate="0" id="rateMNT" model="res.currency.rate">
            <field name="currency_id" ref="MNT" />
            <field name="name">2010-01-01</field>
            <field name="rate">1643.57</field>
        </record>

        <record forcecreate="0" id="rateMAD" model="res.currency.rate">
            <field name="currency_id" ref="MAD" />
            <field name="name">2010-01-01</field>
            <field name="rate">10.9962499</field>
        </record>

        <record forcecreate="0" id="rateBND" model="res.currency.rate">
            <field name="currency_id" ref="BND" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.54</field>
        </record>

        <record forcecreate="0" id="rateDZD" model="res.currency.rate">
            <field name="currency_id" ref="DZD" />
            <field name="name">2010-01-01</field>
            <field name="rate">99.65</field>
        </record>

        <record forcecreate="0" id="rateGHS" model="res.currency.rate">
            <field name="currency_id" ref="GHS" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.39</field>
        </record>

        <record forcecreate="0" id="rateGMD" model="res.currency.rate">
            <field name="currency_id" ref="GMD" />
            <field name="name">2010-01-01</field>
            <field name="rate">38.89</field>
        </record>

        <record forcecreate="0" id="rateMZN" model="res.currency.rate">
            <field name="currency_id" ref="MZN" />
            <field name="name">2010-01-01</field>
            <field name="rate">33.65</field>
        </record>

        <record forcecreate="0" id="rateMMK" model="res.currency.rate">
            <field name="currency_id" ref="MMK" />
            <field name="name">2010-01-01</field>
            <field name="rate">1080.82</field>
        </record>

        <record forcecreate="0" id="rateNAD" model="res.currency.rate">
            <field name="currency_id" ref="NAD" />
            <field name="name">2010-01-01</field>
            <field name="rate">10.06</field>
        </record>

        <record forcecreate="0" id="rateNPR" model="res.currency.rate">
            <field name="currency_id" ref="NPR" />
            <field name="name">2010-01-01</field>
            <field name="rate">108.33</field>
        </record>

        <record forcecreate="0" id="rateALL" model="res.currency.rate">
            <field name="currency_id" ref="ALL" />
            <field name="name">2010-01-01</field>
            <field name="rate">138.00</field>
        </record>

        <record forcecreate="0" id="rateNIO" model="res.currency.rate">
            <field name="currency_id" ref="NIO" />
            <field name="name">2010-01-01</field>
            <field name="rate">28.97</field>
        </record>

        <record forcecreate="0" id="rateNGN" model="res.currency.rate">
            <field name="currency_id" ref="NGN" />
            <field name="name">2010-01-01</field>
            <field name="rate">196.77</field>
        </record>

        <record forcecreate="0" id="rateKPW" model="res.currency.rate">
            <field name="currency_id" ref="KPW" />
            <field name="name">2010-01-01</field>
            <field name="rate">1105.24376765</field>
        </record>

        <record forcecreate="0" id="rateZWL" model="res.currency.rate">
            <field name="currency_id" ref="ZWL" />
            <field name="name">2010-01-01</field>
            <field name="rate">395.80</field>
        </record>

        <record forcecreate="0" id="rateZIG" model="res.currency.rate">
            <field name="currency_id" ref="ZIG" />
            <field name="name">2024-04-08</field>
            <field name="rate">14.69</field>
        </record>

        <record forcecreate="0" id="rateZMW" model="res.currency.rate">
            <field name="currency_id" ref="ZMW" />
            <field name="name">2010-01-01</field>
            <field name="rate">11.61</field>
        </record>

        <record forcecreate="0" id="rateYER" model="res.currency.rate">
            <field name="currency_id" ref="YER" />
            <field name="name">2010-01-01</field>
            <field name="rate">264.784483</field>
        </record>

        <record forcecreate="0" id="rateEUR" model="res.currency.rate">
            <field name="currency_id" ref="EUR" />
            <field name="name">2010-01-01</field>
            <field name="rate">1.2834</field>
        </record>

        <record forcecreate="0" id="rateVUV" model="res.currency.rate">
            <field name="currency_id" ref="VUV" />
            <field name="name">2010-01-01</field>
            <field name="rate">114.024315363</field>
        </record>

        <record forcecreate="0" id="rateUZS" model="res.currency.rate">
            <field name="currency_id" ref="UZS" />
            <field name="name">2010-01-01</field>
            <field name="rate">2331.3093</field>
        </record>

        <record forcecreate="0" id="rateAED" model="res.currency.rate">
            <field name="currency_id" ref="AED" />
            <field name="name">2010-01-01</field>
            <field name="rate">4.51253195</field>
        </record>

        <record forcecreate="0" id="rateTMT" model="res.currency.rate">
            <field name="currency_id" ref="TMT" />
            <field name="name">2010-01-01</field>
            <field name="rate">4.31</field>
        </record>

        <record forcecreate="0" id="rateTND" model="res.currency.rate">
            <field name="currency_id" ref="TND" />
            <field name="name">2010-01-01</field>
            <field name="rate">34.0661408</field>
        </record>

        <record forcecreate="0" id="rateTTD" model="res.currency.rate">
            <field name="currency_id" ref="TTD" />
            <field name="name">2010-01-01</field>
            <field name="rate">8.61926302</field>
        </record>

        <record forcecreate="0" id="rateTOP" model="res.currency.rate">
            <field name="currency_id" ref="TOP" />
            <field name="name">2010-01-01</field>
            <field name="rate">31.1217</field>
        </record>

        <record forcecreate="0" id="rateTHB" model="res.currency.rate">
            <field name="currency_id" ref="THB" />
            <field name="name">2010-01-01</field>
            <field name="rate">38.4070124</field>
        </record>

        <record forcecreate="0" id="rateTZS" model="res.currency.rate">
            <field name="currency_id" ref="TZS" />
            <field name="name">2010-01-01</field>
            <field name="rate">1947.06815</field>
        </record>

        <record forcecreate="0" id="rateTJS" model="res.currency.rate">
            <field name="currency_id" ref="TJS" />
            <field name="name">2010-01-01</field>
            <field name="rate">6.15</field>
        </record>

        <record forcecreate="0" id="rateTWD" model="res.currency.rate">
            <field name="currency_id" ref="TWD" />
            <field name="name">2010-01-01</field>
            <field name="rate">36.8329536</field>
        </record>

        <record forcecreate="0" id="rateSYP" model="res.currency.rate">
            <field name="currency_id" ref="SYP" />
            <field name="name">2010-01-01</field>
            <field name="rate">78.8338</field>
        </record>

        <record forcecreate="0" id="rateSZL" model="res.currency.rate">
            <field name="currency_id" ref="SZL" />
            <field name="name">2010-01-01</field>
            <field name="rate">10.07</field>
        </record>

        <record forcecreate="0" id="rateSRD" model="res.currency.rate">
            <field name="currency_id" ref="SRD" />
            <field name="name">2010-01-01</field>
            <field name="rate">9.17930</field>
        </record>

        <record forcecreate="0" id="rateSDG" model="res.currency.rate">
            <field name="currency_id" ref="SDG" />
            <field name="name">2010-01-01</field>
            <field name="rate">3.1999</field>
        </record>

        <record forcecreate="0" id="rateLKR" model="res.currency.rate">
            <field name="currency_id" ref="LKR" />
            <field name="name">2010-01-01</field>
            <field name="rate">163.552526</field>
        </record>

        <record forcecreate="0" id="rateSSP" model="res.currency.rate">
            <field name="currency_id" ref="SSP" />
            <field name="name">2010-01-01</field>
            <field name="rate">5.528</field>
        </record>

        <record forcecreate="0" id="rateGBP" model="res.currency.rate">
            <field name="currency_id" ref="GBP" />
            <field name="name">2010-01-01</field>
            <field name="rate"> 0.784221994</field>
        </record>

        <record forcecreate="0" id="rateSOS" model="res.currency.rate">
            <field name="currency_id" ref="SOS" />
            <field name="name">2010-01-01</field>
            <field name="rate">1993.71</field>
        </record>

        <record forcecreate="0" id="rateSBD" model="res.currency.rate">
            <field name="currency_id" ref="SBD" />
            <field name="name">2010-01-01</field>
            <field name="rate">8.6605</field>
        </record>

        <record forcecreate="0" id="rateSLL" model="res.currency.rate">
            <field name="currency_id" ref="SLL" />
            <field name="name">2010-01-01</field>
            <field name="rate">5320.43478</field>
        </record>

        <record forcecreate="0" id="rateSLE" model="res.currency.rate">
            <field name="currency_id" ref="SLE" />
            <field name="name">2023-06-08</field>
            <field name="rate">22.5847</field>
        </record>

        <record forcecreate="0" id="rateSCR" model="res.currency.rate">
            <field name="currency_id" ref="SCR" />
            <field name="name">2010-01-01</field>
            <field name="rate">18.2587287</field>
        </record>

        <record forcecreate="0" id="rateRSD" model="res.currency.rate">
            <field name="currency_id" ref="RSD" />
            <field name="name">2010-01-01</field>
            <field name="rate">117.381295</field>
        </record>

        <record forcecreate="0" id="rateSAR" model="res.currency.rate">
            <field name="currency_id" ref="SAR" />
            <field name="name">2010-01-01</field>
            <field name="rate">4.58898972</field>
        </record>

        <record forcecreate="0" id="rateSTD" model="res.currency.rate">
            <field name="currency_id" ref="STD" />
            <field name="name">2010-01-01</field>
            <field name="rate">24105.86</field>
        </record>

        <record forcecreate="0" id="rateWST" model="res.currency.rate">
            <field name="currency_id" ref="WST" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.8628</field>
        </record>

        <record forcecreate="0" id="rateSHP" model="res.currency.rate">
            <field name="currency_id" ref="SHP" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.7856</field>
        </record>

        <record forcecreate="0" id="rateRWF" model="res.currency.rate">
            <field name="currency_id" ref="RWF" />
            <field name="name">2010-01-01</field>
            <field name="rate">752.57</field>
        </record>

        <record forcecreate="0" id="rateQAR" model="res.currency.rate">
            <field name="currency_id" ref="QAR" />
            <field name="name">2010-01-01</field>
            <field name="rate">4.45500218</field>
        </record>

        <record forcecreate="0" id="ratePEN" model="res.currency.rate">
            <field name="currency_id" ref="PEN" />
            <field name="name">2010-01-01</field>
            <field name="rate">3.20731573</field>
        </record>

        <record forcecreate="0" id="ratePYG" model="res.currency.rate">
            <field name="currency_id" ref="PYG" />
            <field name="name">2010-01-01</field>
            <field name="rate">5343.66812</field>
        </record>

        <record forcecreate="0" id="ratePGK" model="res.currency.rate">
            <field name="currency_id" ref="PGK" />
            <field name="name">2010-01-01</field>
            <field name="rate">2.5903895</field>
        </record>

        <record forcecreate="0" id="ratePKR" model="res.currency.rate">
            <field name="currency_id" ref="PKR" />
            <field name="name">2010-01-01</field>
            <field name="rate">115.97432</field>
        </record>

        <record forcecreate="0" id="rateOMR" model="res.currency.rate">
            <field name="currency_id" ref="OMR" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.472921728</field>
        </record>

        <record forcecreate="0" id="rateCVE" model="res.currency.rate">
            <field name="currency_id" ref="CVE" />
            <field name="name">2010-01-01</field>
            <field name="rate">0.61</field>
        </record>

        <record forcecreate="0" id="rateGTQ" model="res.currency.rate">
            <field name="rate">11.2020</field>
            <field name="currency_id" ref="GTQ"/>
            <field name="name">2010-01-01</field>
        </record>

    </data>
</odoo>

```

  File: data/res_lang_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <function name="install_lang" model="res.lang"/>
    </data>
    <data>
        <record id="base.lang_my" model="res.lang">
            <field name="url_code">mya</field>
        </record>
        <record id="base.lang_ar" model="res.lang">
            <field name="flag_image" type="base64" file="base/static/img/lang_flags/lang_ar.png"/>
        </record>
        <record id="base.lang_sr@latin" model="res.lang">
            <field name="flag_image" type="base64" file="base/static/img/country_flags/rs.png"/>
        </record>
    </data>
</odoo>

```

  File: data/res_partner_bank_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
<data noupdate="1">
    <record model="res.partner.bank" id="bank_partner_demo">
        <field name="acc_number">60-16-13 31926819</field>
        <field name="partner_id" ref="partner_demo"/>
    </record>
</data>
</odoo>

```

  File: data/res_partner_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="True">
        <record id="main_partner" model="res.partner" context="{'default_is_company': True}">
            <field name="name">My Company</field>
            <field name="company_id" eval="None"/>
            <field name="is_company" eval="True"/>
            <field name="street"></field>
            <field name="city"></field>
            <field name="zip"></field>
            <field name="phone"></field>
            <field name="image_1920" type="base64" file="base/static/img/res_company_logo.png"/>
        </record>

        <record model="res.partner" id="base.partner_root">
            <field name="name">System</field>
            <field name="company_id" ref="main_company"/>
            <field name="email">odoobot@example.com</field>
            <field name="active" eval="False"/>
        </record>

        <record model="res.partner" id="base.partner_admin">
            <field name="name">Administrator</field>
            <field name="company_id" ref="main_company"/>
            <field name="email">admin@example.com</field>
        </record>

        <record id="public_partner" model="res.partner">
            <field name="name">Public user</field>
            <field name="active" eval="False"/>
        </record>

        <!--
        Resource: res.partner.title
        -->
        <record id="res_partner_title_madam" model="res.partner.title">
            <field name="name">Madam</field>
            <field name="shortcut">Mrs.</field>
        </record>
        <record id="res_partner_title_miss" model="res.partner.title">
            <field name="name">Miss</field>
            <field name="shortcut">Miss</field>
        </record>
        <record id="res_partner_title_mister" model="res.partner.title">
            <field name="name">Mister</field>
            <field name="shortcut">Mr.</field>
        </record>
        <record id="res_partner_title_doctor" model="res.partner.title">
            <field name="name">Doctor</field>
            <field name="shortcut">Dr.</field>
        </record>
        <record id="res_partner_title_prof" model="res.partner.title">
            <field name="name">Professor</field>
            <field name="shortcut">Prof.</field>
        </record>

        <record id="res_partner_industry_A" model="res.partner.industry">
            <field name="name">Agriculture</field>
            <field name="full_name">A - AGRICULTURE, FORESTRY AND FISHING</field>
        </record>

        <record id="res_partner_industry_B" model="res.partner.industry">
            <field name="name">Mining</field>
            <field name="full_name">B - MINING AND QUARRYING</field>
        </record>

        <record id="res_partner_industry_C" model="res.partner.industry">
            <field name="name">Manufacturing</field>
            <field name="full_name">C - MANUFACTURING</field>
        </record>

        <record id="res_partner_industry_D" model="res.partner.industry">
            <field name="name">Energy supply</field>
            <field name="full_name">D - ELECTRICITY, GAS, STEAM AND AIR CONDITIONING SUPPLY</field>
        </record>

        <record id="res_partner_industry_E" model="res.partner.industry">
            <field name="name">Water supply</field>
            <field name="full_name">E - WATER SUPPLY; SEWERAGE, WASTE MANAGEMENT AND REMEDIATION ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_F" model="res.partner.industry">
            <field name="name">Construction</field>
            <field name="full_name">F - CONSTRUCTION</field>
        </record>

        <record id="res_partner_industry_G" model="res.partner.industry">
            <field name="name">Wholesale/Retail</field>
            <field name="full_name">G - WHOLESALE AND RETAIL TRADE; REPAIR OF MOTOR VEHICLES AND MOTORCYCLES</field>
        </record>

        <record id="res_partner_industry_H" model="res.partner.industry">
            <field name="name">Transportation/Logistics</field>
            <field name="full_name">H - TRANSPORTATION AND STORAGE</field>
        </record>

        <record id="res_partner_industry_I" model="res.partner.industry">
            <field name="name">Food/Hospitality</field>
            <field name="full_name">I - ACCOMMODATION AND FOOD SERVICE ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_J" model="res.partner.industry">
            <field name="name">IT/Communication</field>
            <field name="full_name">J - INFORMATION AND COMMUNICATION</field>
        </record>

        <record id="res_partner_industry_K" model="res.partner.industry">
            <field name="name">Finance/Insurance</field>
            <field name="full_name">K - FINANCIAL AND INSURANCE ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_L" model="res.partner.industry">
            <field name="name">Real Estate</field>
            <field name="full_name">L - REAL ESTATE ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_M" model="res.partner.industry">
            <field name="name">Scientific</field>
            <field name="full_name">M - PROFESSIONAL, SCIENTIFIC AND TECHNICAL ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_N" model="res.partner.industry">
            <field name="name">Administrative/Utilities</field>
            <field name="full_name">N - ADMINISTRATIVE AND SUPPORT SERVICE ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_O" model="res.partner.industry">
            <field name="name">Public Administration</field>
            <field name="full_name">O - PUBLIC ADMINISTRATION AND DEFENCE; COMPULSORY SOCIAL SECURITY</field>
        </record>

        <record id="res_partner_industry_P" model="res.partner.industry">
            <field name="name">Education</field>
            <field name="full_name">P - EDUCATION</field>
        </record>

        <record id="res_partner_industry_Q" model="res.partner.industry">
            <field name="name">Health/Social</field>
            <field name="full_name">Q - HUMAN HEALTH AND SOCIAL WORK ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_R" model="res.partner.industry">
            <field name="name">Entertainment</field>
            <field name="full_name">R - ARTS, ENTERTAINMENT AND RECREATION</field>
        </record>

        <record id="res_partner_industry_S" model="res.partner.industry">
            <field name="name">Other Services</field>
            <field name="full_name">S - OTHER SERVICE ACTIVITIES</field>
        </record>

        <record id="res_partner_industry_T" model="res.partner.industry">
            <field name="name">Households</field>
            <field name="full_name">T - ACTIVITIES OF HOUSEHOLDS AS EMPLOYERS; UNDIFFERENTIATED GOODS- AND SERVICES-PRODUCING ACTIVITIES OF HOUSEHOLDS FOR OWN USE</field>
        </record>

        <record id="res_partner_industry_U" model="res.partner.industry">
            <field name="name">Extraterritorial</field>
            <field name="full_name">U - ACTIVITIES OF EXTRATERRITORIAL ORGANISATIONS AND BODIES</field>
        </record>

    </data>
</odoo>

```

  File: data/res_partner_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="0">
        <!--
        Resource: res.partner.category
        -->
        <record id="res_partner_category_0" model="res.partner.category">
            <field name="name">Vendor</field>
            <field name="color" eval="2"/>
        </record>
        <record id="res_partner_category_2" model="res.partner.category">
            <field name="name">Prospects</field>
            <field name="color" eval="3"/>
        </record>
        <record id="res_partner_category_3" model="res.partner.category">
            <field name="name">Employees</field>
            <field name="color" eval="4"/>
        </record>
        <record id="res_partner_category_8" model="res.partner.category">
            <field name="name">Consulting Services</field>
            <field name="color" eval="5"/>
        </record>
        <record id="res_partner_category_11" model="res.partner.category">
            <field name="name">Services</field>
            <field name="color" eval="7"/>
        </record>
        <record id="res_partner_category_12" model="res.partner.category">
            <field name="name">Office Supplies</field>
            <field name="parent_id" ref="res_partner_category_0"/>
            <field name="color" eval="8"/>
        </record>
        <record id="res_partner_category_14" model="res.partner.category">
            <field name="name">Desk Manufacturers</field>
            <field name="color" eval="10"/>
            <field name="parent_id" ref="res_partner_category_0"/>
        </record>

       <!--
        Resource: res.partner
        -->
        <record id="res_partner_1" model="res.partner">
            <field name="name">Wood Corner</field>
            <field eval="[Command.set([ref('res_partner_category_14'), ref('res_partner_category_12')])]" name="category_id"/>
            <field name="is_company">1</field>
            <field name="street">1839 Arbor Way</field>
            <field name="city">Turlock</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">95380</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">wood.corner26@example.com</field>
            <field name="phone">(623)-853-7197</field>
            <field name="website">http://www.wood-corner.com</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_1-image.png"/>
            <field name="vat">US12345672</field>
        </record>
        <record id="res_partner_2" model="res.partner">
            <field name="name">Deco Addict</field>
            <field eval="[Command.set([ref('base.res_partner_category_14')])]" name="category_id"/>
            <field name="is_company">1</field>
            <field name="street">77 Santa Barbara Rd</field>
            <field name="city">Pleasant Hill</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">94523</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">deco_addict@yourcompany.example.com</field>
            <field name="phone">(603)-996-3829</field>
            <field name="website">http://www.deco-addict.com</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_2-image.png"/>
            <field name="vat">US12345673</field>
        </record>
        <record id="res_partner_3" model="res.partner">
            <field name="name">Gemini Furniture</field>
            <field eval="[Command.set([ref('res_partner_category_8'), ref('res_partner_category_14')])]" name="category_id"/>
            <field name="is_company">1</field>
            <field name="street">317 Fairchild Dr</field>
            <field name="city">Fairfield</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">94535</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">gemini_furniture@fake.geminifurniture.com</field>
            <field name="phone">(941)-284-4875</field>
            <field name="website">http://www.gemini-furniture.com/</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_3-image.png"/>
            <field name="vat">US12345674</field>
        </record>

        <record id="res_partner_4" model="res.partner">
            <field name="name">Ready Mat</field>
            <field eval="[Command.set([ref('res_partner_category_14'), ref('res_partner_category_12')])]" name="category_id"/>
            <field name="is_company">1</field>
            <field name="street">7500 W Linne Road</field>
            <field name="city">Tracy</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">95304</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">ready.mat28@example.com</field>
            <field name="phone">(803)-873-6126</field>
            <field name="website">http://www.ready-mat.com/</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_4-image.png"/>
            <field name="vat">US12345675</field>
        </record>

        <record id="res_partner_10" model="res.partner">
            <field name="name">The Jackson Group</field>
            <field name="is_company">1</field>
            <field name="street">1611 Peony Dr</field>
            <field name="city">Tracy</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">95377</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">jackson.group82@example.com</field>
            <field name="phone">(334)-502-1024</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_10-image.jpg"/>
            <field name="vat">US12345676</field>
        </record>

        <record id="res_partner_12" model="res.partner">
            <field name="name">Azure Interior</field>
            <field eval="[Command.set([ref('res_partner_category_11')])]" name="category_id"/>
            <field name="is_company">1</field>
            <field name="street">4557 De Silva St</field>
            <field name="city">Fremont</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">94538</field>
            <field name="phone">(870)-931-0505</field>
            <field name="country_id" ref="base.us"/>
            <field name="email">azure.Interior24@example.com</field>
            <field name="website">http://www.azure-interior.com</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_12-image.png"/>
            <field name="vat">US12345677</field>
        </record>

        <record id="res_partner_18" model="res.partner">
            <field name="name">Lumber Inc</field>
            <field name="is_company">1</field>
            <field name="street">1337 N San Joaquin St</field>
            <field name="city">Stockton</field>
            <field name="state_id" ref='state_us_5'/>
            <field name="zip">95202</field>
            <field name="email">lumber-inv92@example.com</field>
            <field name="phone">(828)-316-0593</field>
            <field name="country_id" ref="base.us"/>
            <field name="website">http://www.lumber-inc.com</field>
            <field name="image_1920" type="base64" file="base/static/img/res_partner_18-image.png"/>
            <field name="vat">US12345678</field>
        </record>

        <record id="res_partner_address_1" model="res.partner">
            <field name="name">Willie Burke</field>
            <field name="parent_id" ref="res_partner_1"/>
            <field name="function">Service Manager</field>
            <field name="email">willie.burke80@example.com</field>
            <field name="phone">(846)-523-2111</field>
        </record>
        <record id="res_partner_address_2" model="res.partner">
            <field name="name">Ron Gibson</field>
            <field name="parent_id" ref="res_partner_1"/>
            <field name="function">Store Manager</field>
            <field name="email">ron.gibson76@example.com</field>
            <field name="phone">(976)-397-4091</field>
        </record>
        <record id="res_partner_address_3" model="res.partner">
            <field name="name">Douglas Fletcher</field>
            <field name="parent_id" ref="res_partner_2"/>
            <field name="function">Functional Consultant</field>
            <field name="email">douglas.fletcher51@example.com</field>
            <field name="phone">(132)-553-7242</field>
        </record>
        <record id="res_partner_address_4" model="res.partner">
            <field name="name">Floyd Steward</field>
            <field name="parent_id" ref="res_partner_2"/>
            <field name="function">Analyst</field>
            <field name="email">floyd.steward34@example.com</field>
            <field name="phone">(145)-138-3401</field>
        </record>
        <record id="res_partner_address_5" model="res.partner">
            <field name="name">Edwin Hansen</field>
            <field name="parent_id" ref="res_partner_3"/>
            <field name="function">Marketing Manager</field>
            <field name="email">edwin.hansen58@example.com</field>
            <field name="phone">(943)-352-2555</field>
        </record>
        <record id="res_partner_address_7" model="res.partner">
            <field name="name">Billy Fox</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Production Supervisor</field>
            <field name="email">billy.fox45@example.com</field>
            <field name="phone">(915)-498-5611</field>
        </record>
        <record id="res_partner_address_10" model="res.partner">
            <field name="name">Jesse Brown</field>
            <field name="parent_id" ref="res_partner_3"/>
            <field name="function">Senior Consultant</field>
            <field name="email">jesse.brown74@example.com</field>
            <field name="phone">(829)-386-3277</field>
            <field name="company_id" ref="base.main_company"/>
        </record>
        <record id="res_partner_address_11" model="res.partner">
            <field name="name">Soham Palmer</field>
            <field name="parent_id" ref="res_partner_3"/>
            <field name="function">Director</field>
            <field name="email">soham.palmer15@example.com</field>
            <field name="phone">(379)-167-2040</field>
        </record>
        <record id="res_partner_address_13" model="res.partner">
            <field name="name">Kim Snyder</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Senior Associate</field>
            <field name="email">kim.snyder96@example.com</field>
            <field name="phone">(215)-379-4865</field>
        </record>
        <record id="res_partner_address_14" model="res.partner">
            <field name="name">Edith Sanchez</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Analyst</field>
            <field name="email">edith.sanchez68@example.com</field>
            <field name="phone">(938)-175-2048</field>
        </record>
        <record id="res_partner_address_15" model="res.partner">
            <field name="name">Brandon Freeman</field>
            <field name="function">Creative Director</field>
            <field name="parent_id" ref="res_partner_12"/>
            <field name="email">brandon.freeman55@example.com</field>
            <field name="phone">(355)-687-3262</field>
        </record>
        <record id="res_partner_address_16" model="res.partner">
            <field name="name">Nicole Ford</field>
            <field name="function">Director</field>
            <field name="parent_id" ref="res_partner_12"/>
            <field name="email">nicole.ford75@example.com</field>
            <field name="phone">(946)-638-6034</field>
        </record>
        <record id="res_partner_address_17" model="res.partner">
            <field name="name">Toni Rhodes</field>
            <field name="function">Managing Partner</field>
            <field name="parent_id" ref="res_partner_10"/>
            <field name="email">toni.rhodes11@example.com</field>
            <field name="phone">(198)-539-4948</field>
        </record>
        <record id="res_partner_address_18" model="res.partner">
            <field name="name">Gordon Owens</field>
            <field name="function">Senior Consultant</field>
            <field name="parent_id" ref="res_partner_10"/>
            <field name="email">gordon.owens47@example.com</field>
            <field name="phone">(336)-723-6569</field>
        </record>
        <record id="res_partner_address_24" model="res.partner">
            <field name="name">Theodore Gardner</field>
            <field name="function">System Analyst</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="email">theodore.gardner36@example.com</field>
            <field name="phone">(186)-612-6561</field>
        </record>
        <record id="res_partner_address_25" model="res.partner">
            <field name="name">Oscar Morgan</field>
            <field name="parent_id" ref="res_partner_3"/>
            <field name="function">Order Clerk</field>
            <field name="email">oscar.morgan11@example.com</field>
            <field name="phone">(561)-239-1744</field>
        </record>
        <record id="res_partner_address_27" model="res.partner">
            <field name="name">Tom Ruiz</field>
            <field name="parent_id" ref="res_partner_1"/>
            <field name="function">Software Developer</field>
            <field name="email">tom.ruiz89@example.com</field>
            <field name="phone">(102)-834-1602</field>
        </record>
        <record id="res_partner_address_28" model="res.partner">
            <field name="name">Colleen Diaz</field>
            <field name="function">Business Executive</field>
            <field name="parent_id" ref="res_partner_12"/>
            <field name="email">colleen.diaz83@example.com</field>
            <field name="phone">(255)-595-8393</field>
        </record>
        <record id="res_partner_address_30" model="res.partner">
            <field name="name">Lorraine Douglas</field>
            <field name="function">Functional Consultant</field>
            <field name="parent_id" ref="res_partner_18"/>
            <field name="email">lorraine.douglas35@example.com</field>
            <field name="phone">(443)-648-9155</field>
        </record>
        <record id="res_partner_address_31" model="res.partner">
            <field name="name">Addison Olson</field>
            <field name="parent_id" ref="res_partner_2"/>
            <field name="function">Sales Representative</field>
            <field name="email">addison.olson28@example.com</field>
            <field name="phone">(223)-399-7637</field>
        </record>
        <record id="res_partner_address_32" model="res.partner">
            <field name="name">Sandra Neal</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Sales Manager</field>
            <field name="email">sandra.neal80@example.com</field>
            <field name="phone">(430)-371-7293</field>
        </record>
        <record id="res_partner_address_33" model="res.partner">
            <field name="name">Julie Richards</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Financial Manager</field>
            <field name="email">julie.richards84@example.com</field>
            <field name="phone">(225)-148-7811</field>
        </record>
        <record id="res_partner_address_34" model="res.partner">
            <field name="name">Travis Mendoza</field>
            <field name="parent_id" ref="res_partner_4"/>
            <field name="function">Knowledge Manager</field>
            <field name="email">travis.mendoza24@example.com</field>
            <field name="phone">(840)-944-8661</field>
        </record>
        <record id="res_partner_main1" model="res.partner">
            <field name="name">Chester Reed</field>
            <field name="parent_id" ref="main_partner"/>
            <field name="function">Chief Executive Officer (CEO)</field>
            <field name="email">chester.reed79@example.com</field>
            <field name="phone">(979)-904-8902</field>
        </record>
        <record id="res_partner_main2" model="res.partner">
            <field name="name">Dwayne Newman</field>
            <field name="function">Chief Operations Officer (COO)</field>
            <field name="parent_id" ref="main_partner"/>
            <field name="email">dwayne.newman28@example.com</field>
            <field name="phone">(614)-177-4937</field>
        </record>
    </data>
</odoo>

```

  File: data/res_partner_image_demo.xml
  Content:
```
<?xml version='1.0' encoding='utf-8'?>
<odoo>
    <data noupdate="0">

        <record id="base.res_partner_address_1" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_1.jpg"/>
        </record>

        <record id="base.res_partner_address_2" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_2.jpg"/>
        </record>

        <record id="base.res_partner_address_3" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_3.jpg"/>
        </record>

        <record id="base.res_partner_address_4" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_4.jpg"/>
        </record>

        <record id="base.res_partner_address_5" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_5.jpg"/>
        </record>

        <record id="base.res_partner_address_7" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_7.jpg"/>
        </record>

        <record id="base.res_partner_address_10" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_10.jpg"/>
        </record>

        <record id="base.res_partner_address_11" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_11.jpg"/>
        </record>

        <record id="base.res_partner_address_13" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_13.jpg"/>
        </record>

        <record id="base.res_partner_address_14" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_14.jpg"/>
        </record>

        <record id="base.res_partner_address_15" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_15.jpg"/>
        </record>

        <record id="base.res_partner_address_16" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_16.jpg"/>
        </record>

        <record id="base.res_partner_address_17" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_17.jpg"/>
        </record>

        <record id="base.res_partner_address_18" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_18.jpg"/>
        </record>

        <record id="base.res_partner_address_24" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_24.jpg"/>
        </record>

        <record id="base.res_partner_address_25" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_25.jpg"/>
        </record>

        <record id="base.res_partner_address_27" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_27.jpg"/>
        </record>

        <record id="base.res_partner_address_28" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_28.jpg"/>
        </record>

        <record id="base.res_partner_address_30" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_30.jpg"/>
        </record>

        <record id="base.res_partner_address_31" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_31.jpg"/>
        </record>

        <record id="base.res_partner_address_32" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_32.jpg"/>
        </record>

        <record id="base.res_partner_address_33" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_33.jpg"/>
        </record>

        <record id="base.res_partner_address_34" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_address_34.jpg"/>
        </record>

        <record id="base.res_partner_main1" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_main1.jpg"/>
        </record>

        <record id="base.res_partner_main2" model="res.partner">
            <field name="image_1920" type="base64" file="base/static/img/res_partner_main2.jpg"/>
        </record>

    </data>
</odoo>

```

  File: data/res_users_data.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- user 1 is the technical admin user -->
        <record model="res.users" id="base.user_root">
            <field name="partner_id" ref="base.partner_root"/>
            <field name="company_id" ref="main_company"/>
            <field name="company_ids" eval="[Command.link(ref('main_company'))]"/>
            <field name="email">odoobot@example.com</field>
            <field name="signature"><![CDATA[<span>-- <br/>
System</span>]]></field>
        </record>

        <!-- user 2 is the human admin user -->
        <record id="user_admin" model="res.users">
            <field name="login">admin</field>
            <field name="password">admin</field>
            <field name="partner_id" ref="base.partner_admin"/>
            <field name="company_id" ref="main_company"/>
            <field name="company_ids" eval="[Command.link(ref('main_company'))]"/>
            <field name="groups_id" eval="[Command.set([])]"/>
            <field name="signature"><![CDATA[<span>-- <br/>
Administrator</span>]]></field>
        </record>

        <!-- Default user with full access rights for newly created users -->
        <record id="default_user" model="res.users">
            <field name="name">Default User Template</field>
            <field name="login">default</field>
            <field name="active" eval="False"/>
        </record>

        <record id="public_user" model="res.users">
            <field name="name">Public user</field>
            <field name="login">public</field>
            <field name="password"></field>
            <!-- Avoid auto-including this demo user in any default group -->
            <field name="groups_id" eval="[Command.set([])]"/>
            <field name="image_1920" type="base64" file="base/static/img/public_user-image.png"/>
            <field name="partner_id" ref="public_partner"/>
            <field name="active" eval="False"/>
        </record>
    </data>
</odoo>

```

  File: data/res_users_demo.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record id="partner_demo" model="res.partner">
            <field name="name">Marc Demo</field>
            <field name="company_id" ref="main_company"/>
            <field name="company_name">YourCompany</field>
            <field name="street">3575  Buena Vista Avenue</field>
            <field name="city">Eugene</field>
            <field name="state_id"  model="res.country.state" search="[('code','=','OR')]"/>
            <field name="zip">97401</field>
            <field name="country_id" ref="us"/>
            <field name="tz">Europe/Brussels</field>
            <field name="email">mark.brown23@example.com</field>
            <field name="phone">(441)-695-2334</field>
        </record>

        <!-- Only update if we don't have information coming from the database manager -->
        <function model="res.partner" name="write">
            <value eval="[ref('base.main_partner')]"/>
            <value eval="{
                'name': 'YourCompany',
                'street': '250 Executive Park Blvd, Suite 3400',
                'city': 'San Francisco',
                'zip': '94134',
                'country_id': ref('base.us'),
                'state_id': ref('base.state_us_5'),
                'phone': '+1 555-555-5556',
                'website': 'www.example.com',
                'email': 'info@yourcompany.com',
            } if obj(ref('base.main_partner')).name == 'My Company' else {}" model="res.partner"/>
        </function>

        <record id="user_demo" model="res.users">
            <field name="partner_id" ref="base.partner_demo"/>
            <field name="login">demo</field>
            <field name="password">demo</field>
            <field name="signature" type="html"><span>-- <br/>+Mr Demo</span></field>
            <field name="company_id" ref="main_company"/>
            <field name="groups_id" eval="[Command.set([ref('base.group_user'), ref('base.group_partner_manager'), ref('base.group_allow_export')])]"/>
            <field name="image_1920" type="base64" file="base/static/img/user_demo-image.png"/>
        </record>

        <record model="res.partner" id="base.partner_root">
            <field name="tz">Europe/Brussels</field>
        </record>

        <record model="res.partner" id="base.partner_admin">
            <field name="name">Mitchell Admin</field>
            <field name="company_name">YourCompany</field>
            <field name="street">215 Vine St</field>
            <field name="city">Scranton</field>
            <field name="zip">18503</field>
            <field name='country_id' ref='base.us'/>
            <field name='state_id' ref='state_us_39'/>
            <field name="phone">+1 555-555-5555</field>
            <field name="email">admin@yourcompany.example.com</field>
            <field name="tz">Europe/Brussels</field>
            <field name="image_1920" type="base64" file="base/static/img/partner_root-image.png"/>
        </record>

        <record id="base.user_admin" model="res.users">
            <field name="signature" type="html"><span>-- <br/>Mitchell Admin</span></field>
        </record>

        <!-- Portal : partner and user -->
        <record id="partner_demo_portal" model="res.partner">
            <field name="name">Joel Willis</field>
            <field name="email">joel.willis63@example.com</field>
            <field name="street">858 Lynn Street</field>
            <field name="city">Bayonne</field>
            <field model="res.country.state" name="state_id" search="[('code','ilike','NJ')]"/>
            <field name="zip">07002</field>
            <field name="country_id" ref="base.us"/>
            <field name="company_name">YourCompany</field>
            <field name="image_1920" type="base64" file="base/static/img/partner_demo_portal.png"/>
            <field name="phone">(683)-556-5104</field>
        </record>
        <record id="demo_user0" model="res.users" context="{'no_reset_password': True}">
            <field name="partner_id" ref="partner_demo_portal"/>
            <field name="login">portal</field>
            <field name="password">portal</field>
            <field name="signature"><![CDATA[<span>-- <br/>Mr Demo Portal</span>]]></field>
            <field name="groups_id" eval="[Command.clear()]"/><!-- Avoid auto-including this user in any default group -->
        </record>

        <record id="base.group_portal" model="res.groups"><!-- Add the demo user to the portal (and therefore to the portal member group) -->
            <field name="users" eval="[Command.link(ref('demo_user0'))]"/>
        </record>
    </data>
</odoo>

```

  File: data/rtlcss.json
  Content:
```
{
    "options": {
        "autoRename": false,
        "autoRenameStrict": false,
        "blacklist": {
            "rtlcss": {
                "config": true,
                "options": true
            }
        },
        "clean": true,
        "greedy": false,
        "processUrls": false,
        "stringMap": [],
        "useCalc": false,
        "aliases": {},
        "processEnv": false
    },
    "plugins": [],
    "map": false
}

```

Static:
  File: static/description/board.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/description/board.svg
  Content:
```
<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M4 8a4 4 0 0 1 4-4h17v17a4 4 0 0 1-4 4H4V8Z" fill="#FC868B"/><path d="M4 35a4 4 0 0 1 4-4h11v11a4 4 0 0 1-4 4H4V35Z" fill="#F9464C"/><path d="M25 46h4a4 4 0 0 0 4-4V31h-4a4 4 0 0 0-4 4v11Z" fill="#FBB945"/><path d="M31 17v4a4 4 0 0 0 4 4h11v-4a4 4 0 0 0-4-4H31Z" fill="#088BF5"/><path d="M31 4v4a4 4 0 0 0 4 4h11V8a4 4 0 0 0-4-4H31Z" fill="#2EBCFA"/><path d="M38 46h4a4 4 0 0 0 4-4V31h-4a4 4 0 0 0-4 4v11Z" fill="#F78613"/></svg>

```

  File: static/description/icon.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/description/icon.svg
  Content:
```
<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#o_icon_base_icon__a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 38V13L25 0l21 13v25L25 50 4 38Zm2-1.16V15.294L24 25.58v21.545L6 36.84Zm20 10.285V25.58l18-10.285v21.544L26 47.125ZM6.943 13.53 25 23.848 43.057 13.53 25 2.352 6.943 13.53Z" fill="#1AD3BB"/></g><defs><clipPath id="o_icon_base_icon__a"><path fill="#fff" d="M0 0h50v50H0z"/></clipPath></defs></svg>

```

  File: static/description/modules.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/description/modules.svg
  Content:
```
<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M23 .078V19a4 4 0 0 1-4 4H.077C1.045 10.787 10.788 1.045 23 .08Z" fill="#1AD3BB"/><path d="M49.921 23H31a4 4 0 0 1-4-4V.077C39.212 1.045 48.955 10.788 49.921 23Z" fill="#985184"/><path d="M49.921 27C48.955 39.212 39.212 48.955 27 49.921V31a4 4 0 0 1 4-4h18.921Z" fill="#2EBCFA"/><path d="M23 49.921C10.786 48.955 1.044 39.212.077 27H19a4 4 0 0 1 4 4v18.921Z" fill="#F9464C"/></svg>

```

  File: static/description/settings.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/description/settings.svg
  Content:
```
<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M25 17V4c.795 0 1.59.204 2.303.61l14.394 8.222A4.548 4.548 0 0 1 44 16.778v16.444c0 .752-.188 1.478-.53 2.121L31.981 28.91A8 8 0 0 0 25 17Z" fill="#FBB945"/><path d="M25 17V4c-.795 0-1.59.204-2.303.61L8.303 12.832A4.548 4.548 0 0 0 6 16.778v16.444c0 .752.187 1.478.53 2.121l11.489-6.434A8 8 0 0 1 25 17Z" fill="#985184"/><path d="M6.53 35.344a4.577 4.577 0 0 0 1.773 1.824l14.393 8.222a4.65 4.65 0 0 0 4.607 0l14.393-8.222a4.577 4.577 0 0 0 1.774-1.824L31.98 28.91A7.998 7.998 0 0 1 25 33.001a7.998 7.998 0 0 1-6.981-4.09l-11.49 6.432Z" fill="#F86126"/></svg>

```

  File: static/img/avatar.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/avatar_grey.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/bg_background_template.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/company_image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/419.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ad.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ae.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/af.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ag.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ai.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/al.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/am.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/an.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ao.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ar.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/as.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/at.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/au.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/aw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ax.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/az.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ba.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bb.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bd.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/be.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bi.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bj.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bo.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/br.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bs.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/by.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/bz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ca.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cd.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ch.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ci.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ck.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/co.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cv.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cx.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cy.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/cz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/de.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/dj.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/dk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/dm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/do.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/dz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ec.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ee.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/eg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/eh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/er.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/es.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/et.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fi.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fj.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fo.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/fr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ga.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gb.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gd.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ge.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gi.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gq.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gs.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/gy.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/hk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/hn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/hr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ht.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/hu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/id.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ie.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/il.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/im.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/in.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/io.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/iq.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ir.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/iran.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/is.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/it.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/je.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/jm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/jo.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/jp.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ke.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ki.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/km.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kp.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ky.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/kz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/la.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lb.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/li.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ls.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/lv.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ly.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ma.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/md.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/me.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ml.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mo.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mp.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mq.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ms.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mv.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mx.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/my.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/mz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/na.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ne.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ng.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ni.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/no.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/np.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/nz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/om.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pa.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pe.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ph.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ps.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/pw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/py.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/qa.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ro.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/rs.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ru.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/rw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sa.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sb.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sd.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/se.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sh.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/si.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/so.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ss.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/st.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sv.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sx.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sy.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/sz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/td.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/th.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tj.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tl.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/to.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tr.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tt.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tv.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/tz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ua.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ug.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/us.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/uy.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/uz.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/va.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/vc.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ve.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/vg.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/vi.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/vn.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/vu.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/wf.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ws.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/xk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/ye.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/za.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/zm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/country_flags/zw.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/account_accountant.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/appointment.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/helpdesk.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/hr_appraisal.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/industry_fsm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/knowledge.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/marketing_automation.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/mrp_plm.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/mrp_workorder.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/payment_sepa_direct_debit.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/planning.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/quality_control.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/sale_amazon.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/sale_ebay.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/sale_subscription.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/sign.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/social.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/stock_barcode.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/timesheet_grid.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/voip.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/web_mobile.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/web_studio.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/website_form_editor.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/website_twitter_wall.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/icons/website_version.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/lang_flags/lang_ar.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/logo_sample.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/logo_white.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/main_partner-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/money.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_accounting-periods.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_bank-account.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_calendar.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_chart-of-accounts.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_cog.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_company-data.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_confetti.svg
  Content:
```
<svg width='600' height='90' viewBox='0 0 600 90' fill='none' xmlns='http://www.w3.org/2000/svg'><rect x='42' y='-10' width='6' height='10'/><rect x='84' y='-10' width='6' height='10'/><rect x='126' y='-13' width='5' height='13'/><rect x='168' y='-13' width='5' height='13'/><rect x='210' y='-10' width='6' height='10'/><rect x='252' y='-13' width='5' height='13'/><rect x='294' y='-10' width='6' height='10'/><rect x='336' y='-13' width='5' height='13'/><rect x='378' y='-13' width='5' height='13'/><rect x='420' y='-10' width='6' height='10'/><rect x='462' y='-10' width='6' height='10'/><rect x='504' y='-13' width='5' height='13'/><rect x='546' y='-10' width='6' height='10'/><style type='text/css'> rect { opacity: 0; } rect:nth-child(1) { transform-origin: 45px 5px; transform: rotate(-145deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 88ms; animation-duration: 631ms; } rect:nth-child(2) { transform-origin: 87px 5px; transform: rotate(164deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 131ms; animation-duration: 442ms; } rect:nth-child(3) { transform-origin: 128px 6px; transform: rotate(4deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 92ms; animation-duration: 662ms; } rect:nth-child(4) { transform-origin: 170px 6px; transform: rotate(-175deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 17ms; animation-duration: 593ms; } rect:nth-child(5) { transform-origin: 213px 5px; transform: rotate(-97deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 122ms; animation-duration: 476ms; } rect:nth-child(6) { transform-origin: 255px 6px; transform: rotate(57deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 271ms; animation-duration: 381ms; } rect:nth-child(7) { transform-origin: 297px 5px; transform: rotate(-46deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 131ms; animation-duration: 619ms; } rect:nth-child(8) { transform-origin: 338px 6px; transform: rotate(-65deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 85ms; animation-duration: 668ms; } rect:nth-child(9) { transform-origin: 380px 6px; transform: rotate(13deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 128ms; animation-duration: 377ms; } rect:nth-child(10) { transform-origin: 423px 5px; transform: rotate(176deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 311ms; animation-duration: 508ms; } rect:nth-child(11) { transform-origin: 465px 5px; transform: rotate(108deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 108ms; animation-duration: 595ms; } rect:nth-child(12) { transform-origin: 506px 6px; transform: rotate(62deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 105ms; animation-duration: 375ms; } rect:nth-child(13) { transform-origin: 549px 5px; transform: rotate(16deg); animation: o_onb_anim 700ms infinite ease-out; animation-delay: 149ms; animation-duration: 491ms; } rect:nth-child(odd) { fill: #65BB5C; } rect:nth-child(even) { z-index: 1; fill: #58cafe; } rect:nth-child(4n) { animation-duration: 1400ms; fill: #ff6e83; } rect:nth-child(3n) { animation-duration: 1750ms; animation-delay: 700ms; } rect:nth-child(4n-7) { fill: #bea4ff; } rect:nth-child(6n) { fill: #feb535; } @keyframes o_onb_anim { from { opacity: 0; } 20% { opacity: 1; } to { transform: translateY(90px); } } </style></svg>

```

  File: static/img/onboarding_default.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_looking_glass.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_puzzle.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_quotation-layout.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_sample-quotation.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/onboarding_taxes.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/partner_demo_portal.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/partner_root-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/public_user-image.png
  Content:
```

```

  File: static/img/res_company_logo.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_1-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_10-image.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_12-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_18-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_2-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_3-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_4-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/res_partner_address_1.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_10.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_11.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_13.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_14.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_15.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_16.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_17.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_18.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_2.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_24.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_25.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_27.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_28.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_3.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_30.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_31.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_32.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_33.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_34.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_4.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_5.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_address_7.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_main1.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/res_partner_main2.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: static/img/truck.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/user-slash.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/img/user_demo-image.png
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
```

  File: static/src/css/description.css
  Content:
```
/**
 *  This CSS is for the html description of modules
 * TODO clean
 */
/* --------------------------------- *
 *          STYLING CONTEXT          *
 * --------------------------------- */
/* --- Styling for the V8/Lato/White/Purple design --- */
.openerp .oe_form_sheet_width {
  max-width: 960px;
}

.o_web_client .o_form_view .oe_styling_v8 .container {
  width: 100%;
}

.openerp .oe_form .oe_styling_v8 {
  width: 100%;
  padding: 0;
  margin: 0;
  font-family: "Open Sans", "Helvetica", Sans;
  font-weight: 300;
  color: #646464;
  background: white;
  font-size: 16px;
}
.openerp .oe_form .oe_styling_v8 .container {
  width: 100%;
}
.openerp .oe_form .oe_styling_v8 .oe_websiteonly {
  display: none;
}
.openerp .oe_form .oe_styling_v8 .oe_website_contents {
  background: whitesmoke;
  padding-bottom: 1px;
}
.openerp .oe_form .oe_styling_v8 b {
  font-weight: 600;
}
.openerp .oe_form .oe_styling_v8 a {
  color: #6D57E0;
  text-decoration: none;
}
.openerp .oe_form .oe_styling_v8 a:visited {
  color: #5b284f;
}
.openerp .oe_form .oe_styling_v8 a:hover {
  color: #0096EB;
}
.openerp .oe_form .oe_styling_v8 .oe_title_font {
  font-family: "Lato", "Open Sans", "Helvetica", Sans;
}
.openerp .oe_form .oe_styling_v8 .oe_page {
  background: white;
  overflow: hidden;
  -moz-border-radius: 1px;
  -webkit-border-radius: 1px;
  border-radius: 1px;
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
}
.openerp .oe_form .oe_styling_v8 .oe_emph {
  font-weight: 400;
}
.openerp .oe_form .oe_styling_v8 .oe_dark {
  overflow: hidden;
  background: #FCFCFC;
  -moz-box-shadow: 0px 5px 9px -7px rgba(0, 0, 255, 0.5) inset, 0px -3px 9px -7px rgba(0, 0, 255, 0.5) inset;
  -webkit-box-shadow: 0px 5px 9px -7px rgba(0, 0, 255, 0.5) inset, 0px -3px 9px -7px rgba(0, 0, 255, 0.5) inset;
  box-shadow: 0px 5px 9px -7px rgba(0, 0, 255, 0.5) inset, 0px -3px 9px -7px rgba(0, 0, 255, 0.5) inset;
}

/* --------------------------------- *
 *               LAYOUT              *
 * --------------------------------- */
/* ------ BASE GRID CONSTRUCTS ----- */
.oe_page {
  margin: 0px auto 64px auto;
  max-width: 100%;
}

.oe_row {
  width: 100%;
  margin-top: 16px;
  margin-bottom: 16px;
  margin-left: auto;
  margin-right: auto;
}

.oe_row.oe_fit {
  width: auto;
}

.oe_clearfix:after, .oe_row:after {
  content: ".";
  display: block;
  clear: both;
  visibility: hidden;
  line-height: 0;
  height: 0;
}

[class*='oe_span'] {
  float: left;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  padding: 0 16px;
}

.oe_span12 {
  width: 100%;
}

.oe_span10 {
  width: 83.33333%;
}

.oe_span9 {
  width: 75%;
}

.oe_span8 {
  width: 66.66667%;
}

.oe_span6 {
  width: 50%;
}

.oe_span4 {
  width: 33.33333%;
}

.oe_span3 {
  width: 25%;
}

.oe_span2 {
  width: 16.66667%;
}

[class*='oe_span'].oe_fit {
  padding-left: 0px !important;
  padding-right: 0px !important;
}

.oe_row.oe_flex [class*='oe_span'] {
  display: inline-block;
  float: none;
  vertical-align: top;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  padding: 0 16px;
  width: auto;
}
.oe_row.oe_flex .oe_span12 {
  max-width: 100%;
}
.oe_row.oe_flex .oe_span10 {
  max-width: 83.33333%;
}
.oe_row.oe_flex .oe_span9 {
  max-width: 75%;
}
.oe_row.oe_flex .oe_span8 {
  max-width: 66.66667%;
}
.oe_row.oe_flex .oe_span6 {
  max-width: 50%;
}
.oe_row.oe_flex .oe_span4 {
  max-width: 33.33333%;
}
.oe_row.oe_flex .oe_span3 {
  max-width: 25%;
}
.oe_row.oe_flex .oe_span2 {
  max-width: 16.66667%;
}

.oe_mb0 {
  margin-bottom: 0px !important;
}

.oe_mb4 {
  margin-bottom: 4px !important;
}

.oe_mb8 {
  margin-bottom: 8px !important;
}

.oe_mb16 {
  margin-bottom: 16px !important;
}

.oe_mb32 {
  margin-bottom: 32px !important;
}

.oe_mb48 {
  margin-bottom: 48px !important;
}

.oe_mb64 {
  margin-bottom: 64px !important;
}

.oe_mt0 {
  margin-top: 0px !important;
}

.oe_mt4 {
  margin-top: 4px !important;
}

.oe_mt8 {
  margin-top: 8px !important;
}

.oe_mt16 {
  margin-top: 16px !important;
}

.oe_mt32 {
  margin-top: 32px !important;
}

.oe_mt48 {
  margin-top: 48px !important;
}

.oe_mt64 {
  margin-top: 64px !important;
}

/* ------ GENERIC LAYOUT MODIFIERS ----- */
.oe_rightfit {
  padding-right: 0px !important;
}

.oe_leftfit {
  padding-left: 0px !important;
}

.oe_leftalign {
  text-align: left;
}

.oe_rightalign {
  text-align: right;
}

.oe_centeralign {
  text-align: center;
}

.oe_centered {
  margin-left: auto;
  margin-right: auto;
}

.oe_hidden {
  display: none !important;
  opacity: 0 !important;
}

.oe_invisible {
  visibility: hidden !important;
}

.oe_transparent {
  opacity: 0 !important;
}

.oe_mb0 {
  margin-bottom: 0px !important;
}

.oe_mb4 {
  margin-bottom: 4px !important;
}

.oe_mb8 {
  margin-bottom: 8px !important;
}

.oe_mb16 {
  margin-bottom: 16px !important;
}

.oe_mb32 {
  margin-bottom: 32px !important;
}

.oe_mb64 {
  margin-bottom: 64px !important;
}

.oe_spaced {
  margin-top: 32px;
  margin-bottom: 32px;
}

.oe_more_spaced {
  margin-top: 64px;
  margin-bottom: 64px;
}

.oe_padded {
  padding-top: 16px;
  padding-bottom: 16px;
}

.oe_more_padded {
  padding-top: 32px;
  padding-bottom: 32px;
}

/* --------------------------------- *
 *        WEBPAGE COMPONENTS         *
 * --------------------------------- */
/* ------ BUTTONS ----- */
.oe_button {
  position: relative;
  bottom: 0;
  display: inline-block;
  cursor: pointer;
  -moz-user-select: -moz-none;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}

.oe_styling_v8 .oe_button, .oe_styling_v8 a.oe_button {
  padding: 8px 14px;
  background: #8b72b6;
  color: white;
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  border-radius: 2px;
  -moz-box-shadow: 0px 2px 0px #afa8cc;
  -webkit-box-shadow: 0px 2px 0px #afa8cc;
  box-shadow: 0px 2px 0px #afa8cc;
  text-shadow: 0px 1px 1px rgba(0, 0, 0, 0.44);
  border: solid 1px rgba(0, 0, 0, 0.09);
  -moz-transition-property: bottom, background;
  -o-transition-property: bottom, background;
  -webkit-transition-property: bottom, background;
  transition-property: bottom, background;
  -moz-transition-duration: 250ms;
  -o-transition-duration: 250ms;
  -webkit-transition-duration: 250ms;
  transition-duration: 250ms;
}
.oe_styling_v8 .oe_button:hover, .oe_styling_v8 a.oe_button:hover {
  background: #8b5bdd;
  color: white;
}
.oe_styling_v8 .oe_button:active, .oe_styling_v8 a.oe_button:active {
  background: #333333;
  bottom: -3px;
}
.oe_styling_v8 .oe_button.oe_big, .oe_styling_v8 a.oe_button.oe_big {
  font-size: 24px;
}
.oe_styling_v8 .oe_button.oe_bigger, .oe_styling_v8 a.oe_button.oe_bigger {
  font-size: 32px;
}
.oe_styling_v8 .oe_button.oe_small, .oe_styling_v8 a.oe_button.oe_small {
  font-size: 13px;
  padding: 2px 4px;
}
.oe_styling_v8 .oe_button.oe_small:active, .oe_styling_v8 a.oe_button.oe_small:active {
  bottom: -1px;
}
.oe_styling_v8 .oe_button.oe_medium, .oe_styling_v8 a.oe_button.oe_medium {
  padding: 5px 12px;
  font-size: 16px;
}
.oe_styling_v8 .oe_button.oe_tacky, .oe_styling_v8 a.oe_button.oe_tacky {
  background: #ff4444;
  -moz-box-shadow: 0px 2px 0px #eba8a8;
  -webkit-box-shadow: 0px 2px 0px #eba8a8;
  box-shadow: 0px 2px 0px #eba8a8;
}
.oe_styling_v8 .oe_button.oe_tacky:hover, .oe_styling_v8 a.oe_button.oe_tacky:hover {
  background: #ff1010;
}
.oe_styling_v8 .oe_button.oe_tacky:active, .oe_styling_v8 a.oe_button.oe_tacky:active {
  background: black;
}
.oe_styling_v8 .oe_button.oe_disabled, .oe_styling_v8 a.oe_button.oe_disabled {
  background: #c8c8c8;
  -moz-box-shadow: 0px 2px 0px #b4b4b4;
  -webkit-box-shadow: 0px 2px 0px #b4b4b4;
  box-shadow: 0px 2px 0px #b4b4b4;
  cursor: default;
}
.oe_styling_v8 .oe_button.oe_disabled:hover, .oe_styling_v8 a.oe_button.oe_disabled:hover {
  background: #c8c8c8;
  -moz-box-shadow: 0px 2px 0px #b4b4b4;
  -webkit-box-shadow: 0px 2px 0px #b4b4b4;
  box-shadow: 0px 2px 0px #b4b4b4;
}
.oe_styling_v8 .oe_button.oe_disabled:active, .oe_styling_v8 a.oe_button.oe_disabled:active {
  background: #c8c8c8;
  bottom: 0px;
  -moz-box-shadow: 0px 2px 0px #b4b4b4;
  -webkit-box-shadow: 0px 2px 0px #b4b4b4;
  box-shadow: 0px 2px 0px #b4b4b4;
}

.oe_styling_v8.oe_styling_black .oe_button {
  -moz-box-shadow: 0px 2px 0px #463555;
  -webkit-box-shadow: 0px 2px 0px #463555;
  box-shadow: 0px 2px 0px #463555;
}

/* ------ FORMS ----- */
.oe_styling_v8 {
  /* FIXME: this is a quick hack for the release */
}
.oe_styling_v8 .oe_input {
  padding: 4px 7px;
  border-radius: 3px;
  border: solid 1px #d6d6d6;
  box-shadow: 0px 2px #e6e6e6;
  background: #fafafa;
  font-weight: 300;
  outline: none;
  -moz-transition: all 150ms linear;
  -o-transition: all 150ms linear;
  -webkit-transition: all 150ms linear;
  transition: all 150ms linear;
}
.oe_styling_v8 .oe_input:focus {
  border: solid 1px #969696;
  box-shadow: 0px 2px #d2d2d2;
}
.oe_styling_v8 .oe_input.oe_valid {
  background: #F2FFEC;
  border-color: #b1ebb6;
  box-shadow: 0px 2px #e1f8e1;
  color: #0f610f;
}
.oe_styling_v8 .oe_input.oe_invalid {
  background: #fff2f2;
  border-color: #EBB1B1;
  box-shadow: 0px 2px #F8E1E1;
  color: #610F0F;
}
.oe_styling_v8 .oe_input.oe_big {
  padding: 8px 14px;
}
.oe_styling_v8 .oe_input_label {
  font-weight: 300;
  font-size: 16px;
}
.oe_styling_v8 .oe_input_label.oe_big {
  font-size: 20px;
}
.oe_styling_v8 .oe_textarea {
  width: 300px;
  height: 80px;
}
.oe_styling_v8 .oe_form_layout_table {
  width: 100%;
}
.oe_styling_v8 .oe_form_layout_table td {
  padding-bottom: 16px;
}
.oe_styling_v8 .oe_form_layout_table td:first-child {
  text-align: right;
  padding-right: 16px;
}

/* ------ SLOGANS ----- */
.oe_styling_v8 .oe_slogan {
  color: #333333;
  font-family: "Lato", "Open Sans", "Helvetica", Sans;
  text-align: center;
  margin-top: 32px;
  margin-bottom: 32px;
}
.oe_styling_v8 h1.oe_slogan {
  font-size: 64px;
  font-weight: 900;
  margin-top: 48px;
  margin-bottom: 48px;
}
.oe_styling_v8 h2.oe_slogan {
  font-size: 40px;
  font-weight: 300;
}
.oe_styling_v8 h3.oe_slogan {
  font-size: 26px;
  font-weight: 300;
  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50);
  opacity: 0.5;
}
.oe_styling_v8 h4.oe_slogan {
  font-size: 24px;
  font-weight: 300;
}
.oe_styling_v8 h4.oe_slogan:before, .oe_styling_v8 h4.oe_slogan:after {
  margin: 0 20px;
  content: "";
  display: inline-block;
  width: 100px;
  height: 0px;
  border-top: solid 1px;
  vertical-align: middle;
  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=30);
  opacity: 0.3;
}
.oe_styling_v8 h5.oe_slogan {
  font-weight: 300;
}

/* ------ QUOTES ----- */
.oe_quote {
  margin: 8px;
  padding: 16px;
  background: rgba(0, 0, 0, 0.02);
  border: solid 1px rgba(0, 0, 0, 0.06);
  -moz-border-radius: 2px;
  -webkit-border-radius: 2px;
  border-radius: 2px;
}
.oe_quote .oe_q, .oe_quote q {
  margin: 10px;
  display: block;
  font-style: italic;
  text-align: center;
  font-size: 20px;
  color: #4e66e7;
}
.oe_quote .oe_q:before, .oe_quote .oe_q:after, .oe_quote q:before, .oe_quote q:after {
  content: '"';
  font-weight: 900;
  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=20);
  opacity: 0.2;
}
.oe_quote cite {
  display: block;
  font-style: normal;
  margin-top: 16px;
}
.oe_quote .oe_photo {
  float: left;
  -moz-border-radius: 3px;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  margin-right: 16px;
}
.oe_quote .oe_author {
  font-size: 20px;
  padding-top: 6px;
  color: #8d7bac;
}

.oe_dark .oe_quote {
  background: white;
  border: 1px solid #f0f0ff;
}

/* ------ PICTURES ----- */
.oe_picture {
  display: block;
  max-width: 84%;
  max-height: 400px;
  margin: 16px 8%;
}

.oe_screenshot {
  -moz-border-radius: 3px;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -moz-box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.2);
  box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.2);
}

.oe_pic_ctr {
  position: relative;
}

.oe_pic_ctr > img.oe_picture {
  width: 100%;
  max-width: none;
  max-height: none;
  margin: 0;
}

.oe_pic_ctr > .oe_title {
  position: absolute;
  top: 15px;
  right: 38px;
}

.oe_styling_v8 .oe_pic_ctr > .oe_title {
  font-size: 64px;
  color: white;
  font-weight: 600;
  margin: 0;
  text-shadow: 0px 2px 0px #494949, 0px 2px 5px rgba(0, 0, 0, 0.33), 0px 0px 60px rgba(0, 0, 0, 0.22);
}

/*  ----- Link Image with Footer ----- */
/* FIXME: Terrible CSS, rewrite this */
div.oe_demo {
  position: relative;
  border: 1px solid #dedede;
}
div.oe_demo span.oe_demo_play {
  top: 50%;
  left: 50%;
  width: 80px;
  height: 60px;
  margin-top: -30px;
  margin-left: -40px;
  display: block;
  position: absolute;
  background: url("../img/layout/play-button.png") no-repeat left top transparent;
  pointer-events: none;
}
div.oe_demo img {
  max-width: 100%;
  width: 100%;
}
div.oe_demo div.oe_demo_footer {
  position: absolute;
  left: 0;
  background-color: rgba(0, 0, 0, 0.4);
  opacity: 0.85;
  bottom: -1px;
  width: 100%;
  padding-top: 7px;
  padding-bottom: 7px;
  color: white;
  font-size: 14px;
  font-weight: bold;
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  pointer-events: none;
}

div.oe_demo:hover span.oe_demo_play {
  background: url("../img/layout/play-button-over.png") no-repeat left top transparent;
}

/*  ----- SEPARATOR ----- */
.oe_styling_v8 .oe_container.oe_separator {
  height: 64px;
  margin-bottom: 16px;
  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeDE9IjAuNSIgeTE9IjAuMCIgeDI9IjAuNSIgeTI9IjEuMCI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgc3RvcC1vcGFjaXR5PSIwLjAiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAwMDAiIHN0b3Atb3BhY2l0eT0iMC4wMiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JhZCkiIC8+PC9zdmc+IA==');
  background: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, rgba(0, 0, 0, 0)), color-stop(100%, rgba(0, 0, 0, 0.02)));
  background: -moz-linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.02));
  background: -webkit-linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.02));
  background: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.02));
  -moz-box-shadow: 0px -3px 10px -5px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px -3px 10px -5px rgba(0, 0, 0, 0.1) inset;
  box-shadow: 0px -3px 10px -5px rgba(0, 0, 0, 0.1) inset;
  overflow-y: hidden;
}

/*  ----- TABS -----  */
.oe_row_tabs {
  text-align: center;
  margin-top: 0px;
  margin-bottom: 0px;
  padding-top: 21px;
}

.oe_row_tab {
  position: relative;
  min-width: 120px;
  padding: 8px;
  font-size: 20px;
  display: inline-block;
  margin: 0px -2px;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border: solid 1px rgba(0, 0, 0, 0.1);
  border-bottom: none;
  background: #fafafa;
  background-image: +linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.02));
  box-shadow: 0px -3px 10px -5px rgba(0, 0, 0, 0.1) inset;
  cursor: pointer;
  -moz-transition: all 250ms linear;
  -o-transition: all 250ms linear;
  -webkit-transition: all 250ms linear;
  transition: all 250ms linear;
}

.oe_row_tab:hover {
  padding-bottom: 12px;
  top: -4px;
  background-color: white;
}

.oe_row_tab.oe_active {
  background-color: white;
  background-image: none;
  box-shadow: none;
  border-top-color: #8272b6;
  border-top-width: 2px;
  cursor: default;
}

.oe_row_tab.oe_active:hover {
  padding-bottom: 8px;
  top: 0asx;
}

/* ------ CALL TO ACTION ----- */
.oe_calltoaction {
  height: 32px;
  margin-top: -32px;
  position: relative;
}

```

  File: static/src/css/description.sass
  Content:
```
@charset "utf-8" 
@import "compass/css3"
@import "compass/css3/user-interface"

/**
 *  This CSS is for the html description of modules
 * TODO clean
 */

/* --------------------------------- * 
 *          STYLING CONTEXT          *
 * --------------------------------- */

/* --- Styling for the V8/Lato/White/Purple design --- */

$v8_title_font_color: rgb(51,51,51)
$v8_text_font_color:  rgb(100,100,100)
$v8_font_paragraph_color:   rgb(51,51,51)
$v8_body_color:   rgb(245,245,245)
$v8_bg_color:     rgb(255,255,255)
$v8_text_font_family:  'Open Sans','Helvetica',Sans
$v8_title_font_family:  'Lato','Open Sans','Helvetica',Sans
$v8_anchor_color: #6D57E0
$v8_anchor_visited_color: rgb(91, 40, 79)


.openerp .oe_form_sheet_width
  max-width: 960px

.o_web_client .o_form_view .oe_styling_v8 .container
  width: 100%

.openerp .oe_form .oe_styling_v8
  width: 100%
  padding: 0
  margin: 0
  font-family: $v8_text_font_family
  font-weight: 300
  color: $v8_text_font_color
  background: $v8_bg_color
  font-size: 16px

  .container
    width: 100%

  .oe_websiteonly
    display: none

  .oe_website_contents
    background: $v8_body_color
    padding-bottom: 1px

  b
    font-weight: 600
  a
    color: $v8_anchor_color
    text-decoration: none
  a:visited
    color: $v8_anchor_visited_color
  a:hover
    color: #0096EB

  .oe_title_font
    font-family: $v8_title_font_family


  .oe_page
    background: $v8_bg_color
    overflow: hidden
    +border-radius(1px)
    +box-shadow(0 1px 3px rgba(0,0,0,0.35))

  .oe_emph
    font-weight: 400

  .oe_dark
    overflow: hidden
    background: #FCFCFC
    +box-shadow(0px 5px 9px -7px rgba(0,0,255,0.5) inset, 0px -3px 9px -7px rgba(0,0,255,0.5) inset)

/* --------------------------------- * 
 *               LAYOUT              *
 * --------------------------------- */

/* ------ BASE GRID CONSTRUCTS ----- */

.oe_page
  margin: 0px auto 64px auto
  max-width: 100%


.oe_row
  width: 100%
  margin-top: 16px
  margin-bottom: 16px
  margin-left: auto
  margin-right: auto

.oe_row.oe_fit
  width: auto

.oe_clearfix:after, .oe_row:after
  content: "."
  display: block
  clear: both
  visibility: hidden
  line-height: 0
  height: 0

$oe_span12_width: 100%
$oe_span10_width: 83.33333333%
$oe_span9_width:  75%
$oe_span8_width:  66.66666667%
$oe_span6_width:  50%
$oe_span4_width:  33.33333333%
$oe_span3_width:  25%
$oe_span2_width:  16.66666667%

[class*='oe_span']
  float: left
  +box-sizing(border-box)
  padding: 0 16px
.oe_span12
  width: $oe_span12_width
.oe_span10
  width: $oe_span10_width
.oe_span9
  width: $oe_span9_width
.oe_span8
  width: $oe_span8_width
.oe_span6
  width: $oe_span6_width
.oe_span4
  width: $oe_span4_width
.oe_span3
  width: $oe_span3_width
.oe_span2
  width: $oe_span2_width

[class*='oe_span'].oe_fit
  padding-left: 0px !important
  padding-right: 0px !important

.oe_row.oe_flex
  [class*='oe_span']
    display: inline-block
    float: none
    vertical-align: top
    +box-sizing(border-box)
    padding: 0 16px
    width: auto
  .oe_span12
    max-width: $oe_span12_width
  .oe_span10
    max-width: $oe_span10_width
  .oe_span9
    max-width: $oe_span9_width
  .oe_span8
    max-width: $oe_span8_width
  .oe_span6
    max-width: $oe_span6_width
  .oe_span4
    max-width: $oe_span4_width
  .oe_span3
    max-width: $oe_span3_width
  .oe_span2
    max-width: $oe_span2_width

.oe_mb0
  margin-bottom: 0px !important
.oe_mb4
  margin-bottom: 4px !important
.oe_mb8
  margin-bottom: 8px !important
.oe_mb16
  margin-bottom: 16px !important
.oe_mb32
  margin-bottom: 32px !important
.oe_mb48
  margin-bottom: 48px !important
.oe_mb64
  margin-bottom: 64px !important

.oe_mt0
  margin-top: 0px !important
.oe_mt4
  margin-top: 4px !important
.oe_mt8
  margin-top: 8px !important
.oe_mt16
  margin-top: 16px !important
.oe_mt32
  margin-top: 32px !important
.oe_mt48
  margin-top: 48px !important
.oe_mt64
  margin-top: 64px !important

/* ------ GENERIC LAYOUT MODIFIERS ----- */

.oe_rightfit
  padding-right: 0px !important
.oe_leftfit
  padding-left: 0px !important
.oe_leftalign 
  text-align: left
.oe_rightalign
  text-align: right
.oe_centeralign
  text-align: center
.oe_centered
  margin-left: auto
  margin-right: auto
.oe_hidden
  display: none !important
  opacity: 0 !important
.oe_invisible
  visibility: hidden !important
.oe_transparent
  opacity: 0 !important

.oe_mb0
  margin-bottom: 0px !important
.oe_mb4
  margin-bottom: 4px !important
.oe_mb8
  margin-bottom: 8px !important
.oe_mb16
  margin-bottom: 16px !important
.oe_mb32
  margin-bottom: 32px !important
.oe_mb64
  margin-bottom: 64px !important

.oe_spaced
  margin-top: 32px 
  margin-bottom: 32px 
.oe_more_spaced
  margin-top: 64px 
  margin-bottom: 64px
.oe_padded
  padding-top: 16px 
  padding-bottom: 16px
.oe_more_padded
  padding-top: 32px
  padding-bottom: 32px

/* --------------------------------- * 
 *        WEBPAGE COMPONENTS         *
 * --------------------------------- */

/* ------ BUTTONS ----- */

.oe_button
  position: relative
  bottom: 0
  display: inline-block
  cursor: pointer
  +user-select(none)

.oe_styling_v8 .oe_button, .oe_styling_v8 a.oe_button
  padding: 8px 14px
  background: rgb(139, 114, 182)
  color: white
  +border-radius(2px)
  +box-shadow(0px 2px 0px rgb(175, 168, 204))
  +text-shadow(0px 1px 1px rgba(0,0,0, 0.44))
  border: solid 1px rgba(0,0,0,0.09)
  +transition-property((bottom, background))
  +transition-duration(250ms)
  &:hover
    background: rgb(139,91,221)
    color: white
  &:active
    background: rgb(51,51,51)
    bottom: -3px
  &.oe_big
    font-size: 24px
  &.oe_bigger
    font-size: 32px
  &.oe_small
    font-size: 13px
    padding: 2px 4px
    &:active
      bottom: -1px
  &.oe_medium
    padding: 5px 12px
    font-size: 16px
  &.oe_tacky
    background: rgb(255,68,68)
    +box-shadow(0px 2px 0px #eba8a8)
    &:hover
      background: rgb(255,16,16)
    &:active
      background: black
  &.oe_disabled
    background: rgb(200,200,200)
    +box-shadow(0px 2px 0px rgb(180,180,180))
    cursor: default
    &:hover
      background: rgb(200,200,200)
      +box-shadow(0px 2px 0px rgb(180,180,180))
    &:active
      background: rgb(200,200,200)
      bottom: 0px
      +box-shadow(0px 2px 0px rgb(180,180,180))

.oe_styling_v8.oe_styling_black .oe_button
  +box-shadow(0px 2px 0px rgb(70,53,85))

/* ------ FORMS ----- */

.oe_styling_v8
  .oe_input
    padding: 4px 7px
    border-radius: 3px
    border: solid 1px rgb(214,214,214)
    box-shadow: 0px 2px rgb(230,230,230)
    background: rgb(250,250,250)
    font-weight: 300
    outline: none
    @include transition( all 150ms linear )
    &:focus
      border: solid 1px rgb(150,150,150)
      box-shadow: 0px 2px rgb(210,210,210)

    &.oe_valid
      background: #F2FFEC
      border-color: rgb(177,235,182)
      box-shadow: 0px 2px rgb(225,248,225)
      color: rgb(15,97,15)

    &.oe_invalid
      background: rgb(255,242,242)
      border-color: #EBB1B1
      box-shadow: 0px 2px #F8E1E1
      color: #610F0F
    &.oe_big
      padding: 8px 14px
  .oe_input_label
    font-weight: 300
    font-size: 16px
    &.oe_big
      font-size: 20px

  /* FIXME: this is a quick hack for the release */ 

  .oe_textarea
    width: 300px
    height: 80px
  .oe_form_layout_table
    width: 100%
    td
      padding-bottom: 16px
      &:first-child
        text-align: right
        padding-right: 16px

/* ------ SLOGANS ----- */

.oe_styling_v8 
  .oe_slogan
    color: $v8_title_font_color
    font-family: $v8_title_font_family
    text-align: center
    margin-top: 32px
    margin-bottom: 32px

  h1.oe_slogan
    font-size: 64px
    font-weight: 900
    margin-top: 48px
    margin-bottom: 48px

  h2.oe_slogan
    font-size: 40px
    font-weight: 300

  h3.oe_slogan
    font-size: 26px
    font-weight: 300
    +opacity(0.5)

  h4.oe_slogan
    font-size: 24px
    font-weight: 300
  h4.oe_slogan:before, h4.oe_slogan:after
    margin: 0 20px
    content: ""
    display: inline-block
    width: 100px
    height: 0px
    border-top: solid 1px
    vertical-align: middle
    +opacity(0.3)

  h5.oe_slogan
    font-weight: 300
    //TODO

/* ------ QUOTES ----- */

.oe_quote
  margin: 8px
  padding: 16px
  background: rgba(0,0,0,0.02)
  border: solid 1px rgba(0,0,0,0.06)
  +border-radius(2px)

  .oe_q,q
    margin: 10px
    display: block
    font-style: italic
    text-align: center
    font-size: 20px
    color: rgb(78, 102, 231)
    &:before, &:after
      content: '\"'
      font-weight: 900
      +opacity(0.2)

  cite
    display: block
    font-style: normal
    margin-top: 16px
  
  .oe_photo
    float: left
    +border-radius(3px)
    margin-right: 16px

  .oe_author
    font-size: 20px
    padding-top: 6px
    color: rgb(141, 123, 172)

.oe_dark .oe_quote
  background: white
  border: 1px solid rgb(240,240,255)

/* ------ PICTURES ----- */

// display a picture in a span
.oe_picture
  display: block
  max-width: 84%
  max-height: 400px
  margin: 16px 8%

// style the picture like a screenshot
.oe_screenshot
  +border-radius(3px)
  +box-shadow(0px 3px 8px rgba(0,0,0,0.2))

// display a picture taking full width of a row
.oe_pic_ctr
  position: relative

.oe_pic_ctr > img.oe_picture
  width: 100%
  max-width: none
  max-height: none
  margin: 0

// styling of the picture's title
.oe_pic_ctr > .oe_title
  position: absolute
  top: 15px
  right: 38px

.oe_styling_v8 .oe_pic_ctr > .oe_title
  font-size: 64px
  color: white
  font-weight: 600
  margin: 0
  +text-shadow( 0px 2px 0px rgb(73, 73, 73), 0px 2px 5px rgba(0, 0, 0, 0.33), 0px 0px 60px rgba(0, 0, 0, 0.22))

/*  ----- Link Image with Footer ----- */
/* FIXME: Terrible CSS, rewrite this */

div.oe_demo
  position: relative
  border: 1px solid #dedede
  span.oe_demo_play
    top: 50%
    left: 50%
    width: 80px
    height: 60px
    margin-top: -30px
    margin-left: -40px
    display: block
    position: absolute
    background: url("../img/layout/play-button.png") no-repeat left top transparent
    pointer-events: none
  img
    max-width: 100%
    width: 100%
  div.oe_demo_footer
    position: absolute
    left: 0
    background-color: rgba(0,0,0,0.4)
    opacity: 0.85
    bottom: -1px
    width: 100%
    padding-top: 7px
    padding-bottom: 7px
    color: white
    font-size: 14px
    font-weight: bold
    border-bottom-left-radius: 3px
    border-bottom-right-radius: 3px
    pointer-events: none

div.oe_demo:hover
  span.oe_demo_play
    background: url("../img/layout/play-button-over.png") no-repeat left top transparent

/*  ----- SEPARATOR ----- */

.oe_styling_v8 .oe_container.oe_separator
  height: 64px
  margin-bottom: 16px
  @include background(linear-gradient(rgba(0,0,0,0),rgba(0,0,0,0.02)))
  +box-shadow(0px -3px 10px -5px rgba(0,0,0,0.1) inset)
  overflow-y: hidden

/*  ----- TABS -----  */

.oe_row_tabs
  text-align: center
  margin-top: 0px
  margin-bottom: 0px
  padding-top: 21px

.oe_row_tab
  position: relative
  min-width: 120px
  padding: 8px
  font-size: 20px
  display: inline-block
  margin: 0px -2px
  border-top-left-radius: 4px
  border-top-right-radius: 4px
  border: solid 1px rgba(0,0,0,0.1)
  border-bottom: none
  background: rgb(250,250,250)
  background-image: +linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.02))
  box-shadow: 0px -3px 10px -5px rgba(0,0,0,0.1) inset
  cursor: pointer
  @include transition(all 250ms linear)

.oe_row_tab:hover
  padding-bottom: 12px
  top: -4px
  background-color: white

.oe_row_tab.oe_active
  background-color: white
  background-image: none
  box-shadow: none
  border-top-color: rgb(130, 114, 182)
  border-top-width: 2px
  cursor: default

.oe_row_tab.oe_active:hover
  padding-bottom: 8px
  top: 0asx

/* ------ CALL TO ACTION ----- */

.oe_calltoaction
  height: 32px
  margin-top: -32px
  position: relative


```

  File: static/src/css/modules.css
  Content:
```

.oe_module_icon {
    width: 50px;
    max-height: 50px;
    max-width: 23%;
    float: left;
}

.oe_module_flag {
    position: absolute;
    left: 12px;
    top: calc(50% - 35px);
    font: 27px icon;
    text-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);
}

.oe_module_desc {
    font-size: 13px;
    padding-left: 10px;
    width: 77%;
}

.o_kanban_view.o_modules_kanban .o_kanban_renderer .oe_module_vignette,
.o_modules_field .o_modules_kanban .oe_module_vignette {
    align-items: center;
    display: flex;
}

.o_kanban_view.o_modules_kanban .o_kanban_renderer .o_kanban_record .o_dropdown_kanban,
.o_modules_field .o_modules_kanban .o_kanban_renderer .o_kanban_record .o_dropdown_kanban {
    visibility: visible;
    opacity: 0.5;
}

.o_kanban_view.o_modules_kanban .o_kanban_renderer .o_kanban_record:hover .o_dropdown_kanban,
.o_kanban_view.o_modules_kanban .o_kanban_renderer .o_kanban_record .o_dropdown_kanban.show {
    opacity: 1;
}

.o_modules_field .o_modules_kanban .o_kanban_renderer {
    --KanbanRecord-width: 280px;
    --KanbanRecord-width-small: 280px;
}

.oe_module_name > span  {
    color: #999999;
    min-height: 26px;
    line-height: 1.1;
    display: block;
}

.oe_module_desc p {
    margin: 3px 0 3px;
}

.oe_module_desc > h4 {
    margin-right: 20px;

    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: top;
}

.oe_module_desc {
    min-width: 0;
}

.o_module_form.o_form_view .oe_avatar > img {
    border: none;
    box-shadow: none;
    max-width: 70px;
    max-height: 70px;
}

```

  File: static/src/scss/res_partner.scss
  Content:
```
.o_kanban_view .o_res_partner_kanban {
    .oe_kanban_action_a:hover > .badge {
        background-color: $o-brand-primary;
        color: white;
    }

}

.o_partner_merge_wizard {
    .o_form_sheet {
        padding: 12px !important;
    }
    .row {
        --gutter-x: 0;
    }
}

// This is an ugly workaround to prevent having ugly borders in the Password confirmation dialog
// TODO: remove me in master
.modal .o_form_view .o_form_sheet_bg.bg-primary {
    --background-color: #{$o-view-background-color};
}

```

  File: static/tests/test_ir_model_fields_translation.js
  Content:
```
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { stepUtils } from "@web_tour/tour_service/tour_utils";
function checkLoginColumn(translation) {
    return [
        stepUtils.showAppsMenuItem(), {
            content: "Settings",
            trigger: 'a[data-menu-xmlid="base.menu_administration"]',
            run: 'click',
        }, {
            content: "Open Users & Companies",
            trigger: '[data-menu-xmlid="base.menu_users"]',
            run: "click",
        }, {
            content: "Open Users",
            trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
            run: "click",
        }, {
            content: `Login column should be ${translation}`,
            trigger: `[data-name="login"] span:contains("${translation}")`,
            isCheck: true,
        }
    ]
}

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour', {
    test: true,
    url: '/web',
    steps: () => checkLoginColumn('Login')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour2', {
    test: true,
    url: '/web',
    steps: () => checkLoginColumn('Login2')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour', {
    test: true,
    url: '/web',
    steps: () => checkLoginColumn('Identifiant')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour2', {
    test: true,
    url: '/web',
    steps: () => checkLoginColumn('Identifiant2')
});

```

Tests:
  File: tests/__init__.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import common
from . import test_acl
from . import test_api
from . import test_barcode
from . import test_base
from . import test_basecase
from . import test_cache
from . import test_date_utils
from . import test_deprecation
from . import test_db_cursor
from . import test_display_name
from . import test_expression
from . import test_float
from . import test_format_address_mixin
from . import test_func
from . import test_http_case
from . import test_image
from . import test_avatar_mixin
from . import test_ir_actions
from . import test_ir_attachment
from . import test_ir_cron
from . import test_ir_filters
from . import test_ir_http
from . import test_ir_mail_server
from . import test_ir_mail_server_smtpd
from . import test_ir_model
from . import test_ir_module
from . import test_ir_sequence
from . import test_ir_sequence_date_range
from . import test_ir_default
from . import test_mail
from . import test_menu
from . import test_mimetypes
from . import test_misc
from . import test_module
from . import test_orm
from . import test_ormcache
from . import test_osv
from . import test_overrides
from . import test_qweb_field
from . import test_qweb
from . import test_res_config
from . import test_res_lang
from . import test_search
from . import test_split_table
from . import test_sql
from . import test_translate
from . import test_tz
# from . import test_uninstall  # loop
from . import test_user_has_group
from . import test_views
from . import test_xmlrpc
from . import test_res_company
from . import test_res_currency
from . import test_res_country
from . import test_res_partner
from . import test_res_partner_bank
from . import test_res_users
from . import test_reports
from . import test_test_retry
from . import test_test_suite
from . import test_tests_tags
from . import test_transactions
from . import test_form_create
from . import test_cloc
from . import test_profiler
from . import test_pdf
from . import test_neutralize
from . import test_config_parameter
from . import test_ir_module_category
from . import test_num2words_ar

```

  File: tests/common.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import threading

from contextlib import contextmanager
from unittest.mock import patch, Mock

from odoo.tests.common import TransactionCase, HttpCase
from odoo import Command

DISABLED_MAIL_CONTEXT = {
    'tracking_disable': True,
    'mail_create_nolog': True,
    'mail_create_nosubscribe': True,
    'mail_notrack': True,
    'no_reset_password': True,
}


class BaseCommon(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        # Mail logic won't be tested by default in other modules.
        # Mail API overrides should be tested with dedicated tests on purpose
        # Hack to use with_context and avoid manual context dict modification
        cls.env = cls.env['base'].with_context(**DISABLED_MAIL_CONTEXT).env

        cls.partner = cls.env['res.partner'].create({
            'name': 'Test Partner',
        })
        cls.currency = cls.env.company.currency_id

    @classmethod
    def _enable_currency(cls, currency_code):
        currency = cls.env['res.currency'].with_context(active_test=False).search(
            [('name', '=', currency_code.upper())]
        )
        currency.action_unarchive()
        return currency

    @classmethod
    def _use_currency(cls, currency_code):
        # Enforce constant currency
        currency = cls._enable_currency(currency_code)
        if not cls.env.company.currency_id == currency:
            cls.env.transaction.cache.set(cls.env.company, type(cls.env.company).currency_id, currency.id, dirty=True)
            # this is equivalent to cls.env.company.currency_id = currency but without triggering buisness code checks.
            # The value is added in cache, and the cache value is set as dirty so that that
            # the value will be written to the database on next flush.
            # this was needed because some journal entries may exist when running tests, especially l10n demo data.

class BaseUsersCommon(BaseCommon):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        cls.group_portal = cls.env.ref('base.group_portal')
        cls.group_user = cls.env.ref('base.group_user')

        cls.user_portal = cls.env['res.users'].create({
            'name': 'Test Portal User',
            'login': 'portal_user',
            'password': 'portal_user',
            'email': 'portal_user@gladys.portal',
            'groups_id': [Command.set([cls.group_portal.id])],
        })

        cls.user_internal = cls.env['res.users'].create({
            'name': 'Test Internal User',
            'login': 'internal_user',
            'password': 'internal_user',
            'email': 'mark.brown23@example.com',
            'groups_id': [Command.set([cls.group_user.id])],
        })


class TransactionCaseWithUserDemo(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        cls.env.ref('base.partner_admin').write({'name': 'Mitchell Admin'})
        cls.user_demo = cls.env['res.users'].search([('login', '=', 'demo')])
        cls.partner_demo = cls.user_demo.partner_id

        if not cls.user_demo:
            cls.env['ir.config_parameter'].sudo().set_param('auth_password_policy.minlength', 4)
            cls.partner_demo = cls.env['res.partner'].create({
                'name': 'Marc Demo',
                'email': 'mark.brown23@example.com',
            })
            cls.user_demo = cls.env['res.users'].create({
                'login': 'demo',
                'password': 'demo',
                'partner_id': cls.partner_demo.id,
                'groups_id': [Command.set([cls.env.ref('base.group_user').id, cls.env.ref('base.group_partner_manager').id])],
            })


class HttpCaseWithUserDemo(HttpCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.user_admin = cls.env.ref('base.user_admin')
        cls.user_admin.write({'name': 'Mitchell Admin'})
        cls.partner_admin = cls.user_admin.partner_id
        cls.user_demo = cls.env['res.users'].search([('login', '=', 'demo')])
        cls.partner_demo = cls.user_demo.partner_id

        if not cls.user_demo:
            cls.env['ir.config_parameter'].sudo().set_param('auth_password_policy.minlength', 4)
            cls.partner_demo = cls.env['res.partner'].create({
                'name': 'Marc Demo',
                'email': 'mark.brown23@example.com',
            })
            cls.user_demo = cls.env['res.users'].create({
                'login': 'demo',
                'password': 'demo',
                'partner_id': cls.partner_demo.id,
                'groups_id': [Command.set([cls.env.ref('base.group_user').id, cls.env.ref('base.group_partner_manager').id])],
            })


class SavepointCaseWithUserDemo(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        cls.user_demo = cls.env['res.users'].search([('login', '=', 'demo')])
        cls.partner_demo = cls.user_demo.partner_id

        if not cls.user_demo:
            cls.env['ir.config_parameter'].sudo().set_param('auth_password_policy.minlength', 4)
            cls.partner_demo = cls.env['res.partner'].create({
                'name': 'Marc Demo',
                'email': 'mark.brown23@example.com',
            })
            cls.user_demo = cls.env['res.users'].create({
                'login': 'demo',
                'password': 'demo',
                'partner_id': cls.partner_demo.id,
                'groups_id': [Command.set([cls.env.ref('base.group_user').id, cls.env.ref('base.group_partner_manager').id])],
            })

    @classmethod
    def _load_partners_set(cls):
        cls.partner_category = cls.env['res.partner.category'].create({
            'name': 'Sellers',
            'color': 2,
        })
        cls.partner_category_child_1 = cls.env['res.partner.category'].create({
            'name': 'Office Supplies',
            'parent_id': cls.partner_category.id,
        })
        cls.partner_category_child_2 = cls.env['res.partner.category'].create({
            'name': 'Desk Manufacturers',
            'parent_id': cls.partner_category.id,
        })

        # Load all the demo partners
        cls.partners = cls.env['res.partner'].create([
            {
                'name': 'Inner Works', # Wood Corner
                'state_id': cls.env.ref('base.state_us_1').id,
                'category_id': [Command.set([cls.partner_category_child_1.id, cls.partner_category_child_2.id,])],
                'child_ids': [Command.create({
                    'name': 'Sheila Ruiz', # 'Willie Burke',
                }), Command.create({
                    'name': 'Wyatt Howard', # 'Ron Gibson',
                }), Command.create({
                    'name': 'Austin Kennedy', # Tom Ruiz
                })],
            }, {
                'name': 'Pepper Street', # 'Deco Addict',
                'state_id': cls.env.ref('base.state_us_2').id,
                'child_ids': [Command.create({
                    'name': 'Liam King', # 'Douglas Fletcher',
                }), Command.create({
                    'name': 'Craig Richardson', # 'Floyd Steward',
                }), Command.create({
                    'name': 'Adam Cox', # 'Addison Olson',
                })],
            }, {
                'name': 'AnalytIQ', #'Gemini Furniture',
                'state_id': cls.env.ref('base.state_us_3').id,
                'child_ids': [Command.create({
                    'name': 'Pedro Boyd', # Edwin Hansen
                }), Command.create({
                    'name': 'Landon Roberts', # 'Jesse Brown',
                    'company_id': cls.env.ref('base.main_company').id,
                }), Command.create({
                    'name': 'Leona Shelton', # 'Soham Palmer',
                }), Command.create({
                    'name': 'Scott Kim', # 'Oscar Morgan',
                })],
            }, {
                'name': 'Urban Trends', # 'Ready Mat',
                'state_id': cls.env.ref('base.state_us_4').id,
                'category_id': [Command.set([cls.partner_category_child_1.id, cls.partner_category_child_2.id,])],
                'child_ids': [Command.create({
                    'name': 'Louella Jacobs', # 'Billy Fox',
                }), Command.create({
                    'name': 'Albert Alexander', # 'Kim Snyder',
                }), Command.create({
                    'name': 'Brad Castillo', # 'Edith Sanchez',
                }), Command.create({
                    'name': 'Sophie Montgomery', # 'Sandra Neal',
                }), Command.create({
                    'name': 'Chloe Bates', # 'Julie Richards',
                }), Command.create({
                    'name': 'Mason Crawford', # 'Travis Mendoza',
                }), Command.create({
                    'name': 'Elsie Kennedy', # 'Theodore Gardner',
                })],
            }, {
                'name': 'Ctrl-Alt-Fix', # 'The Jackson Group',
                'state_id': cls.env.ref('base.state_us_5').id,
                'child_ids': [Command.create({
                    'name': 'carole miller', # 'Toni Rhodes',
                }), Command.create({
                    'name': 'Cecil Holmes', # 'Gordon Owens',
                })],
            }, {
                'name': 'Ignitive Labs', # 'Azure Interior',
                'state_id': cls.env.ref('base.state_us_6').id,
                'child_ids': [Command.create({
                    'name': 'Jonathan Webb', # 'Brandon Freeman',
                }), Command.create({
                    'name': 'Clinton Clark', # 'Nicole Ford',
                }), Command.create({
                    'name': 'Howard Bryant', # 'Colleen Diaz',
                })],
            }, {
                'name': 'Amber & Forge', # 'Lumber Inc',
                'state_id': cls.env.ref('base.state_us_7').id,
                'child_ids': [Command.create({
                    'name': 'Mark Webb', # 'Lorraine Douglas',
                })],
            }, {
                'name': 'Rebecca Day', # 'Chester Reed',
                'parent_id': cls.env.ref('base.main_partner').id,
            }, {
                'name': 'Gabriella Jennings', # 'Dwayne Newman',
                'parent_id': cls.env.ref('base.main_partner').id,
            }
        ])


class TransactionCaseWithUserPortal(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.user_portal = cls.env['res.users'].sudo().search([('login', '=', 'portal')])
        cls.partner_portal = cls.user_portal.partner_id

        if not cls.user_portal:
            cls.env['ir.config_parameter'].sudo().set_param('auth_password_policy.minlength', 4)
            cls.partner_portal = cls.env['res.partner'].create({
                'name': 'Joel Willis',
                'email': 'joel.willis63@example.com',
            })
            cls.user_portal = cls.env['res.users'].with_context(no_reset_password=True).create({
                'login': 'portal',
                'password': 'portal',
                'partner_id': cls.partner_portal.id,
                'groups_id': [Command.set([cls.env.ref('base.group_portal').id])],
            })


class HttpCaseWithUserPortal(HttpCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.user_portal = cls.env['res.users'].sudo().search([('login', '=', 'portal')])
        cls.partner_portal = cls.user_portal.partner_id

        if not cls.user_portal:
            cls.env['ir.config_parameter'].sudo().set_param('auth_password_policy.minlength', 4)
            cls.partner_portal = cls.env['res.partner'].create({
                'name': 'Joel Willis',
                'email': 'joel.willis63@example.com',
            })
            cls.user_portal = cls.env['res.users'].with_context(no_reset_password=True).create({
                'login': 'portal',
                'password': 'portal',
                'partner_id': cls.partner_portal.id,
                'groups_id': [Command.set([cls.env.ref('base.group_portal').id])],
            })


class MockSmtplibCase:
    """Class which allows you to mock the smtplib feature, to be able to test in depth the
    sending of emails. Unlike "MockEmail" which mocks mainly the <ir.mail_server> methods,
    here we mainly mock the smtplib to be able to test the <ir.mail_server> model.
    """
    @contextmanager
    def mock_smtplib_connection(self):
        self.emails = []

        origin = self

        class TestingSMTPSession:
            """SMTP session object returned during the testing.

            So we do not connect to real SMTP server. Store the mail
            server id used for the SMTP connection and other information.

            Can be mocked for testing to know which with arguments the email was sent.
            """
            def quit(self):
                pass

            def send_message(self, message, smtp_from, smtp_to_list):
                origin.emails.append({
                    'smtp_from': smtp_from,
                    'smtp_to_list': smtp_to_list,
                    'message': message.as_string(),
                    'from_filter': self.from_filter,
                })

            def sendmail(self, smtp_from, smtp_to_list, message_str, mail_options):
                origin.emails.append({
                    'smtp_from': smtp_from,
                    'smtp_to_list': smtp_to_list,
                    'message': message_str,
                    'from_filter': self.from_filter,
                })

            def set_debuglevel(self, smtp_debug):
                pass

            def ehlo_or_helo_if_needed(self):
                pass

            def login(self, user, password):
                pass

            def starttls(self, keyfile=None, certfile=None, context=None):
                pass

        self.testing_smtp_session = TestingSMTPSession()

        IrMailServer = self.env['ir.mail_server']
        connect_origin = type(IrMailServer).connect
        find_mail_server_origin = type(IrMailServer)._find_mail_server

        # custom mock to avoid losing context
        def mock_function(func):
            mock = Mock()

            def _call(*args, **kwargs):
                mock(*args[1:], **kwargs)
                return func(*args, **kwargs)

            _call.mock = mock
            return _call

        with patch('smtplib.SMTP_SSL', side_effect=lambda *args, **kwargs: self.testing_smtp_session), \
             patch('smtplib.SMTP', side_effect=lambda *args, **kwargs: self.testing_smtp_session), \
             patch.object(type(IrMailServer), '_is_test_mode', lambda self: False), \
             patch.object(type(IrMailServer), 'connect', mock_function(connect_origin)) as connect_mocked, \
             patch.object(type(IrMailServer), '_find_mail_server', mock_function(find_mail_server_origin)) as find_mail_server_mocked:
            self.connect_mocked = connect_mocked.mock
            self.find_mail_server_mocked = find_mail_server_mocked.mock
            yield

    def _build_email(self, mail_from, return_path=None, **kwargs):
        return self.env['ir.mail_server'].build_email(
            mail_from,
            kwargs.pop('email_to', 'dest@example-é.com'),
            kwargs.pop('subject', 'subject'),
            kwargs.pop('body', 'body'),
            headers={'Return-Path': return_path} if return_path else None,
            **kwargs,
        )

    def _send_email(self, msg, smtp_session):
        with patch.object(threading.current_thread(), 'testing', False):
            self.env['ir.mail_server'].send_email(msg, smtp_session=smtp_session)
        return smtp_session.messages.pop()

    def assertSMTPEmailsSent(self, smtp_from=None, smtp_to_list=None, message_from=None,
                             mail_server=None, from_filter=None,
                             emails_count=1):
        """Check that the given email has been sent. If one of the parameter is
        None it is just ignored and not used to retrieve the email.

        :param smtp_from: FROM used for the authentication to the mail server
        :param smtp_to_list: List of destination email address
        :param message_from: FROM used in the SMTP headers
        :arap mail_server: used to compare the 'from_filter' as an alternative
          to using the from_filter parameter
        :param from_filter: from_filter of the <ir.mail_server> used to send the
          email. False means 'match everything';'
        :param emails_count: the number of emails which should match the condition
        :return: True if at least one email has been found with those parameters
        """
        if from_filter is not None and mail_server:
            raise ValueError('Invalid usage: use either from_filter either mail_server')
        if from_filter is None and mail_server is not None:
            from_filter = mail_server.from_filter
        matching_emails = filter(
            lambda email:
                (smtp_from is None or smtp_from == email['smtp_from'])
                and (smtp_to_list is None or smtp_to_list == email['smtp_to_list'])
                and (message_from is None or 'From: %s' % message_from in email['message'])
                and (from_filter is None or from_filter == email['from_filter']),
            self.emails,
        )

        debug_info = ''
        matching_emails_count = len(list(matching_emails))
        if matching_emails_count != emails_count:
            emails_from = []
            for email in self.emails:
                from_found = next((
                    line.split('From:')[1].strip() for line in email['message'].splitlines()
                    if line.startswith('From:')), '')
                emails_from.append(from_found)
            debug_info = '\n'.join(
                f"SMTP-From: {email['smtp_from']}, SMTP-To: {email['smtp_to_list']}, Msg-From: {email_msg_from}, From_filter: {email['from_filter']})"
                for email, email_msg_from in zip(self.emails, emails_from)
            )
        self.assertEqual(
            matching_emails_count, emails_count,
            msg=f'Incorrect emails sent: {matching_emails_count} found, {emails_count} expected'
                f'\nConditions\nSMTP-From: {smtp_from}, SMTP-To: {smtp_to_list}, Msg-From: {message_from}, From_filter: {from_filter}'
                f'\nNot found in\n{debug_info}'
        )

    @classmethod
    def _init_mail_gateway(cls):
        cls.default_from_filter = False
        cls.env['ir.config_parameter'].sudo().set_param('mail.default.from_filter', cls.default_from_filter)

    @classmethod
    def _init_mail_servers(cls):
        cls.env['ir.mail_server'].search([]).unlink()

        ir_mail_server_values = {
            'smtp_host': 'smtp_host',
            'smtp_encryption': 'none',
        }
        cls.mail_servers = cls.env['ir.mail_server'].create([
            {
                'name': 'Domain based server',
                'from_filter': 'test.mycompany.com',
                'sequence': 0,
                ** ir_mail_server_values,
            }, {
                'name': 'User specific server',
                'from_filter': 'specific_user@test.mycompany.com',
                'sequence': 1,
                ** ir_mail_server_values,
            }, {
                'name': 'Server Notifications',
                'from_filter': 'notifications.test@test.mycompany.com',
                'sequence': 2,
                ** ir_mail_server_values,
            }, {
                'name': 'Server No From Filter',
                'from_filter': False,
                'sequence': 3,
                ** ir_mail_server_values,
            },
        ])
        (
            cls.mail_server_domain, cls.mail_server_user,
            cls.mail_server_notification, cls.mail_server_default
        ) = cls.mail_servers

```

  File: tests/fire_small.jpeg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: tests/odoo.jpg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

  File: tests/split_table/copy_attributes.split1.xml
  Content:
```
<root>
    <table id="cool-table" class="fancy-style">
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
    <table id="cool-table" class="fancy-style">
        <tr>
            <td>
                <td>2</td>
                <td>2</td>
                <td>2</td>
            </td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/copy_attributes.xml
  Content:
```
<root>
    <table id="cool-table" class="fancy-style">
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>
            <td>2</td>
            <td>2</td>
            <td>2</td>
            </td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/first_nested.split2.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>5</td>
                        <td>5</td>
                    </tr>
                </table>
                <table>
                    <tr>
                        <td>6</td>
                        <td>6</td>
                        <td>6</td>
                    </tr>
                </table>
            </td>
            <td>7</td>
            <td>7</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
    <table>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/first_nested.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>5</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>6</td>
                        <td>6</td>
                    </tr>
                </table>
            </td>
            <td>7</td>
            <td>7</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/nested.split2.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
    </table>
    <table>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>5</td>
                        <td>5</td>
                    </tr>
                </table>
                <table>
                    <tr>
                        <td>6</td>
                        <td>6</td>
                        <td>6</td>
                    </tr>
                </table>
            </td>
            <td>7</td>
            <td>7</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/nested.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
        <tr>
            <td>
                <table>
                    <tr>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>5</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>6</td>
                        <td>6</td>
                    </tr>
                </table>
            </td>
            <td>7</td>
            <td>7</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/simple.split1.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
    <table>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
    </table>
    <table>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/simple.split2.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
    </table>
    <table>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
    </table>
</root>

```

  File: tests/split_table/simple.xml
  Content:
```
<root>
    <table>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>3</td>
        </tr>
    </table>
</root>

```

  File: tests/ssl/ca.cert.pem
  Content:
```
-----BEGIN CERTIFICATE-----
MIIByTCCAXugAwIBAgIUXOt3OuI/y68E6ogXPRKjMxM3d4kwBQYDK2VwMFExCzAJ
BgNVBAYTAkJFMRQwEgYDVQQHDAtIb3V0ZXNpcGxvdTEsMCoGA1UEAwwjSG91dGVz
aXBsb3UgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwIBcNMjQwNDIyMTUxNDU3WhgP
MzAyMzA4MjQxNTE0NTdaMFExCzAJBgNVBAYTAkJFMRQwEgYDVQQHDAtIb3V0ZXNp
cGxvdTEsMCoGA1UEAwwjSG91dGVzaXBsb3UgQ2VydGlmaWNhdGlvbiBBdXRob3Jp
dHkwKjAFBgMrZXADIQA9E6L8dKzknznGYYkNMVRt78Rs8L5sIOLFaJHfzfpcdaNj
MGEwHQYDVR0OBBYEFOCOFRwpR4cKRG3au4pqU5tc8ItOMB8GA1UdIwQYMBaAFOCO
FRwpR4cKRG3au4pqU5tc8ItOMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD
AgGGMAUGAytlcANBAMDS7x9X9IIM1jCQdzTibtVu14mZmXoBJ8GoFMojUSvyz86y
81vpi1ZEOZoZm/HadUBlONvL4aGqbu0t6yABeA8=
-----END CERTIFICATE-----

```

  File: tests/ssl/client.cert.pem
  Content:
```
-----BEGIN CERTIFICATE-----
MIICCTCCAbugAwIBAgICEAAwBQYDK2VwMFExCzAJBgNVBAYTAkJFMRQwEgYDVQQH
DAtIb3V0ZXNpcGxvdTEsMCoGA1UEAwwjSG91dGVzaXBsb3UgQ2VydGlmaWNhdGlv
biBBdXRob3JpdHkwIBcNMjQwNDIyMTUxNDU3WhgPMzAyMzA4MjQxNTE0NTdaMEAx
CzAJBgNVBAYTAkJFMRQwEgYDVQQHDAtIb3V0ZXNpcGxvdTEbMBkGA1UEAwwSSG91
dGVzaXBsb3UgQ2xpZW50MCowBQYDK2VwAyEAFkZcOJ5bNr2NZcwZuXkdC5PfX+fu
M+YWyh5eeMtU7mujgcUwgcIwCQYDVR0TBAIwADARBglghkgBhvhCAQEEBAMCBaAw
MwYJYIZIAYb4QgENBCYWJE9wZW5TU0wgR2VuZXJhdGVkIENsaWVudCBDZXJ0aWZp
Y2F0ZTAdBgNVHQ4EFgQUxag2EgTttBUfjSg/MHMs+4h/16cwHwYDVR0jBBgwFoAU
4I4VHClHhwpEbdq7impTm1zwi04wDgYDVR0PAQH/BAQDAgXgMB0GA1UdJQQWMBQG
CCsGAQUFBwMCBggrBgEFBQcDBDAFBgMrZXADQQAezi5mtJ3Y5A8DLuxL7g9rPff7
qUQqwg3RlGQ7QAkwiuUa6nQ1kfcIGSTFe6sOBL5ACMLwxP1ibgAENxBamvAC
-----END CERTIFICATE-----

```

  File: tests/ssl/client.key.pem
  Content:
```
-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEICS5j5g1kNSbzhCRT7eDN4k12P0x5n8tg6HLPcCuY7DD
-----END PRIVATE KEY-----

```

  File: tests/ssl/self_signed.cert.pem
  Content:
```
-----BEGIN CERTIFICATE-----
MIIDFzCCAf+gAwIBAgIUfnEIpcavhz3Pn9P5YMIZzku+OJUwDQYJKoZIhvcNAQEL
BQAwGjEYMBYGA1UEAwwPU2VsZlNpZ25lZCBMbXRkMCAXDTI0MDQyMjE1MTQ1N1oY
DzMwMjMwODI0MTUxNDU3WjAaMRgwFgYDVQQDDA9TZWxmU2lnbmVkIExtdGQwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDIfgXKzK/FiQzqqAtOCqbTSCtp
rFr5hpTQJWscfQXfkQiJC0nLLojj4sLSNf/PnP8eglju+AIO6st2TF3v+qugog0o
D9cMvjhzqwLfpJzSr7EN5n4X3TAoyucPg/aF3+ACXwVXuTfxTCbJbEeBrWSk7b1k
R1bORVQvH895V08rVs2MZ5v3sutF0EWeiyh4O/EzpSiKywLUE5eLoZiJtN9j3yGm
bJii/fCcON4sQTxpL2/i2jbPo2dH2EKKS1xO0LBt4IoiOidRTQiOsjL2VANZiCer
UuWUlsG5albCcExvVzQnINRb7+6F6NJqJdC+rRqQG6YeXpUeXBe8GMZjpqLdAgMB
AAGjUzBRMB0GA1UdDgQWBBSRC2v9uCKuJ6lpWVbe2nO6gI6bJTAfBgNVHSMEGDAW
gBSRC2v9uCKuJ6lpWVbe2nO6gI6bJTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQDADAKCY4WDhVJnReyP2fc/E/N2Wa29BCdR9LZxS2sNd5gyQnZJ
FHLqu1R+tMACtXG4q1AEuN0yn7hsqCfy3hQH5mFLqQzNqoWF6HDQr2b7kfw/E1S3
bH/K+6Kbu5fEYWRZNo5Ti62mEHhSS2tBw0qmN9pceT/ZFhYpe44RQzuxEckOXBpx
g1J8NAqvknfvl9nu31C8Ye98XlsHDGz/qUvmIPqXCmmg26NcT/NE26A76tgegUDo
U/K4WFOr5cyHcIfaYWFg2/SKukudQldwU92ZvJOSwYvn3MKixg/YZGK+0MwzMm4c
+ZKttL1Pwub4Gt9ZaFrzrM1t2NRTgMiKU2lQ
-----END CERTIFICATE-----

```

  File: tests/ssl/self_signed.key.pem
  Content:
```
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDIfgXKzK/FiQzq
qAtOCqbTSCtprFr5hpTQJWscfQXfkQiJC0nLLojj4sLSNf/PnP8eglju+AIO6st2
TF3v+qugog0oD9cMvjhzqwLfpJzSr7EN5n4X3TAoyucPg/aF3+ACXwVXuTfxTCbJ
bEeBrWSk7b1kR1bORVQvH895V08rVs2MZ5v3sutF0EWeiyh4O/EzpSiKywLUE5eL
oZiJtN9j3yGmbJii/fCcON4sQTxpL2/i2jbPo2dH2EKKS1xO0LBt4IoiOidRTQiO
sjL2VANZiCerUuWUlsG5albCcExvVzQnINRb7+6F6NJqJdC+rRqQG6YeXpUeXBe8
GMZjpqLdAgMBAAECggEAF197B7eRXZB1dTJjpan1OoKv2PETEVg1/LFYCX6uaBqi
1EMrdlM1pId42dkaD5czC1imddlreAIO99AS+sPjgpBRw1QGvda72F7dMLr33fyb
F06XGutveVn00j4P8m8f0MxItaot549Oou22GlvfSfY96DUEMtDUmG0iGqMUji3V
SeHvAeginTCaoux5OPdB94jcRpsSf+B0pRS0JMpW/87+mg3bzT8ouPYkbfRZ92Wo
4x3b1kcBbq7xvtmSsN0PxqZGcuuDn3zjO1XI6HCwWWP+ICUIC6+Tw8szWIvJ9Cgp
te2nvcAYstnrW15smJTjRNhikMpu3EsBajsgfsScywKBgQDyoAGlucEfREVmVuba
hbLfhGTmKvvsgS2e7p5ktJPkdCyvImU6l9Crzt8qD+9ic2LEgvRBtqaaHkC8DgLc
LiEL/QiIbNdGhfxm9+bWMW0wx6HWRwC1b7t1BT3Dh4y9I4YYkLR2NDqh1R8D4X0D
mEk9pfR2nFEDjkGyDp9gyCB68wKBgQDTi21DuKu14WQCfrInn3SGoDTeHGRhV6b6
HrOJj4ppbqffjUcvvpSzYJAZtk8eHdHMM8tut+OejxPzabFdgXrO4EaMiH5XYaTx
zDFpTe/cGZvb5m9jg6fEb0YCB6KfefDpFABXOlaILyl8JwnC0BT1bEL7k8c/s/it
LIVIy38+7wKBgQDG0lonPZ5FigO5BpOtFQzs36hzeVvyhjUlXXNNITFkb9NCPVRo
/ImSkTcNV/uaWOXiFVImG5BREWOI945ecirAkT0R1udesmOQ2as/cUeCRsWXO54Y
EJS0I3Rmq8ioIdk8fjB0AP7fKS9+VaTFcmDqdPlszVISMNwjFpqCi90aAwKBgQCT
RkxJi3Wv6DyyJ/Zr820ylLJ5t5aC1n0fQOSJbm9UO3+P+VGIAcyQnTd1TyEBvIzk
92I3sLo9FysymXCrwor3H9i92gDrYMVuuVPlFidZOlLx4xnFVFEmRrmcjChBkqmP
+ybJk4nOwdbF4n+/KxKMUlTHxPhAd1E3bvlT1qi97QKBgAHUTniLWiqxH4wyspIW
SV7EW87Suat+p6TdR81FonNAgLMGjtTqRcHkoCfQfExpPycuybpqtJK7IeiVqNc5
lCe48Hl6hpASfwe9T2K3q68UACU5pk5i/PTydFCI+zwVbaiBGip71skzGUVzcPY9
JBbw8hEOjPwcK4SAgi+Yprmc
-----END PRIVATE KEY-----

```

  File: tests/ssl/server.cert.pem
  Content:
```
-----BEGIN CERTIFICATE-----
MIIChzCCAjmgAwIBAgICEAEwBQYDK2VwMFExCzAJBgNVBAYTAkJFMRQwEgYDVQQH
DAtIb3V0ZXNpcGxvdTEsMCoGA1UEAwwjSG91dGVzaXBsb3UgQ2VydGlmaWNhdGlv
biBBdXRob3JpdHkwIBcNMjQwNDIyMTUxNDU3WhgPMzAyMzA4MjQxNTE0NTdaMEAx
CzAJBgNVBAYTAkJFMRQwEgYDVQQHDAtIb3V0ZXNpcGxvdTEbMBkGA1UEAwwSSG91
dGVzaXBsb3UgU2VydmVyMCowBQYDK2VwAyEACb6GUUvOz8O1IlrH9/4sxaRGAemi
c/eMlQ7xjAjUbLOjggFCMIIBPjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIG
QDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgU2VydmVyIENlcnRp
ZmljYXRlMB0GA1UdDgQWBBRkIUgQms0wKozvwQp1b1XU53E3kjCBjgYDVR0jBIGG
MIGDgBTgjhUcKUeHCkRt2ruKalObXPCLTqFVpFMwUTELMAkGA1UEBhMCQkUxFDAS
BgNVBAcMC0hvdXRlc2lwbG91MSwwKgYDVQQDDCNIb3V0ZXNpcGxvdSBDZXJ0aWZp
Y2F0aW9uIEF1dGhvcml0eYIUXOt3OuI/y68E6ogXPRKjMxM3d4kwDgYDVR0PAQH/
BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMBQGA1UdEQQNMAuCCWxvY2FsaG9z
dDAFBgMrZXADQQDidpmoltxDR1Qh5ZDluVC1DENZpXk+My23SDzATvxovbmkHEK2
/LdWbqrTPJZIHGhs9W/7vWSbLzyHYTKH2fAD
-----END CERTIFICATE-----

```

  File: tests/ssl/server.key.pem
  Content:
```
-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIHSVKSyvMJwmNHpoMj3BLlBy40bQ2vJJyUNknXcyPUkO
-----END PRIVATE KEY-----

```

  File: tests/test_acl.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from lxml import etree

from odoo.exceptions import AccessError
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.tests.common import TransactionCase
from odoo.tools.misc import mute_logger
from odoo import Command

# test group that demo user should not have
GROUP_SYSTEM = 'base.group_system'


class TestACL(TransactionCaseWithUserDemo):

    def setUp(self):
        super(TestACL, self).setUp()
        self.erp_system_group = self.env.ref(GROUP_SYSTEM)

    def _set_field_groups(self, model, field_name, groups):
        field = model._fields[field_name]
        self.patch(field, 'groups', groups)

    def test_field_visibility_restriction(self):
        """Check that model-level ``groups`` parameter effectively restricts access to that
           field for users who do not belong to one of the explicitly allowed groups"""
        currency = self.env['res.currency'].with_user(self.user_demo)

        # Add a view that adds a label for the field we are going to check
        extension = self.env["ir.ui.view"].create({
            "name": "Add separate label for decimal_places",
            "model": "res.currency",
            "inherit_id": self.env.ref("base.view_currency_form").id,
            "arch": """
                <data>
                    <field name="decimal_places" position="attributes">
                        <attribute name="nolabel">1</attribute>
                    </field>
                    <field name="decimal_places" position="before">
                        <label for="decimal_places"/>
                    </field>
                </data>
            """,
        })
        currency = currency.with_context(check_view_ids=extension.ids)

        # Verify the test environment first
        original_fields = currency.fields_get([])
        with self.debug_mode():
            # <group groups="base.group_no_one">
            #     <group string="Price Accuracy">
            #         <field name="rounding"/>
            #         <field name="decimal_places"/>
            #     </group>
            form_view = currency.get_view(False, 'form')
        view_arch = etree.fromstring(form_view.get('arch'))
        has_group_system = self.user_demo.has_group(GROUP_SYSTEM)
        self.assertFalse(has_group_system, "`demo` user should not belong to the restricted group before the test")
        self.assertIn('decimal_places', original_fields, "'decimal_places' field must be properly visible before the test")
        self.assertNotEqual(view_arch.xpath("//field[@name='decimal_places'][@nolabel='1']"), [],
                             "Field 'decimal_places' must be found in view definition before the test")
        self.assertNotEqual(view_arch.xpath("//label[@for='decimal_places']"), [],
                             "Label for 'decimal_places' must be found in view definition before the test")

        # restrict access to the field and check it's gone
        self._set_field_groups(currency, 'decimal_places', GROUP_SYSTEM)

        fields = currency.fields_get([])
        form_view = currency.get_view(False, 'form')
        view_arch = etree.fromstring(form_view.get('arch'))
        self.assertNotIn('decimal_places', fields, "'decimal_places' field should be gone")
        self.assertEqual(view_arch.xpath("//field[@name='decimal_places']"), [],
                          "Field 'decimal_places' must not be found in view definition")
        self.assertEqual(view_arch.xpath("//label[@for='decimal_places']"), [],
                          "Label for 'decimal_places' must not be found in view definition")

        # Make demo user a member of the restricted group and check that the field is back
        self.erp_system_group.users += self.user_demo
        has_group_system = self.user_demo.has_group(GROUP_SYSTEM)
        fields = currency.fields_get([])
        with self.debug_mode():
            form_view = currency.get_view(False, 'form')
        view_arch = etree.fromstring(form_view.get('arch'))
        self.assertTrue(has_group_system, "`demo` user should now belong to the restricted group")
        self.assertIn('decimal_places', fields, "'decimal_places' field must be properly visible again")
        self.assertNotEqual(view_arch.xpath("//field[@name='decimal_places']"), [],
                             "Field 'decimal_places' must be found in view definition again")
        self.assertNotEqual(view_arch.xpath("//label[@for='decimal_places']"), [],
                             "Label for 'decimal_places' must be found in view definition again")

    @mute_logger('odoo.models')
    def test_field_crud_restriction(self):
        "Read/Write RPC access to restricted field should be forbidden"
        partner = self.env['res.partner'].browse(1).with_user(self.user_demo)

        # Verify the test environment first
        has_group_system = self.user_demo.has_group(GROUP_SYSTEM)
        self.assertFalse(has_group_system, "`demo` user should not belong to the restricted group")
        self.assertTrue(partner.read(['bank_ids']))
        self.assertTrue(partner.write({'bank_ids': []}))

        # Now restrict access to the field and check it's forbidden
        self._set_field_groups(partner, 'bank_ids', GROUP_SYSTEM)

        with self.assertRaises(AccessError):
            partner.search_fetch([], ['bank_ids'])
        with self.assertRaises(AccessError):
            partner.fetch(['bank_ids'])
        with self.assertRaises(AccessError):
            partner.read(['bank_ids'])
        with self.assertRaises(AccessError):
            partner.write({'bank_ids': []})

        # Add the restricted group, and check that it works again
        self.erp_system_group.users += self.user_demo
        has_group_system = self.user_demo.has_group(GROUP_SYSTEM)
        self.assertTrue(has_group_system, "`demo` user should now belong to the restricted group")
        self.assertTrue(partner.read(['bank_ids']))
        self.assertTrue(partner.write({'bank_ids': []}))

    @mute_logger('odoo.models')
    def test_fields_browse_restriction(self):
        """Test access to records having restricted fields"""
        # Invalidate cache to avoid restricted value to be available
        # in the cache
        self.env.invalidate_all()
        partner = self.env['res.partner'].with_user(self.user_demo)
        self._set_field_groups(partner, 'email', GROUP_SYSTEM)

        # accessing fields must no raise exceptions...
        partner = partner.search([], limit=1)
        partner.name
        # ... except if they are restricted
        with self.assertRaises(AccessError):
            with mute_logger('odoo.models'):
                partner.email

    def test_view_create_edit_button(self):
        """ Test form view Create, Edit, Delete button visibility based on access right of model.
        Test the user with and without access in the same unit test / transaction
        to test the views cache is properly working """
        methods = ['create', 'edit', 'delete']
        company = self.env['res.company'].with_user(self.user_demo)
        company_view = company.get_view(False, 'form')
        view_arch = etree.fromstring(company_view['arch'])

        # demo not part of the group_system, create edit and delete must be False
        for method in methods:
            self.assertEqual(view_arch.get(method), 'False')

        # demo part of the group_system, create edit and delete must not be specified
        company = self.env['res.company'].with_user(self.env.ref("base.user_admin"))
        company_view = company.get_view(False, 'form')
        view_arch = etree.fromstring(company_view['arch'])
        for method in methods:
            self.assertIsNone(view_arch.get(method))

    def test_m2o_field_create_edit(self):
        """ Test many2one field Create and Edit option visibility based on access rights of relation field
        Test the user with and without access in the same unit test / transaction
        to test the views cache is properly working """
        methods = ['create', 'write']
        company = self.env['res.company'].with_user(self.user_demo)
        company_view = company.get_view(False, 'form')
        view_arch = etree.fromstring(company_view['arch'])
        field_node = view_arch.xpath("//field[@name='currency_id']")
        self.assertTrue(len(field_node), "currency_id field should be in company from view")
        for method in methods:
            self.assertEqual(field_node[0].get('can_' + method), 'False')

        company = self.env['res.company'].with_user(self.env.ref("base.user_admin"))
        company_view = company.get_view(False, 'form')
        view_arch = etree.fromstring(company_view['arch'])
        field_node = view_arch.xpath("//field[@name='currency_id']")
        for method in methods:
            self.assertEqual(field_node[0].get('can_' + method), 'True')

    def test_get_views_fields(self):
        """ Tests fields restricted to group_system are not passed when calling `get_views` as demo
        but the same fields are well passed when calling `get_views` as admin"""
        Partner = self.env['res.partner']
        self._set_field_groups(Partner, 'email', GROUP_SYSTEM)
        views = Partner.with_user(self.user_demo).get_views([(False, 'form')])
        self.assertFalse('email' in views['models']['res.partner'])
        views = Partner.with_user(self.env.ref("base.user_admin")).get_views([(False, 'form')])
        self.assertTrue('email' in views['models']['res.partner'])


class TestIrRule(TransactionCaseWithUserDemo):

    def test_ir_rule(self):
        model_res_partner = self.env.ref('base.model_res_partner')
        group_user = self.env.ref('base.group_user')

        # create an ir_rule for the Employee group with an blank domain
        rule1 = self.env['ir.rule'].create({
            'name': 'test_rule1',
            'model_id': model_res_partner.id,
            'domain_force': False,
            'groups': [Command.set(group_user.ids)],
        })

        # read as demo user the partners (one blank domain)
        partners_demo = self.env['res.partner'].with_user(self.user_demo)
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # same with domain 1=1
        rule1.domain_force = "[(1,'=',1)]"
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # same with domain []
        rule1.domain_force = "[]"
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # create another ir_rule for the Employee group (to test multiple rules)
        rule2 = self.env['ir.rule'].create({
            'name': 'test_rule2',
            'model_id': model_res_partner.id,
            'domain_force': False,
            'groups': [Command.set(group_user.ids)],
        })

        # read as demo user with domains [] and blank
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # same with domains 1=1 and blank
        rule1.domain_force = "[(1,'=',1)]"
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # same with domains 1=1 and 1=1
        rule2.domain_force = "[(1,'=',1)]"
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # create another ir_rule for the Employee group (to test multiple rules)
        rule3 = self.env['ir.rule'].create({
            'name': 'test_rule3',
            'model_id': model_res_partner.id,
            'domain_force': False,
            'groups': [Command.set(group_user.ids)],
        })

        # read the partners as demo user
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # same with domains 1=1, 1=1 and 1=1
        rule3.domain_force = "[(1,'=',1)]"
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # modify the global rule on res_company which triggers a recursive check
        # of the rules on company
        global_rule = self.env.ref('base.res_company_rule_employee')
        global_rule.domain_force = "[('id','in', company_ids)]"

        # read as demo user (exercising the global company rule)
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # Modify the ir_rule for employee to have a rule that fordids seeing any
        # record. We use a domain with implicit AND operator for later tests on
        # normalization.
        rule2.domain_force = "[('id','=',False),('name','=',False)]"

        # check that demo user still sees partners, because group-rules are OR'ed
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partner.")

        # create a new group with demo user in it, and a complex rule
        group_test = self.env['res.groups'].create({
            'name': 'Test Group',
            'users': [Command.set(self.user_demo.ids)],
        })

        # add the rule to the new group, with a domain containing an implicit
        # AND operator, which is more tricky because it will have to be
        # normalized before combining it
        rule3.write({
            'domain_force': "[('name','!=',False),('id','!=',False)]",
            'groups': [Command.set(group_test.ids)],
        })

        # read the partners again as demo user, which should give results
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see partners even with the combined rules.")

        # delete global domains (to combine only group domains)
        self.env['ir.rule'].search([('groups', '=', False)]).unlink()

        # read the partners as demo user (several group domains, no global domain)
        partners = partners_demo.search([])
        self.assertTrue(partners, "Demo user should see some partners.")

```

  File: tests/test_api.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, models, Command
from odoo.addons.base.tests.common import SavepointCaseWithUserDemo
from odoo.tools import mute_logger, unique, lazy
from odoo.exceptions import AccessError


class TestAPI(SavepointCaseWithUserDemo):
    """ test the new API of the ORM """

    @classmethod
    def setUpClass(cls):
        super(TestAPI, cls).setUpClass()
        cls._load_partners_set()

    def assertIsRecordset(self, value, model):
        self.assertIsInstance(value, models.BaseModel)
        self.assertEqual(value._name, model)

    def assertIsRecord(self, value, model):
        self.assertIsRecordset(value, model)
        self.assertTrue(len(value) <= 1)

    def assertIsNull(self, value, model):
        self.assertIsRecordset(value, model)
        self.assertFalse(value)

    @mute_logger('odoo.models')
    def test_00_query(self):
        """ Build a recordset, and check its contents. """
        domain = [('name', 'ilike', 'j'), ('id', 'in', self.partners.ids)]
        partners = self.env['res.partner'].search(domain)

        # partners is a collection of browse records
        self.assertTrue(partners)

        # partners and its contents are instance of the model
        self.assertIsRecordset(partners, 'res.partner')
        for p in partners:
            self.assertIsRecord(p, 'res.partner')

    @mute_logger('odoo.models')
    def test_01_query_offset(self):
        """ Build a recordset with offset, and check equivalence. """
        partners1 = self.env['res.partner'].search([('id', 'in', self.partners.ids)], offset=5)
        partners2 = self.env['res.partner'].search([('id', 'in', self.partners.ids)])[5:]
        self.assertIsRecordset(partners1, 'res.partner')
        self.assertIsRecordset(partners2, 'res.partner')
        self.assertEqual(list(partners1), list(partners2))

    @mute_logger('odoo.models')
    def test_02_query_limit(self):
        """ Build a recordset with offset, and check equivalence. """
        partners1 = self.env['res.partner'].search([('id', 'in', self.partners.ids)], order='id asc', limit=5)
        partners2 = self.env['res.partner'].search([('id', 'in', self.partners.ids)], order='id asc')[:5]
        self.assertIsRecordset(partners1, 'res.partner')
        self.assertIsRecordset(partners2, 'res.partner')
        self.assertEqual(list(partners1), list(partners2))

    @mute_logger('odoo.models')
    def test_03_query_offset_limit(self):
        """ Build a recordset with offset and limit, and check equivalence. """
        partners1 = self.env['res.partner'].search([('id', 'in', self.partners.ids)], order='id asc', offset=3, limit=7)
        partners2 = self.env['res.partner'].search([('id', 'in', self.partners.ids)], order='id asc')[3:10]
        self.assertIsRecordset(partners1, 'res.partner')
        self.assertIsRecordset(partners2, 'res.partner')
        self.assertEqual(list(partners1), list(partners2))

    @mute_logger('odoo.models')
    def test_04_query_count(self):
        """ Test the search_count method. """
        self.cr.execute("SELECT COUNT(*) FROM res_partner WHERE active")
        count1 = self.cr.fetchone()[0]
        count2 = self.env['res.partner'].search_count([])
        self.assertIsInstance(count1, int)
        self.assertIsInstance(count2, int)
        self.assertEqual(count1, count2)

    @mute_logger('odoo.models')
    def test_05_immutable(self):
        """ Check that a recordset remains the same, even after updates. """
        domain = [('name', 'ilike', 'g'), ('id', 'in', self.partners.ids)]
        partners = self.env['res.partner'].search(domain)
        self.assertTrue(partners)
        ids = partners.ids

        # modify those partners, and check that partners has not changed
        partners.write({'active': False})
        self.assertEqual(ids, partners.ids)

        # redo the search, and check that the result is now empty
        partners2 = self.env['res.partner'].search(domain)
        self.assertFalse(partners2)

    @mute_logger('odoo.models')
    def test_06_fields(self):
        """ Check that relation fields return records, recordsets or nulls. """
        user = self.env.user
        self.assertIsRecord(user, 'res.users')
        self.assertIsRecord(user.partner_id, 'res.partner')
        self.assertIsRecordset(user.groups_id, 'res.groups')

        for name, field in self.partners._fields.items():
            if field.type == 'many2one':
                for p in self.partners:
                    self.assertIsRecord(p[name], field.comodel_name)
            elif field.type == 'reference':
                for p in self.partners:
                    if p[name]:
                        self.assertIsRecord(p[name], field.comodel_name)
            elif field.type in ('one2many', 'many2many'):
                for p in self.partners:
                    self.assertIsRecordset(p[name], field.comodel_name)

    @mute_logger('odoo.models')
    def test_07_null(self):
        """ Check behavior of null instances. """
        # select a partner without a parent
        partner = self.env['res.partner'].search([('parent_id', '=', False), ('id', 'in', self.partners.ids)])[0]

        # check partner and related null instances
        self.assertTrue(partner)
        self.assertIsRecord(partner, 'res.partner')

        self.assertFalse(partner.parent_id)
        self.assertIsNull(partner.parent_id, 'res.partner')

        self.assertIs(partner.parent_id.id, False)

        self.assertFalse(partner.parent_id.user_id)
        self.assertIsNull(partner.parent_id.user_id, 'res.users')

        self.assertIs(partner.parent_id.user_id.name, False)

        self.assertFalse(partner.parent_id.user_id.groups_id)
        self.assertIsRecordset(partner.parent_id.user_id.groups_id, 'res.groups')

    @mute_logger('odoo.models')
    def test_40_new_new(self):
        """ Call new-style methods in the new API style. """
        partners = self.env['res.partner'].search([('name', 'ilike', 'g'), ('id', 'in', self.partners.ids)])
        self.assertTrue(partners)

        # call method write on partners itself, and check its effect
        partners.write({'active': False})
        for p in partners:
            self.assertFalse(p.active)

    @mute_logger('odoo.models')
    def test_45_new_new(self):
        """ Call new-style methods on records (new API style). """
        partners = self.env['res.partner'].search([('name', 'ilike', 'g'), ('id', 'in', self.partners.ids)])
        self.assertTrue(partners)

        # call method write on partner records, and check its effects
        for p in partners:
            p.write({'active': False})
        for p in partners:
            self.assertFalse(p.active)

    @mute_logger('odoo.models')
    @mute_logger('odoo.addons.base.models.ir_model')
    def test_50_environment(self):
        """ Test environment on records. """
        # partners and reachable records are attached to self.env
        partners = self.env['res.partner'].search([('name', 'ilike', 'j'), ('id', 'in', self.partners.ids)])
        self.assertEqual(partners.env, self.env)
        for x in (partners, partners[0], partners[0].company_id):
            self.assertEqual(x.env, self.env)
        for p in partners:
            self.assertEqual(p.env, self.env)

        # check that the current user can read and modify company data
        partners[0].company_id.name
        partners[0].company_id.write({'name': 'Fools'})

        # create an environment with a demo user
        demo = self.env['res.users'].create({
            'name': 'test_environment_demo',
            'login': 'test_environment_demo',
            'password': 'test_environment_demo',
        })
        demo_env = self.env(user=demo)
        self.assertNotEqual(demo_env, self.env)

        # partners and related records are still attached to self.env
        self.assertEqual(partners.env, self.env)
        for x in (partners, partners[0], partners[0].company_id):
            self.assertEqual(x.env, self.env)
        for p in partners:
            self.assertEqual(p.env, self.env)

        # create record instances attached to demo_env
        demo_partners = partners.with_user(demo)
        self.assertEqual(demo_partners.env, demo_env)
        for x in (demo_partners, demo_partners[0], demo_partners[0].company_id):
            self.assertEqual(x.env, demo_env)
        for p in demo_partners:
            self.assertEqual(p.env, demo_env)

        # demo user can read but not modify company data
        demo_partner = self.env['res.partner'].search([('name', '=', 'Landon Roberts')]).with_user(demo)
        self.assertTrue(demo_partner.company_id, 'This partner is supposed to be linked to a company')
        demo_partner.company_id.name
        with self.assertRaises(AccessError):
            demo_partner.company_id.write({'name': 'Pricks'})

        # remove demo user from all groups
        demo.write({'groups_id': [Command.clear()]})

        # demo user can no longer access partner data
        with self.assertRaises(AccessError):
            demo_partner.company_id.name

    @mute_logger('odoo.models')
    def test_55_environment_lang(self):
        """ Check the record env.lang behavior """
        partner = self.partner_demo
        self.env['res.lang']._activate_lang('fr_FR')
        self.assertEqual(partner.with_context(lang=None).env.lang, None, 'None lang context should have None env.lang')
        self.assertEqual(partner.with_context(lang='en_US').env.lang, 'en_US', 'en_US active lang context should have en_US env.lang')
        self.assertEqual(partner.with_context(lang='fr_FR').env.lang, 'fr_FR', 'fr_FR active lang context should have fr_FR env.lang')
        self.assertEqual(partner.with_context(lang='nl_NL').env.lang, None, 'Inactive lang context lang should have None env.lang')
        self.assertEqual(partner.with_context(lang='Dummy').env.lang, None, 'Ilegal lang context should have None env.lang')

    def test_56_environment_uid_origin(self):
        """Check the expected behavior of `env.uid_origin`"""
        user_demo = self.user_demo
        user_admin = self.env.ref('base.user_admin')
        self.assertEqual(self.env.uid_origin, None)
        self.assertEqual(self.env['base'].with_user(user_demo).env.uid_origin, user_demo.id)
        self.assertEqual(self.env['base'].with_user(user_demo).with_user(user_admin).env.uid_origin, user_demo.id)
        self.assertEqual(self.env['base'].with_user(user_admin).with_user(user_demo).env.uid_origin, user_admin.id)

    @mute_logger('odoo.models')
    def test_60_cache(self):
        """ Check the record cache behavior """
        Partners = self.env['res.partner']
        pids = []
        data = {
            'partner One': ['Partner One - One', 'Partner One - Two'],
            'Partner Two': ['Partner Two - One'],
            'Partner Three': ['Partner Three - One'],
        }
        for p in data:
            pids.append(Partners.create({
                'name': p,
                'child_ids': [Command.create({'name': c}) for c in data[p]],
            }).id)

        partners = Partners.search([('id', 'in', pids)])
        partner1, partner2 = partners[0], partners[1]
        children1, children2 = partner1.child_ids, partner2.child_ids
        self.assertTrue(children1)
        self.assertTrue(children2)

        # take a child contact
        child = children1[0]
        self.assertEqual(child.parent_id, partner1)
        self.assertIn(child, partner1.child_ids)
        self.assertNotIn(child, partner2.child_ids)

        # fetch data in the cache
        for p in partners:
            p.name, p.company_id.name, p.user_id.name, p.contact_address
        self.env.cache.check(self.env)

        # change its parent
        child.write({'parent_id': partner2.id})
        self.env.cache.check(self.env)

        # check recordsets
        self.assertEqual(child.parent_id, partner2)
        self.assertNotIn(child, partner1.child_ids)
        self.assertIn(child, partner2.child_ids)
        self.assertEqual(set(partner1.child_ids + child), set(children1))
        self.assertEqual(set(partner2.child_ids), set(children2 + child))
        self.env.cache.check(self.env)

        # delete it
        child.unlink()
        self.env.cache.check(self.env)

        # check recordsets
        self.assertEqual(set(partner1.child_ids), set(children1) - set([child]))
        self.assertEqual(set(partner2.child_ids), set(children2))
        self.env.cache.check(self.env)

        # convert from the cache format to the write format
        partner = partner1
        partner.country_id, partner.child_ids
        data = partner._convert_to_write(partner._cache)
        self.assertEqual(data['country_id'], partner.country_id.id)
        self.assertEqual(data['child_ids'], [Command.set(partner.child_ids.ids)])

    @mute_logger('odoo.models')
    def test_60_prefetch(self):
        """ Check the record cache prefetching """
        partners = self.env['res.partner'].search([('id', 'in', self.partners.ids)], limit=models.PREFETCH_MAX)
        self.assertTrue(len(partners) > 1)

        # all the records in partners are ready for prefetching
        self.assertItemsEqual(partners.ids, partners._prefetch_ids)

        # reading ONE partner should fetch them ALL
        for partner in partners:
            state = partner.state_id
            break
        partner_ids_with_field = [partner.id
                                  for partner in partners
                                  if 'state_id' in partner._cache]
        self.assertItemsEqual(partner_ids_with_field, partners.ids)

        # partners' states are ready for prefetching
        state_ids = {
            partner._cache['state_id']
            for partner in partners
            if partner._cache['state_id'] is not None
        }
        self.assertTrue(len(state_ids) > 1)
        self.assertItemsEqual(state_ids, state._prefetch_ids)

        # reading ONE partner country should fetch ALL partners' countries
        for partner in partners:
            if partner.state_id:
                partner.state_id.name
                break
        state_ids_with_field = [st.id for st in partners.state_id if 'name' in st._cache]
        self.assertItemsEqual(state_ids_with_field, state_ids)

    @mute_logger('odoo.models')
    def test_60_prefetch_model(self):
        """ Check the prefetching model. """
        partners = self.env['res.partner'].search([('id', 'in', self.partners.ids)], limit=models.PREFETCH_MAX)
        self.assertTrue(partners)

        def same_prefetch(a, b):
            self.assertEqual(set(a._prefetch_ids), set(b._prefetch_ids))

        def diff_prefetch(a, b):
            self.assertNotEqual(set(a._prefetch_ids), set(b._prefetch_ids))

        # the recordset operations below use different prefetch sets
        diff_prefetch(partners, partners.browse())
        diff_prefetch(partners, partners[0])
        diff_prefetch(partners, partners[:5])

        # the recordset operations below share the prefetch set
        same_prefetch(partners, partners.browse(partners.ids))
        same_prefetch(partners, partners.with_user(self.user_demo))
        same_prefetch(partners, partners.with_context(active_test=False))
        same_prefetch(partners, partners[:10].with_prefetch(partners._prefetch_ids))

        # iteration and relational fields should use the same prefetch set
        self.assertEqual(type(partners).country_id.type, 'many2one')
        self.assertEqual(type(partners).bank_ids.type, 'one2many')
        self.assertEqual(type(partners).category_id.type, 'many2many')

        vals0 = {
            'name': 'Empty relational fields',
            'country_id': False,
            'bank_ids': [],
            'category_id': [],
        }
        vals1 = {
            'name': 'Non-empty relational fields',
            'country_id': self.ref('base.be'),
            'bank_ids': [Command.create({'acc_number': 'FOO42'})],
            'category_id': [Command.link(self.partner_category.id)],
        }
        partners = partners.create(vals0) + partners.create(vals1)
        for partner in partners:
            same_prefetch(partner, partners)
            same_prefetch(partner.country_id, partners.country_id)
            same_prefetch(partner.bank_ids, partners.bank_ids)
            same_prefetch(partner.category_id, partners.category_id)

    @mute_logger('odoo.models')
    def test_60_prefetch_read(self):
        """ Check that reading a field computes it on self only. """
        Partner = self.env['res.partner']
        field = type(Partner).company_type
        self.assertTrue(field.compute and not field.store)

        partner1 = Partner.create({'name': 'Foo'})
        partner2 = Partner.create({'name': 'Bar', 'parent_id': partner1.id})
        self.assertEqual(partner1.child_ids, partner2)

        # reading partner1 should not prefetch 'company_type' on partner2
        self.env.clear()
        partner1 = partner1.with_prefetch()
        partner1.read(['company_type'])
        self.assertIn('company_type', partner1._cache)
        self.assertNotIn('company_type', partner2._cache)

        # reading partner1 should not prefetch 'company_type' on partner2
        self.env.clear()
        partner1 = partner1.with_prefetch()
        partner1.read(['child_ids', 'company_type'])
        self.assertIn('company_type', partner1._cache)
        self.assertNotIn('company_type', partner2._cache)

    def test_60_reversed(self):
        records = self.partners
        self.assertGreater(len(records), 1)

        # check order
        self.assertEqual(list(reversed(records)), list(reversed(list(records))))

        first = next(iter(records))
        last = next(reversed(records))
        self.assertEqual(first, records[0])
        self.assertEqual(last, records[-1])

        # check prefetching
        prefetch_ids = records.ids
        reversed_ids = [record.id for record in reversed(records)]

        self.assertEqual(list(first._prefetch_ids), prefetch_ids)
        self.assertEqual(list(last._prefetch_ids), reversed_ids)

        self.assertEqual(list(reversed(first._prefetch_ids)), reversed_ids)
        self.assertEqual(list(reversed(last._prefetch_ids)), prefetch_ids)

        # check prefetching across many2one field
        prefetch_ids = records.state_id.ids
        reversed_ids = list(unique(
            record.state_id.id
            for record in reversed(records)
            if record.state_id
        ))

        self.assertEqual(list(first.state_id._prefetch_ids), prefetch_ids)
        self.assertEqual(list(last.state_id._prefetch_ids), reversed_ids)

        self.assertEqual(list(reversed(first.state_id._prefetch_ids)), reversed_ids)
        self.assertEqual(list(reversed(last.state_id._prefetch_ids)), prefetch_ids)

        # check prefetching across x2many field
        prefetch_ids = records.child_ids.ids
        reversed_ids = list(unique(
            child.id
            for record in reversed(records)
            for child in record.child_ids
        ))

        self.assertEqual(list(first.child_ids._prefetch_ids), prefetch_ids)
        self.assertEqual(list(last.child_ids._prefetch_ids), reversed_ids)

        self.assertEqual(list(reversed(first.child_ids._prefetch_ids)), reversed_ids)
        self.assertEqual(list(reversed(last.child_ids._prefetch_ids)), prefetch_ids)

    @mute_logger('odoo.models')
    def test_70_one(self):
        """ Check method one(). """
        # check with many records
        ps = self.env['res.partner'].search([('name', 'ilike', 'a'), ('id', 'in', self.partners.ids)])
        self.assertTrue(len(ps) > 1)
        with self.assertRaises(ValueError):
            ps.ensure_one()

        p1 = ps[0]
        self.assertEqual(len(p1), 1)
        self.assertEqual(p1.ensure_one(), p1)

        p0 = self.env['res.partner'].browse()
        self.assertEqual(len(p0), 0)
        with self.assertRaises(ValueError):
            p0.ensure_one()

    @mute_logger('odoo.models')
    def test_80_contains(self):
        """ Test membership on recordset. """
        p1 = self.partners[0]
        ps = self.partners
        self.assertTrue(p1 in ps)

        with self.assertRaisesRegex(TypeError, r"unsupported operand types in: 42 in res\.partner.*"):
            42 in ps
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: ir\.ui\.menu.* in res\.partner.*"):
            self.env['ir.ui.menu'] in ps

    @mute_logger('odoo.models')
    def test_80_lazy_contains(self):
        """ Test membership on recordset. """
        p1 = lazy(lambda: self.partners[0])
        ps = lazy(lambda: self.partners)
        self.assertTrue(p1 in ps)

        with self.assertRaisesRegex(TypeError, r"unsupported operand types in: 42 in res\.partner.*"):
            lazy(lambda: 42) in ps
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: ir\.ui\.menu.* in res\.partner.*"):
            lazy(lambda: self.env['ir.ui.menu']) in ps

    @mute_logger('odoo.models')
    def test_80_set_operations(self):
        """ Check set operations on recordsets. """
        pa = self.env['res.partner'].search([('name', 'ilike', 'a'), ('id', 'in', self.partners.ids)])
        pb = self.env['res.partner'].search([('name', 'ilike', 'b'), ('id', 'in', self.partners.ids)])

        self.assertTrue(pa)
        self.assertTrue(pb)
        self.assertTrue(set(pa) & set(pb))

        concat = pa + pb
        self.assertEqual(list(concat), list(pa) + list(pb))
        self.assertEqual(len(concat), len(pa) + len(pb))

        difference = pa - pb
        self.assertEqual(len(difference), len(set(difference)))
        self.assertEqual(set(difference), set(pa) - set(pb))
        self.assertLessEqual(difference, pa)

        intersection = pa & pb
        self.assertEqual(len(intersection), len(set(intersection)))
        self.assertEqual(set(intersection), set(pa) & set(pb))
        self.assertLessEqual(intersection, pa)
        self.assertLessEqual(intersection, pb)

        union = pa | pb
        self.assertEqual(len(union), len(set(union)))
        self.assertEqual(set(union), set(pa) | set(pb))
        self.assertGreaterEqual(union, pa)
        self.assertGreaterEqual(union, pb)

        # one cannot mix different models with set operations
        ps = pa
        ms = self.env['ir.ui.menu'].search([])
        self.assertNotEqual(ps._name, ms._name)
        self.assertNotEqual(ps, ms)

        with self.assertRaisesRegex(TypeError, r"unsupported operand types in: res\.partner.* \+ 'string'"):
            ps + 'string'
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* \+ ir\.ui\.menu.*"):
            ps + ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* - ir\.ui\.menu.*"):
            ps - ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* & ir\.ui\.menu.*"):
            ps & ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* \| ir\.ui\.menu.*"):
            ps | ms
        with self.assertRaises(TypeError):
            ps < ms
        with self.assertRaises(TypeError):
            ps <= ms
        with self.assertRaises(TypeError):
            ps > ms
        with self.assertRaises(TypeError):
            ps >= ms

    @mute_logger('odoo.models')
    def test_80_lazy_set_operations(self):
        """ Check set operations on recordsets. """
        pa = lazy(lambda: self.env['res.partner'].search([('name', 'ilike', 'a'), ('id', 'in', self.partners.ids)]))
        pb = lazy(lambda: self.env['res.partner'].search([('name', 'ilike', 'b'), ('id', 'in', self.partners.ids)]))

        self.assertTrue(pa)
        self.assertTrue(pb)
        self.assertTrue(set(pa) & set(pb))

        concat = pa + pb
        self.assertEqual(list(concat), list(pa) + list(pb))
        self.assertEqual(len(concat), len(pa) + len(pb))

        difference = pa - pb
        self.assertEqual(len(difference), len(set(difference)))
        self.assertEqual(set(difference), set(pa) - set(pb))
        self.assertLessEqual(difference, pa)

        intersection = pa & pb
        self.assertEqual(len(intersection), len(set(intersection)))
        self.assertEqual(set(intersection), set(pa) & set(pb))
        self.assertLessEqual(intersection, pa)
        self.assertLessEqual(intersection, pb)

        union = pa | pb
        self.assertEqual(len(union), len(set(union)))
        self.assertEqual(set(union), set(pa) | set(pb))
        self.assertGreaterEqual(union, pa)
        self.assertGreaterEqual(union, pb)

        # one cannot mix different models with set operations
        ps = pa
        ms = lazy(lambda: self.env['ir.ui.menu'].search([]))
        self.assertNotEqual(ps._name, ms._name)
        self.assertNotEqual(ps, ms)

        with self.assertRaisesRegex(TypeError, r"unsupported operand types in: res\.partner.* \+ 'string'"):
            ps + 'string'
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* \+ ir\.ui\.menu.*"):
            ps + ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* - ir\.ui\.menu.*"):
            ps - ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* & ir\.ui\.menu.*"):
            ps & ms
        with self.assertRaisesRegex(TypeError, r"inconsistent models in: res\.partner.* \| ir\.ui\.menu.*"):
            ps | ms
        with self.assertRaises(TypeError):
            ps < ms
        with self.assertRaises(TypeError):
            ps <= ms
        with self.assertRaises(TypeError):
            ps > ms
        with self.assertRaises(TypeError):
            ps >= ms

    @mute_logger('odoo.models')
    def test_80_filter(self):
        """ Check filter on recordsets. """
        ps = self.partners
        customers = ps.browse([p.id for p in ps if p.employee])

        # filter on a single field
        self.assertEqual(ps.filtered(lambda p: p.employee), customers)
        self.assertEqual(ps.filtered('employee'), customers)

        # filter on a sequence of fields
        self.assertEqual(
            ps.filtered(lambda p: p.parent_id.employee),
            ps.filtered('parent_id.employee')
        )

    @mute_logger('odoo.models')
    def test_80_map(self):
        """ Check map on recordsets. """
        ps = self.partners
        parents = ps.browse()
        for p in ps:
            parents |= p.parent_id

        # map a single field
        self.assertEqual(ps.mapped(lambda p: p.parent_id), parents)
        self.assertEqual(ps.mapped('parent_id'), parents)
        self.assertEqual(ps.parent_id, parents)

        # map a sequence of fields
        self.assertEqual(
            ps.mapped(lambda p: p.parent_id.name),
            [p.parent_id.name for p in ps]
        )
        self.assertEqual(
            ps.mapped('parent_id.name'),
            [p.name for p in parents]
        )
        self.assertEqual(
            ps.parent_id.mapped('name'),
            [p.name for p in parents]
        )

        # map an empty sequence of fields
        self.assertEqual(ps.mapped(''), ps)

    @mute_logger('odoo.models')
    def test_80_sorted(self):
        """ Check sorted on recordsets. """
        ps = self.env['res.partner'].search([('id', 'in', self.partners.ids)])

        # sort by model order
        qs = ps[:len(ps) // 2] + ps[len(ps) // 2:]
        self.assertEqual(qs.sorted().ids, ps.ids)

        # sort by name, with a function or a field name
        by_name_ids = [p.id for p in sorted(ps, key=lambda p: p.name)]
        self.assertEqual(ps.sorted(lambda p: p.name).ids, by_name_ids)
        self.assertEqual(ps.sorted('name').ids, by_name_ids)

        # sort by inverse name, with a field name
        by_name_ids = [p.id for p in sorted(ps, key=lambda p: p.name, reverse=True)]
        self.assertEqual(ps.sorted('name', reverse=True).ids, by_name_ids)

        # sorted doesn't filter out new records but don't sort them either (limitation)
        new_p = self.env['res.partner'].new({
            'child_ids': [
                Command.create({'name': 'z'}),
                Command.create({'name': 'a'}),
            ],
        })
        self.assertEqual(len(new_p.child_ids.sorted()), 2)

        # sorted keeps the _prefetch_ids
        partners_with_children = self.env['res.partner'].create([
            {
                'name': 'required',
                'child_ids': [
                    Command.create({'name': 'z'}),
                    Command.create({'name': 'a'}),
                ],
            },
            {
                'name': 'required',
                'child_ids': [
                    Command.create({'name': 'z'}),
                    Command.create({'name': 'a'}),
                ],
            },
        ])
        partners_with_children.invalidate_model(['name'])
        # Only one query to fetch name of children of each partner
        with self.assertQueryCount(1):
            for partner in partners_with_children:
                partner.child_ids.sorted('id').mapped('name')

    def test_group_on(self):
        p0, p1, p2 = self.env['res.partner'].create([
            {'name': "bob", 'function': "guest"},
            {'name': "james", 'function': "host"},
            {'name': "rhod", 'function': "guest"}
        ])
        pn = self.env['res.partner'].new({'name': 'alex', 'function': "host"})

        with self.subTest("Should work with mixes of db and new records"):
            self.assertEqual(
                (p0 | p1 | p2 | pn).grouped('function'),
                {'guest': p0 | p2, 'host': p1 | pn}
            )
            self.assertEqual(
                (p0 | p1 | p2 | pn).grouped(lambda r: len(r.name)),
                {3: p0, 4: p2 | pn, 5: p1},
            )

        with self.subTest("Should allow cross-group prefetching"):
            byfn = (p0 | p1 | p2).grouped('function')
            self.env.invalidate_all(flush=False)
            self.assertFalse(self.env.cache._data, "ensure the cache is empty")
            self.assertEqual(byfn['guest'].mapped('name'), ['bob', 'rhod'])
            # name should have been prefetched by previous statement (on guest
            # group), so should be nothing here
            with self.assertQueries([]):
                _ = byfn['host'].name


class TestExternalAPI(SavepointCaseWithUserDemo):

    def test_call_kw(self):
        """kwargs is not modified by the execution of the call"""
        partner = self.env['res.partner'].create({'name': 'MyPartner1'})
        args = (partner.ids, ['name'])
        kwargs = {'context': {'test': True}}
        api.call_kw(self.env['res.partner'], 'read', args, kwargs)
        self.assertEqual(kwargs, {'context': {'test': True}})

```

  File: tests/test_avatar_mixin.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from base64 import b64decode

from odoo.tests.common import TransactionCase

class TestAvatarMixin(TransactionCase):

    """ tests the avatar mixin """
    def setUp(self):
        super().setUp()
        # Set partner manually to fake seed create_date
        partner_without_image = self.env['res.partner'].create({'name': 'Marc Demo', 'create_date': '2015-11-12 00:00:00'})
        self.user_without_image = self.env['res.users'].create({
            'name': 'Marc Demo',
            'email': 'mark.brown23@example.com',
            'image_1920': False,
            'create_date': '2015-11-12 00:00:00',
            'login': 'demo_1',
            'password': 'demo_1',
            'partner_id': partner_without_image.id,
        })
        self.user_without_name = self.env['res.users'].create({
            'name': '',
            'email': 'marc.grey25@example.com',
            'image_1920': False,
            'login': 'marc_1',
            'password': 'marc_1',
        })
        self.external_partner = self.env['res.partner'].create({
            'name': 'Josh Demo',
            'email': 'josh.brown23@example.com',
            'image_1920': False
        })

    def test_partner_has_avatar_even_if_it_has_no_image(self):
        self.assertTrue(self.user_without_image.partner_id.avatar_128)
        self.assertTrue(self.user_without_image.partner_id.avatar_256)
        self.assertTrue(self.user_without_image.partner_id.avatar_512)
        self.assertTrue(self.user_without_image.partner_id.avatar_1024)
        self.assertTrue(self.user_without_image.partner_id.avatar_1920)

    def test_content_of_generated_partner_avatar(self):
        expectedAvatar = (
            "<?xml version='1.0' encoding='UTF-8' ?>"
            "<svg height='180' width='180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>"
            "<rect fill='hsl(184, 40%, 45%)' height='180' width='180'/>"
            "<text fill='#ffffff' font-size='96' text-anchor='middle' x='90' y='125' font-family='sans-serif'>M</text>"
            "</svg>"
        )
        self.assertEqual(expectedAvatar, b64decode(self.user_without_image.partner_id.avatar_1920).decode('utf-8'))

    def test_partner_without_name_has_default_placeholder_image_as_avatar(self):
        self.assertEqual(self.user_without_name.partner_id._avatar_get_placeholder(), b64decode(self.user_without_name.partner_id.avatar_1920))

    def test_external_partner_has_default_placeholder_image_as_avatar(self):
        self.assertEqual(self.external_partner._avatar_get_placeholder(), b64decode(self.external_partner.avatar_1920))

    def test_partner_and_user_have_the_same_avatar(self):
        self.assertEqual(self.user_without_image.partner_id.avatar_1920, self.user_without_image.avatar_1920)

```

  File: tests/test_barcode.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo.tools import check_barcode_encoding, get_barcode_check_digit


class TestBarcode(TransactionCase):
    def test_barcode_check_digit(self):
        ean8 = "87111125"
        self.assertEqual(get_barcode_check_digit("0" * 10 + ean8), int(ean8[-1]))
        ean13 = "1234567891231"
        self.assertEqual(get_barcode_check_digit("0" * 5 + ean13), int(ean13[-1]))

    def test_barcode_encoding(self):
        self.assertTrue(check_barcode_encoding('20220006', 'ean8'))
        self.assertTrue(check_barcode_encoding('93855341', 'ean8'))
        self.assertTrue(check_barcode_encoding('2022071416014', 'ean13'))
        self.assertTrue(check_barcode_encoding('9745213796142', 'ean13'))

        self.assertFalse(check_barcode_encoding('2022a006', 'ean8'), 'should contains digits only')
        self.assertFalse(check_barcode_encoding('20220000', 'ean8'), 'incorrect check digit')
        self.assertFalse(check_barcode_encoding('93855341', 'ean13'), 'ean13 is a 13-digits barcode')
        self.assertFalse(check_barcode_encoding('9745213796142', 'ean8'), 'ean8 is a 8-digits barcode')
        self.assertFalse(check_barcode_encoding('9745213796148', 'ean13'), 'incorrect check digit')
        self.assertFalse(check_barcode_encoding('2022!71416014', 'ean13'), 'should contains digits only')
        self.assertFalse(check_barcode_encoding('0022071416014', 'ean13'), 'when starting with one zero, it indicates that a 12-digit UPC-A code follows')

```

  File: tests/test_base.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast

from textwrap import dedent

from odoo import Command
from odoo.tests.common import TransactionCase, BaseCase
from odoo.tools import mute_logger
from odoo.tools.safe_eval import safe_eval, const_eval, expr_eval
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo


class TestSafeEval(BaseCase):
    def test_const(self):
        # NB: True and False are names in Python 2 not consts
        expected = (1, {"a": {2.5}}, [None, u"foo"])
        actual = const_eval('(1, {"a": {2.5}}, [None, u"foo"])')
        self.assertEqual(actual, expected)
        # Test RETURN_CONST
        self.assertEqual(const_eval('10'), 10)

    def test_expr(self):
        # NB: True and False are names in Python 2 not consts
        expected = 3 * 4
        actual = expr_eval('3 * 4')
        self.assertEqual(actual, expected)

    def test_expr_eval_opcodes(self):
        for expr, expected in [
            ('3', 3),  # RETURN_CONST
            ('[1,2,3,4][1:3]', [2, 3]),  # BINARY_SLICE
        ]:
            self.assertEqual(expr_eval(expr), expected)

    def test_safe_eval_opcodes(self):
        for expr, locals_dict, expected in [
            ('[x for x in (1,2)]', {}, [1, 2]),  # LOAD_FAST_AND_CLEAR
            ('list(x for x in (1,2))', {}, [1, 2]),  # END_FOR, CALL_INTRINSIC_1
            ('v if v is None else w', {'v': False, 'w': 'foo'}, 'foo'),  # POP_JUMP_IF_NONE
            ('v if v is not None else w', {'v': None, 'w': 'foo'}, 'foo'),  # POP_JUMP_IF_NOT_NONE
            ('{a for a in (1, 2)}', {}, {1, 2}),  # RERAISE
        ]:
            self.assertEqual(safe_eval(expr, locals_dict=locals_dict), expected)

    def test_safe_eval_exec_opcodes(self):
        for expr, locals_dict, expected in [
            ("""
                def f(v):
                    if v:
                        x = 1
                    return x
                result = f(42)
            """, {}, 1),  # LOAD_FAST_CHECK
        ]:
            safe_eval(dedent(expr), locals_dict=locals_dict, mode="exec", nocopy=True)
            self.assertEqual(locals_dict['result'], expected)

    def test_01_safe_eval(self):
        """ Try a few common expressions to verify they work with safe_eval """
        expected = (1, {"a": 9 * 2}, (True, False, None))
        actual = safe_eval('(1, {"a": 9 * 2}, (True, False, None))')
        self.assertEqual(actual, expected, "Simple python expressions are not working with safe_eval")

    def test_02_literal_eval(self):
        """ Try simple literal definition to verify it works with literal_eval """
        expected = (1, {"a": 9}, (True, False, None))
        actual = ast.literal_eval('(1, {"a": 9}, (True, False, None))')
        self.assertEqual(actual, expected, "Simple python expressions are not working with literal_eval")

    def test_03_literal_eval_arithmetic(self):
        """ Try arithmetic expression in literal_eval to verify it does not work """
        with self.assertRaises(ValueError):
           ast.literal_eval('(1, {"a": 2*9}, (True, False, None))')

    def test_04_literal_eval_forbidden(self):
        """ Try forbidden expressions in literal_eval to verify they are not allowed """
        with self.assertRaises(ValueError):
           ast.literal_eval('{"a": True.__class__}')

    @mute_logger('odoo.tools.safe_eval')
    def test_05_safe_eval_forbiddon(self):
        """ Try forbidden expressions in safe_eval to verify they are not allowed"""
        # no forbidden builtin expression
        with self.assertRaises(ValueError):
            safe_eval('open("/etc/passwd","r")')

        # no forbidden opcodes
        with self.assertRaises(ValueError):
            safe_eval("import odoo", mode="exec")

        # no dunder
        with self.assertRaises(NameError):
            safe_eval("self.__name__", {'self': self}, mode="exec")


class TestParentStore(TransactionCase):
    """ Verify that parent_store computation is done right """

    def setUp(self):
        super(TestParentStore, self).setUp()

        # force res_partner_category.copy() to copy children
        category = self.env['res.partner.category']
        self.patch(category._fields['child_ids'], 'copy', True)

        # setup categories
        self.root = category.create({'name': 'Root category'})
        self.cat0 = category.create({'name': 'Parent category', 'parent_id': self.root.id})
        self.cat1 = category.create({'name': 'Child 1', 'parent_id': self.cat0.id})
        self.cat2 = category.create({'name': 'Child 2', 'parent_id': self.cat0.id})
        self.cat21 = category.create({'name': 'Child 2-1', 'parent_id': self.cat2.id})

    def test_duplicate_parent(self):
        """ Duplicate the parent category and verify that the children have been duplicated too """
        new_cat0 = self.cat0.copy()
        new_struct = new_cat0.search([('parent_id', 'child_of', new_cat0.id)])
        self.assertEqual(len(new_struct), 4, "After duplication, the new object must have the childs records")
        old_struct = new_cat0.search([('parent_id', 'child_of', self.cat0.id)])
        self.assertEqual(len(old_struct), 4, "After duplication, previous record must have old childs records only")
        self.assertFalse(new_struct & old_struct, "After duplication, nodes should not be mixed")

    def test_duplicate_children_01(self):
        """ Duplicate the children then reassign them to the new parent (1st method). """
        new_cat1 = self.cat1.copy()
        new_cat2 = self.cat2.copy()
        new_cat0 = self.cat0.copy({'child_ids': []})
        (new_cat1 + new_cat2).write({'parent_id': new_cat0.id})
        new_struct = new_cat0.search([('parent_id', 'child_of', new_cat0.id)])
        self.assertEqual(len(new_struct), 4, "After duplication, the new object must have the childs records")
        old_struct = new_cat0.search([('parent_id', 'child_of', self.cat0.id)])
        self.assertEqual(len(old_struct), 4, "After duplication, previous record must have old childs records only")
        self.assertFalse(new_struct & old_struct, "After duplication, nodes should not be mixed")

    def test_duplicate_children_02(self):
        """ Duplicate the children then reassign them to the new parent (2nd method). """
        new_cat1 = self.cat1.copy()
        new_cat2 = self.cat2.copy()
        new_cat0 = self.cat0.copy({'child_ids': [Command.set((new_cat1 + new_cat2).ids)]})
        new_struct = new_cat0.search([('parent_id', 'child_of', new_cat0.id)])
        self.assertEqual(len(new_struct), 4, "After duplication, the new object must have the childs records")
        old_struct = new_cat0.search([('parent_id', 'child_of', self.cat0.id)])
        self.assertEqual(len(old_struct), 4, "After duplication, previous record must have old childs records only")
        self.assertFalse(new_struct & old_struct, "After duplication, nodes should not be mixed")

    def test_duplicate_children_03(self):
        """ Duplicate the children then reassign them to the new parent (3rd method). """
        new_cat1 = self.cat1.copy()
        new_cat2 = self.cat2.copy()
        new_cat0 = self.cat0.copy({'child_ids': []})
        new_cat0.write({'child_ids': [Command.link(new_cat1.id), Command.link(new_cat2.id)]})
        new_struct = new_cat0.search([('parent_id', 'child_of', new_cat0.id)])
        self.assertEqual(len(new_struct), 4, "After duplication, the new object must have the childs records")
        old_struct = new_cat0.search([('parent_id', 'child_of', self.cat0.id)])
        self.assertEqual(len(old_struct), 4, "After duplication, previous record must have old childs records only")
        self.assertFalse(new_struct & old_struct, "After duplication, nodes should not be mixed")


class TestGroups(TransactionCase):

    def test_res_groups_fullname_search(self):
        all_groups = self.env['res.groups'].search([])

        groups = all_groups.search([('full_name', 'like', 'Sale')])
        self.assertItemsEqual(groups.ids, [g.id for g in all_groups if 'Sale' in g.full_name],
                              "did not match search for 'Sale'")

        groups = all_groups.search([('full_name', 'like', 'Technical')])
        self.assertItemsEqual(groups.ids, [g.id for g in all_groups if 'Technical' in g.full_name],
                              "did not match search for 'Technical'")

        groups = all_groups.search([('full_name', 'like', 'Sales /')])
        self.assertItemsEqual(groups.ids, [g.id for g in all_groups if 'Sales /' in g.full_name],
                              "did not match search for 'Sales /'")

        groups = all_groups.search([('full_name', 'in', ['Administration / Access Rights','Contact Creation'])])
        self.assertTrue(groups, "did not match search for 'Administration / Access Rights' and 'Contact Creation'")

    def test_res_group_recursion(self):
        # four groups with no cycle, check them all together
        a = self.env['res.groups'].create({'name': 'A'})
        b = self.env['res.groups'].create({'name': 'B'})
        c = self.env['res.groups'].create({'name': 'G', 'implied_ids': [Command.set((a + b).ids)]})
        d = self.env['res.groups'].create({'name': 'D', 'implied_ids': [Command.set(c.ids)]})
        self.assertTrue((a + b + c + d)._check_m2m_recursion('implied_ids'))

        # create a cycle and check
        a.implied_ids = d
        self.assertFalse(a._check_m2m_recursion('implied_ids'))

    def test_res_group_copy(self):
        a = self.env['res.groups'].with_context(lang='en_US').create({'name': 'A'})
        b = a.copy()
        self.assertFalse(a.name == b.name)

    def test_apply_groups(self):
        a = self.env['res.groups'].create({'name': 'A'})
        b = self.env['res.groups'].create({'name': 'B'})
        c = self.env['res.groups'].create({'name': 'C', 'implied_ids': [Command.set(a.ids)]})

        # C already implies A, we want both B+C to imply A
        (b + c)._apply_group(a)

        self.assertIn(a, b.implied_ids)
        self.assertIn(a, c.implied_ids)

    def test_remove_groups(self):
        u1 = self.env['res.users'].create({'login': 'u1', 'name': 'U1'})
        u2 = self.env['res.users'].create({'login': 'u2', 'name': 'U2'})
        default = self.env.ref('base.default_user')
        portal = self.env.ref('base.group_portal')
        p = self.env['res.users'].create({'login': 'p', 'name': 'P', 'groups_id': [Command.set([portal.id])]})

        a = self.env['res.groups'].create({'name': 'A', 'users': [Command.set(u1.ids)]})
        b = self.env['res.groups'].create({'name': 'B', 'users': [Command.set(u1.ids)]})
        c = self.env['res.groups'].create({'name': 'C', 'implied_ids': [Command.set(a.ids)], 'users': [Command.set([p.id, u2.id, default.id])]})
        d = self.env['res.groups'].create({'name': 'D', 'implied_ids': [Command.set(a.ids)], 'users': [Command.set([u2.id, default.id])]})

        def assertUsersEqual(users, group):
            self.assertEqual(
                sorted([r.login for r in users]),
                sorted([r.login for r in group.with_context(active_test=False).users])
            )
        # sanity checks
        assertUsersEqual([u1, u2, p, default], a)
        assertUsersEqual([u1], b)
        assertUsersEqual([u2, p, default], c)
        assertUsersEqual([u2, default], d)

        # C already implies A, we want none of B+C to imply A
        (b + c)._remove_group(a)

        self.assertNotIn(a, b.implied_ids)
        self.assertNotIn(a, c.implied_ids)
        self.assertIn(a, d.implied_ids)

        # - Since B didn't imply A, removing A from the implied groups of (B+C)
        #   should not remove user U1 from A, even though C implied A, since C does
        #   not have U1 as a user
        # - P should be removed as was only added via inheritance to C
        # - U2 should not be removed from A since it is implied via C but also via D
        assertUsersEqual([u1, u2, default], a)
        assertUsersEqual([u1], b)
        assertUsersEqual([u2, p, default], c)
        assertUsersEqual([u2, default], d)

        # When adding the template user to a new group, it should add it to existing internal users
        e = self.env['res.groups'].create({'name': 'E'})
        default.write({'groups_id': [Command.link(e.id)]})
        self.assertIn(u1, e.users)
        self.assertIn(u2, e.users)
        self.assertIn(default, e.with_context(active_test=False).users)
        self.assertNotIn(p, e.users)

```

  File: tests/test_basecase.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests import common


class TestSingleTransactionCase(common.SingleTransactionCase):
    """
    Check the whole-class transaction behavior of SingleTransactionCase.
    """

    def test_00(self):
        """ Create a partner. """
        self.env['res.partner'].create({'name': 'test_per_class_teardown_partner'})
        partners = self.env['res.partner'].search([('name', '=', 'test_per_class_teardown_partner')])
        self.assertEqual(1, len(partners), "Test partner not found.")

    def test_01(self):
        """ Find the created partner. """
        partners = self.env['res.partner'].search([('name', '=', 'test_per_class_teardown_partner')])
        self.assertEqual(1, len(partners), "Test partner not found.")

    def test_20a(self):
        """ Create a partner with a XML ID """
        pid, _ = self.env['res.partner'].name_create('Mr Blue')
        self.env['ir.model.data'].create({'name': 'test_partner_blue',
                                          'module': 'base',
                                          'model': 'res.partner',
                                          'res_id': pid})

    def test_20b(self):
        """ Resolve xml id with ref() and browse_ref() """
        xid = 'base.test_partner_blue'
        partner = self.env.ref(xid)
        pid = self.ref(xid)
        self.assertTrue(pid, "ref() should resolve xid to database ID")
        self.assertEqual(pid, partner.id, "ref() is not consistent with env.ref()")
        partner2 = self.browse_ref(xid)
        self.assertEqual(partner, partner2, "browse_ref() should resolve xid to browse records")


class TestTransactionCase(common.TransactionCase):
    """
    Check the per-method transaction behavior of TransactionCase.
    """

    def test_00(self):
        """ Create a partner. """
        partners = self.env['res.partner'].search([('name', '=', 'test_per_class_teardown_partner')])
        self.assertEqual(0, len(partners), "Test partner found.")
        self.env['res.partner'].create({'name': 'test_per_class_teardown_partner'})
        partners = self.env['res.partner'].search([('name', '=', 'test_per_class_teardown_partner')])
        self.assertEqual(1, len(partners), "Test partner not found.")

    def test_01(self):
        """ Don't find the created partner. """
        partners = self.env['res.partner'].search([('name', '=', 'test_per_class_teardown_partner')])
        self.assertEqual(0, len(partners), "Test partner found.")

    def test_20a(self):
        """ Create a partner with a XML ID then resolve xml id with ref() and browse_ref() """
        pid, _ = self.env['res.partner'].name_create('Mr Yellow')
        self.env['ir.model.data'].create({'name': 'test_partner_yellow',
                                          'module': 'base',
                                          'model': 'res.partner',
                                          'res_id': pid})
        xid = 'base.test_partner_yellow'
        partner = self.env.ref(xid)
        pid = self.ref(xid)
        self.assertEqual(pid, partner.id, "ref() should resolve xid to database ID")
        partner2 = self.browse_ref(xid)
        self.assertEqual(partner, partner2, "browse_ref() should resolve xid to browse records")

```

  File: tests/test_cache.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import os
import platform
import psutil
import unittest

from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.exceptions import CacheMiss
from odoo.tests.common import TransactionCase


class TestRecordCache(TransactionCaseWithUserDemo):

    def test_cache(self):
        """ Check the record cache object. """
        Model = self.env['res.partner']
        name = type(Model).name
        ref = type(Model).ref

        cache = self.env.cache

        def check1(record, field, value):
            # value is None means no value in cache
            self.assertEqual(cache.contains(record, field), value is not None)
            try:
                self.assertEqual(cache.get(record, field), value)
                self.assertIsNotNone(value)
            except CacheMiss:
                self.assertIsNone(value)
            self.assertEqual(field in cache.get_fields(record), value is not None)
            self.assertEqual(record in cache.get_records(record, field), value is not None)

        def check(record, name_val, ref_val):
            """ check the values of fields 'name' and 'ref' on record. """
            check1(record, name, name_val)
            check1(record, ref, ref_val)

        foo1, bar1 = Model.browse([1, 2])
        foo2, bar2 = Model.with_user(self.user_demo).browse([1, 2])
        self.assertNotEqual(foo1.env.uid, foo2.env.uid)

        # cache is empty
        cache.invalidate()
        check(foo1, None, None)
        check(foo2, None, None)
        check(bar1, None, None)
        check(bar2, None, None)

        self.assertCountEqual(cache.get_missing_ids(foo1 + bar1, name), [1, 2])
        self.assertCountEqual(cache.get_missing_ids(foo2 + bar2, name), [1, 2])

        # set values in one environment only
        cache.set(foo1, name, 'FOO1_NAME')
        cache.set(foo1, ref, 'FOO1_REF')
        cache.set(bar1, name, 'BAR1_NAME')
        cache.set(bar1, ref, 'BAR1_REF')
        check(foo1, 'FOO1_NAME', 'FOO1_REF')
        check(foo2, 'FOO1_NAME', 'FOO1_REF')
        check(bar1, 'BAR1_NAME', 'BAR1_REF')
        check(bar2, 'BAR1_NAME', 'BAR1_REF')
        self.assertCountEqual(cache.get_missing_ids(foo1 + bar1, name), [])
        self.assertCountEqual(cache.get_missing_ids(foo2 + bar2, name), [])

        # set values in both environments
        cache.set(foo2, name, 'FOO2_NAME')
        cache.set(foo2, ref, 'FOO2_REF')
        cache.set(bar2, name, 'BAR2_NAME')
        cache.set(bar2, ref, 'BAR2_REF')
        check(foo1, 'FOO2_NAME', 'FOO2_REF')
        check(foo2, 'FOO2_NAME', 'FOO2_REF')
        check(bar1, 'BAR2_NAME', 'BAR2_REF')
        check(bar2, 'BAR2_NAME', 'BAR2_REF')
        self.assertCountEqual(cache.get_missing_ids(foo1 + bar1, name), [])
        self.assertCountEqual(cache.get_missing_ids(foo2 + bar2, name), [])

        # remove value in one environment
        cache.remove(foo1, name)
        check(foo1, None, 'FOO2_REF')
        check(foo2, None, 'FOO2_REF')
        check(bar1, 'BAR2_NAME', 'BAR2_REF')
        check(bar2, 'BAR2_NAME', 'BAR2_REF')
        self.assertCountEqual(cache.get_missing_ids(foo1 + bar1, name), [1])
        self.assertCountEqual(cache.get_missing_ids(foo2 + bar2, name), [1])

        # partial invalidation
        cache.invalidate([(name, None), (ref, foo1.ids)])
        check(foo1, None, None)
        check(foo2, None, None)
        check(bar1, None, 'BAR2_REF')
        check(bar2, None, 'BAR2_REF')

        # total invalidation
        cache.invalidate()
        check(foo1, None, None)
        check(foo2, None, None)
        check(bar1, None, None)
        check(bar2, None, None)

    @unittest.skipIf(
        not(platform.system() == 'Linux' and platform.machine() == 'x86_64'),
        "This test only makes sense on 64-bit Linux-like systems",
    )
    def test_memory(self):
        """ Check memory consumption of the cache. """
        NB_RECORDS = 100000
        MAX_MEMORY = 100

        cache = self.env.cache
        model = self.env['res.partner']
        records = [model.new() for index in range(NB_RECORDS)]

        process = psutil.Process(os.getpid())
        rss0 = process.memory_info().rss

        char_names = [
            'name', 'display_name', 'email', 'website', 'phone', 'mobile',
            'street', 'street2', 'city', 'zip', 'vat', 'ref',
        ]
        for name in char_names:
            field = model._fields[name]
            for record in records:
                cache.set(record, field, 'test')

        mem_usage = process.memory_info().rss - rss0
        self.assertLess(
            mem_usage, MAX_MEMORY * 1024 * 1024,
            "Caching %s records must take less than %sMB of memory" % (NB_RECORDS, MAX_MEMORY),
        )

```

  File: tests/test_cloc.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo.tools import cloc
from odoo.tests import TransactionCase, tagged

XML_TEST = """<!-- Comment -->
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <node>Line</node>
    <!-- Comment -->
    <node>Line</node>
    <!-- Comment
        Multi
    Line -->
    <![CDATA[
        Line
    ]]>
    <![CDATA[
        <!-- comment in CDATA -->
        cdata Line
    yes6]]>
    <![CDATA[<!-- not a comment-->]]>
    <![CDATA[<!-- not a comment
     but counted as is
    -->]]>
    <!-- <![CDATA[ This is a valid comment ]]> -->
    <!-- <![CDATA[ Multi line
    comment]]> -->
    <record id="my_id" model="model">
        <field name="name">name</field>
    </record>
    <![CDATA[ <!-- no a comment]]>
    <node>not a comment but found as is</node>
    <!-- comment -->
    <node>After closed comment back to normal</node>
</odoo>
"""

PY_TEST_NO_RETURN = '''line = 1
line = 2'''

PY_TEST = '''
# comment 1

def func(): # eol comment 3
    """ docstring
    """
    pass

def query():
    long_query = """
        SELECT *
        FROM table
        WHERE id = 1;
    """
    return query

print(i.lineno, i, getattr(i,'s',None), getattr(i,'value',None))
'''

JS_TEST = r'''
/*
comment
*/

function() {
    return 1+2; // comment
}

function() {
    hello = 4; /*
        comment
    */
    console.log(hello);
    regex = /\/*h/;
    legit_code_counted = 1;
    regex2 = /.*/;
}
'''

CSS_TEST = '''
/*
  Comment
*/

p {
  text-align: center;
  color: red;
  text-overflow: ' /* ';
}


#content, #footer, #supplement {
   position: absolute;
   left: 510px;
   width: 200px;
   text-overflow: ' */ ';
}
'''

SCSS_TEST = '''
/*
  Comment
*/

// Standalone list views
.o_content > .o_list_view > .table-responsive > .table {
    // List views always have the table-sm class, maybe we should remove
    // it (and consider it does not exist) and change the default table paddings
    @include o-list-view-full-width-padding($base-x: $table-cell-padding-x-sm, $base-y: $table-cell-padding-y-sm, $ratio: 2);
    &:not(.o_list_table_grouped) {
        @include media-breakpoint-up(xl) {
            @include o-list-view-full-width-padding($base-x: $table-cell-padding-x-sm, $base-y: $table-cell-padding-y-sm, $ratio: 2.5);
        }
    }

    .o_optional_columns_dropdown_toggle {
        padding: 8px 10px;
    }
}

#content, #footer, #supplement {
   text-overflow: '/*';
   left: 510px;
   width: 200px;
   text-overflow: '*/';
}
'''

class TestClocCustomization(TransactionCase):
    def create_xml_id(self, module, name, rec):
        self.env['ir.model.data'].create({
            'name': name,
            'model': rec._name,
            'res_id': rec.id,
            'module': module,
        })

    def create_field(self, name):
        field = self.env['ir.model.fields'].with_context(studio=True).create({
            'name': name,
            'field_description': name,
            'model': 'res.partner',
            'model_id': self.env.ref('base.model_res_partner').id,
            'ttype': 'integer',
            'store': False,
            'compute': "for rec in self: rec['x_invoice_count'] = 10",
        })
        # Simulate the effect of https://github.com/odoo/odoo/commit/9afce4805fc8bac45fdba817488aa867fddff69b
        # Updating a module create xml_id of the module even for manual field if it's the original module
        # of the model
        self.create_xml_id('base', name, field)
        return field

    def create_server_action(self, name):
        return self.env['ir.actions.server'].create({
            'name': name,
            'code': """
for rec in records:
    rec['name'] = test
            """,
            'state': 'code',
            'type': 'ir.actions.server',
            'model_id': self.env.ref('base.model_res_partner').id,
        })

    def test_ignore_auto_generated_computed_field(self):
        """
            Check that we count custom fields with no module or studio not auto generated
            Having an xml_id but no existing module is consider as not belonging to a module
        """
        f1 = self.create_field('x_invoice_count')
        self.create_xml_id('studio_customization', 'invoice_count', f1)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 0, 'Studio auto generated count field should not be counted in cloc')
        f2 = self.create_field('x_studio_custom_field')
        self.create_xml_id('studio_customization', 'studio_custom', f2)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 1, 'Count other studio computed field')
        self.create_field('x_custom_field')
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 2, 'Count fields without xml_id')
        f4 = self.create_field('x_custom_field_export')
        self.create_xml_id('__export__', 'studio_custom', f4)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 3, 'Count fields with xml_id but without module')

    def test_several_xml_id(self):
        sa = self.create_server_action("Test double xml_id")
        self.create_xml_id("__export__", "first", sa)
        self.create_xml_id("base", "second", sa)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 2, 'Count Should count SA with a non standard xml_id')
        self.create_xml_id("__import__", "third", sa)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 2, 'SA with several xml_id should be counted only once')

    def test_cloc_exclude_xml_id(self):
        sa = self.create_server_action("Test double xml_id")
        self.create_xml_id("__cloc_exclude__", "sa_first", sa)
        self.create_xml_id("__upgrade__", "sa_second", sa)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 0, 'Should not count SA with cloc_exclude xml_id')

        f1 = self.create_field('x_invoice_count')
        self.create_xml_id("__cloc_exclude__", "field_first", f1)
        self.create_xml_id("__upgrade__", "field_second", f1)
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 0, 'Should not count Field with cloc_exclude xml_id')

    def test_field_no_xml_id(self):
        self.env['ir.model.fields'].create({
            'name': "x_no_xml_id",
            'field_description': "no_xml_id",
            'model': 'res.partner',
            'model_id': self.env.ref('base.model_res_partner').id,
            'ttype': 'integer',
            'store': False,
            'compute': "for rec in self: rec['x_invoice_count'] = 10",
        })
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 1, 'Should count field with no xml_id at all')


class TestClocParser(TransactionCase):

    def test_parser(self):
        cl = cloc.Cloc()
        xml_count = cl.parse_xml(XML_TEST)
        self.assertEqual(xml_count, (18, 31))
        py_count = cl.parse_py(PY_TEST_NO_RETURN)
        self.assertEqual(py_count, (2, 2))
        py_count = cl.parse_py(PY_TEST)
        if self._python_version >= (3, 8, 0):
            # Multi line str lineno return the begining of the str
            # in python 3.8, it result in a different count for
            # multi str used in expressions
            self.assertEqual(py_count, (7, 16))
        else:
            self.assertEqual(py_count, (8, 16))
        js_count = cl.parse_js(JS_TEST)
        self.assertEqual(js_count, (10, 17))
        css_count = cl.parse_css(CSS_TEST)
        self.assertEqual(css_count, (11, 17))
        scss_count = cl.parse_scss(SCSS_TEST)
        self.assertEqual(scss_count, (17, 26))


@tagged('post_install', '-at_install')
class TestClocStdNoCusto(TransactionCase):

    def test_no_custo_install(self):
        """
            Make sure after the installation of module
            no database customization is counted
        """
        cl = cloc.Cloc()
        cl.count_customization(self.env)
        self.assertEqual(cl.code.get('odoo/studio', 0), 0, 'Module should not generate customization in database')

```

  File: tests/test_config_parameter.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.addons.base.models.ir_config_parameter import _default_parameters
from odoo.exceptions import ValidationError
from odoo.tests.common import TransactionCase


class TestIrConfigParameter(TransactionCase):

    def test_default_parameters(self):
        """ Check the behavior of _default_parameters
        when updating keys and deleting records. """
        for key in _default_parameters:
            config_parameter = self.env['ir.config_parameter'].search([('key', '=', key)], limit=1)
            with self.assertRaises(ValidationError):
                config_parameter.unlink()

            new_key = f"{key}_updated"
            with self.assertRaises(ValidationError):
                config_parameter.write({'key': new_key})

```

  File: tests/test_date_utils.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from datetime import date

from odoo.tests import BaseCase
from odoo.tools.date_utils import get_fiscal_year


class TestDateUtils(BaseCase):

    def test_fiscal_year(self):
        self.assertEqual(get_fiscal_year(date(2024, 12, 31)), (date(2024, 1, 1), date(2024, 12, 31)))
        self.assertEqual(get_fiscal_year(date(2024, 12, 31), 30, 11), (date(2024, 12, 1), date(2025, 11, 30)))
        self.assertEqual(get_fiscal_year(date(2024, 10, 31), 30, 11), (date(2023, 12, 1), date(2024, 11, 30)))
        self.assertEqual(get_fiscal_year(date(2024, 10, 31), 30, 12), (date(2023, 12, 31), date(2024, 12, 30)))

        self.assertEqual(get_fiscal_year(date(2024, 10, 31), month=11), (date(2023, 12, 1), date(2024, 11, 30)))
        self.assertEqual(get_fiscal_year(date(2024, 2, 29)), (date(2024, 1, 1), date(2024, 12, 31)))

        self.assertEqual(get_fiscal_year(date(2024, 12, 31), 29, 2), (date(2024, 3, 1), date(2025, 2, 28)))
        self.assertEqual(get_fiscal_year(date(2024, 12, 31), 28, 2), (date(2024, 3, 1), date(2025, 2, 28)))
        self.assertEqual(get_fiscal_year(date(2023, 12, 31), 28, 2), (date(2023, 3, 1), date(2024, 2, 29)))
        self.assertEqual(get_fiscal_year(date(2023, 12, 31), 29, 2), (date(2023, 3, 1), date(2024, 2, 29)))

        self.assertEqual(get_fiscal_year(date(2024, 2, 29), 28, 2), (date(2023, 3, 1), date(2024, 2, 29)))
        self.assertEqual(get_fiscal_year(date(2023, 2, 28), 28, 2), (date(2022, 3, 1), date(2023, 2, 28)))
        self.assertEqual(get_fiscal_year(date(2023, 2, 28), 29, 2), (date(2022, 3, 1), date(2023, 2, 28)))

```

  File: tests/test_db_cursor.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import logging
from functools import partial

import psycopg2
from psycopg2.extensions import ISOLATION_LEVEL_REPEATABLE_READ

import odoo
from odoo.sql_db import db_connect, TestCursor
from odoo.tests import common
from odoo.tests.common import BaseCase
from odoo.tools.misc import config

ADMIN_USER_ID = common.ADMIN_USER_ID

def registry():
    return odoo.registry(common.get_db_name())


class TestRealCursor(BaseCase):

    def test_execute_bad_params(self):
        """
        Try to use iterable but non-list or int params in query parameters.
        """
        with registry().cursor() as cr:
            with self.assertRaises(ValueError):
                cr.execute("SELECT id FROM res_users WHERE login=%s", 'admin')
            with self.assertRaises(ValueError):
                cr.execute("SELECT id FROM res_users WHERE id=%s", 1)
            with self.assertRaises(ValueError):
                cr.execute("SELECT id FROM res_users WHERE id=%s", '1')

    def test_using_closed_cursor(self):
        with registry().cursor() as cr:
            cr.close()
            with self.assertRaises(psycopg2.InterfaceError):
                cr.execute("SELECT 1")

    def test_multiple_close_call_cursor(self):
        cr = registry().cursor()
        cr.close()
        cr.close()

    def test_transaction_isolation_cursor(self):
        with registry().cursor() as cr:
            self.assertEqual(cr.connection.isolation_level, ISOLATION_LEVEL_REPEATABLE_READ)

class TestTestCursor(common.TransactionCase):
    def setUp(self):
        super().setUp()
        # make the registry in test mode
        self.registry.enter_test_mode(self.cr)
        self.addCleanup(self.registry.leave_test_mode)
        # now we make a test cursor for self.cr
        self.cr = self.registry.cursor()
        self.addCleanup(self.cr.close)
        self.env = odoo.api.Environment(self.cr, odoo.SUPERUSER_ID, {})
        self.record = self.env['res.partner'].create({'name': 'Foo'})

    def write(self, record, value):
        record.ref = value

    def flush(self, record):
        record.flush_model(['ref'])

    def check(self, record, value):
        # make sure to fetch the field from the database
        record.invalidate_recordset()
        self.assertEqual(record.read(['ref'])[0]['ref'], value)

    def test_single_cursor(self):
        """ Check the behavior of a single test cursor. """
        self.assertIsInstance(self.cr, TestCursor)
        self.write(self.record, 'A')
        self.cr.commit()

        self.write(self.record, 'B')
        self.cr.rollback()
        self.check(self.record, 'A')

        self.write(self.record, 'C')
        self.cr.rollback()
        self.check(self.record, 'A')

    def test_sub_commit(self):
        """ Check the behavior of a subcursor that commits. """
        self.assertIsInstance(self.cr, TestCursor)
        self.write(self.record, 'A')
        self.cr.commit()

        self.write(self.record, 'B')
        self.flush(self.record)

        # check behavior of a "sub-cursor" that commits
        with self.registry.cursor() as cr:
            self.assertIsInstance(cr, TestCursor)
            record = self.record.with_env(self.env(cr=cr))
            self.check(record, 'B')
            self.write(record, 'C')

        self.check(self.record, 'C')

        self.cr.rollback()
        self.check(self.record, 'A')

    def test_sub_rollback(self):
        """ Check the behavior of a subcursor that rollbacks. """
        self.assertIsInstance(self.cr, TestCursor)
        self.write(self.record, 'A')
        self.cr.commit()

        self.write(self.record, 'B')
        self.flush(self.record)

        # check behavior of a "sub-cursor" that rollbacks
        with self.assertRaises(ValueError):
            with self.registry.cursor() as cr:
                self.assertIsInstance(cr, TestCursor)
                record = self.record.with_env(self.env(cr=cr))
                self.check(record, 'B')
                self.write(record, 'C')
                raise ValueError(42)

        self.check(self.record, 'B')

        self.cr.rollback()
        self.check(self.record, 'A')

    def test_interleaving(self):
        """If test cursors are retrieved independently it becomes possible for
        the savepoint operations to be interleaved (especially as some are lazy
        e.g. the request cursor, so cursors might be semantically nested but
        technically interleaved), and for them to commit one another:

        .. code-block:: sql

            SAVEPOINT A
            SAVEPOINT B
            RELEASE SAVEPOINT A
            RELEASE SAVEPOINT B -- "savepoint b does not exist"
        """
        a = self.registry.cursor()
        _b = self.registry.cursor()
        # `a` should warn that it found un-closed cursor `b` when trying to close itself
        with self.assertLogs('odoo.sql_db', level=logging.WARNING) as cm:
            a.close()
        [msg] = cm.output
        self.assertIn('WARNING:odoo.sql_db:Found different un-closed cursor', msg)
        # avoid a warning on teardown (when self.cr finds a still on the stack)
        # as well as ensure the stack matches our expectations
        self.assertEqual(a._cursors_stack.pop(), a)

    def test_borrow_connection(self):
        """Tests the behavior of the postgresql connection pool recycling/borrowing"""
        origin_db_port = config['db_port']
        if not origin_db_port and hasattr(self.env.cr._cnx, 'info'):
            # Check the edge case of the db port set,
            # which is set as an integer in our DSN/connection_info
            # but as string in the DSN of psycopg2
            # The connections must be recycled/borrowed when the db_port is set
            # e.g
            # `connection.dsn`
            # {'database': '14.0', 'port': 5432, 'sslmode': 'prefer'}
            # must match
            # `cr._cnx.dsn`
            # 'port=5432 sslmode=prefer dbname=14.0'
            config['db_port'] = self.env.cr._cnx.info.port

        cursors = []
        try:
            connection = db_connect(self.cr.dbname)

            # Case #1: 2 cursors, both opened/used, do not recycle/borrow.
            # The 2nd cursor must not use the connection of the 1st cursor as it's used (not closed).
            cursors.append(connection.cursor())
            cursors.append(connection.cursor())
            # Ensure the port is within psycopg's dsn, as explained in an above comment,
            # we want to test the behavior of the connections borrowing including the port provided in the dsn.
            if config['db_port']:
                self.assertTrue('port=' in cursors[0]._cnx.dsn)
            # Check the connection of the 1st cursor is different than the connection of the 2nd cursor.
            self.assertNotEqual(id(cursors[0]._cnx), id(cursors[1]._cnx))

            # Case #2: Close 1st cursor, open 3rd cursor, must recycle/borrow.
            # The 3rd must recycle/borrow the connection of the 1st one.
            cursors[0].close()
            cursors.append(connection.cursor())
            # Check the connection of this 3rd cursor uses the connection of the 1st cursor that has been closed.
            self.assertEqual(id(cursors[0]._cnx), id(cursors[2]._cnx))

        finally:
            # Cleanups:
            # - Close the cursors which have been left opened
            # - Reset the config `db_port`
            for cursor in cursors:
                if not cursor.closed:
                    cursor.close()
            config['db_port'] = origin_db_port


class TestCursorHooks(common.TransactionCase):
    def setUp(self):
        super().setUp()
        self.log = []

    def prepare_hooks(self, cr):
        self.log.clear()
        cr.precommit.add(partial(self.log.append, 'preC'))
        cr.postcommit.add(partial(self.log.append, 'postC'))
        cr.prerollback.add(partial(self.log.append, 'preR'))
        cr.postrollback.add(partial(self.log.append, 'postR'))
        self.assertEqual(self.log, [])

    def test_hooks_on_cursor(self):
        cr = self.registry.cursor()

        # check hook on commit()
        self.prepare_hooks(cr)
        cr.commit()
        self.assertEqual(self.log, ['preC', 'postC'])

        # check hook on flush(), then on rollback()
        self.prepare_hooks(cr)
        cr.flush()
        self.assertEqual(self.log, ['preC'])
        cr.rollback()
        self.assertEqual(self.log, ['preC', 'preR', 'postR'])

        # check hook on close()
        self.prepare_hooks(cr)
        cr.close()
        self.assertEqual(self.log, ['preR', 'postR'])

    def test_hooks_on_testcursor(self):
        self.registry.enter_test_mode(self.cr)
        self.addCleanup(self.registry.leave_test_mode)

        cr = self.registry.cursor()

        # check hook on commit(); post-commit hooks are ignored
        self.prepare_hooks(cr)
        cr.commit()
        self.assertEqual(self.log, ['preC'])

        # check hook on flush(), then on rollback()
        self.prepare_hooks(cr)
        cr.flush()
        self.assertEqual(self.log, ['preC'])
        cr.rollback()
        self.assertEqual(self.log, ['preC', 'preR', 'postR'])

        # check hook on close()
        self.prepare_hooks(cr)
        cr.close()
        self.assertEqual(self.log, ['preR', 'postR'])

class TestCursorHooksTransactionCaseCleanup(common.TransactionCase):
    """Check savepoint cases handle commit hooks properly."""
    def test_isolation_first(self):
        def mutate_second_test_ref():
            for name in ['precommit', 'postcommit', 'prerollback', 'postrollback']:
                del self.env.cr.precommit.data.get(f'test_cursor_hooks_savepoint_case_cleanup_test_second_{name}', [''])[0]
        self.env.cr.precommit.add(mutate_second_test_ref)

    def test_isolation_second(self):
        references = [['not_empty']] * 4
        cr = self.env.cr
        commit_callbacks = [cr.precommit, cr.postcommit, cr.prerollback, cr.postrollback]
        callback_names = ['precommit', 'postcommit', 'prerollback', 'postrollback']

        for callback_name, callbacks, reference in zip(callback_names, commit_callbacks, references):
            callbacks.data.setdefault(f"test_cursor_hooks_savepoint_case_cleanup_test_second_{callback_name}", reference)

        for callback in commit_callbacks:
            callback.run()

        for callback_name, reference in zip(callback_names, references):
            self.assertTrue(bool(reference), f"{callback_name} failed to clean up between transaction tests")
            self.assertTrue(reference[0] == 'not_empty', f"{callback_name} failed to clean up between transaction tests")

```

  File: tests/test_deprecation.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import inspect

from odoo.tests.common import TransactionCase, tagged

DEPRECATED_MODEL_ATTRIBUTES = [
    'view_init',
    '_needaction',
    '_sql',
    '_execute_sql',
]


@tagged('-at_install', 'post_install', 'deprecation')
class TestModelDeprecations(TransactionCase):

    def test_model_attributes(self):
        for model_name, Model in self.registry.items():
            for attr in DEPRECATED_MODEL_ATTRIBUTES:
                with self.subTest(model=model_name, attr=attr):
                    value = getattr(Model, attr, None)
                    if value is None:
                        continue
                    msg = f"Deprecated method/attribute {model_name}.{attr}"
                    module = inspect.getmodule(value)
                    if module:
                        msg += f" in {module}"
                    self.fail(msg)

    def test_name_get(self):
        for model_name, Model in self.registry.items():
            with self.subTest(model=model_name):
                # name_get should exist but define by BaseModel
                module = inspect.getmodule(Model.name_get)
                if module.__name__ == 'odoo.models':
                    continue
                self.fail(f"Deprecated name_get method found on {model_name} in {module.__name__}, you should override `_compute_display_name` instead")

```

  File: tests/test_display_name.py
  Content:
```
import contextlib

from odoo.exceptions import UserError
from odoo.tests.common import TransactionCase, tagged


IGNORE_MODEL_NAMES = {
    'ir.attachment',
    'test_new_api.attachment',
    'payment.link.wizard',
    'account.multicurrency.revaluation.wizard',
    'account_followup.manual_reminder',
}

@tagged('-at_install', 'post_install')
class TestEveryModel(TransactionCase):

    def test_display_name_new_record(self):
        for model_name in self.registry:
            model = self.env[model_name]
            if model._abstract or not model._auto or model_name in IGNORE_MODEL_NAMES:
                continue

            with self.subTest(
                msg="`_compute_display_name` doesn't work with new record (first onchange call).",
                model=model_name,
            ):
                # Check that the first onchange with display_name works on every models
                # OR it will fail anyway when people will use click on New
                fields_used = model._fields['display_name'].get_depends(model)[0]
                fields_used = [f.split('.', 1)[0] for f in fields_used]
                fields_spec = dict.fromkeys(fields_used + ['display_name'], {})
                with contextlib.suppress(UserError):
                    model.onchange({}, [], fields_spec)

```

  File: tests/test_expression.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import collections
import textwrap
import unittest
from ast import literal_eval
from unittest.mock import patch

import psycopg2

from odoo.addons.base.tests.common import SavepointCaseWithUserDemo
from odoo.fields import Date
from odoo.models import BaseModel
from odoo.tests.common import BaseCase, TransactionCase
from odoo.tools import mute_logger
from odoo.osv import expression
from odoo import Command


class TestExpression(SavepointCaseWithUserDemo):

    @classmethod
    def setUpClass(cls):
        super(TestExpression, cls).setUpClass()
        cls._load_partners_set()
        cls.env['res.currency'].with_context({'active_test': False}).search([('name', 'in', ['EUR', 'USD'])]).write({'active': True})

    def _search(self, model, domain, init_domain=None):
        sql = model.search(domain, order="id")
        fil = model.search(init_domain or [], order="id").filtered_domain(domain)
        self.assertEqual(sql._ids, fil._ids, f"filtered_domain do not match SQL search for domain: {domain}")
        return sql

    def test_00_in_not_in_m2m(self):
        # Create 4 partners with no category, or one or two categories (out of two categories).
        categories = self.env['res.partner.category']
        cat_a = categories.create({'name': 'test_expression_category_A'})
        cat_b = categories.create({'name': 'test_expression_category_B'})

        partners = self.env['res.partner']
        a = partners.create({'name': 'test_expression_partner_A', 'category_id': [Command.set([cat_a.id])]})
        b = partners.create({'name': 'test_expression_partner_B', 'category_id': [Command.set([cat_b.id])]})
        ab = partners.create({'name': 'test_expression_partner_AB', 'category_id': [Command.set([cat_a.id, cat_b.id])]})
        c = partners.create({'name': 'test_expression_partner_C'})

        # The tests.

        # On a one2many or many2many field, `in` should be read `contains` (and
        # `not in` should be read `doesn't contain`.
        with_a = self._search(partners, [('category_id', 'in', [cat_a.id])])
        self.assertEqual(a + ab, with_a, "Search for category_id in cat_a failed.")

        with_b = self._search(partners, [('category_id', 'in', [cat_b.id])])
        self.assertEqual(b + ab, with_b, "Search for category_id in cat_b failed.")

        # Partners with the category A or the category B.
        with_a_or_b = self._search(partners, [('category_id', 'in', [cat_a.id, cat_b.id])])
        self.assertEqual(a + b + ab, with_a_or_b, "Search for category_id contains cat_a or cat_b failed.")

        # Show that `contains list` is really `contains element or contains element`.
        with_a_or_with_b = self._search(partners, ['|', ('category_id', 'in', [cat_a.id]), ('category_id', 'in', [cat_b.id])])
        self.assertEqual(a + b + ab, with_a_or_with_b, "Search for category_id contains cat_a or contains cat_b failed.")

        # If we change the OR in AND...
        with_a_and_b = self._search(partners, [('category_id', 'in', [cat_a.id]), ('category_id', 'in', [cat_b.id])])
        self.assertEqual(ab, with_a_and_b, "Search for category_id contains cat_a and cat_b failed.")

        # Partners without category A and without category B.
        without_a_or_b = self._search(partners, [('category_id', 'not in', [cat_a.id, cat_b.id])])
        self.assertFalse(without_a_or_b & (a + b + ab), "Search for category_id doesn't contain cat_a or cat_b failed (1).")
        self.assertTrue(c in without_a_or_b, "Search for category_id doesn't contain cat_a or cat_b failed (2).")

        # Show that `doesn't contain list` is really `doesn't contain element and doesn't contain element`.
        without_a_and_without_b = self._search(partners, [('category_id', 'not in', [cat_a.id]), ('category_id', 'not in', [cat_b.id])])
        self.assertFalse(without_a_and_without_b & (a + b + ab), "Search for category_id doesn't contain cat_a and cat_b failed (1).")
        self.assertTrue(c in without_a_and_without_b, "Search for category_id doesn't contain cat_a and cat_b failed (2).")

        # We can exclude any partner containing the category A.
        without_a = self._search(partners, [('category_id', 'not in', [cat_a.id])])
        self.assertTrue(a not in without_a, "Search for category_id doesn't contain cat_a failed (1).")
        self.assertTrue(ab not in without_a, "Search for category_id doesn't contain cat_a failed (2).")
        self.assertLessEqual(b + c, without_a, "Search for category_id doesn't contain cat_a failed (3).")

        # (Obviously we can do the same for cateory B.)
        without_b = self._search(partners, [('category_id', 'not in', [cat_b.id])])
        self.assertTrue(b not in without_b, "Search for category_id doesn't contain cat_b failed (1).")
        self.assertTrue(ab not in without_b, "Search for category_id doesn't contain cat_b failed (2).")
        self.assertLessEqual(a + c, without_b, "Search for category_id doesn't contain cat_b failed (3).")

    def test_05_not_str_m2m(self):
        partners = self.env['res.partner']
        categories = self.env['res.partner.category']

        cids = {}
        for name in 'A B AB'.split():
            cids[name] = categories.create({'name': name}).id

        partners_config = {
            '0': [],
            'a': [cids['A']],
            'b': [cids['B']],
            'ab': [cids['AB']],
            'a b': [cids['A'], cids['B']],
            'b ab': [cids['B'], cids['AB']],
        }
        pids = {}
        for name, cat_ids in partners_config.items():
            pids[name] = partners.create({'name': name, 'category_id': [Command.set(cat_ids)]}).id

        base_domain = [('id', 'in', list(pids.values()))]

        def test(op, value, expected):
            found_ids = self._search(partners, base_domain + [('category_id', op, value)]).ids
            expected_ids = [pids[name] for name in expected]
            self.assertItemsEqual(found_ids, expected_ids, '%s %r should return %r' % (op, value, expected))

        test('=', 'A', ['a', 'a b'])
        test('!=', 'B', ['0', 'a', 'ab'])
        test('like', 'A', ['a', 'ab', 'a b', 'b ab'])
        test('not ilike', 'B', ['0', 'a'])
        test('not like', 'AB', ['0', 'a', 'b', 'a b'])

    def test_09_hierarchy_filtered_domain(self):
        Partner = self.env['res.partner']
        p = Partner.create({'name': 'dummy'})

        # hierarchy without parent
        self.assertFalse(p.parent_id)
        p2 = self._search(Partner, [('parent_id', 'child_of', p.id)], [('id', '=', p.id)])
        self.assertEqual(p2, p)
        p3 = self._search(Partner, [('parent_id', 'parent_of', p.id)], [('id', '=', p.id)])
        self.assertEqual(p3, p)

    def test_10_hierarchy_in_m2m(self):
        Partner = self.env['res.partner']
        Category = self.env['res.partner.category']

        # search through m2m relation
        partners = self._search(Partner, [('category_id', 'child_of', self.partner_category.id)])
        self.assertTrue(partners)

        # setup test partner categories
        categ_root = Category.create({'name': 'Root category'})
        categ_0 = Category.create({'name': 'Parent category', 'parent_id': categ_root.id})
        categ_1 = Category.create({'name': 'Child1', 'parent_id': categ_0.id})

        # test hierarchical search in m2m with child id (list of ids)
        cats = self._search(Category, [('id', 'child_of', categ_root.ids)])
        self.assertEqual(len(cats), 3)

        # test hierarchical search in m2m with child id (single id)
        cats = self._search(Category, [('id', 'child_of', categ_root.id)])
        self.assertEqual(len(cats), 3)

        # test hierarchical search in m2m with child ids
        cats = self._search(Category, [('id', 'child_of', (categ_0 + categ_1).ids)])
        self.assertEqual(len(cats), 2)

        # test hierarchical search in m2m with child ids
        cats = self._search(Category, [('id', 'child_of', categ_0.ids)])
        self.assertEqual(len(cats), 2)

        # test hierarchical search in m2m with child ids
        cats = self._search(Category, [('id', 'child_of', categ_1.ids)])
        self.assertEqual(len(cats), 1)

        # test hierarchical search in m2m with an empty list
        cats = self._search(Category, [('id', 'child_of', [])])
        self.assertEqual(len(cats), 0)

        # test hierarchical search in m2m with 'False' value
        with self.assertLogs('odoo.osv.expression'):
            cats = self._search(Category, [('id', 'child_of', False)])
        self.assertEqual(len(cats), 0)

        # test hierarchical search in m2m with parent id (list of ids)
        cats = self._search(Category, [('id', 'parent_of', categ_1.ids)])
        self.assertEqual(len(cats), 3)

        # test hierarchical search in m2m with parent id (single id)
        cats = self._search(Category, [('id', 'parent_of', categ_1.id)])
        self.assertEqual(len(cats), 3)

        # test hierarchical search in m2m with parent ids
        cats = self._search(Category, [('id', 'parent_of', (categ_root + categ_0).ids)])
        self.assertEqual(len(cats), 2)

        # test hierarchical search in m2m with parent ids
        cats = self._search(Category, [('id', 'parent_of', categ_0.ids)])
        self.assertEqual(len(cats), 2)

        # test hierarchical search in m2m with parent ids
        cats = self._search(Category, [('id', 'parent_of', categ_root.ids)])
        self.assertEqual(len(cats), 1)

        # test hierarchical search in m2m with an empty list
        cats = self._search(Category, [('id', 'parent_of', [])])
        self.assertEqual(len(cats), 0)

        # test hierarchical search in m2m with 'False' value
        with self.assertLogs('odoo.osv.expression'):
            cats = self._search(Category, [('id', 'parent_of', False)])
        self.assertEqual(len(cats), 0)

    @mute_logger('odoo.models.unlink')
    def test_10_hierarchy_access(self):
        Partner = self.env['res.partner'].with_user(self.user_demo)
        top = Partner.create({'name': 'Top'})
        med = Partner.create({'name': 'Medium', 'parent_id': top.id})
        bot = Partner.create({'name': 'Bottom', 'parent_id': med.id})

        # restrict access of user Demo to partners Top and Bottom
        accessible = top + bot
        self.env['ir.rule'].search([]).unlink()
        self.env['ir.rule'].create({
            'name': 'partners rule',
            'model_id': self.env['ir.model']._get('res.partner').id,
            'domain_force': str([('id', 'in', accessible.ids)]),
        })

        # these searches should return the subset of accessible nodes that are
        # in the given hierarchy
        self.assertEqual(Partner.search([]), accessible)
        self.assertEqual(Partner.search([('id', 'child_of', top.ids)]), accessible)
        self.assertEqual(Partner.search([('id', 'parent_of', bot.ids)]), accessible)

        # same kind of search from another model
        Bank = self.env['res.partner.bank'].with_user(self.user_demo)
        bank_top, bank_med, bank_bot = Bank.create([
            {'acc_number': '1', 'partner_id': top.id},
            {'acc_number': '2', 'partner_id': med.id},
            {'acc_number': '3', 'partner_id': bot.id},
        ])

        self.assertEqual(Bank.search([('partner_id', 'in', accessible.ids)]), bank_top + bank_bot)
        self.assertEqual(Bank.search([('partner_id', 'child_of', top.ids)]), bank_top + bank_med + bank_bot)
        self.assertEqual(Bank.search([('partner_id', 'parent_of', bot.ids)]), bank_top + bank_med + bank_bot)

    def test_10_eq_lt_gt_lte_gte(self):
        # test if less/greater than or equal operators work
        currency = self.env['res.currency'].search([], limit=1)
        # test equal
        res = self._search(currency, [('rounding', '=', currency.rounding)])
        self.assertTrue(currency in res)
        # test not equal
        res = self._search(currency, [('rounding', '!=', currency.rounding)])
        self.assertTrue(currency not in res)
        # test greater than
        res = self._search(currency, [('rounding', '>', currency.rounding)])
        self.assertTrue(currency not in res)
        # test greater than or equal
        res = self._search(currency, [('rounding', '>=', currency.rounding)])
        self.assertTrue(currency in res)
        # test less than
        res = self._search(currency, [('rounding', '<', currency.rounding)])
        self.assertTrue(currency not in res)
        # test less than or equal
        res = self._search(currency, [('rounding', '<=', currency.rounding)])
        self.assertTrue(currency in res)

    def test_10_equivalent_id(self):
        # equivalent queries
        Currency = self.env['res.currency']
        non_currency_id = max(Currency.search([]).ids) + 1003
        res_0 = self._search(Currency, [])
        res_1 = self._search(Currency, [('name', 'not like', 'probably_unexisting_name')])
        self.assertEqual(res_0, res_1)
        res_2 = self._search(Currency, [('id', 'not in', [non_currency_id])])
        self.assertEqual(res_0, res_2)
        res_3 = self._search(Currency, [('id', 'not in', [])])
        self.assertEqual(res_0, res_3)
        res_4 = self._search(Currency, [('id', '!=', False)])
        self.assertEqual(res_0, res_4)

        # equivalent queries, integer and string
        Partner = self.env['res.partner']
        all_partners = self._search(Partner, [])
        self.assertTrue(len(all_partners) > 1)
        one = self.env.ref('base.main_partner')
        others = all_partners - one

        res_1 = self._search(Partner, [('id', '=', one.id)])
        self.assertEqual(one, res_1)
        # Partner.search([('id', '!=', others)]) # not permitted
        res_2 = self._search(Partner, [('id', 'not in', others.ids)])
        self.assertEqual(one, res_2)
        res_3 = self._search(Partner, ['!', ('id', '!=', one.id)])
        self.assertEqual(one, res_3)
        res_4 = self._search(Partner, ['!', ('id', 'in', others.ids)])
        self.assertEqual(one, res_4)
        # res_5 = Partner.search([('id', 'in', one)]) # TODO make it permitted, just like for child_of
        # self.assertEqual(one, res_5)
        res_6 = self._search(Partner, [('id', 'in', [one.id])])
        self.assertEqual(one, res_6)
        res_7 = self._search(Partner, [('name', '=', one.name)])
        self.assertEqual(one, res_7)
        res_8 = self._search(Partner, [('name', 'in', [one.name])])
        # res_9 = Partner.search([('name', 'in', one.name)]) # TODO

    def test_15_m2o(self):
        Partner = self.env['res.partner']

        # testing equality with name
        partners = self._search(Partner, [('parent_id', '=', 'Pepper Street')])
        self.assertTrue(partners)

        # testing the in operator with name
        partners = self._search(Partner, [('parent_id', 'in', 'Pepper Street')])
        self.assertTrue(partners)

        # testing the in operator with a list of names
        partners = self._search(Partner, [('parent_id', 'in', ['Pepper Street', 'Inner Works'])])
        self.assertTrue(partners)

        # check if many2one works with empty search list
        partners = self._search(Partner, [('company_id', 'in', [])])
        self.assertFalse(partners)

        # create new company with partners, and partners with no company
        company2 = self.env['res.company'].create({'name': 'Acme 2'})
        for i in range(4):
            Partner.create({'name': 'P of Acme %s' % i, 'company_id': company2.id})
            Partner.create({'name': 'P of All %s' % i, 'company_id': False})

        # check if many2one works with negative empty list
        all_partners = Partner.search([])
        res_partners = self._search(Partner, ['|', ('company_id', 'not in', []), ('company_id', '=', False)])
        self.assertEqual(all_partners, res_partners, "not in [] fails")

        # check that many2one will pick the correct records with a list
        partners = self._search(Partner, [('company_id', 'in', [False])])
        self.assertTrue(len(partners) >= 4, "We should have at least 4 partners with no company")

        # check that many2one will exclude the correct records with a list
        partners = self._search(Partner, [('company_id', 'not in', [1])])
        self.assertTrue(len(partners) >= 4, "We should have at least 4 partners not related to company #1")

        # check that many2one will exclude the correct records with a list and False
        partners = self._search(Partner, ['|', ('company_id', 'not in', [1]),
                                        ('company_id', '=', False)])
        self.assertTrue(len(partners) >= 8, "We should have at least 8 partners not related to company #1")

        # check that multi-level expressions also work
        partners = self._search(Partner, [('company_id.partner_id', 'in', [])])
        self.assertFalse(partners)

        # check multi-level expressions with magic columns
        partners = self._search(Partner, [('create_uid.active', '=', True)])

        # check that multi-level expressions with negative op work
        all_partners = self._search(Partner, [('company_id', '!=', False)])

        # FP Note: filtered_domain differs
        res_partners = Partner.search([('company_id.partner_id', 'not in', [])])
        self.assertEqual(all_partners, res_partners, "not in [] fails")

        # Test the '(not) like/in' behavior. res.partner and its parent_id
        # column are used because parent_id is a many2one, allowing to test the
        # Null value, and there are actually some null and non-null values in
        # the demo data.
        all_partners = self._search(Partner, [])
        non_partner_id = max(all_partners.ids) + 1

        with_parent = all_partners.filtered(lambda p: p.parent_id)
        without_parent = all_partners.filtered(lambda p: not p.parent_id)
        with_website = all_partners.filtered(lambda p: p.website)

        # We treat null values differently than in SQL. For instance in SQL:
        #   SELECT id FROM res_partner WHERE parent_id NOT IN (0)
        # will return only the records with non-null parent_id.
        #   SELECT id FROM res_partner WHERE parent_id IN (0)
        # will return expectedly nothing (our ids always begin at 1).
        # This means the union of those two results will give only some
        # records, but not all present in database.
        #
        # When using domains and the ORM's search method, we think it is
        # more intuitive that the union returns all the records, and that
        # a domain like ('parent_id', 'not in', [0]) will return all
        # the records. For instance, if you perform a search for the companies
        # that don't have OpenERP has a parent company, you expect to find,
        # among others, the companies that don't have parent company.
        #

        # existing values be treated similarly if we simply check that some
        # existing value belongs to them.
        res_0 = self._search(Partner, [('parent_id', 'not like', 'probably_unexisting_name')]) # get all rows, included null parent_id
        self.assertEqual(res_0, all_partners)
        res_1 = self._search(Partner, [('parent_id', 'not in', [non_partner_id])]) # get all rows, included null parent_id
        self.assertEqual(res_1, all_partners)
        res_2 = self._search(Partner, [('parent_id', '!=', False)]) # get rows with not null parent_id, deprecated syntax
        self.assertEqual(res_2, with_parent)
        res_3 = self._search(Partner, [('parent_id', 'not in', [])]) # get all rows, included null parent_id
        self.assertEqual(res_3, all_partners)
        res_4 = self._search(Partner, [('parent_id', 'not in', [False])]) # get rows with not null parent_id
        self.assertEqual(res_4, with_parent)
        res_4b = self._search(Partner, [('parent_id', 'not ilike', '')]) # get only rows without parent
        self.assertEqual(res_4b, without_parent)

        # The results of these queries, when combined with queries 0..4 must
        # give the whole set of ids.
        res_5 = self._search(Partner, [('parent_id', 'like', 'probably_unexisting_name')])
        self.assertFalse(res_5)
        res_6 = self._search(Partner, [('parent_id', 'in', [non_partner_id])])
        self.assertFalse(res_6)
        res_7 = self._search(Partner, [('parent_id', '=', False)])
        self.assertEqual(res_7, without_parent)
        res_8 = self._search(Partner, [('parent_id', 'in', [])])
        self.assertFalse(res_8)
        res_9 = self._search(Partner, [('parent_id', 'in', [False])])
        self.assertEqual(res_9, without_parent)
        res_9b = self._search(Partner, [('parent_id', 'ilike', '')]) # get those with a parent
        self.assertEqual(res_9b, with_parent)

        # These queries must return exactly the results than the queries 0..4,
        # i.e. not ... in ... must be the same as ... not in ... .
        res_10 = self._search(Partner, ['!', ('parent_id', 'like', 'probably_unexisting_name')])
        self.assertEqual(res_0, res_10)
        res_11 = self._search(Partner, ['!', ('parent_id', 'in', [non_partner_id])])
        self.assertEqual(res_1, res_11)
        res_12 = self._search(Partner, ['!', ('parent_id', '=', False)])
        self.assertEqual(res_2, res_12)
        res_13 = self._search(Partner, ['!', ('parent_id', 'in', [])])
        self.assertEqual(res_3, res_13)
        res_14 = self._search(Partner, ['!', ('parent_id', 'in', [False])])
        self.assertEqual(res_4, res_14)

        # Testing many2one field is not enough, a regular char field is tested
        res_15 = self._search(Partner, [('website', 'in', [])])
        self.assertFalse(res_15)
        res_16 = self._search(Partner, [('website', 'not in', [])])
        self.assertEqual(res_16, all_partners)
        res_17 = self._search(Partner, [('website', '!=', False)])
        self.assertEqual(res_17, with_website)

        # check behavior for required many2one fields: currency_id is required
        companies = self.env['res.company'].search([])
        res_101 = self._search(companies, [('currency_id', 'not ilike', '')]) # get no companies
        self.assertFalse(res_101)
        res_102 = self._search(companies, [('currency_id', 'ilike', '')]) # get all companies
        self.assertEqual(res_102, companies)

    def test_in_operator(self):
        """ check that we can use the 'in' operator for plain fields """
        menu = self.env['ir.ui.menu']
        menus = self._search(menu, [('sequence', 'in', [1, 2, 10, 20])])
        self.assertTrue(menus)

    def test_in_boolean(self):
        """ Check the 'in' operator for boolean fields. """
        Partner = self.env['res.partner']
        self.assertIn('active', Partner._fields, "I need a model with field 'active'")
        count_true = Partner.search_count([('active', '=', True)])
        self.assertTrue(count_true, "I need an active partner")
        count_false = Partner.search_count([('active', '=', False)])
        self.assertTrue(count_false, "I need an inactive partner")

        count = Partner.search_count([('active', 'in', [True])])
        self.assertEqual(count, count_true)

        count = Partner.search_count([('active', 'in', [False])])
        self.assertEqual(count, count_false)

        count = Partner.search_count([('active', 'in', [True, False])])
        self.assertEqual(count, count_true + count_false)

    def test_15_o2m(self):
        Partner = self.env['res.partner']

        # test one2many operator with empty search list
        partners = self._search(Partner, [('child_ids', 'in', [])])
        self.assertFalse(partners)

        # test one2many operator with False
        partners = self._search(Partner, [('child_ids', '=', False)])
        for partner in partners:
            self.assertFalse(partner.child_ids)

        # verify domain evaluation for one2many != False and one2many == False
        categories = self.env['res.partner.category'].search([])
        parents = self._search(categories, [('child_ids', '!=', False)])
        self.assertEqual(parents, categories.filtered(lambda c: c.child_ids))
        leafs = self._search(categories, [('child_ids', '=', False)])
        self.assertEqual(leafs, categories.filtered(lambda c: not c.child_ids))

        # test many2many operator with empty search list
        partners = self._search(Partner, [('category_id', 'in', [])])
        self.assertFalse(partners)

        # test many2many operator with False
        partners = self._search(Partner, [('category_id', '=', False)])
        self.assertTrue(partners)
        for partner in partners:
            self.assertFalse(partner.category_id)

        partners = self._search(Partner, [('category_id', '!=', False)])
        self.assertTrue(partners)
        for partner in partners:
            self.assertTrue(partner.category_id)

        # filtering on nonexistent value across x2many should return nothing
        partners = self._search(Partner, [('child_ids.city', '=', 'foo')])
        self.assertFalse(partners)

    def test_15_equivalent_one2many_1(self):
        Company = self.env['res.company']
        company3 = Company.create({'name': 'Acme 3'})
        company4 = Company.create({'name': 'Acme 4', 'parent_id': company3.id})

        # one2many towards same model
        res_1 = self._search(Company, [('child_ids', 'in', company3.child_ids.ids)]) # any company having a child of company3 as child
        self.assertEqual(res_1, company3)
        res_2 = self._search(Company, [('child_ids', 'in', company3.child_ids[0].ids)]) # any company having the first child of company3 as child
        self.assertEqual(res_2, company3)

        # child_of x returns x and its children (direct or not).
        expected = company3 + company4
        res_1 = self._search(Company, [('id', 'child_of', [company3.id])])
        self.assertEqual(res_1, expected)
        res_2 = self._search(Company, [('id', 'child_of', company3.id)])
        self.assertEqual(res_2, expected)
        res_3 = self._search(Company, [('id', 'child_of', [company3.name])])
        self.assertEqual(res_3, expected)
        res_4 = self._search(Company, [('id', 'child_of', company3.name)])
        self.assertEqual(res_4, expected)

        # parent_of x returns x and its parents (direct or not).
        expected = company3 + company4
        res_1 = self._search(Company, [('id', 'parent_of', [company4.id])])
        self.assertEqual(res_1, expected)
        res_2 = self._search(Company, [('id', 'parent_of', company4.id)])
        self.assertEqual(res_2, expected)
        res_3 = self._search(Company, [('id', 'parent_of', [company4.name])])
        self.assertEqual(res_3, expected)
        res_4 = self._search(Company, [('id', 'parent_of', company4.name)])
        self.assertEqual(res_4, expected)

        # try testing real subsets with IN/NOT IN
        Partner = self.env['res.partner']
        Users = self.env['res.users']
        p1, _ = Partner.name_create("Dédé Boitaclou")
        p2, _ = Partner.name_create("Raoulette Pizza O'poil")
        u1a = Users.create({'login': 'dbo', 'partner_id': p1}).id
        u1b = Users.create({'login': 'dbo2', 'partner_id': p1}).id
        u2 = Users.create({'login': 'rpo', 'partner_id': p2}).id

        res = self._search(Partner, [('user_ids', 'in', u1a)])
        self.assertEqual([p1], res.ids, "o2m IN accept single int on right side")
        res = self._search(Partner, [('user_ids', '=', 'Dédé Boitaclou')])
        self.assertEqual([p1], res.ids, "o2m NOT IN matches none on the right side")
        res = self._search(Partner, [('user_ids', 'in', [10000])])
        self.assertEqual([], res.ids, "o2m NOT IN matches none on the right side")
        res = self._search(Partner, [('user_ids', 'in', [u1a,u2])])
        self.assertEqual([p1,p2], res.ids, "o2m IN matches any on the right side")
        all_ids = self._search(Partner, []).ids
        res = self._search(Partner, [('user_ids', 'not in', u1a)])
        self.assertEqual(set(all_ids) - set([p1]), set(res.ids), "o2m NOT IN matches none on the right side")
        res = self._search(Partner, [('user_ids', '!=', 'Dédé Boitaclou')])
        self.assertEqual(set(all_ids) - set([p1]), set(res.ids), "o2m NOT IN matches none on the right side")
        res = self._search(Partner, [('user_ids', 'not in', [u1b, u2])])
        self.assertEqual(set(all_ids) - set([p1,p2]), set(res.ids), "o2m NOT IN matches none on the right side")

    def test_15_equivalent_one2many_2(self):
        Currency = self.env['res.currency']
        CurrencyRate = self.env['res.currency.rate']

        CurrencyRate.create([
            {
                'currency_id': self.env.ref('base.EUR').id,
                'name': '2000-01-01',
                'rate': 1.0,
            }, {
                'currency_id': self.env.ref('base.USD').id,
                'name': '2000-01-01',
                'rate': 1.2834,
            }, {
                'currency_id': self.env.ref('base.USD').id,
                'name': '2000-01-02',
                'rate': 1.5289,
            }
        ])

        # create a currency and a currency rate
        currency = Currency.create({'name': 'ZZZ', 'symbol': 'ZZZ', 'rounding': 1.0})
        currency_rate = CurrencyRate.create({'name': '2010-01-01', 'currency_id': currency.id, 'rate': 1.0})
        non_currency_id = currency_rate.id + 1000
        default_currency = Currency.browse(1)

        # search the currency via its rates one2many (the one2many must point back at the currency)
        currency_rate1 = self._search(CurrencyRate, [('currency_id', 'not like', 'probably_unexisting_name')])
        currency_rate2 = self._search(CurrencyRate, [('id', 'not in', [non_currency_id])])
        self.assertEqual(currency_rate1, currency_rate2)
        currency_rate3 = self._search(CurrencyRate, [('id', 'not in', [])])
        self.assertEqual(currency_rate1, currency_rate3)

        # one2many towards another model
        res_3 = self._search(Currency, [('rate_ids', 'in', default_currency.rate_ids.ids)]) # currencies having a rate of main currency
        self.assertEqual(res_3, default_currency)
        res_4 = self._search(Currency, [('rate_ids', 'in', default_currency.rate_ids[0].ids)]) # currencies having first rate of main currency
        self.assertEqual(res_4, default_currency)
        res_5 = self._search(Currency, [('rate_ids', 'in', default_currency.rate_ids[0].id)]) # currencies having first rate of main currency
        self.assertEqual(res_5, default_currency)
        # res_6 = Currency.search([('rate_ids', 'in', [default_currency.rate_ids[0].name])])
        # res_7 = Currency.search([('rate_ids', '=', default_currency.rate_ids[0].name)])
        # res_8 = Currency.search([('rate_ids', 'like', default_currency.rate_ids[0].name)])

        res_9 = self._search(Currency, [('rate_ids', 'like', 'probably_unexisting_name')])
        self.assertFalse(res_9)
        # Currency.search([('rate_ids', 'unexisting_op', 'probably_unexisting_name')]) # TODO expected exception

        # get the currencies referenced by some currency rates using a weird negative domain
        res_10 = self._search(Currency, [('rate_ids', 'not like', 'probably_unexisting_name')])
        res_11 = self._search(Currency, [('rate_ids', 'not in', [non_currency_id])])
        self.assertEqual(res_10, res_11)
        res_12 = self._search(Currency, [('rate_ids', '!=', False)])
        self.assertEqual(res_10, res_12)
        res_13 = self._search(Currency, [('rate_ids', 'not in', [])])
        self.assertEqual(res_10, res_13)

    def test_20_expression_parse(self):
        # TDE note: those tests have been added when refactoring the expression.parse() method.
        # They come in addition to the already existing tests; maybe some tests
        # will be a bit redundant
        Users = self.env['res.users']

        # Create users
        a = Users.create({'name': 'test_A', 'login': 'test_A'})
        b1 = Users.create({'name': 'test_B', 'login': 'test_B'})
        b2 = Users.create({'name': 'test_B2', 'login': 'test_B2', 'parent_id': b1.partner_id.id})

        # Test1: simple inheritance
        users = self._search(Users, [('name', 'like', 'test')])
        self.assertEqual(users, a + b1 + b2, 'searching through inheritance failed')
        users = self._search(Users, [('name', '=', 'test_B')])
        self.assertEqual(users, b1, 'searching through inheritance failed')

        # Test2: inheritance + relational fields
        users = self._search(Users, [('child_ids.name', 'like', 'test_B')])
        self.assertEqual(users, b1, 'searching through inheritance failed')

        # Special =? operator mean "is equal if right is set, otherwise always True"
        users = self._search(Users, [('name', 'like', 'test'), ('parent_id', '=?', False)])
        self.assertEqual(users, a + b1 + b2, '(x =? False) failed')
        users = self._search(Users, [('name', 'like', 'test'), ('parent_id', '=?', b1.partner_id.id)])
        self.assertEqual(users, b2, '(x =? id) failed')

    def test_30_normalize_domain(self):
        normalize_domain = expression.normalize_domain

        self.assertEqual(normalize_domain([]), [expression.TRUE_LEAF])
        self.assertEqual(normalize_domain([expression.TRUE_LEAF]), [expression.TRUE_LEAF])
        self.assertEqual(normalize_domain([expression.FALSE_LEAF]), [expression.FALSE_LEAF])
        self.assertEqual(normalize_domain([('a', '=', 1)]), [('a', '=', 1)])
        self.assertEqual(
            normalize_domain([('a', '=', 1), ('b', '=', 2)]),
            ['&', ('a', '=', 1), ('b', '=', 2)],
        )
        self.assertEqual(
            normalize_domain(['|', ('a', '=', 1), ('b', '=', 2)]),
            ['|', ('a', '=', 1), ('b', '=', 2)],
        )
        self.assertEqual(
            normalize_domain(['|', ('a', '=', 1), ('b', '=', 2), ('c', '=', 3)]),
            ['&', '|', ('a', '=', 1), ('b', '=', 2), ('c', '=', 3)],
        )
        self.assertEqual(
            normalize_domain([('a', '=', 1), '|', ('b', '=', 2), ('c', '=', 3)]),
            ['&', ('a', '=', 1), '|', ('b', '=', 2), ('c', '=', 3)],
        )
        self.assertEqual(
            normalize_domain(['&', expression.TRUE_LEAF, ('a', '=', 1)]),
            ['&', expression.TRUE_LEAF, ('a', '=', 1)],
        )
        domain = [
            ('a', '=', 1),
            ('b.z', '=', 2),
            '|', '|', ('c', '=', 3), '!', ('d', '=', 4), ('e', '=', 5),
            ('f', '=', 6),
        ]
        self.assertEqual(normalize_domain(domain), ['&', '&', '&'] + domain)

        with self.assertRaises(ValueError):
            normalize_domain(['&'])

        with self.assertRaises(ValueError):
            normalize_domain(['&', ('a', '=', 1)])

        with self.assertRaises(ValueError):
            normalize_domain([('a', '=', 1), '&', ('b', '=', 2)])

        with self.assertRaises(ValueError):
            normalize_domain([('a', '=', 1), '!'])

    def test_35_negating_thruty_leafs(self):
        self.assertEqual(expression.distribute_not(['!', '!', expression.TRUE_LEAF]), [expression.TRUE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', '!', expression.FALSE_LEAF]), [expression.FALSE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', '!', '!', '!', expression.TRUE_LEAF]), [expression.TRUE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', '!', '!', '!', expression.FALSE_LEAF]), [expression.FALSE_LEAF], "distribute_not applied wrongly")

        self.assertEqual(expression.distribute_not(['!', expression.TRUE_LEAF]), [expression.FALSE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', expression.FALSE_LEAF]), [expression.TRUE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', '!', '!', expression.TRUE_LEAF]), [expression.FALSE_LEAF], "distribute_not applied wrongly")
        self.assertEqual(expression.distribute_not(['!', '!', '!', expression.FALSE_LEAF]), [expression.TRUE_LEAF], "distribute_not applied wrongly")

    def test_40_negating_long_expression(self):
        source = ['!', '&', ('user_id', '=', 4), ('partner_id', 'in', [1, 2])]
        expect = ['|', ('user_id', '!=', 4), ('partner_id', 'not in', [1, 2])]
        self.assertEqual(expression.distribute_not(source), expect,
            "distribute_not on expression applied wrongly")

        pos_leaves = [[('a', 'in', [])], [('d', '!=', 3)]]
        neg_leaves = [[('a', 'not in', [])], [('d', '=', 3)]]

        source = expression.OR([expression.AND(pos_leaves)] * 1000)
        expect = source
        self.assertEqual(expression.distribute_not(source), expect,
            "distribute_not on long expression without negation operator should not alter it")

        source = ['!'] + source
        expect = expression.AND([expression.OR(neg_leaves)] * 1000)
        self.assertEqual(expression.distribute_not(source), expect,
            "distribute_not on long expression applied wrongly")

    def test_accent(self):
        if not self.registry.has_unaccent:
            raise unittest.SkipTest("unaccent not enabled")

        Model = self.env['res.partner.category']
        helen = Model.create({'name': 'Hélène'})
        self.assertEqual(helen, Model.search([('name', 'ilike', 'Helene')]))
        self.assertEqual(helen, Model.search([('name', 'ilike', 'hélène')]))
        self.assertEqual(helen, Model.search([('name', '=ilike', 'Hel%')]))
        self.assertEqual(helen, Model.search([('name', '=ilike', 'hél%')]))
        self.assertNotIn(helen, Model.search([('name', 'not ilike', 'Helene')]))
        self.assertNotIn(helen, Model.search([('name', 'not ilike', 'hélène')]))

        # =like and like should be case and accent sensitive
        self.assertEqual(helen, Model.search([('name', '=like', 'Hél%')]))
        self.assertNotIn(helen, Model.search([('name', '=like', 'Hel%')]))
        self.assertEqual(helen, Model.search([('name', 'like', 'élè')]))
        self.assertNotIn(helen, Model.search([('name', 'like', 'ele')]))

        hermione, nicostratus = Model.create([
            {'name': 'Hermione', 'parent_id': helen.id},
            {'name': 'Nicostratus', 'parent_id': helen.id}
        ])
        self.assertEqual(nicostratus.parent_path, f'{helen.id}/{nicostratus.id}/')

        with patch('odoo.osv.expression.get_unaccent_wrapper') as w:
            w().side_effect = lambda x: x
            rs = Model.search([('parent_path', 'like', f'{helen.id}/%')], order='id asc')
            self.assertEqual(rs, helen | hermione | nicostratus)
            # the result of `get_unaccent_wrapper()` is the wrapper and that's
            # what should not be called
            w().assert_not_called()

    def test_pure_function(self):
        orig_false = expression.FALSE_DOMAIN.copy()
        orig_true = expression.TRUE_DOMAIN.copy()
        false = orig_false.copy()
        true = orig_true.copy()

        domain = expression.AND([])
        domain += [('id', '=', 1)]
        domain = expression.AND([])
        self.assertEqual(domain, orig_true)

        domain = expression.AND([false])
        domain += [('id', '=', 1)]
        domain = expression.AND([false])
        self.assertEqual(domain, orig_false)

        domain = expression.OR([])
        domain += [('id', '=', 1)]
        domain = expression.OR([])
        self.assertEqual(domain, orig_false)

        domain = expression.OR([true])
        domain += [('id', '=', 1)]
        domain = expression.OR([true])
        self.assertEqual(domain, orig_true)

        domain = expression.normalize_domain([])
        domain += [('id', '=', 1)]
        domain = expression.normalize_domain([])
        self.assertEqual(domain, orig_true)

    def test_like_wildcards(self):
        # check that =like/=ilike expressions are working on an untranslated field
        Partner = self.env['res.partner']
        partners = self._search(Partner, [('name', '=like', 'I_ner_W_rk_')])
        self.assertTrue(all(partner.name == 'Inner Works' for partner in partners), "Must match only 'Inner Works'")
        partners = self._search(Partner, [('name', '=ilike', 'G%')])
        self.assertTrue(len(partners) >= 1, "Must match one partner (Gemini Furniture)")

        # check that =like/=ilike expressions are working on translated field
        Country = self.env['res.country']
        countries = self._search(Country, [('name', '=like', 'Ind__')])
        self.assertTrue(len(countries) == 1, "Must match India only")
        countries = self._search(Country, [('name', '=ilike', 'z%')])
        self.assertTrue(len(countries) == 2, "Must match only countries with names starting with Z (currently 2)")

    def test_like_cast(self):
        Model = self.env['res.partner.category']
        record = Model.create({'name': 'XY', 'color': 42})

        self.assertIn(record, Model.search([('name', 'like', 'X')]))
        self.assertIn(record, Model.search([('name', 'ilike', 'X')]))
        self.assertIn(record, Model.search([('name', 'not like', 'Z')]))
        self.assertIn(record, Model.search([('name', 'not ilike', 'Z')]))

        self.assertNotIn(record, Model.search([('name', 'like', 'Z')]))
        self.assertNotIn(record, Model.search([('name', 'ilike', 'Z')]))
        self.assertNotIn(record, Model.search([('name', 'not like', 'X')]))
        self.assertNotIn(record, Model.search([('name', 'not ilike', 'X')]))

        # like, ilike, not like, not ilike convert their lhs to str
        self.assertIn(record, Model.search([('color', 'like', '4')]))
        self.assertIn(record, Model.search([('color', 'ilike', '4')]))
        self.assertIn(record, Model.search([('color', 'not like', '3')]))
        self.assertIn(record, Model.search([('color', 'not ilike', '3')]))

        self.assertNotIn(record, Model.search([('color', 'like', '3')]))
        self.assertNotIn(record, Model.search([('color', 'ilike', '3')]))
        self.assertNotIn(record, Model.search([('color', 'not like', '4')]))
        self.assertNotIn(record, Model.search([('color', 'not ilike', '4')]))

        # =like and =ilike don't work on non-character fields
        with mute_logger('odoo.sql_db'), self.assertRaises(psycopg2.Error):
            Model.search([('name', '=', 'X'), ('color', '=like', 4)])
        with self.assertRaises(ValueError):
            Model.search([('name', '=', 'X'), ('color', '=like', '4%')])

    def test_translate_search(self):
        Country = self.env['res.country']
        belgium = self.env.ref('base.be')
        domains = [
            [('name', '=', 'Belgium')],
            [('name', 'ilike', 'Belgi')],
            [('name', 'in', ['Belgium', 'Care Bears'])],
        ]

        for domain in domains:
            countries = self._search(Country, domain)
            self.assertEqual(countries, belgium)

        countries = self._search(Country, [('name', 'not in', ['No country'])])
        all_countries = self._search(Country, [])
        self.assertEqual(countries, all_countries)

    @mute_logger('odoo.sql_db')
    def test_invalid(self):
        """ verify that invalid expressions are refused, even for magic fields """
        Country = self.env['res.country']

        with self.assertRaisesRegex(ValueError, r"^Invalid field res\.country\.does_not_exist in leaf \('does_not_exist', '=', 'foo'\)$"):
            Country.search([('does_not_exist', '=', 'foo')])

        with self.assertRaisesRegex(AssertionError, "^Invalid field 'name.\"Et plouf\"'"):
            Country.search([('name."Et plouf"', 'ilike', 'foo')])

        with self.assertRaisesRegex(AssertionError, "^Invalid field 'name.\"Et plouf\"'"):
            Country.search([('name."Et plouf"', 'in', ['foo'])])

        with self.assertRaisesRegex(KeyError, r"^'does_not_exist'$"):
            Country.search([]).filtered_domain([('does_not_exist', '=', 'foo')])

        with self.assertRaisesRegex(ValueError, r"^Invalid leaf \('create_date', '>>', 'foo'\)$"):
            Country.search([('create_date', '>>', 'foo')])

        with self.assertRaisesRegex(ValueError, r"^stray % in format '%'$"):
            Country.search([]).filtered_domain([('create_date', '>>', 'foo')])

        with self.assertRaisesRegex(psycopg2.DataError, r"invalid input syntax"):
            Country.search([('create_date', '=', "1970-01-01'); --")])

    def test_active(self):
        # testing for many2many field with category office and active=False
        Partner = self.env['res.partner']
        vals = {
            'name': 'OpenERP Test',
            'active': False,
            'category_id': [Command.set([self.partner_category.id])],
            'child_ids': [Command.create({'name': 'address of OpenERP Test', 'country_id': self.ref("base.be")})],
        }
        Partner.create(vals)
        partner = self._search(Partner, [('category_id', 'ilike', 'sellers'), ('active', '=', False)], [('active', '=', False)])
        self.assertTrue(partner, "Record not Found with category sellers and active False.")

        # testing for one2many field with country Belgium and active=False
        partner = self._search(Partner, [('child_ids.country_id','=','Belgium'),('active','=',False)], [('active', '=', False)])
        self.assertTrue(partner, "Record not Found with country Belgium and active False.")

    def test_lp1071710(self):
        """ Check that we can exclude translated fields (bug lp:1071710) """
        # first install french language
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.partner'].search([('name', '=', 'Pepper Street')]).country_id = self.env.ref('base.be')
        # actual test
        Country = self.env['res.country'].with_context(lang='fr_FR')
        be = self.env.ref('base.be')
        be.with_context(lang='fr_FR').name = "Belgique"
        self.assertNotEqual(be.name, "Belgique", "Setting a translation should not impact other languages")
        not_be = self._search(Country, [('name', '!=', 'Belgique')])
        self.assertNotIn(be, not_be)

        # indirect search via m2o
        Partner = self.env['res.partner']
        deco_addict = self._search(Partner, [('name', '=', 'Pepper Street')])

        not_be = self._search(Partner, [('country_id', '!=', 'Belgium')])
        self.assertNotIn(deco_addict, not_be)

        Partner = Partner.with_context(lang='fr_FR')
        not_be = self._search(Partner, [('country_id', '!=', 'Belgique')])
        self.assertNotIn(deco_addict, not_be)

    def test_or_with_implicit_and(self):
        # Check that when using expression.OR on a list of domains with at least one
        # implicit '&' the returned domain is the expected result.
        # from #24038
        d1 = [('foo', '=', 1), ('bar', '=', 1)]
        d2 = ['&', ('foo', '=', 2), ('bar', '=', 2)]

        expected = ['|', '&', ('foo', '=', 1), ('bar', '=', 1),
                         '&', ('foo', '=', 2), ('bar', '=', 2)]
        self.assertEqual(expression.OR([d1, d2]), expected)

    def test_proper_combine_unit_leaves(self):
        # test that unit leaves (TRUE_LEAF, FALSE_LEAF) are properly handled in specific cases
        false = expression.FALSE_DOMAIN
        true = expression.TRUE_DOMAIN
        normal = [('foo', '=', 'bar')]
        # OR with single FALSE_LEAF
        expr = expression.OR([false])
        self.assertEqual(expr, false)
        # OR with multiple FALSE_LEAF
        expr = expression.OR([false, false])
        self.assertEqual(expr, false)
        # OR with FALSE_LEAF and a normal leaf
        expr = expression.OR([false, normal])
        self.assertEqual(expr, normal)
        # OR with AND of single TRUE_LEAF and normal leaf
        expr = expression.OR([expression.AND([true]), normal])
        self.assertEqual(expr, true)
        # AND with single TRUE_LEAF
        expr = expression.AND([true])
        self.assertEqual(expr, true)
        # AND with multiple TRUE_LEAF
        expr = expression.AND([true, true])
        self.assertEqual(expr, true)
        # AND with TRUE_LEAF and normal leaves
        expr = expression.AND([true, normal])
        self.assertEqual(expr, normal)
        # AND with OR with single FALSE_LEAF and normal leaf
        expr = expression.AND([expression.OR([false]), normal])
        self.assertEqual(expr, false)

    def test_filtered_domain_order(self):
        domain = [('name', 'ilike', 'a')]
        countries = self.env['res.country'].search(domain)
        self.assertGreater(len(countries), 1)
        # same ids, same order
        self.assertEqual(countries.filtered_domain(domain)._ids, countries._ids)
        # again, trying the other way around
        countries = countries.browse(reversed(countries._ids))
        self.assertEqual(countries.filtered_domain(domain)._ids, countries._ids)

    def test_filtered_domain_order2(self):
        countries = self.env['res.country'].search([])
        # match the first two countries, in order
        expected = countries[:2]
        id1, id2 = expected._ids
        domain = ['|', ('id', '=', id1), ('id', '=', id2)]
        self.assertEqual(countries.filtered_domain(domain)._ids, expected._ids)
        domain = ['|', ('id', '=', id2), ('id', '=', id1)]
        self.assertEqual(countries.filtered_domain(domain)._ids, expected._ids)

    def test_filtered_domain_any_operator(self):
        Partner = self.env['res.partner']

        all_partner = self._search(Partner, [])
        partner = self.partners[0]

        children_partner_1 = self._search(Partner, [('parent_id', 'any', [('name', '=', partner.name)])])
        self.assertEqual(children_partner_1, partner.child_ids)

        children_other_partners = self._search(Partner, [('parent_id', 'not any', [('name', '=', partner.name)])])
        self.assertEqual(children_other_partners, all_partner - partner.child_ids)

        one_child_partner = partner.child_ids[0]
        parent_partner = self._search(Partner, [('child_ids', 'any', [('name', '=', one_child_partner.name)])])
        self.assertEqual(parent_partner, partner)

        other_partners = self._search(Partner, [('child_ids', 'not any', [('name', '=', one_child_partner.name)])])
        self.assertEqual(other_partners, all_partner - partner)


class TestExpression2(TransactionCase):

    def test_long_table_alias(self):
        # To test the 64 characters limit for table aliases in PostgreSQL
        self.patch(self.registry['res.users'], '_order', 'partner_id')
        self.patch(self.registry['res.partner'], '_order', 'commercial_partner_id,company_id,name')
        self.env['res.users'].search([('name', '=', 'test')])


class TestAutoJoin(TransactionCase):

    def test_auto_join(self):
        # Get models
        partner_obj = self.env['res.partner']
        state_obj = self.env['res.country.state']
        bank_obj = self.env['res.partner.bank']

        # Get test columns
        def patch_auto_join(model, fname, value):
            self.patch(model._fields[fname], 'auto_join', value)

        def patch_domain(model, fname, value):
            self.patch(model._fields[fname], 'domain', value)

        # Get country/state data
        Country = self.env['res.country']
        country_us = Country.search([('code', 'like', 'US')], limit=1)
        State = self.env['res.country.state']
        states = State.search([('country_id', '=', country_us.id)], limit=2)

        # Create demo data: partners and bank object
        p_a = partner_obj.create({'name': 'test__A', 'state_id': states[0].id})
        p_b = partner_obj.create({'name': 'test__B', 'state_id': states[1].id})
        p_c = partner_obj.create({'name': 'test__C', 'state_id': False})
        p_aa = partner_obj.create({'name': 'test__AA', 'parent_id': p_a.id, 'state_id': states[0].id})
        p_ab = partner_obj.create({'name': 'test__AB', 'parent_id': p_a.id, 'state_id': states[1].id})
        p_ba = partner_obj.create({'name': 'test__BA', 'parent_id': p_b.id, 'state_id': states[0].id})
        b_aa = bank_obj.create({'acc_number': '123', 'acc_type': 'bank', 'partner_id': p_aa.id})
        b_ab = bank_obj.create({'acc_number': '456', 'acc_type': 'bank', 'partner_id': p_ab.id})
        b_ba = bank_obj.create({'acc_number': '789', 'acc_type': 'bank', 'partner_id': p_ba.id})

        # --------------------------------------------------
        # Test1: basics about the attribute
        # --------------------------------------------------

        patch_auto_join(partner_obj, 'category_id', True)
        with self.assertRaises(NotImplementedError):
            partner_obj.search([('category_id.name', '=', 'foo')])

        # --------------------------------------------------
        # Test2: one2many
        # --------------------------------------------------

        name_test = '12'

        # Do: one2many without _auto_join
        partners = partner_obj.search([('bank_ids.sanitized_acc_number', 'like', name_test)])
        self.assertEqual(partners, p_aa,
            "_auto_join off: ('bank_ids.sanitized_acc_number', 'like', '..'): incorrect result")

        partners = partner_obj.search(['|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', name_test)])
        self.assertIn(p_aa, partners,
            "_auto_join off: '|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', '..'): incorrect result")
        self.assertIn(p_c, partners,
            "_auto_join off: '|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', '..'): incorrect result")

        # Do: cascaded one2many without _auto_join
        partners = partner_obj.search([('child_ids.bank_ids.id', 'in', [b_aa.id, b_ba.id])])
        self.assertEqual(partners, p_a + p_b,
            "_auto_join off: ('child_ids.bank_ids.id', 'in', [..]): incorrect result")

        # Do: one2many with _auto_join
        patch_auto_join(partner_obj, 'bank_ids', True)
        partners = partner_obj.search([('bank_ids.sanitized_acc_number', 'like', name_test)])
        self.assertEqual(partners, p_aa,
            "_auto_join on: ('bank_ids.sanitized_acc_number', 'like', '..') incorrect result")

        partners = partner_obj.search(['|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', name_test)])
        self.assertIn(p_aa, partners,
            "_auto_join on: '|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', '..'): incorrect result")
        self.assertIn(p_c, partners,
            "_auto_join on: '|', ('name', 'like', 'C'), ('bank_ids.sanitized_acc_number', 'like', '..'): incorrect result")

        # Do: one2many with _auto_join, test final leaf is an id
        bank_ids = [b_aa.id, b_ab.id]
        partners = partner_obj.search([('bank_ids.id', 'in', bank_ids)])
        self.assertEqual(partners, p_aa + p_ab,
            "_auto_join on: ('bank_ids.id', 'in', [..]) incorrect result")

        # Do: 2 cascaded one2many with _auto_join, test final leaf is an id
        patch_auto_join(partner_obj, 'child_ids', True)
        bank_ids = [b_aa.id, b_ba.id]
        partners = partner_obj.search([('child_ids.bank_ids.id', 'in', bank_ids)])
        self.assertEqual(partners, p_a + p_b,
            "_auto_join on: ('child_ids.bank_ids.id', 'not in', [..]): incorrect result")

        # --------------------------------------------------
        # Test3: many2one
        # --------------------------------------------------
        name_test = 'US'

        # Do: many2one without _auto_join
        partners = partner_obj.search([('state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b + p_aa + p_ab + p_ba, partners,
            "_auto_join off: ('state_id.country_id.code', 'like', '..') incorrect result")

        partners = partner_obj.search(['|', ('state_id.code', '=', states[0].code), ('name', 'like', 'C')])
        self.assertIn(p_a, partners, '_auto_join off: disjunction incorrect result')
        self.assertIn(p_c, partners, '_auto_join off: disjunction incorrect result')

        # Do: many2one with 1 _auto_join on the first many2one
        patch_auto_join(partner_obj, 'state_id', True)
        partners = partner_obj.search([('state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b + p_aa + p_ab + p_ba, partners,
            "_auto_join on for state_id: ('state_id.country_id.code', 'like', '..') incorrect result")

        partners = partner_obj.search(['|', ('state_id.code', '=', states[0].code), ('name', 'like', 'C')])
        self.assertIn(p_a, partners, '_auto_join: disjunction incorrect result')
        self.assertIn(p_c, partners, '_auto_join: disjunction incorrect result')

        # Do: many2one with 1 _auto_join on the second many2one
        patch_auto_join(partner_obj, 'state_id', False)
        patch_auto_join(state_obj, 'country_id', True)
        partners = partner_obj.search([('state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b + p_aa + p_ab + p_ba, partners,
            "_auto_join on for country_id: ('state_id.country_id.code', 'like', '..') incorrect result")

        # Do: many2one with 2 _auto_join
        patch_auto_join(partner_obj, 'state_id', True)
        patch_auto_join(state_obj, 'country_id', True)
        partners = partner_obj.search([('state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b + p_aa + p_ab + p_ba, partners,
            "_auto_join on: ('state_id.country_id.code', 'like', '..') incorrect result")

        # --------------------------------------------------
        # Test4: domain attribute on one2many fields
        # --------------------------------------------------

        patch_auto_join(partner_obj, 'child_ids', True)
        patch_auto_join(partner_obj, 'bank_ids', True)
        patch_domain(partner_obj, 'child_ids', lambda self: ['!', ('name', '=', self._name)])
        patch_domain(partner_obj, 'bank_ids', [('sanitized_acc_number', 'like', '2')])

        # Do: 2 cascaded one2many with _auto_join, test final leaf is an id
        partners = partner_obj.search(['&', (1, '=', 1), ('child_ids.bank_ids.id', 'in', [b_aa.id, b_ba.id])])
        self.assertLessEqual(p_a, partners,
            "_auto_join on one2many with domains incorrect result")
        self.assertFalse((p_ab + p_ba) & partners,
            "_auto_join on one2many with domains incorrect result")

        patch_domain(partner_obj, 'child_ids', lambda self: [('name', '=', '__%s' % self._name)])
        partners = partner_obj.search(['&', (1, '=', 1), ('child_ids.bank_ids.id', 'in', [b_aa.id, b_ba.id])])
        self.assertFalse(partners,
            "_auto_join on one2many with domains incorrect result")

        # ----------------------------------------
        # Test5: result-based tests
        # ----------------------------------------

        patch_auto_join(partner_obj, 'bank_ids', False)
        patch_auto_join(partner_obj, 'child_ids', False)
        patch_auto_join(partner_obj, 'state_id', False)
        patch_auto_join(partner_obj, 'parent_id', False)
        patch_auto_join(state_obj, 'country_id', False)
        patch_domain(partner_obj, 'child_ids', [])
        patch_domain(partner_obj, 'bank_ids', [])

        # Do: ('child_ids.state_id.country_id.code', 'like', '..') without _auto_join
        partners = partner_obj.search([('child_ids.state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b, partners,
            "_auto_join off: ('child_ids.state_id.country_id.code', 'like', '..') incorrect result")

        # Do: ('child_ids.state_id.country_id.code', 'like', '..') with _auto_join
        patch_auto_join(partner_obj, 'child_ids', True)
        patch_auto_join(partner_obj, 'state_id', True)
        patch_auto_join(state_obj, 'country_id', True)
        partners = partner_obj.search([('child_ids.state_id.country_id.code', 'like', name_test)])
        self.assertLessEqual(p_a + p_b, partners,
            "_auto_join on: ('child_ids.state_id.country_id.code', 'like', '..') incorrect result")

    def test_nullfields(self):
        obj1 = self.env['res.bank'].create({'name': 'c0'})
        obj2 = self.env['res.bank'].create({'name': 'c1', 'city': 'Ljósálfaheimr'})
        obj3 = self.env['res.bank'].create({'name': 'c2', 'city': 'York'})
        obj4 = self.env['res.bank'].create({'name': 'c3', 'city': 'Springfield'})

        self.assertEqual(
            self.env['res.bank'].search([
                ('id', 'in', (obj1 | obj2 | obj3 | obj4).ids),
                ('city', '!=', 'York'),
            ]),
            (obj1 | obj2 | obj4),
            "Should have returned all banks whose city is not York"
        )

        self.assertEqual(
            self.env['res.bank'].search([
                ('id', 'in', (obj1 | obj2 | obj3 | obj4).ids),
                ('city', 'not ilike', 'field'),
            ]),
            (obj1 | obj2 | obj3),
            "Should have returned all banks whose city doesn't contain field"
        )


class TestQueries(TransactionCase):

    def test_logic(self):
        Model = self.env['res.partner']
        domain = [
            '&', ('name', 'like', 'foo'),
                 '|', ('title', '=', 1), '!', ('ref', '=', '42'),
        ]
        Model.search(domain)

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (
                (
                    ("res_partner"."active" = %s) AND
                    ("res_partner"."name"::text LIKE %s)
                ) AND (
                    ("res_partner"."title" = %s) OR (
                        ("res_partner"."ref" != %s) OR
                        "res_partner"."ref" IS NULL
                    )
                )
            )
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            Model.search(domain)

    def test_order(self):
        Model = self.env['res.partner']
        Model.search([('name', 'like', 'foo')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (("res_partner"."active" = %s) AND ("res_partner"."name"::text LIKE %s))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            Model.search([('name', 'like', 'foo')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (("res_partner"."active" = %s) AND ("res_partner"."name"::text LIKE %s))
            ORDER BY "res_partner"."id"
        ''']):
            Model.search([('name', 'like', 'foo')], order='id')

    def test_count(self):
        Model = self.env['res.partner']
        Model.search([('name', 'like', 'foo')])

        with self.assertQueries(['''
            SELECT COUNT(*)
            FROM "res_partner"
            WHERE (("res_partner"."active" = %s) AND ("res_partner"."name"::text LIKE %s))
        ''']):
            Model.search_count([('name', 'like', 'foo')])

    def test_count_limit(self):
        Model = self.env['res.partner']
        Model.search([('name', 'like', 'foo')])

        with self.assertQueries(['''
            SELECT COUNT(*) FROM (
                SELECT FROM "res_partner"
                WHERE (("res_partner"."active" = %s) AND ("res_partner"."name"::text LIKE %s))
                LIMIT %s
            ) t
        ''']):
            Model.search_count([('name', 'like', 'foo')], limit=1)

    def test_translated_field(self):
        self.env['res.lang']._activate_lang('fr_FR')
        Model = self.env['res.partner.title'].with_context(lang='fr_FR')
        Model.search([('name', 'ilike', 'foo')])

        with self.assertQueries(['''
            SELECT "res_partner_title"."id"
            FROM "res_partner_title"
            WHERE (COALESCE("res_partner_title"."name"->>%s, "res_partner_title"."name"->>%s) like %s)
            ORDER BY COALESCE("res_partner_title"."name"->>%s, "res_partner_title"."name"->>%s)
        ''']):
            Model.search([('name', 'like', 'foo')])

        with self.assertQueries(['''
            SELECT COUNT(*)
            FROM "res_partner_title"
            WHERE ("res_partner_title"."id" = %s)
        ''']):
            Model.search_count([('id', '=', 1)])

    @mute_logger('odoo.models.unlink')
    def test_access_rules(self):
        Model = self.env['res.users'].with_user(self.env.ref('base.user_admin'))
        self.env['ir.rule'].search([]).unlink()
        self.env['ir.rule'].create([{
            'name': 'users rule',
            'model_id': self.env['ir.model']._get('res.users').id,
            'domain_force': str([('id', '=', 1)]),
        }, {
            'name': 'partners rule',
            'model_id': self.env['ir.model']._get('res.partner').id,
            'domain_force': str([('id', '=', 1)]),
        }])
        Model.search([])

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            LEFT JOIN "res_partner" AS "res_users__partner_id" ON
                ("res_users"."partner_id" = "res_users__partner_id"."id")
            WHERE ("res_users"."active" = %s)
            AND (("res_users"."id" = %s) AND ("res_users__partner_id"."id" = %s))
            ORDER BY "res_users__partner_id"."name", "res_users"."login"
        ''']):
            Model.search([])

    def test_rec_names_search(self):
        Model = self.env['ir.model']

        # search on both 'name' and 'model'
        self.assertEqual(Model._rec_names_search, ['name', 'model'])

        with self.assertQueries(['''
            SELECT "ir_model"."id", "ir_model"."name"->>%s
            FROM "ir_model"
            WHERE (
                ("ir_model"."name"->>%s ILIKE %s)
                OR ("ir_model"."model"::text ILIKE %s)
            )
            ORDER BY "ir_model"."model"
            LIMIT %s
        ''']):
            Model.name_search('foo')

        with self.assertQueries(['''
            SELECT "ir_model"."id", "ir_model"."name"->>%s
            FROM "ir_model"
            WHERE (
                ("ir_model"."name" is NULL OR "ir_model"."name"->>%s not ilike %s)
                AND (("ir_model"."model"::text NOT ILIKE %s) OR "ir_model"."model" IS NULL)
            )
            ORDER BY "ir_model"."model"
            LIMIT %s
        ''']):
            Model.name_search('foo', operator='not ilike')


class TestMany2one(TransactionCase):
    def setUp(self):
        super().setUp()
        self.Partner = self.env['res.partner'].with_context(active_test=False)
        self.User = self.env['res.users'].with_context(active_test=False)
        self.company = self.env['res.company'].browse(1)

    def test_inherited(self):
        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            LEFT JOIN "res_partner" AS "res_users__partner_id" ON
                ("res_users"."partner_id" = "res_users__partner_id"."id")
            WHERE ("res_users__partner_id"."name"::text LIKE %s)
            ORDER BY "res_users__partner_id"."name", "res_users"."login"
        ''']):
            self.User.search([('name', 'like', 'foo')])

        # the field supporting the inheritance should be auto_join, too
        # TODO: use another model, since 'res.users' has explicit auto_join
        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            LEFT JOIN "res_partner" AS "res_users__partner_id" ON
                ("res_users"."partner_id" = "res_users__partner_id"."id")
            WHERE ("res_users__partner_id"."name"::text LIKE %s)
            ORDER BY "res_users__partner_id"."name", "res_users"."login"
        ''']):
            self.User.search([('partner_id.name', 'like', 'foo')])

    def test_regular(self):
        self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])
        self.Partner.search([('country_id.code', 'like', 'BE')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" = %s)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id', '=', self.company.id)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE ("res_company"."name"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE ("res_company"."partner_id" IN (
                    SELECT "res_partner"."id"
                    FROM "res_partner"
                    WHERE ("res_partner"."name"::text LIKE %s)
                ))
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE ("res_company"."name"::text LIKE %s)
            )) OR ("res_partner"."country_id" IN (
                SELECT "res_country"."id"
                FROM "res_country"
                WHERE ("res_country"."code"::text LIKE %s)
            )))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([
                '|',
                ('company_id.name', 'like', self.company.name),
                ('country_id.code', 'like', 'BE'),
            ])

    def test_explicit_subquery(self):
        self.Partner.search([('company_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE (("res_company"."active" = %s) AND ("res_company"."name"::text LIKE %s))
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            company_ids = self.company._search([('name', 'like', self.company.name)], order='id')
            self.Partner.search([('company_id', 'in', company_ids)])

        # special case, with a LIMIT to make ORDER BY necessary
        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE (("res_company"."active" = %s) AND ("res_company"."name"::text LIKE %s))
                ORDER BY "res_company"."id"
                LIMIT %s
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            company_ids = self.company._search([('name', 'like', self.company.name)], order='id', limit=1)
            self.Partner.search([('company_id', 'in', company_ids)])

        # special case, when the query has been "forced"
        with self.assertQueries(['''
            SELECT "res_company"."id"
            FROM "res_company"
            WHERE (("res_company"."active" = %s) AND ("res_company"."name"::text LIKE %s))
            ORDER BY "res_company"."id"
        ''', '''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN %s)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            company_ids = self.company._search([('name', 'like', self.company.name)], order='id')
            company_ids = tuple(company_ids)
            self.Partner.search([('company_id', 'in', company_ids)])

        # special case, when the query has been build from a record
        with self.assertQueries(['''
            SELECT "res_company"."id"
            FROM "res_company"
            WHERE (("res_company"."active" = %s) AND ("res_company"."name"::text LIKE %s))
            ORDER BY "res_company"."id"
        ''', '''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN %s)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            companies = self.company.search([('name', 'like', self.company.name)], order='id')
            company_ids = companies._as_query(ordered=False)
            self.Partner.search([('company_id', 'in', company_ids)])

        # special case, when the query has been transformed to SQL
        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE (("res_company"."active" = %s) AND ("res_company"."name"::text LIKE %s))
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            company_ids = self.company._search([('name', 'like', self.company.name)], order='id')
            self.Partner.search([('company_id', 'in', company_ids.subselect())])

    def test_autojoin(self):
        # auto_join on the first many2one
        self.patch(self.Partner._fields['company_id'], 'auto_join', True)
        self.patch(self.company._fields['partner_id'], 'auto_join', False)
        self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            LEFT JOIN "res_company" AS "res_partner__company_id" ON
                ("res_partner"."company_id" = "res_partner__company_id"."id")
            WHERE ("res_partner__company_id"."name"::text LIKE %s)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            LEFT JOIN "res_company" AS "res_partner__company_id" ON
                ("res_partner"."company_id" = "res_partner__company_id"."id")
            WHERE ("res_partner__company_id"."partner_id" IN (
                SELECT "res_partner"."id"
                FROM "res_partner"
                WHERE ("res_partner"."name"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        # auto_join on the second many2one
        self.patch(self.Partner._fields['company_id'], 'auto_join', False)
        self.patch(self.company._fields['partner_id'], 'auto_join', True)
        self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                LEFT JOIN "res_partner" AS "res_company__partner_id" ON
                    ("res_company"."partner_id" = "res_company__partner_id"."id")
                WHERE ("res_company__partner_id"."name"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        # auto_join on both many2one
        self.patch(self.Partner._fields['company_id'], 'auto_join', True)
        self.patch(self.company._fields['partner_id'], 'auto_join', True)
        self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            LEFT JOIN "res_company" AS "res_partner__company_id" ON
                ("res_partner"."company_id" = "res_partner__company_id"."id")
            LEFT JOIN "res_partner" AS "res_partner__company_id__partner_id" ON
                ("res_partner__company_id"."partner_id" = "res_partner__company_id__partner_id"."id")
            WHERE ("res_partner__company_id__partner_id"."name"::text LIKE %s)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id.partner_id.name', 'like', self.company.name)])

        # union with two auto_join
        self.patch(self.Partner._fields['company_id'], 'auto_join', True)
        self.patch(self.Partner._fields['country_id'], 'auto_join', True)
        self.Partner.search([
            '|',
            ('company_id.name', 'like', self.company.name),
            ('country_id.code', 'like', 'BE'),
        ])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            LEFT JOIN "res_country" AS "res_partner__country_id" ON
                ("res_partner"."country_id" = "res_partner__country_id"."id")
            LEFT JOIN "res_company" AS "res_partner__company_id" ON
                ("res_partner"."company_id" = "res_partner__company_id"."id")
            WHERE (("res_partner__company_id"."name"::text LIKE %s)
                OR ("res_partner__country_id"."code"::text LIKE %s))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([
                '|',
                ('company_id.name', 'like', self.company.name),
                ('country_id.code', 'like', 'BE'),
            ])

    def test_name_search(self):
        self.Partner.search([('company_id', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE ("res_company"."name"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id', 'like', self.company.name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (("res_partner"."company_id" IN (
                SELECT "res_company"."id"
                FROM "res_company"
                WHERE (("res_company"."name"::text not like %s) OR "res_company"."name" IS NULL))
            ) OR "res_partner"."company_id" IS NULL)
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('company_id', 'not like', "blablabla")])


class TestOne2many(TransactionCase):
    def setUp(self):
        super().setUp()
        self.Partner = self.env['res.partner'].with_context(active_test=False)
        self.partner = self.Partner.create({
            'name': 'Foo',
            'bank_ids': [
                Command.create({'acc_number': '123', 'acc_type': 'bank'}),
                Command.create({'acc_number': '456', 'acc_type': 'bank'}),
                Command.create({'acc_number': '789', 'acc_type': 'bank'}),
            ],
        })

    def test_regular(self):
        self.Partner.search([('bank_ids', 'in', self.partner.bank_ids.ids)])
        self.Partner.search([('bank_ids.sanitized_acc_number', 'like', '12')])
        self.Partner.search([('child_ids.bank_ids.sanitized_acc_number', 'like', '12')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE "res_partner_bank"."id" IN %s
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('bank_ids', 'in', self.partner.bank_ids.ids)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('bank_ids.sanitized_acc_number', 'like', '12')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner"."parent_id"
                FROM "res_partner"
                WHERE ("res_partner"."id" IN (
                    SELECT "res_partner_bank"."partner_id"
                    FROM "res_partner_bank"
                    WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
                )) AND "res_partner"."parent_id" IS NOT NULL
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('child_ids.bank_ids.sanitized_acc_number', 'like', '12')])

    def test_autojoin(self):
        self.patch(self.Partner._fields['bank_ids'], 'auto_join', True)
        self.patch(self.Partner._fields['child_ids'], 'auto_join', True)
        self.Partner.search([('bank_ids', 'in', self.partner.bank_ids.ids)])
        self.Partner.search([('bank_ids.sanitized_acc_number', 'like', '12')])
        self.Partner.search([('child_ids.bank_ids.sanitized_acc_number', 'like', '12')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE "res_partner_bank"."id" IN %s
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('bank_ids', 'in', self.partner.bank_ids.ids)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('bank_ids.sanitized_acc_number', 'like', '12')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE (("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
            )) AND ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
            )))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([
                ('bank_ids.sanitized_acc_number', 'like', '12'),
                ('bank_ids.sanitized_acc_number', 'like', '45'),
            ])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN
                     (SELECT "res_partner"."parent_id"
                      FROM "res_partner"
                      WHERE (("res_partner"."active" = TRUE) AND ("res_partner"."id" IN
                                (SELECT "res_partner_bank"."partner_id"
                                 FROM "res_partner_bank"
                                 WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)))
                             )))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('child_ids.bank_ids.sanitized_acc_number', 'like', '12')])

        # check domains on one2many fields
        self.patch(self.Partner._fields['bank_ids'], 'domain',
                   [('sanitized_acc_number', 'like', '2')])
        self.patch(self.Partner._fields['child_ids'], 'domain',
                   lambda self: ['!', ('name', '=', self._name)])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner"."parent_id"
                FROM "res_partner"
                WHERE ((
                    ("res_partner"."name" != %s) OR "res_partner"."name" IS NULL
                ) AND (
                    "res_partner"."id" IN (
                        SELECT "res_partner_bank"."partner_id"
                        FROM "res_partner_bank"
                        WHERE ((
                            "res_partner_bank"."id" IN %s
                        ) AND (
                            "res_partner_bank"."sanitized_acc_number"::text LIKE %s
                        ))
                    )
                ))
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('child_ids.bank_ids.id', 'in', self.partner.bank_ids.ids)])

    def test_autojoin_mixed(self):
        self.patch(self.Partner._fields['child_ids'], 'auto_join', True)
        self.patch(self.Partner._fields['state_id'], 'auto_join', True)
        self.patch(self.Partner.state_id._fields['country_id'], 'auto_join', True)
        self.Partner.search([('child_ids.state_id.country_id.code', 'like', 'US')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner"."parent_id"
                FROM "res_partner"
                LEFT JOIN "res_country_state" AS "res_partner__state_id"
                    ON ("res_partner"."state_id" = "res_partner__state_id"."id")
                LEFT JOIN "res_country" AS "res_partner__state_id__country_id"
                    ON ("res_partner__state_id"."country_id" = "res_partner__state_id__country_id"."id")
                WHERE ((
                    "res_partner"."active" = TRUE
                ) AND (
                    "res_partner__state_id__country_id"."code"::text LIKE %s
                ))
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('child_ids.state_id.country_id.code', 'like', 'US')])

    def test_name_search(self):
        self.Partner.search([('bank_ids', 'like', '12')])

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE ("res_partner_bank"."sanitized_acc_number"::text LIKE %s)
            ))
            ORDER BY "res_partner"."complete_name"asc,"res_partner"."id"desc
        ''']):
            self.Partner.search([('bank_ids', 'like', '12')])

    def test_empty(self):
        self.Partner.search([('bank_ids', '!=', False)], order='id')
        self.Partner.search([('bank_ids', '=', False)], order='id')

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE "res_partner_bank"."partner_id" IS NOT NULL
            ))
            ORDER BY "res_partner"."id"
        ''']):
            self.Partner.search([('bank_ids', '!=', False)], order='id')

        with self.assertQueries(['''
            SELECT "res_partner"."id"
            FROM "res_partner"
            WHERE ("res_partner"."id" NOT IN (
                SELECT "res_partner_bank"."partner_id"
                FROM "res_partner_bank"
                WHERE "res_partner_bank"."partner_id" IS NOT NULL
            ))
            ORDER BY "res_partner"."id"
        ''']):
            self.Partner.search([('bank_ids', '=', False)], order='id')


class TestMany2many(TransactionCase):
    def setUp(self):
        super().setUp()
        self.User = self.env['res.users'].with_context(active_test=False)
        self.company = self.env['res.company'].browse(1)

    def test_regular(self):
        group = self.env.ref('base.group_user')
        rule = group.rule_groups[0]

        self.User.search([('groups_id', 'in', group.ids)], order='id')
        self.User.search([('groups_id.name', 'like', group.name)], order='id')
        self.User.search([('groups_id.rule_groups.name', 'like', rule.name)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
                AND "res_users__groups_id"."gid" IN %s
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id', 'in', group.ids)], order='id')

        group_color = group.color
        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE NOT EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
                AND "res_users__groups_id"."gid" IN %s
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id', 'not in', group.ids)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
                AND "res_users__groups_id"."gid" IN (
                    SELECT "res_groups"."id"
                    FROM "res_groups"
                    WHERE ("res_groups"."color" = %s)
                )
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id.color', '=', group_color)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
                AND "res_users__groups_id"."gid" IN (
                    SELECT "res_groups"."id"
                    FROM "res_groups"
                    WHERE EXISTS (
                        SELECT 1 FROM "rule_group_rel" AS "res_groups__rule_groups"
                        WHERE "res_groups__rule_groups"."group_id" = "res_groups"."id"
                        AND "res_groups__rule_groups"."rule_group_id" IN (
                            SELECT "ir_rule"."id"
                            FROM "ir_rule"
                            WHERE ("ir_rule"."name"::text LIKE %s)
                        )
                    )
                )
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id.rule_groups.name', 'like', rule.name)], order='id')

    def test_autojoin(self):
        self.patch(self.User._fields['groups_id'], 'auto_join', True)
        with self.assertRaises(NotImplementedError):
            self.User.search([('groups_id.name', '=', 'foo')])

    def test_name_search(self):
        self.User.search([('company_ids', 'like', self.company.name)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE EXISTS (
                SELECT 1 FROM "res_company_users_rel" AS "res_users__company_ids"
                WHERE "res_users__company_ids"."user_id" = "res_users"."id"
                AND "res_users__company_ids"."cid" IN (
                    SELECT "res_company"."id"
                    FROM "res_company"
                    WHERE ("res_company"."name"::text LIKE %s)
                )
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('company_ids', 'like', self.company.name)], order='id')

    def test_empty(self):
        self.User.search([('groups_id', '!=', False)], order='id')
        self.User.search([('groups_id', '=', False)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id', '!=', False)], order='id')

        with self.assertQueries(['''
            SELECT "res_users"."id"
            FROM "res_users"
            WHERE NOT EXISTS (
                SELECT 1 FROM "res_groups_users_rel" AS "res_users__groups_id"
                WHERE "res_users__groups_id"."uid" = "res_users"."id"
            )
            ORDER BY "res_users"."id"
        ''']):
            self.User.search([('groups_id', '=', False)], order='id')


class TestPrettifyDomain(BaseCase):
    def test_prettify_domain(self):
        _Case = collections.namedtuple('Case', ('name', 'dom', 'pretty'))

        test_matrix = [
            _Case(
                name='single leaf',
                dom=[('name', '=', 'Jack')],
                pretty="[('name', '=', 'Jack')]"
            ),
            _Case(
                name='not',
                dom=['!', ('name', '=', 'Apophis')],
                pretty=textwrap.dedent("""\
                    ['!',
                        ('name', '=', 'Apophis')]
                """).rstrip()
            ),
            _Case(
                name='single and',
                dom=['&',
                        ('name', '=', 'Jack'),
                        ('function', '=', 'Colonel')],
                pretty=textwrap.dedent("""\
                    ['&',
                        ('name', '=', 'Jack'),
                        ('function', '=', 'Colonel')]
                """).rstrip()
            ),
            _Case(
                name='multiple and',
                dom=['&', '&',
                        ('name', 'like', 'Jack'),
                        ('name', 'like', "O'Neill"),
                        ('function', '=', 'Colonel')],
                pretty=textwrap.dedent("""\
                    ['&', '&',
                        ('name', 'like', 'Jack'),
                        ('name', 'like', "O'Neill"),
                        ('function', '=', 'Colonel')]
                """).rstrip()
            ),
            _Case(
                name='and or',
                dom=['&',
                        '|',
                            ('name', 'like', 'Jack'),
                            ('name', 'like', "O'Neill"),
                        ('function', '=', 'Colonel')],
                pretty=textwrap.dedent("""\
                    ['&',
                        '|',
                            ('name', 'like', 'Jack'),
                            ('name', 'like', "O'Neill"),
                        ('function', '=', 'Colonel')]
                """).rstrip()
            ),
            _Case(
                name='any single',
                dom=[('company', 'any', [('name', '=', 'SGC')])],
                pretty="[('company', 'any', [('name', '=', 'SGC')])]"
            ),
            _Case(
                name='any or',
                dom=[('company', 'any', ['|',
                        ('name', '=', 'SGC'),
                        ('name', '=', 'Stargate Command')])],
                pretty=textwrap.dedent("""\
                    [('company', 'any', ['|',
                        ('name', '=', 'SGC'),
                        ('name', '=', 'Stargate Command')])]
                """).rstrip()
            )
        ]

        for case in test_matrix:
            with self.subTest(name=case.name):
                pretty_domain = expression.prettify_domain(case.dom)
                self.assertEqual(pretty_domain, case.pretty)
                self.assertEqual(literal_eval(case.pretty), case.dom)


class TestAnyfy(TransactionCase):
    def _test_combine_anies(self, domain, expected):
        anyfied_domain = expression.domain_combine_anies(domain, self.env['res.partner'])
        return self.assertEqual(anyfied_domain, expected,
                                f'\nFor initial domain: {domain}\nBecame: {anyfied_domain}')

    def test_true_leaf_as_list(self):
        self._test_combine_anies([
            [1, '=', 1]
        ], [
            (1, '=', 1)
        ])

    def test_single_field(self):
        self._test_combine_anies([
            ('name', '=', 'Jack')
        ], [
            ('name', '=', 'Jack')
        ])

    def test_single_many2one_with_subfield(self):
        self._test_combine_anies([
            ('company_id.name', '=', 'SGC'),
        ], [
            ('company_id', 'any', [('name', '=', 'SGC')]),
        ])

    def test_single_one2many_with_subfield(self):
        self._test_combine_anies([
            ('child_ids.name', '=', 'Jack'),
        ], [
            ('child_ids', 'any', [('name', '=', 'Jack')]),
        ])

    def test_and_multiple_fields(self):
        self._test_combine_anies([
            '&', '&',
                ('name', '=', 'Jack'),
                ('name', '=', 'Sam'),
                ('name', '=', 'Daniel'),
        ], [
            '&', '&',
                ('name', '=', 'Jack'),
                ('name', '=', 'Sam'),
                ('name', '=', 'Daniel'),
        ])

    def test_or_multiple_fields(self):
        self._test_combine_anies([
            '|', '|',
                ('name', '=', 'Jack'),
                ('name', '=', 'Sam'),
                ('name', '=', 'Daniel'),
        ], [
            '|', '|',
                ('name', '=', 'Jack'),
                ('name', '=', 'Sam'),
                ('name', '=', 'Daniel'),
        ])

    def test_and_multiple_many2one_with_subfield(self):
        self._test_combine_anies([
            '&', '&',
                ('company_id.name', '=', 'SGC'),
                ('company_id.name', '=', 'NID'),
                ('company_id.name', '=', 'Free Jaffa Nation'),
        ], [
            ('company_id', 'any', [
                '&', '&',
                    ('name', '=', 'SGC'),
                    ('name', '=', 'NID'),
                    ('name', '=', 'Free Jaffa Nation'),
            ])
        ])

    def test_or_multiple_many2one_with_subfield(self):
        self._test_combine_anies([
            '|', '|',
                ('company_id.name', '=', 'SGC'),
                ('company_id.name', '=', 'NID'),
                ('company_id.name', '=', 'Free Jaffa Nation'),
        ], [
            ('company_id', 'any', [
                '|', '|',
                    ('name', '=', 'SGC'),
                    ('name', '=', 'NID'),
                    ('name', '=', 'Free Jaffa Nation'),
            ])
        ])

    def test_and_multiple_one2many_with_subfield(self):
        self._test_combine_anies([
            '&', '&',
                ('child_ids.name', '=', 'Jack'),
                ('child_ids.name', '=', 'Sam'),
                ('child_ids.name', '=', 'Daniel'),
        ], [
            '&', '&',
            ('child_ids', 'any', [('name', '=', 'Jack')]),
            ('child_ids', 'any', [('name', '=', 'Sam')]),
            ('child_ids', 'any', [('name', '=', 'Daniel')]),
        ])

    def test_or_multiple_one2many_with_subfield(self):
        self._test_combine_anies([
            '|', '|',
                ('child_ids.name', '=', 'Jack'),
                ('child_ids.name', '=', 'Sam'),
                ('child_ids.name', '=', 'Daniel'),
        ], [
            ('child_ids', 'any', [
                '|', '|',
                    ('name', '=', 'Jack'),
                    ('name', '=', 'Sam'),
                    ('name', '=', 'Daniel'),
            ])
        ])

    def test_not_single_field(self):
        self._test_combine_anies([
            '!', ('name', '=', 'Jack')
        ], [
            ('name', '!=', 'Jack')
        ])

    def test_not_single_many2one_with_subfield(self):
        self._test_combine_anies([
            '!', ('company_id.name', '=', 'SGC')
        ], [
            ('company_id', 'not any', [('name', '=', 'SGC')])
        ])

    def test_not_single_one2many_with_subfield(self):
        self._test_combine_anies([
            '!', ('child_ids.name', '=', 'Jack')
        ], [
            ('child_ids', 'not any', [('name', '=', 'Jack')])
        ])

    def test_not_or_multiple_fields(self):
        self._test_combine_anies([
            '!', '|', '|',
                ('name', '=', 'Jack'),
                ('name', '=', 'Sam'),
                ('name', '=', 'Daniel'),
        ], [
            '&', '&',
                ('name', '!=', 'Jack'),
                ('name', '!=', 'Sam'),
                ('name', '!=', 'Daniel'),
        ])

    def test_not_and_multiple_many2one_field_with_subfield(self):
        self._test_combine_anies([
            '!', '&', '&',
                ('company_id.name', '=', 'SGC'),
                ('company_id.name', '=', 'NID'),
                ('company_id.name', '=', 'Free Jaffa Nation'),
        ], [
            ('company_id', 'not any', [
                '&', '&',
                    ('name', '=', 'SGC'),
                    ('name', '=', 'NID'),
                    ('name', '=', 'Free Jaffa Nation'),
            ])
        ])

    def test_not_or_multiple_many2one_field_with_subfield(self):
        self._test_combine_anies([
            '!', '|', '|',
                ('company_id.name', '=', 'SGC'),
                ('company_id.name', '=', 'NID'),
                ('company_id.name', '=', 'Free Jaffa Nation'),
        ], [
            ('company_id', 'not any', [
                '|', '|',
                    ('name', '=', 'SGC'),
                    ('name', '=', 'NID'),
                    ('name', '=', 'Free Jaffa Nation'),
            ])
        ])

    def test_not_and_multiple_one2many_field_with_subfield(self):
        self._test_combine_anies([
            '!', '&', '&',
                ('child_ids.name', '=', 'Jack'),
                ('child_ids.name', '=', 'Sam'),
                ('child_ids.name', '=', 'Daniel'),
        ], [
            '|', '|',
                ('child_ids', 'not any', [('name', '=', 'Jack')]),
                ('child_ids', 'not any', [('name', '=', 'Sam')]),
                ('child_ids', 'not any', [('name', '=', 'Daniel')]),
        ])

    def test_not_or_multiple_one2many_field_with_subfield(self):
        self._test_combine_anies([
            '!', '|', '|',
                ('child_ids.name', '=', 'Jack'),
                ('child_ids.name', '=', 'Sam'),
                ('child_ids.name', '=', 'Daniel'),
        ], [
            ('child_ids', 'not any', [
                '|', '|',
                    ('name', '=', 'Jack'),
                    ('name', '=', 'Sam'),
                    ('name', '=', 'Daniel'),
            ])
        ])

```

  File: tests/test_float.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from math import log10

from odoo.tests.common import TransactionCase
from odoo.tools import float_compare, float_is_zero, float_repr, float_round, float_split, float_split_str


class TestFloatPrecision(TransactionCase):
    """ Tests on float precision. """

    def test_rounding_02(self):
        """ Test rounding methods with 2 digits. """
        currency = self.env.ref('base.EUR')

        def try_round(amount, expected):
            digits = max(0, -int(log10(currency.rounding)))
            result = float_repr(currency.round(amount), precision_digits=digits)
            self.assertEqual(result, expected, 'Rounding error: got %s, expected %s' % (result, expected))

        try_round(2.674,'2.67')
        try_round(2.675,'2.68')   # in Python 2.7.2, round(2.675,2) gives 2.67
        try_round(-2.675,'-2.68') # in Python 2.7.2, round(2.675,2) gives 2.67
        try_round(0.001,'0.00')
        try_round(-0.001,'-0.00')
        try_round(0.0049,'0.00')   # 0.0049 is closer to 0 than to 0.01, so should round down
        try_round(0.005,'0.01')   # the rule is to round half away from zero
        try_round(-0.005,'-0.01') # the rule is to round half away from zero
        try_round(6.6 * 0.175, '1.16') # 6.6 * 0.175 is rounded to 1.15 with epsilon = 53
        try_round(-6.6 * 0.175, '-1.16')

        def try_zero(amount, expected):
            self.assertEqual(currency.is_zero(amount), expected,
                             "Rounding error: %s should be zero!" % amount)

        try_zero(0.01, False)
        try_zero(-0.01, False)
        try_zero(0.001, True)
        try_zero(-0.001, True)
        try_zero(0.0046, True)
        try_zero(-0.0046, True)
        try_zero(2.68-2.675, False) # 2.68 - 2.675 = 0.005 -> rounds to 0.01
        try_zero(2.68-2.676, True)  # 2.68 - 2.675 = 0.004 -> rounds to 0.0
        try_zero(2.676-2.68, True)  # 2.675 - 2.68 = -0.004 -> rounds to -0.0
        try_zero(2.675-2.68, False) # 2.675 - 2.68 = -0.005 -> rounds to -0.01

        def try_compare(amount1, amount2, expected):
            self.assertEqual(currency.compare_amounts(amount1, amount2), expected,
                             "Rounding error, compare_amounts(%s,%s) should be %s" % (amount1, amount2, expected))

        try_compare(0.001, 0.001, 0)
        try_compare(-0.001, -0.001, 0)
        try_compare(0.001, 0.002, 0)
        try_compare(-0.001, -0.002, 0)
        try_compare(2.675, 2.68, 0)
        try_compare(2.676, 2.68, 0)
        try_compare(-2.676, -2.68, 0)
        try_compare(2.674, 2.68, -1)
        try_compare(-2.674, -2.68, 1)
        try_compare(3, 2.68, 1)
        try_compare(-3, -2.68, -1)
        try_compare(0.01, 0, 1)
        try_compare(-0.01, 0, -1)

    def test_rounding_03(self):
        """ Test rounding methods with 3 digits. """

        def try_round(amount, expected, digits=3, method='HALF-UP'):
            value = float_round(amount, precision_digits=digits, rounding_method=method)
            result = float_repr(value, precision_digits=digits)
            self.assertEqual(result, expected, 'Rounding error: got %s, expected %s' % (result, expected))

        try_round(2.6735, '2.674')  # Tie rounds away from 0
        try_round(-2.6735, '-2.674')  # Tie rounds away from 0
        try_round(2.6745, '2.675')  # Tie rounds away from 0
        try_round(-2.6745, '-2.675')  # Tie rounds away from 0
        try_round(2.6744, '2.674')
        try_round(-2.6744, '-2.674')
        try_round(0.0004, '0.000')
        try_round(-0.0004, '-0.000')
        try_round(357.4555, '357.456')
        try_round(-357.4555, '-357.456')
        try_round(457.4554, '457.455')
        try_round(-457.4554, '-457.455')

        # Try some rounding value with rounding method HALF-DOWN instead of HALF-UP
        try_round(2.6735, '2.673', method='HALF-DOWN')  # Tie rounds towards 0
        try_round(-2.6735, '-2.673', method='HALF-DOWN')  # Tie rounds towards 0
        try_round(2.6745, '2.674', method='HALF-DOWN')  # Tie rounds towards 0
        try_round(-2.6745, '-2.674', method='HALF-DOWN')  # Tie rounds towards 0
        try_round(2.6744, '2.674', method='HALF-DOWN')
        try_round(-2.6744, '-2.674', method='HALF-DOWN')
        try_round(0.0004, '0.000', method='HALF-DOWN')
        try_round(-0.0004, '-0.000', method='HALF-DOWN')
        try_round(357.4555, '357.455', method='HALF-DOWN')
        try_round(-357.4555, '-357.455', method='HALF-DOWN')
        try_round(457.4554, '457.455', method='HALF-DOWN')
        try_round(-457.4554, '-457.455', method='HALF-DOWN')

        # Try some rounding value with rounding method HALF-EVEN instead of HALF-UP
        try_round(2.6735, '2.674', method='HALF-EVEN')  # Tie rounds to the closest even number (i.e. up here)
        try_round(-2.6735, '-2.674', method='HALF-EVEN')  # Tie rounds to the closest even number (i.e. up here)
        try_round(2.6745, '2.674', method='HALF-EVEN')  # Tie rounds to the closest even number (i.e. down here)
        try_round(-2.6745, '-2.674', method='HALF-EVEN')  # Tie rounds to the closest even number (i.e. down here)
        try_round(2.6744, '2.674', method='HALF-EVEN')
        try_round(-2.6744, '-2.674', method='HALF-EVEN')
        try_round(0.0004, '0.000', method='HALF-EVEN')
        try_round(-0.0004, '-0.000', method='HALF-EVEN')
        try_round(357.4555, '357.455', method='HALF-EVEN')
        try_round(-357.4555, '-357.455', method='HALF-EVEN')
        try_round(457.4554, '457.455', method='HALF-EVEN')
        try_round(-457.4554, '-457.455', method='HALF-EVEN')

        # Try some rounding value with rounding method UP instead of HALF-UP
        # We use 8.175 because when normalizing 8.175 with precision_digits=3 it gives
        # us 8175,0000000001234 as value, and if not handle correctly the rounding UP
        # value will be incorrect (should be 8,175 and not 8,176)
        try_round(8.175, '8.175', method='UP')
        try_round(8.1751, '8.176', method='UP')
        try_round(-8.175, '-8.175', method='UP')
        try_round(-8.1751, '-8.176', method='UP')
        try_round(-6.000, '-6.000', method='UP')
        try_round(1.8, '2', 0, method='UP')
        try_round(-1.8, '-2', 0, method='UP')

        # Try some rounding value with rounding method DOWN instead of HALF-UP
        # We use 2.425 because when normalizing 2.425 with precision_digits=3 it gives
        # us 2424.9999999999995 as value, and if not handle correctly the rounding DOWN
        # value will be incorrect (should be 2.425 and not 2.424)
        try_round(2.425, '2.425', method='DOWN')
        try_round(2.4249, '2.424', method='DOWN')
        try_round(-2.425, '-2.425', method='DOWN')
        try_round(-2.4249, '-2.424', method='DOWN')
        try_round(-2.500, '-2.500', method='DOWN')
        try_round(1.8, '1', 0, method='DOWN')
        try_round(-1.8, '-1', 0, method='DOWN')

        # Extended float range test, inspired by Cloves Almeida's test on bug #882036.
        fractions = [.0, .015, .01499, .675, .67499, .4555, .4555, .45555]
        expecteds = ['.00', '.02', '.01', '.68', '.67', '.46', '.456', '.4556']
        precisions = [2, 2, 2, 2, 2, 2, 3, 4]
        # Note: max precision for double floats is 53 bits of precision or
        # 17 significant decimal digits
        for magnitude in range(7):
            for frac, exp, prec in zip(fractions, expecteds, precisions):
                for sign in [-1,1]:
                    for x in range(0, 10000, 97):
                        n = x * 10 ** magnitude
                        f = sign * (n + frac)
                        f_exp = ('-' if f != 0 and sign == -1 else '') + str(n) + exp
                        try_round(f, f_exp, digits=prec)

        def try_zero(amount, expected):
            self.assertEqual(float_is_zero(amount, precision_digits=3), expected,
                             "Rounding error: %s should be zero!" % amount)

        try_zero(0.0002, True)
        try_zero(-0.0002, True)
        try_zero(0.00034, True)
        try_zero(0.0005, False)
        try_zero(-0.0005, False)
        try_zero(0.0008, False)
        try_zero(-0.0008, False)

        def try_compare(amount1, amount2, expected):
            self.assertEqual(float_compare(amount1, amount2, precision_digits=3), expected,
                             "Rounding error, compare_amounts(%s,%s) should be %s" % (amount1, amount2, expected))

        try_compare(0.0003, 0.0004, 0)
        try_compare(-0.0003, -0.0004, 0)
        try_compare(0.0002, 0.0005, -1)
        try_compare(-0.0002, -0.0005, 1)
        try_compare(0.0009, 0.0004, 1)
        try_compare(-0.0009, -0.0004, -1)
        try_compare(557.4555, 557.4556, 0)
        try_compare(-557.4555, -557.4556, 0)
        try_compare(657.4444, 657.445, -1)
        try_compare(-657.4444, -657.445, 1)

        # Rounding to unusual rounding units (e.g. coin values)
        def try_round(amount, expected, precision_rounding=None, method='HALF-UP'): # pylint: disable=function-redefined
            value = float_round(amount, precision_rounding=precision_rounding, rounding_method=method)
            result = float_repr(value, precision_digits=2)
            self.assertEqual(result, expected, 'Rounding error: got %s, expected %s' % (result, expected))

        try_round(-457.4554, '-457.45', precision_rounding=0.05)
        try_round(457.444, '457.50', precision_rounding=0.5)
        try_round(457.3, '455.00', precision_rounding=5)
        try_round(457.5, '460.00', precision_rounding=5)
        try_round(457.1, '456.00', precision_rounding=3)
        try_round(2.5, '2.50', precision_rounding=0.05, method='DOWN')
        try_round(-2.5, '-2.50', precision_rounding=0.05, method='DOWN')

    def test_rounding_04(self):
        """ check that proper rounding is performed for float persistence """
        currency = self.env.ref('base.EUR')
        currency_rate = self.env['res.currency.rate']

        def try_roundtrip(value, expected, date):
            rate = currency_rate.create({'name': date,
                                         'rate': value,
                                         'currency_id': currency.id})
            self.assertEqual(rate.rate, expected,
                             'Roundtrip error: got %s back from db, expected %s' % (rate, expected))

        # res.currency.rate no more uses 6 digits of precision by default, it now uses whatever precision it gets
        try_roundtrip(10000.999999, 10000.999999, '2000-01-03')

        #TODO re-enable those tests when tests are made on dedicated models
        # (res.currency.rate don't accept negative value anymore)
        #try_roundtrip(-2.6748955, -2.674896, '2000-01-02')
        #try_roundtrip(-10000.999999, -10000.999999, '2000-01-04')

    def test_float_split_05(self):
        """ Test split method with 2 digits. """
        currency = self.env.ref('base.EUR')

        def try_split(value, expected, split_fun, rounding=None):
            digits = max(0, -int(log10(currency.rounding))) if rounding is None else rounding
            result = split_fun(value, precision_digits=digits)
            self.assertEqual(result, expected, 'Split error: got %s, expected %s' % (result, expected))

        try_split(2.674, ('2', '67'), float_split_str)
        try_split(2.675, ('2', '68'), float_split_str)   # in Python 2.7.2, round(2.675,2) gives 2.67
        try_split(-2.675, ('-2', '68'), float_split_str) # in Python 2.7.2, round(2.675,2) gives 2.67
        try_split(0.001, ('0', '00'), float_split_str)
        try_split(-0.001, ('-0', '00'), float_split_str)
        try_split(42, ('42', '00'), float_split_str)
        try_split(0.1, ('0', '10'), float_split_str)
        try_split(13.0, ('13', ''), float_split_str, rounding=0)

        try_split(2.674, (2, 67), float_split)
        try_split(2.675, (2, 68), float_split)   # in Python 2.7.2, round(2.675,2) gives 2.67
        try_split(-2.675, (-2, 68), float_split) # in Python 2.7.2, round(2.675,2) gives 2.67
        try_split(0.001, (0, 0), float_split)
        try_split(-0.001, (0, 0), float_split)
        try_split(42, (42, 0), float_split)
        try_split(0.1, (0, 10), float_split)
        try_split(13.0, (13, 0), float_split, rounding=0)


    def test_rounding_invalid(self):
        """ verify that invalid parameters are forbidden """
        with self.assertRaises(AssertionError):
            float_is_zero(0.01, precision_digits=3, precision_rounding=0.01)

        with self.assertRaises(AssertionError):
            float_is_zero(0.0, precision_rounding=0.0)

        with self.assertRaises(AssertionError):
            float_is_zero(0.0, precision_rounding=-0.1)

        with self.assertRaises(AssertionError):
            float_compare(0.01, 0.02, precision_digits=3, precision_rounding=0.01)

        with self.assertRaises(AssertionError):
            float_compare(1.0, 1.0, precision_rounding=0.0)

        with self.assertRaises(AssertionError):
            float_compare(1.0, 1.0, precision_rounding=-0.1)

        with self.assertRaises(AssertionError):
            float_round(0.01, precision_digits=3, precision_rounding=0.01)

        with self.assertRaises(AssertionError):
            float_round(1.25, precision_rounding=0.0)

        with self.assertRaises(AssertionError):
            float_round(1.25, precision_rounding=-0.1)

    def test_amount_to_text_10(self):
        """ verify that amount_to_text works as expected """
        currency = self.env.ref('base.EUR')

        amount_target = currency.amount_to_text(0.29)
        amount_test = currency.amount_to_text(0.28)
        self.assertNotEqual(amount_test, amount_target,
                            "Amount in text should not depend on float representation")

```

  File: tests/test_form_create.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests import TransactionCase, tagged, Form


@tagged('-at_install', 'post_install')
class TestFormCreate(TransactionCase):
    """
    Test that the basic Odoo models records can be created on
    the interface.
    """

    def test_create_res_partner(self):
        # YTI: Clean that brol
        if hasattr(self.env['res.partner'], 'property_account_payable_id'):
            # Required for `property_account_payable_id`, `property_account_receivable_id` to be visible in the view
            # By default, it's the `group` `group_account_readonly` which is required to see it, in the `account` module
            # But once `account_accountant` gets installed, it becomes `account.group_account_manager`
            # https://github.com/odoo/enterprise/blob/bfa643278028da0bfabded2f87ccb7e323d697c1/account_accountant/views/product_views.xml#L9
            self.env.user.groups_id += self.env.ref('account.group_account_readonly')
            self.env.user.groups_id += self.env.ref('account.group_account_manager')
        partner_form = Form(self.env['res.partner'])
        partner_form.name = 'a partner'
        # YTI: Clean that brol
        if hasattr(self.env['res.partner'], 'property_account_payable_id'):
            property_account_payable_id = self.env['account.account'].create({
                'name': 'Test Account',
                'account_type': 'liability_payable',
                'code': 'TestAccountPayable',
                'reconcile': True
            })
            property_account_receivable_id = self.env['account.account'].create({
                'name': 'Test Account',
                'account_type': 'asset_receivable',
                'code': 'TestAccountReceivable',
                'reconcile': True
            })
            partner_form.property_account_payable_id = property_account_payable_id
            partner_form.property_account_receivable_id = property_account_receivable_id
        partner_form.save()

    def test_create_res_users(self):
        user_form = Form(self.env['res.users'])
        user_form.login = 'a user login'
        user_form.name = 'a user name'
        user_form.save()

    def test_create_res_company(self):
        company_form = Form(self.env['res.company'])
        company_form.name = 'a company'
        company_form.save()

    def test_create_res_group(self):
        group_form = Form(self.env['res.groups'])
        group_form.name = 'a group'
        group_form.save()

    def test_create_res_bank(self):
        bank_form = Form(self.env['res.bank'])
        bank_form.name = 'a bank'
        bank_form.save()

    def test_create_res_country(self):
        country_form = Form(self.env['res.country'])
        country_form.name = 'a country'
        country_form.code = 'ZX'
        country_form.save()

    def test_create_res_lang(self):
        lang_form = Form(self.env['res.lang'])
        # lang_form.url_code = 'LANG'  # invisible field, tested in http_routing
        lang_form.name = 'a lang name'
        lang_form.code = 'a lang code'
        lang_form.save()

```

  File: tests/test_format_address_mixin.py
  Content:
```
from odoo.addons.base.tests.test_views import ViewCase


class FormatAddressCase(ViewCase):
    def assertAddressView(self, model):
        # pe_partner_address_form
        address_arch = """<form><div class="o_address_format"><field name="city"/></div></form>"""
        address_view = self.View.create({
            'name': 'view',
            'model': model,
            'arch': address_arch,
            'priority': 900,
        })

        # view can be created without address_view
        form_arch = """<form><field name="id"/><div class="o_address_format"><field name="street"/></div></form>"""
        view = self.View.create({
            'name': 'view',
            'model': model,
            'arch': form_arch,
        })

        # default view, no address_view defined
        arch = self.env[model].get_view(view.id)['arch']
        self.assertIn('"street"', arch)
        self.assertNotIn('"city"', arch)

        # custom view, address_view defined
        self.env.company.country_id.address_view_id = address_view
        arch = self.env[model].get_view(view.id)['arch']
        self.assertNotIn('"street"', arch)
        self.assertIn('"city"', arch)
        # weird result: <form> inside a <form>
        self.assertRegex(arch, r"<form>.*<form>.*</form>.*</form>")
        # no_address_format context
        arch = self.env[model].with_context(no_address_format=True).get_view(view.id)['arch']
        self.assertIn('"street"', arch)
        self.assertNotIn('"city"', arch)

        belgium = self.env.ref('base.be')
        france = self.env.ref('base.fr')

        belgium.address_view_id = None
        france.address_view_id = address_view

        company_a, company_b = self.env['res.company'].create([
            {'name': 'foo', 'country_id': belgium.id},
            {'name': 'bar', 'country_id': france.id},
        ])

        arch = self.env[model].with_company(company_a).get_view(view.id)['arch']
        self.assertIn('"street"', arch)
        self.assertNotIn('"city"', arch)

        arch = self.env[model].with_company(company_b).get_view(view.id)['arch']
        self.assertNotIn('"street"', arch)
        self.assertIn('"city"', arch)


class TestPartnerFormatAddress(FormatAddressCase):
    def test_address_view(self):
        self.env.company.country_id = self.env.ref('base.us')
        self.assertAddressView('res.partner')

```

  File: tests/test_func.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import functools

from odoo.tests.common import BaseCase
from odoo.tools import frozendict, lazy
from odoo import Command


class TestFrozendict(BaseCase):
    def test_frozendict_immutable(self):
        """ Ensure that a frozendict is immutable. """
        vals = {'name': 'Joe', 'age': 42}
        frozen_vals = frozendict(vals)

        # check __setitem__, __delitem__
        with self.assertRaises(Exception):
            frozen_vals['surname'] = 'Jack'
        with self.assertRaises(Exception):
            frozen_vals['name'] = 'Jack'
        with self.assertRaises(Exception):
            del frozen_vals['name']

        # check update, setdefault, pop, popitem, clear
        with self.assertRaises(Exception):
            frozen_vals.update({'surname': 'Jack'})
        with self.assertRaises(Exception):
            frozen_vals.update({'name': 'Jack'})
        with self.assertRaises(Exception):
            frozen_vals.setdefault('surname', 'Jack')
        with self.assertRaises(Exception):
            frozen_vals.pop('surname', 'Jack')
        with self.assertRaises(Exception):
            frozen_vals.pop('name', 'Jack')
        with self.assertRaises(Exception):
            frozen_vals.popitem()
        with self.assertRaises(Exception):
            frozen_vals.clear()

    def test_frozendict_hash(self):
        """ Ensure that a frozendict is hashable. """
        # dict with simple values
        hash(frozendict({'name': 'Joe', 'age': 42}))

        # dict with tuples, lists, and embedded dicts
        hash(frozendict({
            'user_id': (42, 'Joe'),
            'line_ids': [Command.create({'values': [42]})],
        }))


class TestLazy(BaseCase):
    def test_lazy_compare(self):
        """ Ensure that a lazy can be compared with an other lazy. """
        self.assertEqual(lazy(lambda: 1) <= lazy(lambda: 42), True)
        self.assertEqual(lazy(lambda: 42) <= lazy(lambda: 1), False)
        self.assertEqual(lazy(lambda: 42) == lazy(lambda: 42), True)
        self.assertEqual(lazy(lambda: 1) == lazy(lambda: 42), False)
        self.assertEqual(lazy(lambda: 42) != lazy(lambda: 42), False)
        self.assertEqual(lazy(lambda: 1) != lazy(lambda: 42), True)

        # Object like recordset implement __eq__
        class Obj:
            def __init__(self, num):
                self.num = num

            def __eq__(self, other):
                if isinstance(other, Obj):
                    return self.num == other.num
                raise ValueError('Object does not have the correct type')

        self.assertEqual(lazy(lambda: Obj(42)) == lazy(lambda: Obj(42)), True)
        self.assertEqual(lazy(lambda: Obj(1)) == lazy(lambda: Obj(42)), False)
        self.assertEqual(lazy(lambda: Obj(42)) != lazy(lambda: Obj(42)), False)
        self.assertEqual(lazy(lambda: Obj(1)) != lazy(lambda: Obj(42)), True)

```

  File: tests/test_http_case.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import HttpCase, tagged, ChromeBrowser
from odoo.tools import config, logging
from unittest.mock import patch

@tagged('-at_install', 'post_install')
class TestHttpCase(HttpCase):

    def test_console_error_string(self):
        with self.assertLogs(level='ERROR') as log_catcher:
            with self.assertRaises(AssertionError) as error_catcher:
                code = "console.error('test error','message')"
                with patch('odoo.tests.common.ChromeBrowser.take_screenshot', return_value=None):
                    self.browser_js(url_path='about:blank', code=code)
            # second line must contains error message
            self.assertEqual(error_catcher.exception.args[0].splitlines()[-1], "test error message")
        self.assertEqual(len(log_catcher.output), 1)
        self.assertIn('test error message', log_catcher.output[0])

    def test_console_error_object(self):
        with self.assertLogs(level='ERROR') as log_catcher:
            with self.assertRaises(AssertionError) as error_catcher:
                code = "console.error(TypeError('test error message'))"
                with patch('odoo.tests.common.ChromeBrowser.take_screenshot', return_value=None):
                    self.browser_js(url_path='about:blank', code=code)
            # second line must contains error message
            self.assertEqual(error_catcher.exception.args[0].splitlines()[-2:],
            ['TypeError: test error message', '    at <anonymous>:1:15'])
        self.assertEqual(len(log_catcher.output), 1)
        self.assertIn('TypeError: test error message\n    at <anonymous>:1:15', log_catcher.output[0])

    def test_console_log_object(self):
        logger = logging.getLogger('odoo')
        level = logger.level
        logger.setLevel(logging.INFO)
        self.addCleanup(logger.setLevel, level)

        with self.assertLogs() as log_catcher:
            code = "console.log({custom:{1:'test', 2:'a'}, value:1, description:'dummy'});console.log('test successful');"
            self.browser_js(url_path='about:blank', code=code)
        console_log_count = 0
        for log in log_catcher.output:
            if '.browser:' in log:
                text = log.split('.browser:', 1)[1]
                if text == 'test successful':
                    continue
                self.assertEqual(text, "Object(custom=Object, value=1, description='dummy')")
                console_log_count += 1
        self.assertEqual(console_log_count, 1)


@tagged('-at_install', 'post_install')
class TestChromeBrowser(HttpCase):
    def setUp(self):
        super().setUp()
        screencasts_dir = config['screencasts'] or config['screenshots']
        with patch.dict(config.options, {'screencasts': screencasts_dir, 'screenshots': config['screenshots']}):
            self.browser = ChromeBrowser(self)
        self.addCleanup(self.browser.stop)

    def test_screencasts(self):
        self.browser.start_screencast()
        self.browser.navigate_to('about:blank')
        self.browser._wait_ready()
        code = "setTimeout(() => console.log('test successful'), 2000); setInterval(() => document.body.innerText = (new Date()).getTime(), 100);"
        self.browser._wait_code_ok(code, 10)
        self.browser._save_screencast()

```

  File: tests/test_image.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import io
import binascii

from PIL import Image, ImageDraw, PngImagePlugin

from odoo import tools
from odoo.exceptions import UserError
from odoo.tests.common import TransactionCase


def img_open(data):
    return Image.open(io.BytesIO(data))


class TestImage(TransactionCase):
    """Tests for the different image tools helpers."""
    def setUp(self):
        super(TestImage, self).setUp()
        self.bg_color = (135, 90, 123)
        self.fill_color = (0, 160, 157)

        self.img_1x1_png = base64.b64decode(b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVR4nGNgYGAAAAAEAAH2FzhVAAAAAElFTkSuQmCC')
        self.img_svg = b'<svg></svg>'
        self.img_1920x1080_jpeg = tools.image_apply_opt(Image.new('RGB', (1920, 1080)), 'JPEG')
        # The following image contains a tag `Lens Info` with a value of `3.99mm f/1.8`
        # This particular tag 0xa432 makes the `exif_transpose` method fail in 5.4.1 < Pillow < 7.2.0
        self.img_exif_jpg = base64.b64decode(b"""/9j/4AAQSkZJRgABAQAAAQABAAD/4QDQRXhpZgAATU0AKgAAAAgABgESAAMAAAABAAYAAAEaAAUA
                                  AAABAAAAVgEbAAUAAAABAAAAXgEoAAMAAAABAAEAAAITAAMAAAABAAEAAIdpAAQAAAABAAAAZgAA
                                  AAAAAAABAAAAAQAAAAEAAAABAAWQAAAHAAAABDAyMzGRAQAHAAAABAECAwCgAAAHAAAABDAxMDCg
                                  AQADAAAAAf//AACkMgAFAAAABAAAAKgAAAAAAAABjwAAAGQAAAGPAAAAZAAAAAkAAAAFAAAACQAA
                                  AAX/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAx
                                  NDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy
                                  MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAADAAYDASIAAhEBAxEB/8QAHwAAAQUBAQEB
                                  AQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1Fh
                                  ByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZ
                                  WmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
                                  x8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAEC
                                  AwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHB
                                  CSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0
                                  dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX
                                  2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3+iiigD//2Q==""")

        # Draw a red square in the middle of the image, this will be used to
        # verify crop is working. The border is going to be `self.bg_color` and
        # the middle is going to be `self.fill_color`.

        # horizontal image (border is left/right)
        image = Image.new('RGB', (1920, 1080), color=self.bg_color)
        offset = (image.size[0] - image.size[1]) / 2
        draw = ImageDraw.Draw(image)
        draw.rectangle(xy=[
            (offset, 0),
            (image.size[0] - offset, image.size[1])
        ], fill=self.fill_color)
        self.img_1920x1080_png = tools.image_apply_opt(image, 'PNG')

        # vertical image (border is top/bottom)
        image = Image.new('RGB', (1080, 1920), color=self.bg_color)
        offset = (image.size[1] - image.size[0]) / 2
        draw = ImageDraw.Draw(image)
        draw.rectangle(xy=[
            (0, offset),
            (image.size[0], image.size[1] - offset)
        ], fill=self.fill_color)
        self.img_1080x1920_png = tools.image_apply_opt(image, 'PNG')

    def test_00_base64_to_image(self):
        """Test that base64 is correctly opened as a PIL image."""
        image = img_open(self.img_1x1_png)
        self.assertEqual(type(image), PngImagePlugin.PngImageFile, "base64 as bytes, correct format")
        self.assertEqual(image.size, (1, 1), "base64 as bytes, correct size")

        with self.assertRaises(UserError, msg="This file could not be decoded as an image file. Please try with a different file."):
            image = tools.base64_to_image(b'oazdazpodazdpok')

        with self.assertRaises(UserError, msg="This file could not be decoded as an image file. Please try with a different file."):
            image = tools.base64_to_image(b'oazdazpodazdpokd')

    def test_01_image_to_base64(self):
        """Test that a PIL image is correctly saved as base64."""
        image = Image.new('RGB', (1, 1))
        image_base64 = tools.image_to_base64(image, 'PNG')
        self.assertEqual(image_base64, base64.b64encode(self.img_1x1_png))

    def test_02_image_fix_orientation(self):
        """Test that the orientation of images is correct."""

        # Colors that can be distinguished among themselves even with jpeg loss.
        blue = (0, 0, 255)
        yellow = (255, 255, 0)
        green = (0, 255, 0)
        pink = (255, 0, 255)
        # Image large enough so jpeg loss is not a huge factor in the corners.
        size = 50
        expected = (blue, yellow, green, pink)

        # They are all supposed to be same image: (blue, yellow, green, pink) in
        # that order, but each encoded with a different orientation.
        self._orientation_test(1, (blue, yellow, green, pink), size, expected)  # top/left
        self._orientation_test(2, (yellow, blue, pink, green), size, expected)  # top/right
        self._orientation_test(3, (pink, green, yellow, blue), size, expected)  # bottom/right
        self._orientation_test(4, (green, pink, blue, yellow), size, expected)  # bottom/left
        self._orientation_test(5, (blue, green, yellow, pink), size, expected)  # left/top
        self._orientation_test(6, (yellow, pink, blue, green), size, expected)  # right/top
        self._orientation_test(7, (pink, yellow, green, blue), size, expected)  # right/bottom
        self._orientation_test(8, (green, blue, pink, yellow), size, expected)  # left/bottom

    def test_03_image_fix_orientation_exif(self):
        """Test that a jpg image with exif orientation tag gets rotated"""
        image = img_open(self.img_exif_jpg)
        self.assertEqual(image.size, (6,3))
        image = tools.image_fix_orientation(image)
        self.assertEqual(image.size, (3,6))

    def test_10_image_process_source(self):
        """Test the source parameter of image_process."""
        self.assertFalse(tools.image_process(False), "return False if source is falsy")
        self.assertEqual(tools.image_process(self.img_svg), self.img_svg, "return source if format is SVG")

        # in the following tests, pass `quality` to force the processing
        with self.assertRaises(UserError, msg="This file could not be decoded as an image file. Please try with a different file."):
            tools.image_process(b'oazdazpodazdpokd', quality=95)

        image = img_open(tools.image_process(self.img_1920x1080_jpeg, quality=95))
        self.assertEqual(image.size, (1920, 1080), "OK return the image")

    def test_11_image_process_size(self):
        """Test the size parameter of image_process."""

        # Format of `tests`: (original image, size parameter, expected result, text)
        tests = [
            (self.img_1920x1080_jpeg, (192, 108), (192, 108), "resize to given size"),
            (self.img_1920x1080_jpeg, (1920, 1080), (1920, 1080), "same size, no change"),
            (self.img_1920x1080_jpeg, (192, None), (192, 108), "set height from ratio"),
            (self.img_1920x1080_jpeg, (0, 108), (192, 108), "set width from ratio"),
            (self.img_1920x1080_jpeg, (192, 200), (192, 108), "adapt to width"),
            (self.img_1920x1080_jpeg, (400, 108), (192, 108), "adapt to height"),
            (self.img_1920x1080_jpeg, (3000, 2000), (1920, 1080), "don't resize above original, both set"),
            (self.img_1920x1080_jpeg, (3000, False), (1920, 1080), "don't resize above original, width set"),
            (self.img_1920x1080_jpeg, (None, 2000), (1920, 1080), "don't resize above original, height set"),
            (self.img_1080x1920_png, (3000, 192), (108, 192), "vertical image, resize if below"),
        ]

        count = 0
        for test in tests:
            image = img_open(tools.image_process(test[0], size=test[1]))
            self.assertEqual(image.size, test[2], test[3])
            count = count + 1
        self.assertEqual(count, 10, "ensure the loop is ran")

    def test_12_image_process_verify_resolution(self):
        """Test the verify_resolution parameter of image_process."""
        res = tools.image_process(self.img_1920x1080_jpeg, verify_resolution=True)
        self.assertNotEqual(res, False, "size ok")
        image_excessive = tools.image_apply_opt(Image.new('RGB', (50001, 1000)), 'PNG')
        with self.assertRaises(UserError, msg="size excessive"):
            tools.image_process(image_excessive, verify_resolution=True)

    def test_13_image_process_quality(self):
        """Test the quality parameter of image_process."""

        # CASE: PNG RGBA doesn't apply quality, just optimize
        image = tools.image_apply_opt(Image.new('RGBA', (1080, 1920)), 'PNG')
        res = tools.image_process(image)
        self.assertLessEqual(len(res), len(image))

        # CASE: PNG RGB doesn't apply quality, just optimize
        image = tools.image_apply_opt(Image.new('P', (1080, 1920)), 'PNG')
        res = tools.image_process(image)
        self.assertLessEqual(len(res), len(image))

        # CASE: JPEG optimize + reduced quality
        res = tools.image_process(self.img_1920x1080_jpeg)
        self.assertLessEqual(len(res), len(self.img_1920x1080_jpeg))

        # CASE: JPEG optimize + bigger size => original
        pil_image = Image.new('RGB', (1920, 1080), color=self.bg_color)
        # Drawing non trivial content so that optimization matters.
        ImageDraw.Draw(pil_image).ellipse(xy=[
            (400, 0),
            (1500, 1080)
        ], fill=self.fill_color, outline=(240, 25, 40), width=10)
        image = tools.image_apply_opt(pil_image, 'JPEG')
        res = tools.image_process(image, quality=50)
        self.assertLess(len(res), len(image), "Low quality image should be smaller than original")
        res = tools.image_process(image, quality=99)
        self.assertEqual(len(res), len(image), "Original should be returned if size increased")

        # CASE: GIF doesn't apply quality, just optimize
        image = tools.image_apply_opt(Image.new('RGB', (1080, 1920)), 'GIF')
        res = tools.image_process(image)
        self.assertLessEqual(len(res), len(image))

    def test_14_image_process_crop(self):
        """Test the crop parameter of image_process."""

        # Optimized PNG use palette, getpixel below will return palette value.
        fill = 0
        bg = 1

        # Format of `tests`: (original base64 image, size parameter, crop parameter, res size, res color (top, bottom, left, right), text)
        tests = [
            (self.img_1920x1080_png, None, None, (1920, 1080), (fill, fill, bg, bg), "horizontal, verify initial"),
            (self.img_1920x1080_png, (2000, 2000), 'center', (1080, 1080), (fill, fill, fill, fill), "horizontal, crop biggest possible"),
            (self.img_1920x1080_png, (2000, 4000), 'center', (540, 1080), (fill, fill, fill, fill), "horizontal, size vertical, limit height"),
            (self.img_1920x1080_png, (4000, 2000), 'center', (1920, 960), (fill, fill, bg, bg), "horizontal, size horizontal, limit width"),
            (self.img_1920x1080_png, (512, 512), 'center', (512, 512), (fill, fill, fill, fill), "horizontal, type center"),
            (self.img_1920x1080_png, (512, 512), 'top', (512, 512), (fill, fill, fill, fill), "horizontal, type top"),
            (self.img_1920x1080_png, (512, 512), 'bottom', (512, 512), (fill, fill, fill, fill), "horizontal, type bottom"),
            (self.img_1920x1080_png, (512, 512), 'wrong', (512, 512), (fill, fill, fill, fill), "horizontal, wrong crop value, use center"),
            (self.img_1920x1080_png, (192, 0), None, (192, 108), (fill, fill, bg, bg), "horizontal, not cropped, just do resize"),

            (self.img_1080x1920_png, None, None, (1080, 1920), (bg, bg, fill, fill), "vertical, verify initial"),
            (self.img_1080x1920_png, (2000, 2000), 'center', (1080, 1080), (fill, fill, fill, fill), "vertical, crop biggest possible"),
            (self.img_1080x1920_png, (2000, 4000), 'center', (960, 1920), (bg, bg, fill, fill), "vertical, size vertical, limit height"),
            (self.img_1080x1920_png, (4000, 2000), 'center', (1080, 540), (fill, fill, fill, fill), "vertical, size horizontal, limit width"),
            (self.img_1080x1920_png, (512, 512), 'center', (512, 512), (fill, fill, fill, fill), "vertical, type center"),
            (self.img_1080x1920_png, (512, 512), 'top', (512, 512), (bg, fill, fill, fill), "vertical, type top"),
            (self.img_1080x1920_png, (512, 512), 'bottom', (512, 512), (fill, bg, fill, fill), "vertical, type bottom"),
            (self.img_1080x1920_png, (512, 512), 'wrong', (512, 512), (fill, fill, fill, fill), "vertical, wrong crop value, use center"),
            (self.img_1080x1920_png, (108, 0), None, (108, 192), (bg, bg, fill, fill), "vertical, not cropped, just do resize"),
        ]

        count = 0
        for test in tests:
            count = count + 1
            # process the image, pass quality to make sure the result is palette
            image = img_open(tools.image_process(test[0], size=test[1], crop=test[2], quality=95))
            # verify size
            self.assertEqual(image.size, test[3], "%s - correct size" % test[5])

            half_width, half_height = image.size[0] / 2, image.size[1] / 2
            top, bottom, left, right = 0, image.size[1] - 1, 0, image.size[0] - 1
            # verify top
            px = (half_width, top)
            self.assertEqual(image.getpixel(px), test[4][0], "%s - color top (%s, %s)" % (test[5], px[0], px[1]))
            # verify bottom
            px = (half_width, bottom)
            self.assertEqual(image.getpixel(px), test[4][1], "%s - color bottom (%s, %s)" % (test[5], px[0], px[1]))
            # verify left
            px = (left, half_height)
            self.assertEqual(image.getpixel(px), test[4][2], "%s - color left (%s, %s)" % (test[5], px[0], px[1]))
            # verify right
            px = (right, half_height)
            self.assertEqual(image.getpixel(px), test[4][3], "%s - color right (%s, %s)" % (test[5], px[0], px[1]))

        self.assertEqual(count, 2 * 9, "ensure the loop is ran")

    def test_15_image_process_colorize(self):
        """Test the colorize parameter of image_process."""

        # verify initial condition
        image_rgba = Image.new('RGBA', (1, 1))
        self.assertEqual(image_rgba.mode, 'RGBA')
        self.assertEqual(image_rgba.getpixel((0, 0)), (0, 0, 0, 0))
        rgba = tools.image_apply_opt(image_rgba, 'PNG')

        # CASE: color random, color has changed
        image = img_open(tools.image_process(rgba, colorize=True))
        self.assertEqual(image.mode, 'RGB')
        self.assertNotEqual(image.getpixel((0, 0)), (0, 0, 0))

    def test_16_image_process_format(self):
        """Test the format parameter of image_process."""

        image = img_open(tools.image_process(self.img_1920x1080_jpeg, output_format='PNG'))
        self.assertEqual(image.format, 'PNG', "change format to PNG")

        image = img_open(tools.image_process(self.img_1x1_png, output_format='JpEg'))
        self.assertEqual(image.format, 'JPEG', "change format to JPEG (case insensitive)")

        image = img_open(tools.image_process(self.img_1920x1080_jpeg, output_format='BMP'))
        self.assertEqual(image.format, 'PNG', "change format to BMP converted to PNG")

        image_1080_1920_rgba = tools.image_apply_opt(Image.new('RGBA', (108, 192)), 'PNG')
        image = img_open(tools.image_process(image_1080_1920_rgba, output_format='jpeg'))
        self.assertEqual(image.format, 'JPEG', "change format PNG with RGBA to JPEG")

        # pass quality to force the image to be processed
        image_1080_1920_tiff = tools.image_apply_opt(Image.new('RGB', (108, 192)), 'TIFF')
        image = img_open(tools.image_process(image_1080_1920_tiff, quality=95))
        self.assertEqual(image.format, 'JPEG', "unsupported format to JPEG")

    def test_17_get_webp_size(self):
        # Using 32 bytes image headers as data.
        # Lossy webp: 550x368
        webp_lossy = b'RIFFhv\x00\x00WEBPVP8 \\v\x00\x00\xd2\xbe\x01\x9d\x01*&\x02p\x01>\xd5'
        size = tools.get_webp_size(webp_lossy)
        self.assertEqual((550, 368), size, "Wrong resolution for lossy webp")
        # Lossless webp: 421x163
        webp_lossless = b'RIFF\xba\x84\x00\x00WEBPVP8L\xad\x84\x00\x00/\xa4\x81(\x10MHr\x1bI\x92\xa4'
        size = tools.get_webp_size(webp_lossless)
        self.assertEqual((421, 163), size, "Wrong resolution for lossless webp")
        # Extended webp: 800x600
        webp_extended = b'RIFF\x80\xce\x00\x00WEBPVP8X\n\x00\x00\x00\x10\x00\x00\x00\x1f\x03\x00W\x02\x00AL'
        size = tools.get_webp_size(webp_extended)
        self.assertEqual((800, 600), size, "Wrong resolution for extended webp")

    def test_20_image_data_uri(self):
        """Test that image_data_uri is working as expected."""
        self.assertEqual(tools.image_data_uri(base64.b64encode(self.img_1x1_png)), 'data:image/png;base64,' + base64.b64encode(self.img_1x1_png).decode('ascii'))

    def test_21_image_guess_size_from_field_name(self):
        f = tools.image_guess_size_from_field_name
        # Test case: empty field_name input
        self.assertEqual(f(''), (0, 0))
        # Test case: custom field_name input
        self.assertEqual(f('custom_field'), (0, 0))
        # Test case: field_name input that starts with 'x_'
        self.assertEqual(f('x_field'), (0, 0))
        # Test case: field_name input that starts with 'x_' and ends with a number less than 16
        self.assertEqual(f('x_studio_image_1'), (0, 0))
        # Test case: field_name input that starts with 'x_' and ends with a number greater than 16
        self.assertEqual(f('x_studio_image_32'), (0, 0))
        # Test case: field_name input that has a suffix less than 16
        self.assertEqual(f('image_15'), (0, 0))
        # Test case: field_name input that has a suffix equal to 16
        self.assertEqual(f('image_16'), (16, 16))
        # Test case: field_name input that has a suffix greater than 16
        self.assertEqual(f('image_32'), (32, 32))
        # Test case: field_name input that has a suffix with 2 numbers
        self.assertEqual(f('image_1920_1080'), (1080, 1080))
        # Test case: field_name input that has a float as suffix
        self.assertEqual(f('image_32.5'), (0, 0))
        # Test case: field_name input that has a suffix greater than 16 but no underscore
        self.assertEqual(f('image32'), (0, 0))

    def _assertAlmostEqualSequence(self, rgb1, rgb2, delta=10):
        self.assertEqual(len(rgb1), len(rgb2))
        for index, t in enumerate(zip(rgb1, rgb2)):
            self.assertAlmostEqual(t[0], t[1], delta=delta, msg="%s vs %s at %d" % (rgb1, rgb2, index))

    def _get_exif_colored_square(self, orientation, colors, size):
        image = Image.new('RGB', (size, size), color=self.bg_color)
        draw = ImageDraw.Draw(image)
        # Paint the colors on the 4 corners, to be able to test which colors
        # move on which corners.
        draw.rectangle(xy=[(0, 0), (size // 2, size // 2)], fill=colors[0])        # top/left
        draw.rectangle(xy=[(size // 2, 0), (size, size // 2)], fill=colors[1])     # top/right
        draw.rectangle(xy=[(0, size // 2), (size // 2, size)], fill=colors[2])     # bottom/left
        draw.rectangle(xy=[(size // 2, size // 2), (size, size)], fill=colors[3])  # bottom/right
        # Set the proper exif tag based on orientation params.
        exif = b'Exif\x00\x00II*\x00\x08\x00\x00\x00\x01\x00\x12\x01\x03\x00\x01\x00\x00\x00' + bytes([orientation]) + b'\x00\x00\x00\x00\x00\x00\x00'
        # The image image is saved with the exif tag.
        return tools.image_apply_opt(image, 'JPEG', exif=exif)

    def _orientation_test(self, orientation, colors, size, expected):
        # Generate the test image based on orientation and order of colors.
        image = self._get_exif_colored_square(orientation, colors, size)
        # The image is read again now that it has orientation added.
        fixed_image = tools.image_fix_orientation(img_open(image))
        # Ensure colors are in the right order (blue, yellow, green, pink).
        self._assertAlmostEqualSequence(fixed_image.getpixel((0, 0)), expected[0])                # top/left
        self._assertAlmostEqualSequence(fixed_image.getpixel((size - 1, 0)), expected[1])         # top/right
        self._assertAlmostEqualSequence(fixed_image.getpixel((0, size - 1)), expected[2])         # bottom/left
        self._assertAlmostEqualSequence(fixed_image.getpixel((size - 1, size - 1)), expected[3])  # bottom/right

    def test_ptype_image_to_jpeg(self):
        """converts to RGB when saving as JPEG"""
        image1 = Image.new('P', (1, 1), color='red')
        image2 = Image.new('RGB', (1, 1), color='red')
        self.assertEqual(tools.image.image_apply_opt(image1, 'JPEG'), tools.image.image_apply_opt(image2, 'JPEG'))

```

  File: tests/test_ir_actions.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from datetime import date
import json
from psycopg2 import IntegrityError, ProgrammingError
import requests
from unittest.mock import patch

import odoo
from odoo.exceptions import UserError, ValidationError, AccessError
from odoo.tools import mute_logger
from odoo.tests import common, tagged
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo import Command


class TestServerActionsBase(TransactionCaseWithUserDemo):

    def setUp(self):
        super(TestServerActionsBase, self).setUp()

        # Data on which we will run the server action
        self.test_country = self.env['res.country'].create({
            'name': 'TestingCountry',
            'code': 'TY',
            'address_format': 'SuperFormat',
            'name_position': 'before',
        })
        self.test_partner = self.env['res.partner'].create({
            'city': 'OrigCity',
            'country_id': self.test_country.id,
            'email': 'test.partner@test.example.com',
            'name': 'TestingPartner',
        })
        self.context = {
            'active_model': 'res.partner',
            'active_id': self.test_partner.id,
        }

        # Model data
        Model = self.env['ir.model']
        Fields = self.env['ir.model.fields']
        self.comment_html = '<p>MyComment</p>'
        self.res_partner_model = Model.search([('model', '=', 'res.partner')])
        self.res_partner_name_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'name')])
        self.res_partner_city_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'city')])
        self.res_partner_country_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'country_id')])
        self.res_partner_parent_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'parent_id')])
        self.res_partner_children_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'child_ids')])
        self.res_partner_category_field = Fields.search([('model', '=', 'res.partner'), ('name', '=', 'category_id')])
        self.res_country_model = Model.search([('model', '=', 'res.country')])
        self.res_country_name_field = Fields.search([('model', '=', 'res.country'), ('name', '=', 'name')])
        self.res_country_code_field = Fields.search([('model', '=', 'res.country'), ('name', '=', 'code')])
        self.res_country_name_position_field = Fields.search([('model', '=', 'res.country'), ('name', '=', 'name_position')])
        self.res_partner_category_model = Model.search([('model', '=', 'res.partner.category')])
        self.res_partner_category_name_field = Fields.search([('model', '=', 'res.partner.category'), ('name', '=', 'name')])

        # create server action to
        self.action = self.env['ir.actions.server'].create({
            'name': 'TestAction',
            'model_id': self.res_partner_model.id,
            'model_name': 'res.partner',
            'state': 'code',
            'code': 'record.write({"comment": "%s"})' % self.comment_html,
        })

        server_action_model = Model.search([('model', '=', 'ir.actions.server')])
        self.test_server_action = self.env['ir.actions.server'].create({
            'name': 'TestDummyServerAction',
            'model_id': server_action_model.id,
            'state': 'code',
            'code':
"""
_logger.log(10, "This is a %s debug %s", "test", "log")
_logger.info("This is a %s info %s", "test", "log")
_logger.warning("This is a %s warning %s", "test", "log")
_logger.error("This is a %s error %s", "test", "log")
try:
    0/0
except:
    _logger.exception("This is a %s exception %s", "test", "log")
""",
        })


class TestServerActions(TestServerActionsBase):
    def test_00_server_action(self):
        with self.assertLogs('odoo.addons.base.models.ir_actions.server_action_safe_eval',
                             level='DEBUG') as log_catcher:
            self.test_server_action.run()
            self.assertEqual(log_catcher.output, [
                'DEBUG:odoo.addons.base.models.ir_actions.server_action_safe_eval:This is a test debug log',
                'INFO:odoo.addons.base.models.ir_actions.server_action_safe_eval:This is a test info log',
                'WARNING:odoo.addons.base.models.ir_actions.server_action_safe_eval:This is a test warning log',
                'ERROR:odoo.addons.base.models.ir_actions.server_action_safe_eval:This is a test error log',
"""ERROR:odoo.addons.base.models.ir_actions.server_action_safe_eval:This is a test exception log
Traceback (most recent call last):
  File "ir.actions.server(%d,)", line 6, in <module>
ZeroDivisionError: division by zero""" % self.test_server_action.id
            ])

    def test_00_action(self):
        self.action.with_context(self.context).run()
        self.assertEqual(self.test_partner.comment, self.comment_html, 'ir_actions_server: invalid condition check')
        self.test_partner.write({'comment': False})

        # Do: create contextual action
        self.action.create_action()
        self.assertEqual(self.action.binding_model_id.model, 'res.partner')

        # Do: remove contextual action
        self.action.unlink_action()
        self.assertFalse(self.action.binding_model_id)

    def test_10_code(self):
        self.action.write({
            'state': 'code',
            'code': ("partner_name = record.name + '_code'\n"
                     "record.env['res.partner'].create({'name': partner_name})"),
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: code server action correctly finished should return False')

        partners = self.test_partner.search([('name', 'ilike', 'TestingPartner_code')])
        self.assertEqual(len(partners), 1, 'ir_actions_server: 1 new partner should have been created')

    def test_20_crud_create(self):
        # Do: create a new record in another model
        self.action.write({
            'state': 'object_create',
            'crud_model_id': self.res_partner_model.id,
            'link_field_id': False,
            'value': 'TestingPartner2'
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: create record action correctly finished should return False')
        # Test: new partner created
        partner = self.test_partner.search([('name', 'ilike', 'TestingPartner2')])
        self.assertEqual(len(partner), 1, 'ir_actions_server: TODO')

    def test_20_crud_create_link_many2one(self):

        # Do: create a new record in the same model and link it with a many2one
        self.action.write({
            'state': 'object_create',
            'crud_model_id': self.res_partner_model.id,
            'link_field_id': self.res_partner_parent_field.id,
            'value': "TestNew"
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: create record action correctly finished should return False')
        # Test: new partner created
        partner = self.test_partner.search([('name', 'ilike', 'TestNew')])
        self.assertEqual(len(partner), 1, 'ir_actions_server: TODO')
        # Test: new partner linked
        self.assertEqual(self.test_partner.parent_id, partner, 'ir_actions_server: TODO')

    def test_20_crud_create_link_one2many(self):

        # Do: create a new record in the same model and link it with a one2many
        self.action.write({
            'state': 'object_create',
            'crud_model_id': self.res_partner_model.id,
            'link_field_id': self.res_partner_children_field.id,
            'value': 'TestNew',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: create record action correctly finished should return False')
        # Test: new partner created
        partner = self.test_partner.search([('name', 'ilike', 'TestNew')])
        self.assertEqual(len(partner), 1, 'ir_actions_server: TODO')
        self.assertEqual(partner.name, 'TestNew', 'ir_actions_server: TODO')
        # Test: new partner linked
        self.assertIn(partner, self.test_partner.child_ids, 'ir_actions_server: TODO')

    def test_20_crud_create_link_many2many(self):
        # Do: create a new record in another model
        self.action.write({
            'state': 'object_create',
            'crud_model_id': self.res_partner_category_model.id,
            'link_field_id': self.res_partner_category_field.id,
            'value': 'TestingPartner'
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: create record action correctly finished should return False')
        # Test: new category created
        category = self.env['res.partner.category'].search([('name', 'ilike', 'TestingPartner')])
        self.assertEqual(len(category), 1, 'ir_actions_server: TODO')
        self.assertIn(category, self.test_partner.category_id)

    def test_30_crud_write(self):
        # Do: update partner name
        self.action.write({
            'state': 'object_write',
            'update_path': 'name',
            'value': 'TestNew',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: create record action correctly finished should return False')
        # Test: partner updated
        partner = self.test_partner.search([('name', 'ilike', 'TestNew')])
        self.assertEqual(len(partner), 1, 'ir_actions_server: TODO')
        self.assertEqual(partner.city, 'OrigCity', 'ir_actions_server: TODO')

    def test_35_crud_write_selection(self):
        # Don't want to use res.partner because no 'normal selection field' exists there
        # we'll use a speficic action for this test instead of the one from the test setup
        # Do: update country name_position field
        selection_value = self.res_country_name_position_field.selection_ids.filtered(lambda s: s.value == 'after')
        action = self.env['ir.actions.server'].create({
            'name': 'TestAction',
            'model_id': self.res_country_model.id,
            'model_name': 'res.country',
            'state': 'object_write',
            'update_path': 'name_position',
            'selection_value': selection_value.id,
        })
        action._set_selection_value()  # manual onchange
        self.assertEqual(action.value, selection_value.value)
        context = {
            'active_model': 'res.country',
            'active_id': self.test_country.id,
        }
        run_res = action.with_context(context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: country updated
        self.assertEqual(self.test_country.name_position, 'after')

    def test_36_crud_write_m2m_ops(self):
        """ Test that m2m operations work as expected """
        categ_1 = self.env['res.partner.category'].create({'name': 'TestCateg1'})
        categ_2 = self.env['res.partner.category'].create({'name': 'TestCateg2'})
        # set partner category
        self.action.write({
            'state': 'object_write',
            'update_path': 'category_id',
            'update_m2m_operation': 'set',
            'resource_ref': categ_1,
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertIn(categ_1, self.test_partner.category_id, 'ir_actions_server: tag should have been set')

        # add partner category
        self.action.write({
            'state': 'object_write',
            'update_path': 'category_id',
            'update_m2m_operation': 'add',
            'resource_ref': categ_2,
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertIn(categ_2, self.test_partner.category_id, 'ir_actions_server: new tag should have been added')
        self.assertIn(categ_1, self.test_partner.category_id, 'ir_actions_server: old tag should still be there')

        # remove partner category
        self.action.write({
            'state': 'object_write',
            'update_path': 'category_id',
            'update_m2m_operation': 'remove',
            'resource_ref': categ_1,
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertNotIn(categ_1, self.test_partner.category_id, 'ir_actions_server: tag should have been removed')
        self.assertIn(categ_2, self.test_partner.category_id, 'ir_actions_server: tag should still be there')

        # clear partner category
        self.action.write({
            'state': 'object_write',
            'update_path': 'category_id',
            'update_m2m_operation': 'clear',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertFalse(self.test_partner.category_id, 'ir_actions_server: tags should have been cleared')

    def test_37_field_path_traversal(self):
        """ Test the update_path field traversal - allowing records to be updated along relational links """
        # update the country's name via the partner
        self.action.write({
            'state': 'object_write',
            'update_path': 'country_id.name',
            'value': 'TestUpdatedCountry',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertEqual(self.test_partner.country_id.name, 'TestUpdatedCountry', 'ir_actions_server: country name should have been updated through relation')

        # update a readonly field
        self.action.write({
            'state': 'object_write',
            'update_path': 'country_id.image_url',
            'value': "/base/static/img/country_flags/be.png",
        })
        self.assertEqual(self.test_partner.country_id.image_url, "/base/static/img/country_flags/ty.png", 'ir_actions_server: country flag has this value before the update')
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertEqual(self.test_partner.country_id.image_url, "/base/static/img/country_flags/be.png", 'ir_actions_server: country should have been updated through a readonly field')
        self.assertEqual(self.test_partner.country_id.code, "TY", 'ir_actions_server: country code is still TY')

        # input an invalid path
        with self.assertRaises(ValidationError):
            self.action.write({
                'state': 'object_write',
                'update_path': 'country_id.name.foo',
                'value': 'DoesNotMatter',
            })
            self.action.flush_recordset(['update_path', 'update_field_id'])

    def test_39_boolean_update(self):
        """ Test that boolean fields can be updated """
        # update the country's name via the partner
        self.action.write({
            'state': 'object_write',
            'update_path': 'active',
            'update_boolean_value': 'false',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertFalse(self.test_partner.active, 'ir_actions_server: partner should have been deactivated')
        self.action.write({
            'state': 'object_write',
            'update_path': 'active',
            'update_boolean_value': 'true',
        })
        run_res = self.action.with_context(self.context).run()
        self.assertFalse(run_res, 'ir_actions_server: update record action correctly finished should return False')
        # Test: partner updated
        self.assertTrue(self.test_partner.active, 'ir_actions_server: partner should have been reactivated')

    @mute_logger('odoo.addons.base.models.ir_model', 'odoo.models')
    def test_40_multi(self):
        # Data: 2 server actions that will be nested
        action1 = self.action.create({
            'name': 'Subaction1',
            'sequence': 1,
            'model_id': self.res_partner_model.id,
            'state': 'code',
            'code': 'action = {"type": "ir.actions.act_window"}',
        })
        action2 = self.action.create({
            'name': 'Subaction2',
            'sequence': 2,
            'model_id': self.res_partner_model.id,
            'crud_model_id': self.res_partner_model.id,
            'state': 'object_create',
            'value': 'RaoulettePoiluchette',
        })
        action3 = self.action.create({
            'name': 'Subaction2',
            'sequence': 3,
            'model_id': self.res_partner_model.id,
            'state': 'object_write',
            'update_path': 'city',
            'value': 'RaoulettePoiluchette',
        })
        action4 = self.action.create({
            'name': 'Subaction3',
            'sequence': 4,
            'model_id': self.res_partner_model.id,
            'state': 'code',
            'code': 'action = {"type": "ir.actions.act_url"}',
        })
        self.action.write({
            'state': 'multi',
            'child_ids': [Command.set([action1.id, action2.id, action3.id, action4.id])],
        })

        # Do: run the action
        res = self.action.with_context(self.context).run()

        # Test: new partner created
        # currently res_partner overrides default['name'] whatever its value
        partner = self.test_partner.search([('name', 'ilike', 'RaoulettePoiluchette')])
        self.assertEqual(len(partner), 1)
        # Test: action returned
        self.assertEqual(res.get('type'), 'ir.actions.act_url')

        # Test loops
        with self.assertRaises(ValidationError):
            self.action.write({
                'child_ids': [Command.set([self.action.id])]
            })

    def test_50_groups(self):
        """ check the action is returned only for groups dedicated to user """
        Actions = self.env['ir.actions.actions']

        group0 = self.env['res.groups'].create({'name': 'country group'})

        self.context = {
            'active_model': 'res.country',
            'active_id': self.test_country.id,
        }

        # Do: update model and group
        self.action.write({
            'model_id': self.res_country_model.id,
            'binding_model_id': self.res_country_model.id,
            'groups_id': [Command.link(group0.id)],
            'code': 'record.write({"vat_label": "VatFromTest"})',
        })

        # Test: action is not returned
        bindings = Actions.get_bindings('res.country')
        self.assertFalse(bindings)

        with self.assertRaises(AccessError):
            self.action.with_context(self.context).run()
        self.assertFalse(self.test_country.vat_label)

        # add group to the user, and test again
        self.env.user.write({'groups_id': [Command.link(group0.id)]})

        bindings = Actions.get_bindings('res.country')
        self.assertItemsEqual(bindings.get('action'), self.action.read(['name', 'sequence', 'binding_view_types']))

        self.action.with_context(self.context).run()
        self.assertEqual(self.test_country.vat_label, 'VatFromTest', 'vat label should be changed to VatFromTest')

    def test_60_sort(self):
        """ check the actions sorted by sequence """
        Actions = self.env['ir.actions.actions']

        # Do: update model
        self.action.write({
            'model_id': self.res_country_model.id,
            'binding_model_id': self.res_country_model.id,
        })
        self.action2 = self.action.copy({'name': 'TestAction2', 'sequence': 1})

        # Test: action returned by sequence
        bindings = Actions.get_bindings('res.country')
        self.assertEqual([vals.get('name') for vals in bindings['action']], ['TestAction2', 'TestAction'])
        self.assertEqual([vals.get('sequence') for vals in bindings['action']], [1, 5])

    def test_70_copy_action(self):
        # first check that the base case (reset state) works normally
        r = self.env['ir.actions.todo'].create({
            'action_id': self.action.id,
            'state': 'done',
        })
        self.assertEqual(r.state, 'done')
        self.assertEqual(
            r.copy().state, 'open',
            "by default state should be reset by copy"
        )

        # then check that on server action we've changed that
        self.assertEqual(
            self.action.copy().state, 'code',
            "copying a server action should not reset the state"
        )

    def test_80_permission(self):
        self.action.write({
            'state': 'code',
            'code': """record.write({'date': datetime.date.today()})""",
        })

        user_demo = self.user_demo
        self_demo = self.action.with_user(user_demo.id)

        # can write on contact partner
        self.test_partner.type = "contact"
        self.test_partner.with_user(user_demo.id).check_access_rule("write")

        self_demo.with_context(self.context).run()
        self.assertEqual(self.test_partner.date, date.today())

    def test_90_webhook(self):
        self.action.write({
            'state': 'webhook',
            'webhook_field_ids': [
                Command.link(self.res_partner_name_field.id),
                Command.link(self.res_partner_city_field.id),
                Command.link(self.res_partner_country_field.id),
                ],
            'webhook_url': 'http://example.com/webhook',
        })
        # write a mock for the requests.post method that checks the data
        # and returns a 200 response
        num_requests = 0
        def _patched_post(*args, **kwargs):
            nonlocal num_requests
            response = requests.Response()
            response.status_code = 200 if num_requests == 0 else 400
            self.assertEqual(args[0], 'http://example.com/webhook')
            self.assertEqual(kwargs['data'], json.dumps({
                '_action': "%s(#%s)" % (self.action.name, self.action.id),
                '_id': self.test_partner.id,
                '_model': self.test_partner._name,
                'city': self.test_partner.city,
                'country_id': self.test_partner.country_id.id,
                'id': self.test_partner.id,
                'name': self.test_partner.name,
            }))
            num_requests += 1
            return response

        with patch.object(requests, 'post', _patched_post), mute_logger('odoo.addons.base.models.ir_actions'):
            # first run: 200
            self.action.with_context(self.context).run()
            # second run: 400, should *not* raise but
            # should warn in logs (hence mute_logger)
            self.action.with_context(self.context).run()
        self.assertEqual(num_requests, 2)

    def test_90_convert_to_float(self):
        # make sure eval_value convert the value into float for float-type fields
        self.action.write({
            'state': 'object_write',
            'update_path': 'partner_latitude',
            'value': '20.99',
        })
        self.assertEqual(self.action._eval_value()[self.action.id], 20.99)


class TestCommonCustomFields(common.TransactionCase):
    MODEL = 'res.partner'
    COMODEL = 'res.users'

    def setUp(self):
        # check that the registry is properly reset
        fnames = set(self.registry[self.MODEL]._fields)

        @self.addCleanup
        def check_registry():
            assert set(self.registry[self.MODEL]._fields) == fnames

        self.addCleanup(self.registry.reset_changes)
        self.addCleanup(self.registry.clear_all_caches)

        super().setUp()

    def create_field(self, name, *, field_type='char'):
        """ create a custom field and return it """
        model = self.env['ir.model'].search([('model', '=', self.MODEL)])
        field = self.env['ir.model.fields'].create({
            'model_id': model.id,
            'name': name,
            'field_description': name,
            'ttype': field_type,
        })
        self.assertIn(name, self.env[self.MODEL]._fields)
        return field

    def create_view(self, name):
        """ create a view with the given field name """
        return self.env['ir.ui.view'].create({
            'name': 'yet another view',
            'model': self.MODEL,
            'arch': '<tree string="X"><field name="%s"/></tree>' % name,
        })


class TestCustomFields(TestCommonCustomFields):
    def test_create_custom(self):
        """ custom field names must be start with 'x_' """
        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
            self.create_field('xyz')

    def test_rename_custom(self):
        """ custom field names must be start with 'x_' """
        field = self.create_field('x_xyz')
        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
            field.name = 'xyz'

    def test_create_valid(self):
        """ field names must be valid pg identifiers """
        with self.assertRaises(ValidationError):
            self.create_field('x_foo bar')

    def test_rename_valid(self):
        """ field names must be valid pg identifiers """
        field = self.create_field('x_foo')
        with self.assertRaises(ValidationError):
            field.name = 'x_foo bar'

    def test_create_unique(self):
        """ one cannot create two fields with the same name on a given model """
        self.create_field('x_foo')
        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
            self.create_field('x_foo')

    def test_rename_unique(self):
        """ one cannot create two fields with the same name on a given model """
        field1 = self.create_field('x_foo')
        field2 = self.create_field('x_bar')
        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
            field2.name = field1.name

    def test_remove_without_view(self):
        """ try removing a custom field that does not occur in views """
        field = self.create_field('x_foo')
        field.unlink()

    def test_rename_without_view(self):
        """ try renaming a custom field that does not occur in views """
        field = self.create_field('x_foo')
        field.name = 'x_bar'

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_remove_with_view(self):
        """ try removing a custom field that occurs in a view """
        field = self.create_field('x_foo')
        self.create_view('x_foo')

        # try to delete the field, this should fail but not modify the registry
        with self.assertRaises(UserError):
            field.unlink()
        self.assertIn('x_foo', self.env[self.MODEL]._fields)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_rename_with_view(self):
        """ try renaming a custom field that occurs in a view """
        field = self.create_field('x_foo')
        self.create_view('x_foo')

        # try to delete the field, this should fail but not modify the registry
        with self.assertRaises(UserError):
            field.name = 'x_bar'
        self.assertIn('x_foo', self.env[self.MODEL]._fields)

    def test_unlink_base(self):
        """ one cannot delete a non-custom field expect for uninstallation """
        field = self.env['ir.model.fields']._get(self.MODEL, 'ref')
        self.assertTrue(field)

        with self.assertRaisesRegex(UserError, 'This column contains module data'):
            field.unlink()

        # but it works in the context of uninstalling a module
        field.with_context(_force_unlink=True).unlink()

    def test_unlink_with_inverse(self):
        """ create a custom o2m and then delete its m2o inverse """
        model = self.env['ir.model']._get(self.MODEL)
        comodel = self.env['ir.model']._get(self.COMODEL)

        m2o_field = self.env['ir.model.fields'].create({
            'model_id': comodel.id,
            'name': 'x_my_m2o',
            'field_description': 'my_m2o',
            'ttype': 'many2one',
            'relation': self.MODEL,
        })

        o2m_field = self.env['ir.model.fields'].create({
            'model_id': model.id,
            'name': 'x_my_o2m',
            'field_description': 'my_o2m',
            'ttype': 'one2many',
            'relation': self.COMODEL,
            'relation_field': m2o_field.name,
        })

        # normal mode: you cannot break dependencies
        with self.assertRaises(UserError):
            m2o_field.unlink()

        # uninstall mode: unlink dependant fields
        m2o_field.with_context(_force_unlink=True).unlink()
        self.assertFalse(o2m_field.exists())

    def test_unlink_with_dependant(self):
        """ create a computed field, then delete its dependency """
        # Also applies to compute fields
        comodel = self.env['ir.model'].search([('model', '=', self.COMODEL)])

        field = self.create_field('x_my_char')

        dependant = self.env['ir.model.fields'].create({
            'model_id': comodel.id,
            'name': 'x_oh_boy',
            'field_description': 'x_oh_boy',
            'ttype': 'char',
            'related': 'partner_id.x_my_char',
        })

        # normal mode: you cannot break dependencies
        with self.assertRaises(UserError):
            field.unlink()

        # uninstall mode: unlink dependant fields
        field.with_context(_force_unlink=True).unlink()
        self.assertFalse(dependant.exists())

    def test_unlink_inherited_custom(self):
        """ Creating a field on a model automatically creates an inherited field
            in the comodel, and the latter can only be removed by deleting the
            "parent" field.
        """
        field = self.create_field('x_foo')
        self.assertEqual(field.state, 'manual')

        inherited_field = self.env['ir.model.fields']._get(self.COMODEL, 'x_foo')
        self.assertTrue(inherited_field)
        self.assertEqual(inherited_field.state, 'base')

        # one cannot delete the inherited field itself
        with self.assertRaises(UserError):
            inherited_field.unlink()

        # but the inherited field is deleted when its parent field is
        field.unlink()
        self.assertFalse(field.exists())
        self.assertFalse(inherited_field.exists())
        self.assertFalse(self.env['ir.model.fields'].search_count([
            ('model', 'in', [self.MODEL, self.COMODEL]),
            ('name', '=', 'x_foo'),
        ]))

    def test_create_binary(self):
        """ binary custom fields should be created as attachment=True to avoid
        bloating the DB when creating e.g. image fields via studio
        """
        self.create_field('x_image', field_type='binary')
        custom_binary = self.env[self.MODEL]._fields['x_image']

        self.assertTrue(custom_binary.attachment)

    def test_related_field(self):
        """ create a custom related field, and check filled values """
        #
        # Add a custom field equivalent to the following definition:
        #
        # class Partner(models.Model)
        #     _inherit = 'res.partner'
        #     x_oh_boy = fields.Char(related="country_id.code", store=True)
        #

        # pick N=100 records in comodel
        countries = self.env['res.country'].search([('code', '!=', False)], limit=100)
        self.assertEqual(len(countries), 100, "Not enough records in comodel 'res.country'")

        # create records in model, with N distinct values for the related field
        partners = self.env['res.partner'].create([
            {'name': country.code, 'country_id': country.id} for country in countries
        ])
        self.env.flush_all()

        # create a non-computed field, and assert how many queries it takes
        model_id = self.env['ir.model']._get_id('res.partner')
        query_count = 48
        with self.assertQueryCount(query_count):
            self.env.registry.clear_cache()
            self.env['ir.model.fields'].create({
                'model_id': model_id,
                'name': 'x_oh_box',
                'field_description': 'x_oh_box',
                'ttype': 'char',
                'store': True,
            })

        # same with a related field, it only takes 8 extra queries
        with self.assertQueryCount(query_count + 8):
            self.env.registry.clear_cache()
            self.env['ir.model.fields'].create({
                'model_id': model_id,
                'name': 'x_oh_boy',
                'field_description': 'x_oh_boy',
                'ttype': 'char',
                'related': 'country_id.code',
                'store': True,
            })

        # check the computed values
        for partner in partners:
            self.assertEqual(partner.x_oh_boy, partner.country_id.code)

    def test_relation_of_a_custom_field(self):
        """ change the relation model of a custom field """
        model = self.env['ir.model'].search([('model', '=', self.MODEL)])
        field = self.env['ir.model.fields'].create({
            'name': 'x_foo',
            'model_id': model.id,
            'field_description': 'x_foo',
            'ttype': 'many2many',
            'relation': self.COMODEL,
        })

        # change the relation
        with self.assertRaises(ValidationError):
            field.relation = 'foo'

    def test_selection(self):
        """ custom selection field """
        Model = self.env[self.MODEL]
        model = self.env['ir.model'].search([('model', '=', self.MODEL)])
        field = self.env['ir.model.fields'].create({
            'model_id': model.id,
            'name': 'x_sel',
            'field_description': "Custom Selection",
            'ttype': 'selection',
            'selection_ids': [
                Command.create({'value': 'foo', 'name': 'Foo', 'sequence': 0}),
                Command.create({'value': 'bar', 'name': 'Bar', 'sequence': 1}),
            ],
        })

        x_sel = Model._fields['x_sel']
        self.assertEqual(x_sel.type, 'selection')
        self.assertEqual(x_sel.selection, [('foo', 'Foo'), ('bar', 'Bar')])

        # add selection value 'baz'
        field.selection_ids.create({
            'field_id': field.id, 'value': 'baz', 'name': 'Baz', 'sequence': 2,
        })
        x_sel = Model._fields['x_sel']
        self.assertEqual(x_sel.type, 'selection')
        self.assertEqual(x_sel.selection, [('foo', 'Foo'), ('bar', 'Bar'), ('baz', 'Baz')])

        # assign values to records
        rec1 = Model.create({'name': 'Rec1', 'x_sel': 'foo'})
        rec2 = Model.create({'name': 'Rec2', 'x_sel': 'bar'})
        rec3 = Model.create({'name': 'Rec3', 'x_sel': 'baz'})
        self.assertEqual(rec1.x_sel, 'foo')
        self.assertEqual(rec2.x_sel, 'bar')
        self.assertEqual(rec3.x_sel, 'baz')

        # remove selection value 'foo'
        field.selection_ids[0].unlink()
        x_sel = Model._fields['x_sel']
        self.assertEqual(x_sel.type, 'selection')
        self.assertEqual(x_sel.selection, [('bar', 'Bar'), ('baz', 'Baz')])

        self.assertEqual(rec1.x_sel, False)
        self.assertEqual(rec2.x_sel, 'bar')
        self.assertEqual(rec3.x_sel, 'baz')

        # update selection value 'bar'
        field.selection_ids[0].value = 'quux'
        x_sel = Model._fields['x_sel']
        self.assertEqual(x_sel.type, 'selection')
        self.assertEqual(x_sel.selection, [('quux', 'Bar'), ('baz', 'Baz')])

        self.assertEqual(rec1.x_sel, False)
        self.assertEqual(rec2.x_sel, 'quux')
        self.assertEqual(rec3.x_sel, 'baz')


@tagged('post_install', '-at_install')
class TestCustomFieldsPostInstall(TestCommonCustomFields):
    def test_add_field_valid(self):
        """ custom field names must start with 'x_', even when bypassing the constraints

        If a user bypasses all constraints to add a custom field not starting by `x_`,
        it must not be loaded in the registry.

        This is to forbid users to override class attributes.
        """
        field = self.create_field('x_foo')
        # Drop the SQL constraint, to bypass it,
        # as a user could do through a SQL shell or a `cr.execute` in a server action
        self.env.cr.execute("ALTER TABLE ir_model_fields DROP CONSTRAINT ir_model_fields_name_manual_field")
        self.env.cr.execute("UPDATE ir_model_fields SET name = 'foo' WHERE id = %s", [field.id])
        with self.assertLogs('odoo.addons.base.models.ir_model') as log_catcher:
            # Trick to reload the registry. The above rename done through SQL didn't reload the registry. This will.
            self.env.registry.setup_models(self.cr)
            self.assertIn(
                f'The field `{field.name}` is not defined in the `{field.model}` Python class', log_catcher.output[0]
            )

```

  File: tests/test_ir_attachment.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import base64
import hashlib
import io
import os

from PIL import Image

import odoo
from odoo.exceptions import AccessError
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.tools import image_to_base64

HASH_SPLIT = 2      # FIXME: testing implementations detail is not a good idea


class TestIrAttachment(TransactionCaseWithUserDemo):
    def setUp(self):
        super(TestIrAttachment, self).setUp()
        self.Attachment = self.env['ir.attachment']
        self.filestore = self.Attachment._filestore()

        # Blob1
        self.blob1 = b'blob1'
        self.blob1_b64 = base64.b64encode(self.blob1)
        self.blob1_hash = hashlib.sha1(self.blob1).hexdigest()
        self.blob1_fname = self.blob1_hash[:HASH_SPLIT] + '/' + self.blob1_hash

        # Blob2
        self.blob2 = b'blob2'
        self.blob2_b64 = base64.b64encode(self.blob2)

    def assertApproximately(self, value, expectedSize, delta=1):
        # we don't used bin_size in context, because on write, the cached value is the data and not
        # the size, so we need on each write to invalidate cache if we really want to get the size.
        try:
            value = base64.b64decode(value.decode())
        except UnicodeDecodeError:
            pass
        size = len(value) / 1024 # kb

        self.assertAlmostEqual(size, expectedSize, delta=delta)

    def test_01_store_in_db(self):
        # force storing in database
        self.env['ir.config_parameter'].set_param('ir_attachment.location', 'db')

        # 'ir_attachment.location' is undefined test database storage
        a1 = self.Attachment.create({'name': 'a1', 'raw': self.blob1})
        self.assertEqual(a1.datas, self.blob1_b64)

        self.assertEqual(a1.db_datas, self.blob1)

    def test_02_store_on_disk(self):
        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
        self.assertEqual(a2.store_fname, self.blob1_fname)
        self.assertTrue(os.path.isfile(os.path.join(self.filestore, a2.store_fname)))

    def test_03_no_duplication(self):
        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
        a3 = self.Attachment.create({'name': 'a3', 'raw': self.blob1})
        self.assertEqual(a3.store_fname, a2.store_fname)

    def test_04_keep_file(self):
        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
        a3 = self.Attachment.create({'name': 'a3', 'raw': self.blob1})

        a2_fn = os.path.join(self.filestore, a2.store_fname)

        a3.unlink()
        self.assertTrue(os.path.isfile(a2_fn))

    def test_05_change_data_change_file(self):
        a2 = self.Attachment.create({'name': 'a2', 'raw': self.blob1})
        a2_store_fname1 = a2.store_fname
        a2_fn = os.path.join(self.filestore, a2_store_fname1)

        self.assertTrue(os.path.isfile(a2_fn))

        a2.write({'raw': self.blob2})

        a2_store_fname2 = a2.store_fname
        self.assertNotEqual(a2_store_fname1, a2_store_fname2)

        a2_fn = os.path.join(self.filestore, a2_store_fname2)
        self.assertTrue(os.path.isfile(a2_fn))

    def test_07_write_mimetype(self):
        """
        Tests the consistency of documents' mimetypes
        """

        Attachment = self.Attachment.with_user(self.user_demo.id)
        a2 = Attachment.create({'name': 'a2', 'datas': self.blob1_b64, 'mimetype': 'image/png'})
        self.assertEqual(a2.mimetype, 'image/png', "the new mimetype should be the one given on write")
        a3 = Attachment.create({'name': 'a3', 'datas': self.blob1_b64, 'mimetype': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'})
        self.assertEqual(a3.mimetype, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', "should preserve office mime type")
        a4 = Attachment.create({'name': 'a4', 'datas': self.blob1_b64, 'mimetype': 'Application/VND.OpenXMLformats-officedocument.wordprocessingml.document'})
        self.assertEqual(a4.mimetype, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', "should preserve office mime type (lowercase)")

    def test_08_neuter_xml_mimetype(self):
        """
        Tests that potentially harmful mimetypes (XML mimetypes that can lead to XSS attacks) are converted to text
        """
        Attachment = self.Attachment.with_user(self.user_demo.id)
        document = Attachment.create({'name': 'document', 'datas': self.blob1_b64})
        document.write({'datas': self.blob1_b64, 'mimetype': 'text/xml'})
        self.assertEqual(document.mimetype, 'text/plain', "XML mimetype should be forced to text")
        document.write({'datas': self.blob1_b64, 'mimetype': 'image/svg+xml'})
        self.assertEqual(document.mimetype, 'text/plain', "SVG mimetype should be forced to text")
        document.write({'datas': self.blob1_b64, 'mimetype': 'text/html'})
        self.assertEqual(document.mimetype, 'text/plain', "HTML mimetype should be forced to text")
        document.write({'datas': self.blob1_b64, 'mimetype': 'application/xhtml+xml'})
        self.assertEqual(document.mimetype, 'text/plain', "XHTML mimetype should be forced to text")

    def test_09_dont_neuter_xml_mimetype_for_admin(self):
        """
        Admin user does not have a mime type filter
        """
        document = self.Attachment.create({'name': 'document', 'datas': self.blob1_b64})
        document.write({'datas': self.blob1_b64, 'mimetype': 'text/xml'})
        self.assertEqual(document.mimetype, 'text/xml', "XML mimetype should not be forced to text, for admin user")

    def test_10_image_autoresize(self):
        Attachment = self.env['ir.attachment']
        img_bin = io.BytesIO()
        dir_path = os.path.dirname(os.path.realpath(__file__))
        with Image.open(os.path.join(dir_path, 'odoo.jpg'), 'r') as logo:
            img = Image.new('RGB', (4000, 2000), '#4169E1')
            img.paste(logo)
            img.save(img_bin, 'JPEG')

        img_encoded = image_to_base64(img, 'JPEG')
        img_bin = img_bin.getvalue()

        fullsize = 124.99

        ####################################
        ### test create/write on 'datas'
        ####################################
        attach = Attachment.with_context(image_no_postprocess=True).create({
            'name': 'image',
            'datas': img_encoded,
        })
        self.assertApproximately(attach.datas, fullsize)  # no resize, no compression

        attach = attach.with_context(image_no_postprocess=False)
        attach.datas = img_encoded
        self.assertApproximately(attach.datas, 12.06)  # default resize + default compression

        # resize + default quality (80)
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '1024x768')
        attach.datas = img_encoded
        self.assertApproximately(attach.datas, 3.71)

        # resize + quality 50
        self.env['ir.config_parameter'].set_param('base.image_autoresize_quality', '50')
        attach.datas = img_encoded
        self.assertApproximately(attach.datas, 3.57)

        # no resize + no quality implicit
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '0')
        attach.datas = img_encoded
        self.assertApproximately(attach.datas, fullsize)

        # Check that we only compress quality when we resize. We avoid to compress again during a new write.
        # no resize + quality -> should have no effect
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '10000x10000')
        self.env['ir.config_parameter'].set_param('base.image_autoresize_quality', '50')
        attach.datas = img_encoded
        self.assertApproximately(attach.datas, fullsize)

        ####################################
        ### test create/write on 'raw'
        ####################################

        # reset default ~ delete
        self.env['ir.config_parameter'].search([('key', 'ilike', 'base.image_autoresize%')]).unlink()

        attach = Attachment.with_context(image_no_postprocess=True).create({
            'name': 'image',
            'raw': img_bin,
        })
        self.assertApproximately(attach.raw, fullsize)  # no resize, no compression

        attach = attach.with_context(image_no_postprocess=False)
        attach.raw = img_bin
        self.assertApproximately(attach.raw, 12.06)  # default resize + default compression

        # resize + default quality (80)
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '1024x768')
        attach.raw = img_bin
        self.assertApproximately(attach.raw, 3.71)

        # resize + no quality
        self.env['ir.config_parameter'].set_param('base.image_autoresize_quality', '0')
        attach.raw = img_bin
        self.assertApproximately(attach.raw, 4.09)

        # resize + quality 50
        self.env['ir.config_parameter'].set_param('base.image_autoresize_quality', '50')
        attach.raw = img_bin
        self.assertApproximately(attach.raw, 3.57)

        # no resize + no quality implicit
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '0')
        attach.raw = img_bin
        self.assertApproximately(attach.raw, fullsize)

        # no resize of gif
        self.env['ir.config_parameter'].set_param('base.image_autoresize_max_px', '0x0')
        gif_bin = b'GIF89a\x01\x00\x01\x00\x00\xff\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x00;'
        attach.raw = gif_bin
        self.assertEqual(attach.raw, gif_bin)

    def test_11_copy(self):
        """
        Copying an attachment preserves the data
        """
        document = self.Attachment.create({'name': 'document', 'datas': self.blob2_b64})
        document2 = document.copy({'name': "document (copy)"})
        self.assertEqual(document2.name, "document (copy)")
        self.assertEqual(document2.datas, document.datas)
        self.assertEqual(document2.db_datas, document.db_datas)
        self.assertEqual(document2.store_fname, document.store_fname)
        self.assertEqual(document2.checksum, document.checksum)

        document3 = document.copy({'datas': self.blob1_b64})
        self.assertEqual(document3.datas, self.blob1_b64)
        self.assertEqual(document3.raw, self.blob1)
        self.assertTrue(self.filestore)  # no data in db but has a store_fname
        self.assertEqual(document3.db_datas, False)
        self.assertEqual(document3.store_fname, self.blob1_fname)
        self.assertEqual(document3.checksum, self.blob1_hash)

    def test_12_gc(self):
        # the data needs to be unique so that no other attachment link
        # the file so that the gc removes it
        unique_blob = os.urandom(16)
        a1 = self.Attachment.create({'name': 'a1', 'raw': unique_blob})
        store_path = os.path.join(self.filestore, a1.store_fname)
        self.assertTrue(os.path.isfile(store_path), 'file exists')
        a1.unlink()
        self.Attachment._gc_file_store_unsafe()
        self.assertFalse(os.path.isfile(store_path), 'file removed')

    def test_13_rollback(self):
        self.registry.enter_test_mode(self.cr)
        self.addCleanup(self.registry.leave_test_mode)
        self.cr = self.registry.cursor()
        self.addCleanup(self.cr.close)
        self.env = odoo.api.Environment(self.cr, odoo.SUPERUSER_ID, {})

        # the data needs to be unique so that no other attachment link
        # the file so that the gc removes it
        unique_blob = os.urandom(16)
        a1 = self.Attachment.create({'name': 'a1', 'raw': unique_blob})
        store_path = os.path.join(self.filestore, a1.store_fname)
        self.assertTrue(os.path.isfile(store_path), 'file exists')
        self.env.cr.rollback()
        self.Attachment._gc_file_store_unsafe()
        self.assertFalse(os.path.isfile(store_path), 'file removed')

    def test_14_invalid_mimetype_with_correct_file_extension_no_post_processing(self):
        # test with fake svg with png mimetype
        unique_blob = b'<svg xmlns="http://www.w3.org/2000/svg"></svg>'
        a1 = self.Attachment.create({'name': 'a1', 'raw': unique_blob, 'mimetype': 'image/png'})
        self.assertEqual(a1.raw, unique_blob)
        self.assertEqual(a1.mimetype, 'image/png')


class TestPermissions(TransactionCaseWithUserDemo):
    def setUp(self):
        super().setUp()
        # replace self.env(uid=1) with an actual user environment so rules apply
        self.env = self.env(user=self.user_demo)
        self.Attachments = self.env['ir.attachment']

        # create a record with an attachment and a rule allowing Read access
        # but preventing Create, Update, or Delete
        record = self.Attachments.create({'name': 'record1'})
        self.vals = {'name': 'attach', 'res_id': record.id, 'res_model': record._name}
        a = self.attachment = self.Attachments.create(self.vals)

        # prevent create, write and unlink accesses on record
        self.rule = self.env['ir.rule'].sudo().create({
            'name': 'remove access to record %d' % record.id,
            'model_id': self.env['ir.model']._get_id(record._name),
            'domain_force': "[('id', '!=', %s)]" % record.id,
            'perm_read': False
        })
        self.env.flush_all()
        a.invalidate_recordset()

    def test_read_permission(self):
        """If the record can't be read, the attachment can't be read either
        If the attachment is public, the attachment can be read even if the record can't be read
        If the attachment has no res_model/res_id, it can be read by its author and admins only
        """
        # check that the information can be read out of the box
        self.attachment.datas
        # prevent read access on record
        self.rule.perm_read = True
        self.attachment.invalidate_recordset()
        with self.assertRaises(AccessError):
            self.attachment.datas

        # Make the attachment public
        self.attachment.sudo().public = True
        # Check the information can be read again
        self.attachment.datas
        # Remove the public access
        self.attachment.sudo().public = False
        # Check the record can no longer be accessed
        with self.assertRaises(AccessError):
            self.attachment.datas

        # Create an attachment as user without res_model/res_id
        attachment_user = self.Attachments.create({'name': 'foo'})
        # Check the user can access his own attachment
        attachment_user.datas
        # Create an attachment as superuser without res_model/res_id
        attachment_admin = self.Attachments.with_user(odoo.SUPERUSER_ID).create({'name': 'foo'})
        # Check the record cannot be accessed by a regular user
        with self.assertRaises(AccessError):
            attachment_admin.with_user(self.env.user).datas
        # Check the record can be accessed by an admin (other than superuser)
        admin_user = self.env.ref('base.user_admin')
        # Safety assert that base.user_admin is not the superuser, otherwise the test is useless
        self.assertNotEqual(odoo.SUPERUSER_ID, admin_user.id)
        attachment_admin.with_user(admin_user).datas

    def test_with_write_permissions(self):
        """With write permissions to the linked record, attachment can be
        created, updated, or deleted (or copied).
        """
        # enable write permission on linked record
        self.rule.perm_write = False
        attachment = self.Attachments.create(self.vals)
        attachment.copy()
        attachment.write({'raw': b'test'})
        attachment.unlink()

    def test_basic_modifications(self):
        """Lacking write access to the linked record means create, update, and
        delete on the attachment are forbidden
        """
        with self.assertRaises(AccessError):
            self.Attachments.create(self.vals)
        with self.assertRaises(AccessError):
            self.attachment.write({'raw': b'yay'})
        with self.assertRaises(AccessError):
            self.attachment.unlink()
        with self.assertRaises(AccessError):
            self.attachment.copy()

    def test_cross_record_copies(self):
        """Copying attachments between records (in the same model or not) adds
        wrinkles as the ACLs may diverge a lot more
        """
        # create an other unwritable record in a different model
        unwritable = self.env['res.users.apikeys.description'].create({'name': 'Unwritable'})
        with self.assertRaises(AccessError):
            unwritable.write({})  # checks unwritability
        # create a writable record in the same model
        writable = self.Attachments.create({'name': 'yes'})
        writable.name = 'canwrite'  # checks for writeability

        # can copy from a record with read permissions to one with write permissions
        copied = self.attachment.copy({'res_model': writable._name, 'res_id': writable.id})
        # can copy to self given write permission
        copied.copy()
        # can not copy back to record without write permission
        with self.assertRaises(AccessError):
            copied.copy({'res_id': self.vals['res_id']})

        # can not copy to a record without write permission
        with self.assertRaises(AccessError):
            self.attachment.copy({'res_model': unwritable._name, 'res_id': unwritable.id})
        # even from a record with write permissions
        with self.assertRaises(AccessError):
            copied.copy({'res_model': unwritable._name, 'res_id': unwritable.id})

```

  File: tests/test_ir_cron.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import collections
import secrets
import textwrap
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import timedelta
from unittest.mock import call, patch
from freezegun import freeze_time

import odoo
from odoo import api, fields
from odoo.tests.common import BaseCase, TransactionCase, RecordCapturer, get_db_name, tagged
from odoo.tools import mute_logger


class CronMixinCase:
    def capture_triggers(self, cron_id=None):
        """
        Get a context manager to get all cron triggers created during
        the context lifetime. While in the context, it exposes the
        triggers created so far from the beginning of the context. When
        the context exits, it doesn't capture new triggers anymore.

        The triggers are accessible on the `records` attribute of the
        returned object.

        :param cron_id: An optional cron record id (int) or xmlid (str)
                        to only capture triggers for that cron.
        """
        if isinstance(cron_id, str):  # xmlid case
            cron_id = self.env.ref(cron_id).id

        return RecordCapturer(
            model=self.env['ir.cron.trigger'].sudo(),
            domain=[('cron_id', '=', cron_id)] if cron_id else []
        )

    @classmethod
    def _get_cron_data(cls, env, priority=5):
        unique = secrets.token_urlsafe(8)
        return {
            'name': f'Dummy cron for TestIrCron {unique}',
            'state': 'code',
            'code': '',
            'model_id': env.ref('base.model_res_partner').id,
            'model_name': 'res.partner',
            'user_id': env.uid,
            'active': True,
            'interval_number': 1,
            'interval_type': 'days',
            'numbercall': -1,
            'doall': False,
            'nextcall': fields.Datetime.now() + timedelta(hours=1),
            'lastcall': False,
            'priority': priority,
        }

    @classmethod
    def _get_partner_data(cls, env):
        unique = secrets.token_urlsafe(8)
        return {'name': f'Dummy partner for TestIrCron {unique}'}


class TestIrCron(TransactionCase, CronMixinCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        freezer = freeze_time(cls.cr.now())
        cls.frozen_datetime = freezer.start()
        cls.addClassCleanup(freezer.stop)

        cls.cron = cls.env['ir.cron'].create(cls._get_cron_data(cls.env))
        cls.partner = cls.env['res.partner'].create(cls._get_partner_data(cls.env))

    def setUp(self):
        self.partner.write(self._get_partner_data(self.env))
        self.cron.write(self._get_cron_data(self.env))
        self.env['ir.cron.trigger'].search(
            [('cron_id', '=', self.cron.id)]
        ).unlink()

    def test_cron_direct_trigger(self):
        self.cron.code = textwrap.dedent(f"""\
            model.search(
                [("id", "=", {self.partner.id})]
            ).write(
                {{"name": "You have been CRONWNED"}}
            )
        """)

        self.cron.method_direct_trigger()

        self.assertEqual(self.cron.lastcall, fields.Datetime.now())
        self.assertEqual(self.partner.name, 'You have been CRONWNED')

    def test_cron_no_job_ready(self):
        self.cron.nextcall = fields.Datetime.now() + timedelta(days=1)
        self.cron.flush_recordset()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs])

    def test_cron_ready_by_nextcall(self):
        self.cron.nextcall = fields.Datetime.now()
        self.cron.flush_recordset()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertIn(self.cron.id, [job['id'] for job in ready_jobs])

    def test_cron_ready_by_trigger(self):
        self.cron._trigger()
        self.env['ir.cron.trigger'].flush_model()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertIn(self.cron.id, [job['id'] for job in ready_jobs])

    def test_cron_unactive_never_ready(self):
        self.cron.active = False
        self.cron.nextcall = fields.Datetime.now()
        self.cron._trigger()
        self.cron.flush_recordset()
        self.env['ir.cron.trigger'].flush_model()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs])

    def test_cron_numbercall0_never_ready(self):
        self.cron.numbercall = 0
        self.cron.nextcall = fields.Datetime.now()
        self.cron._trigger()
        self.cron.flush_recordset()
        self.env['ir.cron.trigger'].flush_model()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs])

    def test_cron_ready_jobs_order(self):
        cron_avg = self.cron.copy()
        cron_avg.priority = 5  # average priority

        cron_high = self.cron.copy()
        cron_high.priority = 0  # highest priority

        cron_low = self.cron.copy()
        cron_low.priority = 10  # lowest priority

        crons = cron_high | cron_avg | cron_low  # order is important
        crons.write({'nextcall': fields.Datetime.now()})
        crons.flush_recordset()
        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)

        self.assertEqual(
            [job['id'] for job in ready_jobs if job['id'] in crons._ids],
            list(crons._ids),
        )

    def test_cron_skip_unactive_triggers(self):
        # Situation: an admin disable the cron and another user triggers
        # the cron to be executed *now*, the cron shouldn't be ready and
        # the trigger should not be stored.

        self.cron.active = False
        self.cron.nextcall = fields.Datetime.now() + timedelta(days=2)
        self.cron.flush_recordset()
        with self.capture_triggers() as capture:
            self.cron._trigger()

        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertNotIn(self.cron.id, [job['id'] for job in ready_jobs],
            "the cron shouldn't be ready")
        self.assertFalse(capture.records, "trigger should has been skipped")

    def test_cron_keep_future_triggers(self):
        # Situation: yesterday an admin disabled the cron, while the
        # cron was disabled, another user triggered it to run today.
        # In case the cron as been re-enabled before "today", it should
        # run.

        # go yesterday
        self.frozen_datetime.tick(delta=timedelta(days=-1))

        # admin disable the cron
        self.cron.active = False
        self.cron.nextcall = fields.Datetime.now() + timedelta(days=10)
        self.cron.flush_recordset()

        # user triggers the cron to run *tomorrow of yesterday (=today)
        with self.capture_triggers() as capture:
            self.cron._trigger(at=fields.Datetime.now() + timedelta(days=1))

        # admin re-enable the cron
        self.cron.active = True
        self.cron.flush_recordset()

        # go today, check the cron should run
        self.frozen_datetime.tick(delta=timedelta(days=1))
        ready_jobs = self.registry['ir.cron']._get_all_ready_jobs(self.cr)
        self.assertIn(self.cron.id, [job['id'] for job in ready_jobs],
            "cron should be ready")
        self.assertTrue(capture.records, "trigger should has been kept")

    def test_cron_process_job(self):

        Setup = collections.namedtuple('Setup', ['doall', 'numbercall', 'missedcall', 'trigger'])
        Expect = collections.namedtuple('Expect', ['call_count', 'call_left', 'active'])

        matrix = [
            (Setup(doall=False, numbercall=-1, missedcall=2, trigger=False),
             Expect(call_count=1, call_left=-1, active=True)),
            (Setup(doall=True, numbercall=-1, missedcall=2, trigger=False),
             Expect(call_count=2, call_left=-1, active=True)),
            (Setup(doall=False, numbercall=3, missedcall=2, trigger=False),
             Expect(call_count=1, call_left=2, active=True)),
            (Setup(doall=True, numbercall=3, missedcall=2, trigger=False),
             Expect(call_count=2, call_left=1, active=True)),
            (Setup(doall=True, numbercall=3, missedcall=4, trigger=False),
             Expect(call_count=3, call_left=0, active=False)),
            (Setup(doall=True, numbercall=3, missedcall=0, trigger=True),
             Expect(call_count=1, call_left=2, active=True)),
        ]

        for setup, expect in matrix:
            with self.subTest(setup=setup, expect=expect):
                self.cron.write({
                    'active': True,
                    'doall': setup.doall,
                    'numbercall': setup.numbercall,
                    'nextcall': fields.Datetime.now() - timedelta(days=setup.missedcall - 1),
                })
                with self.capture_triggers(self.cron.id) as capture:
                    if setup.trigger:
                        self.cron._trigger()

                self.cron.flush_recordset()
                capture.records.flush_recordset()
                self.registry.enter_test_mode(self.cr)
                try:
                    with patch.object(self.registry['ir.cron'], '_callback') as callback:
                        self.registry['ir.cron']._process_job(
                            self.registry.db_name,
                            self.registry.cursor(),
                            self.cron.read(load=None)[0]
                        )
                finally:
                    self.registry.leave_test_mode()
                self.cron.invalidate_recordset()
                capture.records.invalidate_recordset()

                self.assertEqual(callback.call_count, expect.call_count)
                self.assertEqual(self.cron.numbercall, expect.call_left)
                self.assertEqual(self.cron.active, expect.active)
                self.assertEqual(self.cron.lastcall, fields.Datetime.now())
                self.assertEqual(self.cron.nextcall, fields.Datetime.now() + timedelta(days=1))
                self.assertEqual(self.env['ir.cron.trigger'].search_count([
                    ('cron_id', '=', self.cron.id),
                    ('call_at', '<=', fields.Datetime.now())]
                ), 0)

    def test_cron_null_interval(self):
        self.cron.interval_number = 0
        self.cron.flush_recordset()
        with self.assertLogs('odoo.addons.base.models.ir_cron', 'ERROR'):
            self.cron._process_job(get_db_name(), self.env.cr, self.cron.read(load=False)[0])
        self.cron.invalidate_recordset(['active'])
        self.assertFalse(self.cron.active)


@tagged('-standard', '-at_install', 'post_install', 'database_breaking')
class TestIrCronConcurrent(BaseCase, CronMixinCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        # Keep a reference on the real cron methods, those without patch
        cls.registry = odoo.registry(get_db_name())
        cls.cron_process_job = cls.registry['ir.cron']._process_job
        cls.cron_process_jobs = cls.registry['ir.cron']._process_jobs
        cls.cron_get_all_ready_jobs = cls.registry['ir.cron']._get_all_ready_jobs
        cls.cron_acquire_one_job = cls.registry['ir.cron']._acquire_one_job
        cls.cron_callback = cls.registry['ir.cron']._callback

    def setUp(self):
        super().setUp()

        with self.registry.cursor() as cr:
            env = api.Environment(cr, odoo.SUPERUSER_ID, {})
            env['ir.cron'].search([]).unlink()
            env['ir.cron.trigger'].search([]).unlink()

            self.cron1_data = env['ir.cron'].create(self._get_cron_data(env, priority=1)).read(load=None)[0]
            self.cron2_data = env['ir.cron'].create(self._get_cron_data(env, priority=2)).read(load=None)[0]
            self.partner_data = env['res.partner'].create(self._get_partner_data(env)).read(load=None)[0]
            self.cron_ids = [self.cron1_data['id'], self.cron2_data['id']]

    def test_cron_concurrency_1(self):
        """
        Two cron threads "th1" and "th2" wake up at the same time and
        see two jobs "job1" and "job2" that are ready (setup).

        Th1 acquire job1, before it can process and release its job, th2
        acquire a job too (setup). Th2 shouldn't be able to acquire job1
        as another thread is processing it, it should skips job1 and
        should acquire job2 instead (test). Both thread then process
        their job, update its `nextcall` and release it (setup).

        All the threads update and release their job before any thread
        attempt to acquire another job. (setup)

        The two thread each attempt to acquire a new job (setup), they
        should both fail to acquire any as each job's nextcall is in the
        future* (test).

        *actually, in their own transaction, the other job's nextcall is
        still "in the past" but any attempt to use that information
        would result in a serialization error. This tests ensure that
        that serialization error is correctly handled and ignored.
        """
        lock = threading.Lock()
        barrier = threading.Barrier(2)

        ###
        # Setup
        ###

        # Watchdog, if a thread was waiting at the barrier when the
        # other exited, it receives a BrokenBarrierError and exits too.
        def process_jobs(*args, **kwargs):
            try:
                self.cron_process_jobs(*args, **kwargs)
            finally:
                barrier.reset()

        # The two threads get the same list of jobs
        def get_all_ready_jobs(*args, **kwargs):
            jobs = self.cron_get_all_ready_jobs(*args, **kwargs)
            barrier.wait()
            return jobs

        # When a thread acquire a job, it processes it till the end
        # before another thread can acquire one.
        def acquire_one_job(*args, **kwargs):
            lock.acquire(timeout=1)
            try:
                with mute_logger('odoo.sql_db'):
                    job = self.cron_acquire_one_job(*args, **kwargs)
            except Exception:
                lock.release()
                raise
            if not job:
                lock.release()
            return job

        # When a thread is done processing its job, it waits for the
        # other thread to catch up.
        def process_job(*args, **kwargs):
            try:
                return_value = self.cron_process_job(*args, **kwargs)
            finally:
                lock.release()
            barrier.wait(timeout=1)
            return return_value

        # Set 2 jobs ready, process them in 2 different threads.
        with self.registry.cursor() as cr:
            env = api.Environment(cr, odoo.SUPERUSER_ID, {})
            env['ir.cron'].browse(self.cron_ids).write({
                'nextcall': fields.Datetime.now() - timedelta(hours=1)
            })

        ###
        # Run
        ###
        with patch.object(self.registry['ir.cron'], '_process_jobs', process_jobs), \
             patch.object(self.registry['ir.cron'], '_get_all_ready_jobs', get_all_ready_jobs), \
             patch.object(self.registry['ir.cron'], '_acquire_one_job', acquire_one_job), \
             patch.object(self.registry['ir.cron'], '_process_job', process_job), \
             patch.object(self.registry['ir.cron'], '_callback') as callback, \
             ThreadPoolExecutor(max_workers=2) as executor:
            fut1 = executor.submit(self.registry['ir.cron']._process_jobs, self.registry.db_name)
            fut2 = executor.submit(self.registry['ir.cron']._process_jobs, self.registry.db_name)
            fut1.result(timeout=2)
            fut2.result(timeout=2)

        ###
        # Validation
        ###

        self.assertEqual(len(callback.call_args_list), 2, 'Two jobs must have been processed.')
        self.assertEqual(callback.call_args_list, [
            call(
                self.cron1_data['name'],
                self.cron1_data['ir_actions_server_id'],
                self.cron1_data['id'],
            ),
            call(
                self.cron2_data['name'],
                self.cron2_data['ir_actions_server_id'],
                self.cron2_data['id'],
            ),
        ])

```

  File: tests/test_ir_default.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.exceptions import ValidationError
from odoo.tests.common import TransactionCase


class TestIrDefault(TransactionCase):

    def test_defaults(self):
        """ check the mechanism of user-defined defaults """
        companyA = self.env.company
        companyB = companyA.create({'name': 'CompanyB'})
        user1 = self.env.user
        user2 = user1.create({'name': 'u2', 'login': 'u2'})
        user3 = user1.create({'name': 'u3', 'login': 'u3',
                              'company_id': companyB.id,
                              'company_ids': companyB.ids})

        # create some default value for some model
        IrDefault1 = self.env['ir.default']
        IrDefault2 = IrDefault1.with_user(user2)
        IrDefault3 = IrDefault1.with_user(user3)

        # set a default value for all users
        IrDefault1.search([('field_id.model', '=', 'res.partner')]).unlink()
        IrDefault1.set('res.partner', 'ref', 'GLOBAL', user_id=False, company_id=False)
        self.assertEqual(IrDefault1._get_model_defaults('res.partner'), {'ref': 'GLOBAL'},
                         "Can't retrieve the created default value for all users.")
        self.assertEqual(IrDefault2._get_model_defaults('res.partner'), {'ref': 'GLOBAL'},
                         "Can't retrieve the created default value for all users.")
        self.assertEqual(IrDefault3._get_model_defaults('res.partner'), {'ref': 'GLOBAL'},
                         "Can't retrieve the created default value for all users.")

        # set a default value for current company (behavior of 'set default' from debug mode)
        IrDefault1.set('res.partner', 'ref', 'COMPANY', user_id=False, company_id=True)
        self.assertEqual(IrDefault1._get_model_defaults('res.partner'), {'ref': 'COMPANY'},
                         "Can't retrieve the created default value for company.")
        self.assertEqual(IrDefault2._get_model_defaults('res.partner'), {'ref': 'COMPANY'},
                         "Can't retrieve the created default value for company.")
        self.assertEqual(IrDefault3._get_model_defaults('res.partner'), {'ref': 'GLOBAL'},
                         "Unexpected default value for company.")

        # set a default value for current user (behavior of 'set default' from debug mode)
        IrDefault2.set('res.partner', 'ref', 'USER', user_id=True, company_id=True)
        self.assertEqual(IrDefault1._get_model_defaults('res.partner'), {'ref': 'COMPANY'},
                         "Can't retrieve the created default value for user.")
        self.assertEqual(IrDefault2._get_model_defaults('res.partner'), {'ref': 'USER'},
                         "Unexpected default value for user.")
        self.assertEqual(IrDefault3._get_model_defaults('res.partner'), {'ref': 'GLOBAL'},
                         "Unexpected default value for company.")

        # check default values on partners
        default1 = IrDefault1.env['res.partner'].default_get(['ref']).get('ref')
        self.assertEqual(default1, 'COMPANY', "Wrong default value.")
        default2 = IrDefault2.env['res.partner'].default_get(['ref']).get('ref')
        self.assertEqual(default2, 'USER', "Wrong default value.")
        default3 = IrDefault3.env['res.partner'].default_get(['ref']).get('ref')
        self.assertEqual(default3, 'GLOBAL', "Wrong default value.")

    def test_conditions(self):
        """ check user-defined defaults with condition """
        IrDefault = self.env['ir.default']

        # default without condition
        IrDefault.search([('field_id.model', '=', 'res.partner')]).unlink()
        IrDefault.set('res.partner', 'ref', 'X')
        self.assertEqual(IrDefault._get_model_defaults('res.partner'),
                         {'ref': 'X'})
        self.assertEqual(IrDefault._get_model_defaults('res.partner', condition='name=Agrolait'),
                         {})

        # default with a condition
        IrDefault.search([('field_id.model', '=', 'res.partner.title')]).unlink()
        IrDefault.set('res.partner.title', 'shortcut', 'X')
        IrDefault.set('res.partner.title', 'shortcut', 'Mr', condition='name=Mister')
        self.assertEqual(IrDefault._get_model_defaults('res.partner.title'),
                         {'shortcut': 'X'})
        self.assertEqual(IrDefault._get_model_defaults('res.partner.title', condition='name=Miss'),
                         {})
        self.assertEqual(IrDefault._get_model_defaults('res.partner.title', condition='name=Mister'),
                         {'shortcut': 'Mr'})

    def test_invalid(self):
        """ check error cases with 'ir.default' """
        IrDefault = self.env['ir.default']
        with self.assertRaises(ValidationError):
            IrDefault.set('unknown_model', 'unknown_field', 42)
        with self.assertRaises(ValidationError):
            IrDefault.set('res.partner', 'unknown_field', 42)
        with self.assertRaises(ValidationError):
            IrDefault.set('res.partner', 'lang', 'some_LANG')
        with self.assertRaises(ValidationError):
            IrDefault.set('res.partner', 'partner_latitude', 'foo')
        with self.assertRaises(ValidationError):
            IrDefault.set('res.partner', 'color', 2147483648)

    def test_removal(self):
        """ check defaults for many2one with their value being removed """
        IrDefault = self.env['ir.default']
        IrDefault.search([('field_id.model', '=', 'res.partner')]).unlink()

        # set a record as a default value
        title = self.env['res.partner.title'].create({'name': 'President'})
        IrDefault.set('res.partner', 'title', title.id)
        self.assertEqual(IrDefault._get_model_defaults('res.partner'), {'title': title.id})

        # delete the record, and check the presence of the default value
        title.unlink()
        self.assertEqual(IrDefault._get_model_defaults('res.partner'), {})

    def test_multi_company_defaults(self):
        """Check defaults in multi-company environment."""
        company_a = self.env["res.company"].create({"name": "C_A"})
        company_b = self.env["res.company"].create({"name": "C_B"})
        company_a_b = (company_a + company_b)
        company_b_a = (company_b + company_a)
        multi_company_user = self.env['res.users'].create({
            'name': 'u2', 'login': 'u2',
            'company_id': company_a.id,
            'company_ids': company_a_b.ids,
        })
        IrDefault = self.env["ir.default"].with_user(multi_company_user)
        IrDefault.with_context(allowed_company_ids=company_a.ids).set(
            'res.partner', 'ref', 'CADefault', user_id=True, company_id=True)
        IrDefault.with_context(allowed_company_ids=company_b.ids).set(
            'res.partner', 'ref', 'CBDefault', user_id=True, company_id=True)
        self.assertEqual(
            IrDefault._get_model_defaults('res.partner')['ref'],
            'CADefault',
        )
        self.assertEqual(
            IrDefault.with_context(allowed_company_ids=company_a.ids)._get_model_defaults('res.partner')['ref'],
            'CADefault',
        )
        self.assertEqual(
            IrDefault.with_context(allowed_company_ids=company_b.ids)._get_model_defaults('res.partner')['ref'],
            'CBDefault',
        )
        self.assertEqual(
            IrDefault.with_context(allowed_company_ids=company_a_b.ids)._get_model_defaults('res.partner')['ref'],
            'CADefault',
        )
        self.assertEqual(
            IrDefault.with_context(allowed_company_ids=company_b_a.ids)._get_model_defaults('res.partner')['ref'],
            'CBDefault',
        )

    def test_json_format_invalid(self):
        """ check the _check_json_format constraint """
        IrDefault = self.env['ir.default']
        field_id = self.env['ir.model.fields'].search([('model', '=', 'res.partner'), ('name', '=', 'ref')])
        with self.assertRaises(ValidationError):
            IrDefault.create({
                'field_id': field_id.id,
                'json_value': '{"name":"John", }',
            })

```

  File: tests/test_ir_filters.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast
import logging

from odoo import exceptions
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.tests.common import TransactionCase, ADMIN_USER_ID, tagged

_logger = logging.getLogger(__name__)

def noid(seq):
    """ Removes values that are not relevant for the test comparisons """
    for d in seq:
        d.pop('id', None)
        d.pop('action_id', None)
    return seq


class FiltersCase(TransactionCaseWithUserDemo):
    def setUp(self):
        super(FiltersCase, self).setUp()
        self.USER_NG = self.env['res.users'].name_search('demo')[0]
        self.USER_ID = self.USER_NG[0]

    def build(self, model, *args):
        Model = self.env[model].with_user(ADMIN_USER_ID)
        for vals in args:
            Model.create(vals)


class TestGetFilters(FiltersCase):

    def test_own_filters(self):
        self.build(
            'ir.filters',
            dict(name='a', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='b', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='c', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='d', user_id=self.USER_ID, model_id='ir.filters'))

        filters = self.env['ir.filters'].with_user(self.USER_ID).get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', is_default=False, user_id=self.USER_NG, domain='[]', context='{}', sort='[]'),
            dict(name='b', is_default=False, user_id=self.USER_NG, domain='[]', context='{}', sort='[]'),
            dict(name='c', is_default=False, user_id=self.USER_NG, domain='[]', context='{}', sort='[]'),
            dict(name='d', is_default=False, user_id=self.USER_NG, domain='[]', context='{}', sort='[]'),
        ])

    def test_global_filters(self):
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', user_id=False, model_id='ir.filters'),
            dict(name='c', user_id=False, model_id='ir.filters'),
            dict(name='d', user_id=False, model_id='ir.filters'),
        )

        filters = self.env['ir.filters'].with_user(self.USER_ID).get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', is_default=False, user_id=False, domain='[]', context='{}', sort='[]'),
            dict(name='b', is_default=False, user_id=False, domain='[]', context='{}', sort='[]'),
            dict(name='c', is_default=False, user_id=False, domain='[]', context='{}', sort='[]'),
            dict(name='d', is_default=False, user_id=False, domain='[]', context='{}', sort='[]'),
        ])

    def test_no_third_party_filters(self):
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', user_id=ADMIN_USER_ID, model_id='ir.filters'),
            dict(name='c', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='d', user_id=ADMIN_USER_ID, model_id='ir.filters')  )

        filters = self.env['ir.filters'].with_user(self.USER_ID).get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', is_default=False, user_id=False, domain='[]', context='{}', sort='[]'),
            dict(name='c', is_default=False, user_id=self.USER_NG, domain='[]', context='{}', sort='[]'),
        ])


class TestOwnDefaults(FiltersCase):

    def test_new_no_filter(self):
        """
        When creating a @is_default filter with no existing filter, that new
        filter gets the default flag
        """
        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        Filters.create_or_replace({
            'name': 'a',
            'model_id': 'ir.filters',
            'user_id': self.USER_ID,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=self.USER_NG, is_default=True,
                 domain='[]', context='{}', sort='[]')
        ])

    def test_new_filter_not_default(self):
        """
        When creating a @is_default filter with existing non-default filters,
        the new filter gets the flag
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='b', user_id=self.USER_ID, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        Filters.create_or_replace({
            'name': 'c',
            'model_id': 'ir.filters',
            'user_id': self.USER_ID,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=self.USER_NG, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='b', user_id=self.USER_NG, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='c', user_id=self.USER_NG, is_default=True, domain='[]', context='{}', sort='[]'),
        ])

    def test_new_filter_existing_default(self):
        """
        When creating a @is_default filter where an existing filter is already
        @is_default, the flag should be *moved* from the old to the new filter
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='b', is_default=True, user_id=self.USER_ID, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        Filters.create_or_replace({
            'name': 'c',
            'model_id': 'ir.filters',
            'user_id': self.USER_ID,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=self.USER_NG, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='b', user_id=self.USER_NG, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='c', user_id=self.USER_NG, is_default=True, domain='[]', context='{}', sort='[]'),
        ])

    def test_update_filter_set_default(self):
        """
        When updating an existing filter to @is_default, if an other filter
        already has the flag the flag should be moved
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=self.USER_ID, model_id='ir.filters'),
            dict(name='b', is_default=True, user_id=self.USER_ID, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        Filters.create_or_replace({
            'name': 'a',
            'model_id': 'ir.filters',
            'user_id': self.USER_ID,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=self.USER_NG, is_default=True, domain='[]', context='{}', sort='[]'),
            dict(name='b', user_id=self.USER_NG, is_default=False, domain='[]', context='{}', sort='[]'),
        ])


class TestGlobalDefaults(FiltersCase):

    def test_new_filter_not_default(self):
        """
        When creating a @is_default filter with existing non-default filters,
        the new filter gets the flag
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', user_id=False, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        Filters.create_or_replace({
            'name': 'c',
            'model_id': 'ir.filters',
            'user_id': False,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=False, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='b', user_id=False, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='c', user_id=False, is_default=True, domain='[]', context='{}', sort='[]'),
        ])

    def test_new_filter_existing_default(self):
        """
        When creating a @is_default filter where an existing filter is already
        @is_default, an error should be generated
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', is_default=True, user_id=False, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        with self.assertRaises(exceptions.UserError):
            Filters.create_or_replace({
                'name': 'c',
                'model_id': 'ir.filters',
                'user_id': False,
                'is_default': True,
            })

    def test_update_filter_set_default(self):
        """
        When updating an existing filter to @is_default, if an other filter
        already has the flag an error should be generated
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', is_default=True, user_id=False, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        with self.assertRaises(exceptions.UserError):
            Filters.create_or_replace({
                'name': 'a',
                'model_id': 'ir.filters',
                'user_id': False,
                'is_default': True,
            })

    def test_update_default_filter(self):
        """
        Replacing the current default global filter should not generate any error
        """
        self.build(
            'ir.filters',
            dict(name='a', user_id=False, model_id='ir.filters'),
            dict(name='b', is_default=True, user_id=False, model_id='ir.filters'),
        )

        Filters = self.env['ir.filters'].with_user(self.USER_ID)
        context_value = "{'some_key': True}"
        Filters.create_or_replace({
            'name': 'b',
            'model_id': 'ir.filters',
            'user_id': False,
            'context': context_value,
            'is_default': True,
        })
        filters = Filters.get_filters('ir.filters')

        self.assertItemsEqual(noid(filters), [
            dict(name='a', user_id=False, is_default=False, domain='[]', context='{}', sort='[]'),
            dict(name='b', user_id=False, is_default=True, domain='[]', context=context_value, sort='[]'),
        ])


class TestReadGroup(TransactionCase):
    """Test function read_group with groupby on a many2one field to a model
    (in test, "user_id" to "res.users") which is ordered by an inherited not stored field (in
    test, "name" inherited from "res.partners").
    """
    def test_read_group_1(self):
        Users = self.env['res.users']
        self.assertEqual(Users._order, "name, login", "Model res.users must be ordered by name, login")
        self.assertFalse(Users._fields['name'].store, "Field name is not stored in res.users")

        Filters = self.env['ir.filters']
        filter_a = Filters.create(dict(name="Filter_A", model_id="ir.filters"))
        filter_b = Filters.create(dict(name="Filter_B", model_id="ir.filters"))
        filter_b.write(dict(user_id=False))

        res = Filters.read_group([], ['name', 'user_id'], ['user_id'])
        self.assertTrue(any(val['user_id'] == False for val in res), "At least one group must contain val['user_id'] == False.")


@tagged('post_install', '-at_install', 'migration')
class TestAllFilters(TransactionCase):
    def check_filter(self, name, model, domain, fields, groupby, order, context):
        if groupby:
            try:
                self.env[model].with_context(context).read_group(domain, fields, groupby, orderby=order)
            except ValueError as e:
                raise self.failureException("Test filter '%s' failed: %s" % (name, e)) from None
            except KeyError as e:
                raise self.failureException("Test filter '%s' failed: field or aggregate %s does not exist"% (name, e)) from None
        elif domain:
            try:
                self.env[model].with_context(context).search(domain, order=order)
            except ValueError as e:
                raise self.failureException("Test filter '%s' failed: %s" % (name, e)) from None
        else:
            _logger.info("No domain or group by in filter %s with model %s and context %s", name, model, context)

    def test_filters(self):
        for filter_ in self.env['ir.filters'].search([]):
            with self.subTest(name=filter_.name):
                context = ast.literal_eval(filter_.context)
                groupby = context.get('group_by')
                self.check_filter(
                    name=filter_.name,
                    model=filter_.model_id,
                    domain=filter_._get_eval_domain(),
                    fields=[field.split(':')[0] for field in (groupby or [])],
                    groupby=groupby,
                    order=','.join(ast.literal_eval(filter_.sort)),
                    context=context,
                )

```

  File: tests/test_ir_http.py
  Content:
```
import logging
import re
import time

from odoo.tests import tagged
from odoo.tests.common import TransactionCase

_logger = logging.getLogger(__name__)


@tagged('-at_install', 'post_install')
class TestIrHttpPerformances(TransactionCase):

    def test_routing_map_performance(self):
        self.env.registry.clear_cache('routing')
        # if the routing map was already generated it is possible that some compiled regex are in cache.
        # we want to mesure the cold state, when the worker just spawned, we need to empty the re cache
        re._cache.clear()

        self.env.registry.clear_cache('routing')
        start = time.time()
        self.env['ir.http'].routing_map()
        duration = time.time() - start
        _logger.info('Routing map web generated in %.3fs', duration)

        # generate the routing map of another website, to check if we can benefit from anything computed by the previous routing map
        start = time.time()
        self.env['ir.http'].routing_map(key=1)
        duration = time.time() - start
        _logger.info('Routing map website1 generated in %.3fs', duration)

```

  File: tests/test_ir_mail_server.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import email.message
import email.policy

from unittest.mock import patch

from odoo import tools
from odoo.addons.base.tests import test_mail_examples
from odoo.addons.base.tests.common import MockSmtplibCase
from odoo.tests import tagged, users
from odoo.tests.common import TransactionCase
from odoo.tools import mute_logger
from odoo.tools import config


class _FakeSMTP:
    """SMTP stub"""
    def __init__(self):
        self.messages = []
        self.from_filter = 'example.com'

    # Python 3 before 3.7.4
    def sendmail(self, smtp_from, smtp_to_list, message_str,
                 mail_options=(), rcpt_options=()):
        self.messages.append(message_str)

    # Python 3.7.4+
    def send_message(self, message, smtp_from, smtp_to_list,
                     mail_options=(), rcpt_options=()):
        self.messages.append(message.as_string())


@tagged('mail_server')
class EmailConfigCase(TransactionCase):

    @patch.dict(config.options, {"email_from": "settings@example.com"})
    def test_default_email_from(self):
        """ Email from setting is respected and comes from configuration. """
        message = self.env["ir.mail_server"].build_email(
            False, "recipient@example.com", "Subject",
            "The body of an email",
        )
        self.assertEqual(message["From"], "settings@example.com")


@tagged('mail_server')
class TestIrMailServer(TransactionCase, MockSmtplibCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.env['ir.config_parameter'].sudo().set_param('mail.default.from_filter', False)
        cls._init_mail_servers()

    def test_assert_base_values(self):
        self.assertFalse(self.env['ir.mail_server']._get_default_bounce_address())
        self.assertFalse(self.env['ir.mail_server']._get_default_from_address())

    def test_bpo_34424_35805(self):
        """Ensure all email sent are bpo-34424 and bpo-35805 free"""
        fake_smtp = _FakeSMTP()
        msg = email.message.EmailMessage(policy=email.policy.SMTP)
        msg['From'] = '"Joé Doe" <joe@example.com>'
        msg['To'] = '"Joé Doe" <joe@example.com>'

        # Message-Id & References fields longer than 77 chars (bpo-35805)
        msg['Message-Id'] = '<929227342217024.1596730490.324691772460938-example-30661-some.reference@test-123.example.com>'
        msg['References'] = '<345227342212345.1596730777.324691772483620-example-30453-other.reference@test-123.example.com>'

        msg_on_the_wire = self._send_email(msg, fake_smtp)
        self.assertEqual(msg_on_the_wire,
            'From: =?utf-8?q?Jo=C3=A9?= Doe <joe@example.com>\r\n'
            'To: =?utf-8?q?Jo=C3=A9?= Doe <joe@example.com>\r\n'
            'Message-Id: <929227342217024.1596730490.324691772460938-example-30661-some.reference@test-123.example.com>\r\n'
            'References: <345227342212345.1596730777.324691772483620-example-30453-other.reference@test-123.example.com>\r\n'
            '\r\n'
        )

    def test_content_alternative_correct_order(self):
        """
        RFC-1521 7.2.3. The Multipart/alternative subtype
        > the alternatives appear in an order of increasing faithfulness
        > to the original content. In general, the best choice is the
        > LAST part of a type supported by the recipient system's local
        > environment.

        Also, the MIME-Version header should be present in BOTH the
        enveloppe AND the parts
        """
        fake_smtp = _FakeSMTP()
        msg = self._build_email("test@example.com", body='<p>Hello world</p>', subtype='html')
        msg_on_the_wire = self._send_email(msg, fake_smtp)

        self.assertGreater(msg_on_the_wire.index('text/html'), msg_on_the_wire.index('text/plain'),
            "The html part should be preferred (=appear after) to the text part")
        self.assertEqual(msg_on_the_wire.count('==============='), 2 + 2, # +2 for the header and the footer
            "There should be 2 parts: one text and one html")
        self.assertEqual(msg_on_the_wire.count('MIME-Version: 1.0'), 3,
            "There should be 3 headers MIME-Version: one on the enveloppe, "
            "one on the html part, one on the text part")

    def test_content_mail_body(self):
        bodies = [
            'content',
            '<p>content</p>',
            '<head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"></head><body><p>content</p></body>',
            test_mail_examples.MISC_HTML_SOURCE,
            test_mail_examples.QUOTE_THUNDERBIRD_HTML,
        ]
        expected_list = [
            'content',
            'content',
            'content',
            "test1\n*test2*\ntest3\ntest4\ntest5\ntest6   test7\ntest8    test9\ntest10\ntest11\ntest12\ngoogle [1]\ntest link [2]\n\n\n[1] http://google.com\n[2] javascript:alert('malicious code')",
            'On 01/05/2016 10:24 AM, Raoul\nPoilvache wrote:\n\n* Test reply. The suite. *\n\n--\nRaoul Poilvache\n\nTop cool !!!\n\n--\nRaoul Poilvache',
        ]
        for body, expected in zip(bodies, expected_list):
            message = self.env['ir.mail_server'].build_email(
                'john.doe@from.example.com',
                'destinataire@to.example.com',
                body=body,
                subject='Subject',
                subtype='html',
            )
            body_alternative = False
            for part in message.walk():
                if part.get_content_maintype() == 'multipart':
                    continue  # skip container
                if part.get_content_type() == 'text/plain':
                    if not part.get_payload():
                        continue
                    body_alternative = tools.ustr(part.get_content())
                    # remove ending new lines as it just adds noise
                    body_alternative = body_alternative.strip('\n')
            self.assertEqual(body_alternative, expected)

    @users('admin')
    def test_mail_server_get_test_email_from(self):
        """ Test the email used to test the mail server connection. Check
        from_filter parsing / default fallback value. """
        test_server = self.env['ir.mail_server'].create({
            'from_filter': 'example_2.com, example_3.com',
            'name': 'Test Server',
            'smtp_host': 'smtp_host',
            'smtp_encryption': 'none',
        })
        for from_filter, expected_test_email in zip(
            [
                'example_2.com, example_3.com',
                'dummy.com, full_email@example_2.com, dummy2.com',
                # fallback on user's email
                ' ',
                ',',
                False,
            ], [
                'noreply@example_2.com',
                'full_email@example_2.com',
                self.env.user.email,
                self.env.user.email,
                self.env.user.email,
            ],
        ):
            with self.subTest(from_filter=from_filter):
                test_server.from_filter = from_filter
                email_from = test_server._get_test_email_from()
                self.assertEqual(email_from, expected_test_email)

    def test_mail_server_match_from_filter(self):
        """ Test the from_filter field on the "ir.mail_server". """
        # Should match
        tests = [
            ('admin@mail.example.com', 'mail.example.com'),
            ('admin@mail.example.com', 'mail.EXAMPLE.com'),
            ('admin@mail.example.com', 'admin@mail.example.com'),
            ('admin@mail.example.com', False),
            ('"fake@test.mycompany.com" <admin@mail.example.com>', 'mail.example.com'),
            ('"fake@test.mycompany.com" <ADMIN@mail.example.com>', 'mail.example.com'),
            ('"fake@test.mycompany.com" <ADMIN@mail.example.com>', 'test.mycompany.com, mail.example.com, test2.com'),
        ]
        for email, from_filter in tests:
            self.assertTrue(self.env['ir.mail_server']._match_from_filter(email, from_filter))

        # Should not match
        tests = [
            ('admin@mail.example.com', 'test@mail.example.com'),
            ('admin@mail.example.com', 'test.mycompany.com'),
            ('admin@mail.example.com', 'mail.éxample.com'),
            ('admin@mmail.example.com', 'mail.example.com'),
            ('admin@mail.example.com', 'mmail.example.com'),
            ('"admin@mail.example.com" <fake@test.mycompany.com>', 'mail.example.com'),
            ('"fake@test.mycompany.com" <ADMIN@mail.example.com>', 'test.mycompany.com, wrong.mail.example.com, test3.com'),
        ]
        for email, from_filter in tests:
            self.assertFalse(self.env['ir.mail_server']._match_from_filter(email, from_filter))

    @mute_logger('odoo.models.unlink')
    def test_mail_server_priorities(self):
        """ Test if we choose the right mail server to send an email. Simulates
        simple Odoo DB so we have to spoof the FROM otherwise we cannot send
        any email. """
        for email_from, (expected_mail_server, expected_email_from) in zip(
            [
                'specific_user@test.mycompany.com',
                'unknown_email@test.mycompany.com',
                # no notification set, must be forced to spoof the FROM
                '"Test" <test@unknown_domain.com>',
            ], [
                (self.mail_server_user, 'specific_user@test.mycompany.com'),
                (self.mail_server_domain, 'unknown_email@test.mycompany.com'),
                (self.mail_server_default, '"Test" <test@unknown_domain.com>'),
            ],
        ):
            with self.subTest(email_from=email_from):
                mail_server, mail_from = self.env['ir.mail_server']._find_mail_server(email_from=email_from)
                self.assertEqual(mail_server, expected_mail_server)
                self.assertEqual(mail_from, expected_email_from)

    @mute_logger('odoo.models.unlink')
    def test_mail_server_send_email(self):
        """ Test main 'send_email' usage: check mail_server choice based on from
        filters, encapsulation, spoofing. """
        IrMailServer = self.env['ir.mail_server']

        for mail_from, (expected_smtp_from, expected_msg_from, expected_mail_server) in zip(
            [
                'specific_user@test.mycompany.com',
                '"Name" <test@unknown_domain.com>',
                'test@unknown_domain.com',
                '"Name" <unknown_name@test.mycompany.com>'
            ], [
                # A mail server is configured for the email
                ('specific_user@test.mycompany.com', 'specific_user@test.mycompany.com', self.mail_server_user),
                # No mail server are configured for the email address, so it will use the
                # notifications email instead and encapsulate the old email
                ('test@unknown_domain.com', '"Name" <test@unknown_domain.com>', self.mail_server_default),
                # same situation, but the original email has no name part
                ('test@unknown_domain.com', 'test@unknown_domain.com', self.mail_server_default),
                # A mail server is configured for the entire domain name, so we can use the bounce
                # email address because the mail server supports it
                ('unknown_name@test.mycompany.com', '"Name" <unknown_name@test.mycompany.com>', self.mail_server_domain),
            ]
        ):
            # test with and without providing an SMTP session, which should not impact test
            for provide_smtp in [False, True]:
                with self.subTest(mail_from=mail_from, provide_smtp=provide_smtp):
                    with self.mock_smtplib_connection():
                        if provide_smtp:
                            smtp_session = IrMailServer.connect(smtp_from=mail_from)
                            message = self._build_email(mail_from=mail_from)
                            IrMailServer.send_email(message, smtp_session=smtp_session)
                        else:
                            message = self._build_email(mail_from=mail_from)
                            IrMailServer.send_email(message)

                    self.connect_mocked.assert_called_once()
                    self.assertEqual(len(self.emails), 1)
                    self.assertSMTPEmailsSent(
                        smtp_from=expected_smtp_from,
                        message_from=expected_msg_from,
                        mail_server=expected_mail_server,
                    )

        # remove the notification server
        # so <notifications.test@test.mycompany.com> will use the <test.mycompany.com> mail server
        # The mail server configured for the notifications email has been removed
        # but we can still use the mail server configured for test.mycompany.com
        # and so we will be able to use the bounce address
        # because we use the mail server for "test.mycompany.com"
        self.mail_server_notification.unlink()
        for provide_smtp in [False, True]:
            with self.mock_smtplib_connection():
                if provide_smtp:
                    smtp_session = IrMailServer.connect(smtp_from='"Name" <test@unknown_domain.com>')
                    message = self._build_email(mail_from='"Name" <test@unknown_domain.com>')
                    IrMailServer.send_email(message, smtp_session=smtp_session)
                else:
                    message = self._build_email(mail_from='"Name" <test@unknown_domain.com>')
                    IrMailServer.send_email(message)

            self.connect_mocked.assert_called_once()
            self.assertEqual(len(self.emails), 1)
            self.assertSMTPEmailsSent(
                smtp_from='test@unknown_domain.com',
                message_from='"Name" <test@unknown_domain.com>',
                from_filter=False,
            )

    @mute_logger('odoo.models.unlink', 'odoo.addons.base.models.ir_mail_server')
    def test_mail_server_send_email_context_force(self):
        """ Allow to force notifications_email / bounce_address from context
        to allow higher-level apps to send values until end of mail stack
        without hacking too much models. """
        # custom notification / bounce email from context
        context_server = self.env['ir.mail_server'].create({
            'from_filter': 'context.example.com',
            'name': 'context',
            'smtp_host': 'test',
        })
        IrMailServer = self.env["ir.mail_server"].with_context(
            domain_notifications_email="notification@context.example.com",
            domain_bounce_address="bounce@context.example.com",
        )
        with self.mock_smtplib_connection():
            mail_server, smtp_from = IrMailServer._find_mail_server(email_from='"Name" <test@unknown_domain.com>')
            self.assertEqual(mail_server, context_server)
            self.assertEqual(smtp_from, "notification@context.example.com")
            smtp_session = IrMailServer.connect(smtp_from=smtp_from)
            message = self._build_email(mail_from='"Name" <test@unknown_domain.com>')
            IrMailServer.send_email(message, smtp_session=smtp_session)

        self.assertEqual(len(self.emails), 1)
        self.assertSMTPEmailsSent(
            smtp_from="bounce@context.example.com",
            message_from='"Name" <notification@context.example.com>',
            from_filter=context_server.from_filter,
        )

        # miss-configured database, no mail servers from filter
        # match the user / notification email
        self.env['ir.mail_server'].search([]).from_filter = "random.domain"
        with self.mock_smtplib_connection():
            message = self._build_email(mail_from='specific_user@test.com')
            IrMailServer.with_context(domain_notifications_email='test@custom_domain.com').send_email(message)

        self.connect_mocked.assert_called_once()
        self.assertSMTPEmailsSent(
            smtp_from='test@custom_domain.com',
            message_from='"specific_user" <test@custom_domain.com>',
            from_filter='random.domain',
        )

    @mute_logger('odoo.models.unlink')
    def test_mail_server_send_email_IDNA(self):
        """ Test that the mail from / recipient envelop are encoded using IDNA """
        with self.mock_smtplib_connection():
            message = self._build_email(mail_from='test@ééééééé.com')
            self.env['ir.mail_server'].send_email(message)

        self.assertEqual(len(self.emails), 1)
        self.assertSMTPEmailsSent(
            smtp_from='test@xn--9caaaaaaa.com',
            smtp_to_list=['dest@xn--example--i1a.com'],
            message_from='test@=?utf-8?b?w6nDqcOpw6nDqcOpw6k=?=.com',
            from_filter=False,
        )

    @mute_logger('odoo.models.unlink', 'odoo.addons.base.models.ir_mail_server')
    @patch.dict(config.options, {
        "from_filter": "dummy@example.com, test.mycompany.com, dummy2@example.com",
        "smtp_server": "example.com",
    })
    def test_mail_server_config_bin(self):
        """ Test the configuration provided in the odoo-bin arguments. This config
        is used when no mail server exists. Test with and without giving a
        pre-configured SMTP session, should not impact results.

        Also check "mail.default.from_filter" parameter usage that should overwrite
        odoo-bin argument "--from-filter".
        """
        IrMailServer = self.env['ir.mail_server']

        # Remove all mail server so we will use the odoo-bin arguments
        IrMailServer.search([]).unlink()
        self.assertFalse(IrMailServer.search([]))

        for mail_from, (expected_smtp_from, expected_msg_from) in zip(
            [
                # inside "from_filter" domain
                'specific_user@test.mycompany.com',
                '"Formatted Name" <specific_user@test.mycompany.com>',
                '"Formatted Name" <specific_user@test.MYCOMPANY.com>',
                '"Formatted Name" <SPECIFIC_USER@test.mycompany.com>',
                # outside "from_filter" domain
                'test@unknown_domain.com',
                '"Formatted Name" <test@unknown_domain.com>',
            ], [
                # inside "from_filter" domain: no rewriting
                ('specific_user@test.mycompany.com', 'specific_user@test.mycompany.com'),
                ('specific_user@test.mycompany.com', '"Formatted Name" <specific_user@test.mycompany.com>'),
                ('specific_user@test.MYCOMPANY.com', '"Formatted Name" <specific_user@test.MYCOMPANY.com>'),
                ('SPECIFIC_USER@test.mycompany.com', '"Formatted Name" <SPECIFIC_USER@test.mycompany.com>'),
                # outside "from_filter" domain: spoofing, as fallback email can be found
                ('test@unknown_domain.com', 'test@unknown_domain.com'),
                ('test@unknown_domain.com', '"Formatted Name" <test@unknown_domain.com>'),
            ]
        ):
            for provide_smtp in [False, True]:  # providing smtp session should ont impact test
                with self.subTest(mail_from=mail_from, provide_smtp=provide_smtp):
                    with self.mock_smtplib_connection():
                        if provide_smtp:
                            smtp_session = IrMailServer.connect(smtp_from=mail_from)
                            message = self._build_email(mail_from=mail_from)
                            IrMailServer.send_email(message, smtp_session=smtp_session)
                        else:
                            message = self._build_email(mail_from=mail_from)
                            IrMailServer.send_email(message)

                    self.connect_mocked.assert_called_once()
                    self.assertEqual(len(self.emails), 1)
                    self.assertSMTPEmailsSent(
                        smtp_from=expected_smtp_from,
                        message_from=expected_msg_from,
                        from_filter="dummy@example.com, test.mycompany.com, dummy2@example.com",
                    )

        # for from_filter in ICP, overwrite the one from odoo-bin
        self.env['ir.config_parameter'].sudo().set_param('mail.default.from_filter', 'icp.example.com')

        # Use an email in the domain of the config parameter "mail.default.from_filter"
        with self.mock_smtplib_connection():
            message = self._build_email(mail_from='specific_user@icp.example.com')
            IrMailServer.send_email(message)

        self.assertSMTPEmailsSent(
            smtp_from='specific_user@icp.example.com',
            message_from='specific_user@icp.example.com',
            from_filter='icp.example.com',
        )

    @mute_logger('odoo.models.unlink')
    @patch.dict(config.options, {'from_filter': 'fake.com', 'smtp_server': 'cli_example.com'})
    def test_mail_server_config_cli(self):
        """ Test the mail server configuration when the "smtp_authentication" is
        "cli". It should take the configuration from the odoo-bin argument. The
        "from_filter" of the mail server should overwrite the one set in the CLI
        arguments.
        """
        IrMailServer = self.env['ir.mail_server']
        # should be ignored by the mail server
        self.env['ir.config_parameter'].sudo().set_param('mail.default.from_filter', 'fake.com')

        server_other = IrMailServer.create([{
            'name': 'Server No From Filter',
            'smtp_host': 'smtp_host',
            'smtp_encryption': 'none',
            'smtp_authentication': 'cli',
            'from_filter': 'dummy@example.com, cli_example.com, dummy2@example.com',
        }])

        for mail_from, (expected_smtp_from, expected_msg_from, expected_mail_server) in zip(
            [
                # check that the CLI server take the configuration in the odoo-bin argument
                # except the from_filter which is taken on the mail server
                'test@cli_example.com',
                # other mail servers still work
                'specific_user@test.mycompany.com',
            ], [
                ('test@cli_example.com', 'test@cli_example.com', server_other),
                ('specific_user@test.mycompany.com', 'specific_user@test.mycompany.com', self.mail_server_user),
            ],
        ):
            with self.subTest(mail_from=mail_from):
                with self.mock_smtplib_connection():
                    message = self._build_email(mail_from=mail_from)
                    IrMailServer.send_email(message)

                self.assertSMTPEmailsSent(
                    smtp_from=expected_smtp_from,
                    message_from=expected_msg_from,
                    mail_server=expected_mail_server,
                )

```

  File: tests/test_ir_mail_server_smtpd.py
  Content:
```
import contextlib
import logging
import shutil
import smtplib
import socket
import ssl
import unittest
import warnings
from base64 import b64encode
from pathlib import Path
from unittest.mock import patch
from socket import getaddrinfo  # keep a reference on the non-patched function

from odoo.exceptions import UserError
from odoo.tools import file_path, mute_logger
from .common import TransactionCaseWithUserDemo

try:
    import aiosmtpd
    import aiosmtpd.controller
    import aiosmtpd.smtp
    import aiosmtpd.handlers
except ImportError:
    aiosmtpd = None


PASSWORD = 'secretpassword'
_openssl = shutil.which('openssl')
_logger = logging.getLogger(__name__)


def _find_free_local_address():
    """ Get a triple (family, address, port) on which it possible to bind
    a local tcp service. """
    addr = aiosmtpd.controller.get_localhost()  # it returns 127.0.0.1 or ::1
    family = socket.AF_INET if addr == '127.0.0.1' else socket.AF_INET6
    with socket.socket(family, socket.SOCK_STREAM) as sock:
        sock.bind((addr, 0))
        port = sock.getsockname()[1]
    return family, addr, port


def _smtp_authenticate(server, session, enveloppe, mechanism, data):
    """ Callback method used by aiosmtpd to validate a login/password pair. """
    result = aiosmtpd.smtp.AuthResult(success=data.password == PASSWORD.encode())
    _logger.debug("AUTH %s", "successfull" if result.success else "failed")
    return result


class Certificate:
    def __init__(self, key, cert):
        self.key = key and Path(file_path(key, filter_ext='.pem'))
        self.cert = Path(file_path(cert, filter_ext='.pem'))

    def __repr__(self):
        return f"Certificate({self.key=}, {self.cert=})"


# skip when optional dependencies are not found
@unittest.skipUnless(aiosmtpd, "aiosmtpd couldn't be imported")
@unittest.skipUnless(_openssl, "openssl not found in path")
# fail fast for timeout errors
@patch('odoo.addons.base.models.ir_mail_server.SMTP_TIMEOUT', .1)
# prevent the CLI from interfering with the tests
@patch.dict('odoo.tools.config.options', {'smtp_server': ''})
class TestIrMailServerSMTPD(TransactionCaseWithUserDemo):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        # aiosmtpd emits deprecation warnings because it uses its own
        # deprecated features, mute those logs.
        # https://github.com/aio-libs/aiosmtpd/issues/347
        class Session(aiosmtpd.smtp.Session):
            @property
            def login_data(self):
                return self._login_data
            @login_data.setter
            def login_data(self, value):
                self._login_data = value
        patcher = patch('aiosmtpd.smtp.Session', Session)
        patcher.start()
        cls.addClassCleanup(patcher.stop)

        # aiosmtpd emits warnings for some unusual configuration, like
        # requiring AUTH on a clear-text transport. Mute those logs
        # since we also test those unusual configurations.
        warnings.filterwarnings(
            'ignore',
            "Requiring AUTH while not requiring TLS can lead to security vulnerabilities!",
            category=UserWarning
        )
        class CustomFilter(logging.Filter):
            def filter(self, record):
                if record.msg == "auth_required == True but auth_require_tls == False":
                    return False
                if record.msg == "tls_context.verify_mode not in {CERT_NONE, CERT_OPTIONAL}; this might cause client connection problems":
                    return False
                return True
        logging.getLogger('mail.log').addFilter(CustomFilter())

        # decrease aiosmtpd verbosity, odoo INFO = aiosmtpd WARNING
        logging.getLogger('mail.log').setLevel(_logger.getEffectiveLevel() + 10)

        # Get various TLS keys and certificates. CA was used to sign
        # both client and server. self_signed is... self signed.
        cls.ssl_ca, cls.ssl_client, cls.ssl_server, cls.ssl_self_signed = [
            Certificate(None, 'base/tests/ssl/ca.cert.pem'),
            Certificate('base/tests/ssl/client.key.pem',
                        'base/tests/ssl/client.cert.pem'),
            Certificate('base/tests/ssl/server.key.pem',
                        'base/tests/ssl/server.cert.pem'),
            Certificate('base/tests/ssl/self_signed.key.pem',
                        'base/tests/ssl/self_signed.cert.pem'),
        ]

        # Patch the two SMTP client classes into trusting the above CA
        class TEST_SMTP(smtplib.SMTP):
            def starttls(self, *, context):
                if context is None:
                    context = ssl._create_stdlib_context()  # what SMTP_SSL does
                    # context = ssl.create_default_context()  # what it should do
                context.load_verify_locations(cafile=str(cls.ssl_ca.cert))
                super().starttls(context=context)
        class TEST_SMTP_SSL(smtplib.SMTP_SSL):
            def _get_socket(self, *args, **kwargs):
                # self.context = ssl.create_default_context()  # what it should do
                self.context.load_verify_locations(cafile=str(cls.ssl_ca.cert))
                return super()._get_socket(*args, **kwargs)
        patcher = patch('smtplib.SMTP', TEST_SMTP)
        patcher.start()
        cls.addClassCleanup(patcher.stop)
        patcher = patch('smtplib.SMTP_SSL', TEST_SMTP_SSL)
        patcher.start()
        cls.addClassCleanup(patcher.stop)

        # reactivate sending emails during this test suite, make sure
        # NOT TO send emails using another ir.mail_server than the one
        # created in setUp!
        patcher = patch.object(cls.registry['ir.mail_server'], '_is_test_mode')
        mock = patcher.start()
        mock.return_value = False
        cls.addClassCleanup(patcher.stop)

        # fix runbot, docker uses a single ipv4 stack but it gives ::1
        # when resolving "localhost" (so stupid), use the following to
        # force aiosmtpd/odoo to bind/connect to a fixed ipv4 OR ipv6
        # address.
        family, _, cls.port = _find_free_local_address()
        cls.localhost = getaddrinfo('localhost', cls.port, family)
        cls.startClassPatcher(patch('socket.getaddrinfo', cls.getaddrinfo))

    @classmethod
    def getaddrinfo(cls, host, port, *args, **kwargs):
        """
        Resolve both "localhost" and "notlocalhost" on the ip address
        bound by aiosmtpd inside `start_smtpd`.
        """
        if host in ('localhost', 'notlocalhost') and port == cls.port:
            return cls.localhost
        return getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)

    @contextlib.contextmanager
    def start_smtpd(
        self, encryption, ssl_context=None, auth_required=True, stop_on_cleanup=True
    ):
        """
        Start a smtp daemon in a background thread, stop it upon exiting
        the context manager.

        :param encryption: 'none', 'ssl' or 'starttls', the kind of
            server to start.
        :param ssl_context: the ``ssl.SSLContext`` object to use with
            'ssl' or 'starttls'.
        :param auth_required: whether the server enforces password
            authentication or not.
        """
        assert encryption in ('none', 'ssl', 'starttls')
        assert encryption == 'none' or ssl_context

        kwargs = {}
        if encryption == 'starttls':
            # for aiosmtpd.smtp.SMTP
            kwargs.update({
                'require_starttls': True,
                'tls_context': ssl_context,
            })
        elif encryption == 'ssl':
            # for aiosmtpd.controller.InetMixin
            kwargs['ssl_context'] = ssl_context
        if auth_required:
            kwargs['authenticator'] = _smtp_authenticate

        smtpd_thread = aiosmtpd.controller.Controller(
            aiosmtpd.handlers.Debugging(),
            hostname=aiosmtpd.controller.get_localhost(),
            server_hostname='localhost',
            port=self.port,
            auth_required=auth_required,
            auth_require_tls=False,
            enable_SMTPUTF8=True,
            **kwargs,
        )
        try:
            smtpd_thread.start()
            yield smtpd_thread
        finally:
            smtpd_thread.stop()

    @mute_logger('mail.log')
    def test_authentication_certificate_matrix(self):
        """
        Connect to a server that is authenticating users via a TLS
        certificate. Test the various possible configurations (missing
        cert, invalid cert and valid cert) against both a STARTTLS and
        a SSL/TLS SMTP server.
        """
        mail_server = self.env['ir.mail_server'].create({
            'name': 'test smtpd',
            'from_filter': 'localhost',
            'smtp_host': 'localhost',
            'smtp_port': self.port,
            'smtp_authentication': 'login',
            'smtp_user': '',
            'smtp_pass': '',
        })

        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ssl_context.load_cert_chain(self.ssl_server.cert, self.ssl_server.key)
        ssl_context.load_verify_locations(cafile=self.ssl_ca.cert)
        ssl_context.verify_mode = ssl.CERT_REQUIRED

        self_signed_key = b64encode(self.ssl_self_signed.key.read_bytes())
        self_signed_cert = b64encode(self.ssl_self_signed.cert.read_bytes())
        client_key = b64encode(self.ssl_client.key.read_bytes())
        client_cert = b64encode(self.ssl_client.cert.read_bytes())
        matrix = [
            # authentication, name, certificate, private key, error pattern
            ('login', "missing", '', '',
                r"The server has closed the connection unexpectedly\. "
                r"Check configuration served on this port number\.\n "
                r"Connection unexpectedly closed"),
            ('certificate', "self signed", self_signed_cert, self_signed_key,
                r"The server has closed the connection unexpectedly\. "
                r"Check configuration served on this port number\.\n "
                r"Connection unexpectedly closed"),
            ('certificate', "valid client", client_cert, client_key, None),
        ]

        for encryption in ('starttls', 'ssl'):
            mail_server.smtp_encryption = encryption
            with self.start_smtpd(encryption, ssl_context, auth_required=False):
                for authentication, name, certificate, private_key, error_pattern in matrix:
                    with self.subTest(encryption=encryption, certificate=name):
                        mail_server.write({
                            'smtp_authentication': authentication,
                            'smtp_ssl_certificate': certificate,
                            'smtp_ssl_private_key': private_key,
                        })
                        if error_pattern:
                            with self.assertRaises(UserError) as error_capture:
                                mail_server.test_smtp_connection()
                            self.assertRegex(error_capture.exception.args[0], error_pattern)
                        else:
                            mail_server.test_smtp_connection()


    def test_authentication_login_matrix(self):
        """
        Connect to a server that is authenticating users via a login/pwd
        pair. Test the various possible configurations (missing pair,
        invalid pair and valid pair) against both a SMTP server without
        encryption, a STARTTLS and a SSL/TLS SMTP server.
        """
        mail_server = self.env['ir.mail_server'].create({
            'name': 'test smtpd',
            'from_filter': 'localhost',
            'smtp_host': 'localhost',
            'smtp_port': self.port,
            'smtp_authentication': 'login',
            'smtp_user': '',
            'smtp_pass': '',
        })

        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ssl_context.load_cert_chain(self.ssl_server.cert, self.ssl_server.key)

        MISSING = ''
        INVALID = 'bad password'
        matrix = [
            # auth_required, password, error_pattern
            (False, MISSING, None),
            (True, MISSING,
                r"The server refused the sender address \(noreply@localhost\) "
                r"with error b'5\.7\.0 Authentication required'"),
            (True, INVALID,
                r"The server has closed the connection unexpectedly\. "
                r"Check configuration served on this port number\.\n "
                r"Connection unexpectedly closed:.* timed out"),
            (True, PASSWORD, None),
        ]

        for encryption in ('none', 'starttls', 'ssl'):
            mail_server.smtp_encryption = encryption
            for auth_required, password, error_pattern in matrix:
                mail_server.smtp_user = password and self.user_demo.email
                mail_server.smtp_pass = password
                with self.subTest(encryption=encryption,
                                  auth_required=auth_required,
                                  password=password):
                    with self.start_smtpd(encryption, ssl_context, auth_required):
                        if error_pattern:
                            with self.assertRaises(UserError) as capture:
                                mail_server.test_smtp_connection()
                            self.assertRegex(capture.exception.args[0], error_pattern)
                        else:
                            mail_server.test_smtp_connection()

    @mute_logger('mail.log')
    def test_encryption_matrix(self):
        """
        Connect to a server on a different encryption configuration than
        the server is configured. Verify that it crashes with a good
        error message.
        """
        mail_server = self.env['ir.mail_server'].create({
            'name': 'test smtpd',
            'from_filter': 'localhost',
            'smtp_host': 'localhost',
            'smtp_port': self.port,
            'smtp_authentication': 'login',
            'smtp_user': '',
            'smtp_pass': '',
        })

        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ssl_context.load_cert_chain(self.ssl_server.cert, self.ssl_server.key)

        matrix = [
            # client, server, error_pattern
            ('none', 'ssl',
                r"The server has closed the connection unexpectedly\. "
                r"Check configuration served on this port number\.\n "
                r"Connection unexpectedly closed: timed out"),
            ('none', 'starttls',
                r"The server refused the sender address \(noreply@localhost\) with error "
                r"b'Must issue a STARTTLS command first'"),
            ('starttls', 'none',
                r"An option is not supported by the server:\n "
                r"STARTTLS extension not supported by server\."),
            ('starttls', 'ssl',
                r"The server has closed the connection unexpectedly\. "
                r"Check configuration served on this port number\.\n "
                r"Connection unexpectedly closed: timed out"),
            ('ssl', 'none',
                r"An SSL exception occurred\. "
                r"Check connection security type\.\n "
                r".*?wrong version number"),
            ('ssl', 'starttls',
                r"An SSL exception occurred\. "
                r"Check connection security type\.\n "
                r".*?wrong version number"),
        ]

        for client_encryption, server_encryption, error_pattern in matrix:
            with self.subTest(server_encryption=server_encryption,
                              client_encryption=client_encryption):
                mail_server.smtp_encryption = client_encryption
                with self.start_smtpd(server_encryption, ssl_context, auth_required=False):
                    with self.assertRaises(UserError) as capture:
                        mail_server.test_smtp_connection()
                    self.assertRegex(capture.exception.args[0], error_pattern)

    def test_man_in_the_middle_matrix(self):
        """
        Simulate that a pirate was successful at intercepting the live
        traffic in between the Odoo server and the legitimate SMTP
        server.
        """
        mail_server = self.env['ir.mail_server'].create({
            'name': 'test smtpd',
            'from_filter': 'localhost',
            'smtp_host': 'localhost',
            'smtp_port': self.port,
            'smtp_authentication': 'login',
            'smtp_user': self.user_demo.email,
            'smtp_pass': PASSWORD,
            'smtp_ssl_certificate': b64encode(self.ssl_client.cert.read_bytes()),
            'smtp_ssl_private_key': b64encode(self.ssl_client.key.read_bytes()),
        })

        cert_good = self.ssl_server
        cert_bad = self.ssl_self_signed
        host_good = 'localhost'
        host_bad = 'notlocalhost'

        # for now it doesn't raise any error for bad cert/host
        matrix = [
            # authentication, certificate, hostname, error_pattern
            ('login', cert_bad, host_good, None),
            ('login', cert_good, host_bad, None),
            ('certificate', cert_bad, host_good, None),
            ('certificate', cert_good, host_bad, None),
        ]

        for encryption in ('starttls', 'ssl'):
            for authentication, certificate, hostname, error_pattern in matrix:
                mail_server.smtp_host = hostname
                mail_server.smtp_authentication = authentication
                mail_server.smtp_encryption = encryption
                with self.subTest(
                    encryption=encryption,
                    authentication=authentication,
                    cert_good=certificate == cert_good,
                    host_good=hostname == host_good,
                ):
                    mitm_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
                    mitm_context.load_cert_chain(certificate.cert, certificate.key)
                    auth_required = authentication == 'login'
                    with self.start_smtpd(encryption, mitm_context, auth_required):
                        if error_pattern:
                            with self.assertRaises(UserError) as capture:
                                mail_server.test_smtp_connection()
                            self.assertRegex(capture.exception.args[0], error_pattern)
                        else:
                            mail_server.test_smtp_connection()

```

  File: tests/test_ir_model.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from psycopg2 import IntegrityError

from odoo.exceptions import ValidationError
from odoo.tests.common import Form, TransactionCase, HttpCase, tagged
from odoo.tools import mute_logger
from odoo import Command


class TestXMLID(TransactionCase):
    def get_data(self, xml_id):
        """ Return the 'ir.model.data' record corresponding to ``xml_id``. """
        module, suffix = xml_id.split('.', 1)
        domain = [('module', '=', module), ('name', '=', suffix)]
        return self.env['ir.model.data'].search(domain)

    def test_create(self):
        model = self.env['res.partner.category']
        xml_id = 'test_convert.category_foo'

        # create category (flag 'noupdate' should be False by default)
        data = dict(xml_id=xml_id, values={'name': 'Foo'})
        category = model._load_records([data])
        self.assertEqual(category, self.env.ref(xml_id, raise_if_not_found=False))
        self.assertEqual(category.name, 'Foo')
        self.assertEqual(self.get_data(xml_id).noupdate, False)

        # update category
        data = dict(xml_id=xml_id, values={'name': 'Bar'})
        category1 = model._load_records([data], update=True)
        self.assertEqual(category, category1)
        self.assertEqual(category.name, 'Bar')
        self.assertEqual(self.get_data(xml_id).noupdate, False)

        # update category
        data = dict(xml_id=xml_id, values={'name': 'Baz'}, noupdate=True)
        category2 = model._load_records([data], update=True)
        self.assertEqual(category, category2)
        self.assertEqual(category.name, 'Baz')
        self.assertEqual(self.get_data(xml_id).noupdate, False)

    def test_create_noupdate(self):
        model = self.env['res.partner.category']
        xml_id = 'test_convert.category_foo'

        # create category
        data = dict(xml_id=xml_id, values={'name': 'Foo'}, noupdate=True)
        category = model._load_records([data])
        self.assertEqual(category, self.env.ref(xml_id, raise_if_not_found=False))
        self.assertEqual(category.name, 'Foo')
        self.assertEqual(self.get_data(xml_id).noupdate, True)

        # update category
        data = dict(xml_id=xml_id, values={'name': 'Bar'}, noupdate=False)
        category1 = model._load_records([data], update=True)
        self.assertEqual(category, category1)
        self.assertEqual(category.name, 'Foo')
        self.assertEqual(self.get_data(xml_id).noupdate, True)

        # update category
        data = dict(xml_id=xml_id, values={'name': 'Baz'}, noupdate=True)
        category2 = model._load_records([data], update=True)
        self.assertEqual(category, category2)
        self.assertEqual(category.name, 'Foo')
        self.assertEqual(self.get_data(xml_id).noupdate, True)

    def test_create_noupdate_multi(self):
        model = self.env['res.partner.category']
        data_list = [
            dict(xml_id='test_convert.category_foo', values={'name': 'Foo'}, noupdate=True),
            dict(xml_id='test_convert.category_bar', values={'name': 'Bar'}, noupdate=True),
        ]

        # create category
        categories = model._load_records(data_list)
        foo = self.env.ref('test_convert.category_foo')
        bar = self.env.ref('test_convert.category_bar')
        self.assertEqual(categories, foo + bar)
        self.assertEqual(foo.name, 'Foo')
        self.assertEqual(bar.name, 'Bar')

        # check data
        self.assertEqual(self.get_data('test_convert.category_foo').noupdate, True)
        self.assertEqual(self.get_data('test_convert.category_bar').noupdate, True)

    def test_create_order(self):
        model = self.env['res.partner.category']
        data_list = [
            dict(xml_id='test_convert.category_foo', values={'name': 'Foo'}),
            dict(xml_id='test_convert.category_bar', values={'name': 'Bar'}, noupdate=True),
            dict(xml_id='test_convert.category_baz', values={'name': 'Baz'}),
        ]

        # create categories
        foo = model._load_records([data_list[0]])
        bar = model._load_records([data_list[1]])
        baz = model._load_records([data_list[2]])
        self.assertEqual(foo.name, 'Foo')
        self.assertEqual(bar.name, 'Bar')
        self.assertEqual(baz.name, 'Baz')

        # update them, and check the order of result
        for data in data_list:
            data['values']['name'] += 'X'
        cats = model._load_records(data_list, update=True)
        self.assertEqual(list(cats), [foo, bar, baz])
        self.assertEqual(foo.name, 'FooX')
        self.assertEqual(bar.name, 'Bar')
        self.assertEqual(baz.name, 'BazX')

    def test_create_inherits(self):
        model = self.env['res.users']
        xml_id = 'test_convert.user_foo'
        par_xml_id = xml_id + '_res_partner'

        # create user
        user = model._load_records([dict(xml_id=xml_id, values={'name': 'Foo', 'login': 'foo'})])
        self.assertEqual(user, self.env.ref(xml_id, raise_if_not_found=False))
        self.assertEqual(user.partner_id, self.env.ref(par_xml_id, raise_if_not_found=False))
        self.assertEqual(user.name, 'Foo')
        self.assertEqual(user.login, 'foo')

    def test_recreate(self):
        model = self.env['res.partner.category']
        xml_id = 'test_convert.category_foo'
        data = dict(xml_id=xml_id, values={'name': 'Foo'})

        # create category
        category = model._load_records([data])
        self.assertEqual(category, self.env.ref(xml_id, raise_if_not_found=False))
        self.assertEqual(category.name, 'Foo')

        # suppress category
        category.unlink()
        self.assertFalse(self.env.ref(xml_id, raise_if_not_found=False))

        # update category, this should recreate it
        category = model._load_records([data], update=True)
        self.assertEqual(category, self.env.ref(xml_id, raise_if_not_found=False))
        self.assertEqual(category.name, 'Foo')

    def test_create_xmlids(self):
        # create users and assign them xml ids
        foo, bar = self.env['res.users']._load_records([{
            'xml_id': 'test_convert.foo',
            'values': {'name': 'Foo', 'login': 'foo'},
            'noupdate': True,
        }, {
            'xml_id': 'test_convert.bar',
            'values': {'name': 'Bar', 'login': 'bar'},
            'noupdate': True,
        }])

        self.assertEqual(foo, self.env.ref('test_convert.foo', raise_if_not_found=False))
        self.assertEqual(bar, self.env.ref('test_convert.bar', raise_if_not_found=False))

        self.assertEqual(foo.partner_id, self.env.ref('test_convert.foo_res_partner', raise_if_not_found=False))
        self.assertEqual(bar.partner_id, self.env.ref('test_convert.bar_res_partner', raise_if_not_found=False))

        self.assertEqual(self.get_data('test_convert.foo').noupdate, True)
        self.assertEqual(self.get_data('test_convert.bar').noupdate, True)

    @mute_logger('odoo.sql_db', 'odoo.addons.base.models.ir_model')
    def test_create_external_id_with_space(self):
        model = self.env['res.partner.category']
        data_list = [{
            'xml_id': 'test_convert.category_with space',
            'values': {'name': 'Bar'},
        }]
        with self.assertRaisesRegex(IntegrityError, 'ir_model_data_name_nospaces'):
            model._load_records(data_list)

    def test_update_xmlid(self):
        def assert_xmlid(xmlid, value, message):
            expected_values = (value._name, value.id)
            with self.assertQueryCount(0):
                self.assertEqual(self.env['ir.model.data']._xmlid_lookup(xmlid), expected_values, message)
            module, name = xmlid.split('.')
            self.env.cr.execute("SELECT model, res_id FROM ir_model_data where module=%s and name=%s", [module, name])
            self.assertEqual((value._name, value.id), self.env.cr.fetchone(), message)

        xmlid = 'base.test_xmlid'
        records = self.env['ir.model.data'].search([], limit=6)
        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[0]},
            ])
        assert_xmlid(xmlid, records[0], f'The xmlid {xmlid} should have been created with record {records[0]}')

        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[1]},
            ], update=True)
        assert_xmlid(xmlid, records[1], f'The xmlid {xmlid} should have been updated with record {records[1]}')

        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[2]},
            ])
        assert_xmlid(xmlid, records[2], f'The xmlid {xmlid} should have been updated with record {records[1]}')

        # noupdate case
        # note: this part is mainly there to avoid breaking the current behaviour, not asserting that it makes sence
        xmlid = 'base.test_xmlid_noupdates'
        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[3], 'noupdate':True}, # record created as noupdate
            ])

        assert_xmlid(xmlid, records[3], f'The xmlid {xmlid} should have been created for record {records[2]}')

        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[4]},
            ], update=True)
        assert_xmlid(xmlid, records[3], f'The xmlid {xmlid} should not have been updated (update mode)')

        with self.assertQueryCount(1):
            self.env['ir.model.data']._update_xmlids([
                {'xml_id': xmlid, 'record': records[5]},
            ])
        assert_xmlid(xmlid, records[5], f'The xmlid {xmlid} should have been updated with record (not an update) {records[1]}')

class TestIrModel(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

        # The test mode is necessary in this case.  After each test, we call
        # registry.reset_changes(), which opens a new cursor to retrieve custom
        # models and fields.  A regular cursor would correspond to the state of
        # the database before setUpClass(), which is not correct.  Instead, a
        # test cursor will correspond to the state of the database of cls.cr at
        # that point, i.e., before the call to setUp().
        cls.registry.enter_test_mode(cls.cr)
        cls.addClassCleanup(cls.registry.leave_test_mode)

        # model and records for banana stages
        cls.env['ir.model'].create({
            'name': 'Banana Ripeness',
            'model': 'x_banana_ripeness',
            'field_id': [
                Command.create({'name': 'x_name', 'ttype': 'char', 'field_description': 'Name'}),
            ]
        })
        # stage values are pairs (id, display_name)
        cls.ripeness_green = cls.env['x_banana_ripeness'].name_create('Green')
        cls.ripeness_okay = cls.env['x_banana_ripeness'].name_create('Okay, I guess?')
        cls.ripeness_gone = cls.env['x_banana_ripeness'].name_create('Walked away on its own')

        # model and records for bananas
        cls.bananas_model = cls.env['ir.model'].create({
            'name': 'Bananas',
            'model': 'x_bananas',
            'field_id': [
                Command.create({'name': 'x_name', 'ttype': 'char', 'field_description': 'Name'}),
                Command.create({'name': 'x_length', 'ttype': 'float', 'field_description': 'Length'}),
                Command.create({'name': 'x_color', 'ttype': 'integer', 'field_description': 'Color'}),
                Command.create({'name': 'x_ripeness_id', 'ttype': 'many2one',
                        'field_description': 'Ripeness','relation': 'x_banana_ripeness',
                        'group_expand': True})
            ]
        })
        # add non-stored field that is not valid in order
        cls.env['ir.model.fields'].create({
            'name': 'x_is_yellow',
            'field_description': 'Is the banana yellow?',
            'ttype': 'boolean',
            'model_id': cls.bananas_model.id,
            'store': False,
            'depends': 'x_color',
            'compute': "for banana in self:\n    banana['x_is_yellow'] = banana.x_color == 9"
        })
        # default stage is ripeness_green
        cls.env['ir.default'].set('x_bananas', 'x_ripeness_id', cls.ripeness_green[0])
        cls.env['x_bananas'].create([{
            'x_name': 'Banana #1',
            'x_length': 3.14159,
            'x_color': 9,
        }, {
            'x_name': 'Banana #2',
            'x_length': 0,
            'x_color': 6,
        }, {
            'x_name': 'Banana #3',
            'x_length': 10,
            'x_color': 6,
        }])

    def setUp(self):
        # this cleanup is necessary after each test, and must be done last
        self.addCleanup(self.registry.reset_changes)
        super().setUp()

    def test_model_order_constraint(self):
        """Check that the order constraint is properly enforced."""
        VALID_ORDERS = ['id', 'id desc', 'id asc, x_length', 'x_color, x_length, create_uid']
        for order in VALID_ORDERS:
            self.bananas_model.order = order

        INVALID_ORDERS = ['', 'x_wat', 'id esc', 'create_uid,', 'id, x_is_yellow']
        for order in INVALID_ORDERS:
            with self.assertRaises(ValidationError), self.cr.savepoint():
                self.bananas_model.order = order

        # check that the constraint is checked at model creation
        fields_value = [
            Command.create({'name': 'x_name', 'ttype': 'char', 'field_description': 'Name'}),
            Command.create({'name': 'x_length', 'ttype': 'float', 'field_description': 'Length'}),
            Command.create({'name': 'x_color', 'ttype': 'integer', 'field_description': 'Color'}),
        ]
        self.env['ir.model'].create({
            'name': 'MegaBananas',
            'model': 'x_mega_bananas',
            'order': 'x_name asc, id desc',         # valid order
            'field_id': fields_value,
        })
        with self.assertRaises(ValidationError):
            self.env['ir.model'].create({
                'name': 'GigaBananas',
                'model': 'x_giga_bananas',
                'order': 'x_name asc, x_wat',       # invalid order
                'field_id': fields_value,
            })

    def test_model_order_search(self):
        """Check that custom orders are applied when querying a model."""
        ORDERS = {
            'id asc': ['Banana #1', 'Banana #2', 'Banana #3'],
            'id desc': ['Banana #3', 'Banana #2', 'Banana #1'],
            'x_color asc, id asc': ['Banana #2', 'Banana #3', 'Banana #1'],
            'x_color asc, id desc': ['Banana #3', 'Banana #2', 'Banana #1'],
            'x_length asc, id': ['Banana #2', 'Banana #1', 'Banana #3'],
        }
        for order, names in ORDERS.items():
            self.bananas_model.order = order
            self.assertEqual(self.env['x_bananas']._order, order)

            bananas = self.env['x_bananas'].search([])
            self.assertEqual(bananas.mapped('x_name'), names, 'failed to order by %s' % order)

    def test_group_expansion(self):
        """Check that the basic custom group expansion works."""
        groups = self.env['x_bananas'].read_group(domain=[],
                                                  fields=['x_ripeness_id'],
                                                  groupby=['x_ripeness_id'])
        expected = [{
            'x_ripeness_id': self.ripeness_green,
            'x_ripeness_id_count': 3,
            '__domain': [('x_ripeness_id', '=', self.ripeness_green[0])],
        }, {
            'x_ripeness_id': self.ripeness_okay,
            'x_ripeness_id_count': 0,
            '__domain': [('x_ripeness_id', '=', self.ripeness_okay[0])],
        }, {
            'x_ripeness_id': self.ripeness_gone,
            'x_ripeness_id_count': 0,
            '__domain': [('x_ripeness_id', '=', self.ripeness_gone[0])],
        }]
        self.assertEqual(groups, expected, 'should include 2 empty ripeness stages')

    def test_rec_name_deletion(self):
        """Check that deleting 'x_name' does not crash."""
        record = self.env['x_bananas'].create({'x_name': "Ifan Ben-Mezd"})
        self.assertEqual(record._rec_name, 'x_name')
        self.assertEqual(self.registry.field_depends[type(record).display_name], ('x_name',))
        self.assertEqual(record.display_name, "Ifan Ben-Mezd")

        # unlinking x_name should fixup _rec_name and display_name
        self.env['ir.model.fields']._get('x_bananas', 'x_name').unlink()
        record = self.env['x_bananas'].browse(record.id)
        self.assertEqual(record._rec_name, None)
        self.assertEqual(self.registry.field_depends[type(record).display_name], ())
        self.assertEqual(record.display_name, f"x_bananas,{record.id}")

    def test_monetary_currency_field(self):
        fields_value = [
            Command.create({'name': 'x_monetary', 'ttype': 'monetary', 'field_description': 'Monetary', 'currency_field': 'test'}),
        ]
        with self.assertRaises(ValidationError):
            self.env['ir.model'].create({
                'name': 'Paper Company Model',
                'model': 'x_paper_model',
                'field_id': fields_value,
            })

        fields_value = [
            Command.create({'name': 'x_monetary', 'ttype': 'monetary', 'field_description': 'Monetary', 'currency_field': 'x_falsy_currency'}),
            Command.create({'name': 'x_falsy_currency', 'ttype': 'one2many', 'field_description': 'Currency', 'relation': 'res.currency'}),
        ]
        with self.assertRaises(ValidationError):
            self.env['ir.model'].create({
                'name': 'Paper Company Model',
                'model': 'x_paper_model',
                'field_id': fields_value,
            })

        fields_value = [
            Command.create({'name': 'x_monetary', 'ttype': 'monetary', 'field_description': 'Monetary', 'currency_field': 'x_falsy_currency'}),
            Command.create({'name': 'x_falsy_currency', 'ttype': 'many2one', 'field_description': 'Currency', 'relation': 'res.partner'}),
        ]
        with self.assertRaises(ValidationError):
            self.env['ir.model'].create({
                'name': 'Paper Company Model',
                'model': 'x_paper_model',
                'field_id': fields_value,
            })

        fields_value = [
            Command.create({'name': 'x_monetary', 'ttype': 'monetary', 'field_description': 'Monetary', 'currency_field': 'x_good_currency'}),
            Command.create({'name': 'x_good_currency', 'ttype': 'many2one', 'field_description': 'Currency', 'relation': 'res.currency'}),
        ]
        model = self.env['ir.model'].create({
            'name': 'Paper Company Model',
            'model': 'x_paper_model',
            'field_id': fields_value,
        })
        monetary_field = model.field_id.search([['name', 'ilike', 'x_monetary']])
        self.assertEqual(len(monetary_field), 1,
                         "Should have the monetary field in the created ir.model")
        self.assertEqual(monetary_field.currency_field, "x_good_currency",
                         "The currency field in monetary should have x_good_currency as name")

@tagged('-at_install', 'post_install')
class TestIrModelEdition(TransactionCase):
    def test_new_ir_model_fields_related(self):
        """Check that related field are handled correctly on new field"""
        model = self.env['ir.model'].create({
            'name': 'Bananas',
            'model': 'x_bananas'
        })
        with self.debug_mode():
            form = Form(self.env['ir.model.fields'].with_context(default_model_id=model.id))
            form.related = 'id'
            self.assertEqual(form.ttype, 'integer')

    def test_delete_manual_models_with_base_fields(self):
        model = self.env["ir.model"].create({
            "model": "x_test_base_delete",
            "name": "test base delete",
            "field_id": [
                Command.create({
                    "name": "x_my_field",
                    "ttype": "char",
                }),
                Command.create({
                  "name": "active",
                  "ttype": "boolean",
                  "state": "base",
                })
            ]
        })
        model2 = self.env["ir.model"].create({
            "model": "x_test_base_delete2",
            "name": "test base delete2",
            "field_id": [
                Command.create({
                    "name": "x_my_field2",
                    "ttype": "char",
                }),
                Command.create({
                  "name": "active",
                  "ttype": "boolean",
                  "state": "base",
                })
            ]
        })
        self.assertTrue(model.exists())
        self.assertTrue(model2.exists())

        self.env["ir.model"].browse(model.ids + model2.ids).unlink()
        self.assertFalse(model.exists())
        self.assertFalse(model2.exists())

@tagged('test_eval_context')
class TestEvalContext(TransactionCase):

    def test_module_usage(self):
        self.env['ir.model.fields'].create({
            'name': 'x_foo_bar_baz',
            'model_id': self.env['ir.model'].search([('model', '=', 'res.partner')]).id,
            'field_description': 'foo',
            'ttype': 'integer',
            'store': False,
            'depends': 'name',
            'compute': ("time.time()\ndatetime.datetime.now()\n"
                        "dateutil.relativedelta.relativedelta(hours=1)")
        })
        self.env['res.partner'].create({'name': 'foo'}).x_foo_bar_baz

@tagged('-at_install', 'post_install')
class TestIrModelFieldsTranslation(HttpCase):
    def test_ir_model_fields_translation(self):
        # If not enabled (like in demo data), landing on res.config will try
        # to disable module_sale_quotation_builder and raise an warning
        group_order_template = self.env.ref('sale_management.group_sale_order_template', raise_if_not_found=False)
        if group_order_template:
            self.env.ref('base.group_user').write({"implied_ids": [(4, group_order_template.id)]})

        # modify en_US translation
        field = self.env['ir.model.fields'].search([('model_id.model', '=', 'res.users'), ('name', '=', 'login')])
        self.assertEqual(field.with_context(lang='en_US').field_description, 'Login')
        # check the name column of res.users is displayed as 'Login'
        self.start_tour("/web", 'ir_model_fields_translation_en_tour', login="admin")
        field.update_field_translations('field_description', {'en_US': 'Login2'})
        # check the name column of res.users is displayed as 'Login2'
        self.start_tour("/web", 'ir_model_fields_translation_en_tour2', login="admin")

        # modify fr_FR translation
        self.env['res.lang']._activate_lang('fr_FR')
        field = self.env['ir.model.fields'].search([('model_id.model', '=', 'res.users'), ('name', '=', 'login')])
        field.update_field_translations('field_description', {'fr_FR': 'Identifiant'})
        self.assertEqual(field.with_context(lang='fr_FR').field_description, 'Identifiant')
        admin = self.env['res.users'].search([('login', '=', 'admin')], limit=1)
        admin.lang = 'fr_FR'
        # check the name column of res.users is displayed as 'Identifiant'
        self.start_tour("/web", 'ir_model_fields_translation_fr_tour', login="admin")
        field.update_field_translations('field_description', {'fr_FR': 'Identifiant2'})
        # check the name column of res.users is displayed as 'Identifiant2'
        self.start_tour("/web", 'ir_model_fields_translation_fr_tour2', login="admin")

```

  File: tests/test_ir_module.py
  Content:
```
from odoo.tests.common import TransactionCase
from odoo.tools import mute_logger


class IrModuleCase(TransactionCase):
    @mute_logger("odoo.modules.module")
    def test_missing_module_icon(self):
        module = self.env["ir.module.module"].create({"name": "missing"})
        base = self.env["ir.module.module"].search([("name", "=", "base")])
        self.assertEqual(base.icon_image, module.icon_image)

    @mute_logger("odoo.modules.module")
    def test_new_module_icon(self):
        module = self.env["ir.module.module"].new({"name": "missing"})
        self.assertFalse(module.icon_image)

    @mute_logger("odoo.modules.module")
    def test_module_wrong_icon(self):
        module = self.env["ir.module.module"].create(
            {"name": "wrong_icon", "icon": "/not/valid.png"}
        )
        self.assertFalse(module.icon_image)

```

  File: tests/test_ir_module_category.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo.exceptions import ValidationError
from odoo.tests.common import TransactionCase

class TestModuleCategory(TransactionCase):

    def test_parent_circular_dependencies(self):
        Cats = self.env['ir.module.category']

        def create(name, **kw):
            return Cats.create(dict(kw, name=name))

        category_a = create('A', parent_id=False)
        category_b = create('B', parent_id=category_a.id)
        category_c = create('C', parent_id=category_b.id)

        with self.assertRaises(ValidationError):
            category_a.write({'parent_id': category_c.id})
        with self.assertRaises(ValidationError):
            category_b.write({'parent_id': category_b.id})

```

  File: tests/test_ir_sequence.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from contextlib import contextmanager

import psycopg2
import psycopg2.errorcodes

import odoo
from odoo.exceptions import UserError
from odoo.tests import common
from odoo.tests.common import BaseCase
from odoo.tools.misc import mute_logger

ADMIN_USER_ID = common.ADMIN_USER_ID

@contextmanager
def environment():
    """ Return an environment with a new cursor for the current database; the
        cursor is committed and closed after the context block.
    """
    registry = odoo.registry(common.get_db_name())
    with registry.cursor() as cr:
        yield odoo.api.Environment(cr, ADMIN_USER_ID, {})


def drop_sequence(code):
    with environment() as env:
        seq = env['ir.sequence'].search([('code', '=', code)])
        seq.unlink()


class TestIrSequenceStandard(BaseCase):
    """ A few tests for a 'Standard' (i.e. PostgreSQL) sequence. """

    def test_ir_sequence_create(self):
        """ Try to create a sequence object. """
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type',
                'name': 'Test sequence',
            })
            self.assertTrue(seq)

    def test_ir_sequence_search(self):
        """ Try a search. """
        with environment() as env:
            seqs = env['ir.sequence'].search([])
            self.assertTrue(seqs)

    def test_ir_sequence_draw(self):
        """ Try to draw a number. """
        with environment() as env:
            n = env['ir.sequence'].next_by_code('test_sequence_type')
            self.assertTrue(n)

    def test_ir_sequence_draw_twice(self):
        """ Try to draw a number from two transactions. """
        with environment() as env0:
            with environment() as env1:
                n0 = env0['ir.sequence'].next_by_code('test_sequence_type')
                self.assertTrue(n0)
                n1 = env1['ir.sequence'].next_by_code('test_sequence_type')
                self.assertTrue(n1)

    @classmethod
    def tearDownClass(cls):
        drop_sequence('test_sequence_type')


class TestIrSequenceNoGap(BaseCase):
    """ Copy of the previous tests for a 'No gap' sequence. """

    def test_ir_sequence_create_no_gap(self):
        """ Try to create a sequence object. """
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_2',
                'name': 'Test sequence',
                'implementation': 'no_gap',
            })
            self.assertTrue(seq)

    def test_ir_sequence_draw_no_gap(self):
        """ Try to draw a number. """
        with environment() as env:
            n = env['ir.sequence'].next_by_code('test_sequence_type_2')
            self.assertTrue(n)

    @mute_logger('odoo.sql_db')
    def test_ir_sequence_draw_twice_no_gap(self):
        """ Try to draw a number from two transactions.
        This is expected to not work.
        """
        with environment() as env0:
            with environment() as env1:
                # NOTE: The error has to be an OperationalError
                # s.t. the automatic request retry (service/model.py) works.
                with self.assertRaises(psycopg2.OperationalError) as e:
                    n0 = env0['ir.sequence'].next_by_code('test_sequence_type_2')
                    self.assertTrue(n0)
                    n1 = env1['ir.sequence'].next_by_code('test_sequence_type_2')
                self.assertEqual(e.exception.pgcode, psycopg2.errorcodes.LOCK_NOT_AVAILABLE, msg="postgresql returned an incorrect errcode")

    @classmethod
    def tearDownClass(cls):
        drop_sequence('test_sequence_type_2')


class TestIrSequenceChangeImplementation(BaseCase):
    """ Create sequence objects and change their ``implementation`` field. """

    def test_ir_sequence_1_create(self):
        """ Try to create a sequence object. """
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_3',
                'name': 'Test sequence',
            })
            self.assertTrue(seq)
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_4',
                'name': 'Test sequence',
                'implementation': 'no_gap',
            })
            self.assertTrue(seq)

    def test_ir_sequence_2_write(self):
        with environment() as env:
            domain = [('code', 'in', ['test_sequence_type_3', 'test_sequence_type_4'])]
            seqs = env['ir.sequence'].search(domain)
            seqs.write({'implementation': 'standard'})
            seqs.write({'implementation': 'no_gap'})

    def test_ir_sequence_3_unlink(self):
        with environment() as env:
            domain = [('code', 'in', ['test_sequence_type_3', 'test_sequence_type_4'])]
            seqs = env['ir.sequence'].search(domain)
            seqs.unlink()

    @classmethod
    def tearDownClass(cls):
        drop_sequence('test_sequence_type_3')
        drop_sequence('test_sequence_type_4')


class TestIrSequenceGenerate(BaseCase):
    """ Create sequence objects and generate some values. """

    def test_ir_sequence_create(self):
        """ Try to create a sequence object. """
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_5',
                'name': 'Test sequence',
            })
            self.assertTrue(seq)

        with environment() as env:
            for i in range(1, 10):
                n = env['ir.sequence'].next_by_code('test_sequence_type_5')
                self.assertEqual(n, str(i))

    def test_ir_sequence_create_no_gap(self):
        """ Try to create a sequence object. """
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_6',
                'name': 'Test sequence',
                'implementation': 'no_gap',
            })
            self.assertTrue(seq)

        with environment() as env:
            for i in range(1, 10):
                n = env['ir.sequence'].next_by_code('test_sequence_type_6')
                self.assertEqual(n, str(i))

    def test_ir_sequence_prefix(self):
        """ test whether the raise a user error for an invalid sequence """

        # try to create a sequence with invalid prefix
        with environment() as env:
            seq = env['ir.sequence'].create({
                'code': 'test_sequence_type_7',
                'name': 'Test sequence',
                'prefix': '%u',
                'suffix': '',
            })
            self.assertTrue(seq)

            with self.assertRaises(UserError):
                env['ir.sequence'].next_by_code('test_sequence_type_7')

    @classmethod
    def tearDownClass(cls):
        drop_sequence('test_sequence_type_5')
        drop_sequence('test_sequence_type_6')


class TestIrSequenceInit(common.TransactionCase):

    def test_00(self):
        """ test whether the read method returns the right number_next value
            (from postgreSQL sequence and not ir_sequence value)
        """
        # first creation of sequence (normal)
        seq = self.env['ir.sequence'].create({
            'number_next': 1,
            'company_id': 1,
            'padding': 4,
            'number_increment': 1,
            'implementation': 'standard',
            'name': 'test-sequence-00',
        })
        # Call next() 4 times, and check the last returned value
        seq.next_by_id()
        seq.next_by_id()
        seq.next_by_id()
        n = seq.next_by_id()
        self.assertEqual(n, "0004", 'The actual sequence value must be 4. reading : %s' % n)
        # reset sequence to 1 by write()
        seq.write({'number_next': 1})
        # Read the value of the current sequence
        n = seq.next_by_id()
        self.assertEqual(n, "0001", 'The actual sequence value must be 1. reading : %s' % n)

```

  File: tests/test_ir_sequence_date_range.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from datetime import date

from odoo.tests.common import SingleTransactionCase
from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DATE_FORMAT


class TestIrSequenceDateRangeStandard(SingleTransactionCase):
    """ A few tests for a 'Standard' (i.e. PostgreSQL) sequence. """

    def test_ir_sequence_date_range_1_create(self):
        """ Try to create a sequence object with date ranges enabled. """
        seq = self.env['ir.sequence'].create({
            'code': 'test_sequence_date_range',
            'name': 'Test sequence',
            'use_date_range': True,
        })
        self.assertTrue(seq)

    def test_ir_sequence_date_range_2_change_dates(self):
        """ Draw numbers to create a first subsequence then change its date range. Then, try to draw a new number adn check a new subsequence was correctly created. """
        year = date.today().year - 1
        january = lambda d: date(year, 1, d)

        seq16 = self.env['ir.sequence'].with_context(ir_sequence_date=january(16))
        n = seq16.next_by_code('test_sequence_date_range')
        self.assertEqual(n, '1')
        n = seq16.next_by_code('test_sequence_date_range')
        self.assertEqual(n, '2')

        # modify the range of date created
        domain = [('sequence_id.code', '=', 'test_sequence_date_range'), ('date_from', '=', january(1))]
        seq_date_range = self.env['ir.sequence.date_range'].search(domain)
        seq_date_range.write({'date_from': january(18)})
        n = seq16.next_by_code('test_sequence_date_range')
        self.assertEqual(n, '1')

        # check the newly created sequence stops at the 17th of January
        domain = [('sequence_id.code', '=', 'test_sequence_date_range'), ('date_from', '=', january(1))]
        seq_date_range = self.env['ir.sequence.date_range'].search(domain)
        self.assertEqual(seq_date_range.date_to, january(17))

    def test_ir_sequence_date_range_3_unlink(self):
        seq = self.env['ir.sequence'].search([('code', '=', 'test_sequence_date_range')])
        seq.unlink()


class TestIrSequenceDateRangeNoGap(SingleTransactionCase):
    """ Copy of the previous tests for a 'No gap' sequence. """

    def test_ir_sequence_date_range_1_create_no_gap(self):
        """ Try to create a sequence object. """
        seq = self.env['ir.sequence'].create({
            'code': 'test_sequence_date_range_2',
            'name': 'Test sequence',
            'use_date_range': True,
            'implementation': 'no_gap',
        })
        self.assertTrue(seq)

    def test_ir_sequence_date_range_2_change_dates(self):
        """ Draw numbers to create a first subsequence then change its date range. Then, try to draw a new number adn check a new subsequence was correctly created. """
        year = date.today().year - 1
        january = lambda d: date(year, 1, d)

        seq16 = self.env['ir.sequence'].with_context({'ir_sequence_date': january(16)})
        n = seq16.next_by_code('test_sequence_date_range_2')
        self.assertEqual(n, '1')
        n = seq16.next_by_code('test_sequence_date_range_2')
        self.assertEqual(n, '2')

        # modify the range of date created
        domain = [('sequence_id.code', '=', 'test_sequence_date_range_2'), ('date_from', '=', january(1))]
        seq_date_range = self.env['ir.sequence.date_range'].search(domain)
        seq_date_range.write({'date_from': january(18)})
        n = seq16.next_by_code('test_sequence_date_range_2')
        self.assertEqual(n, '1')

        # check the newly created sequence stops at the 17th of January
        domain = [('sequence_id.code', '=', 'test_sequence_date_range_2'), ('date_from', '=', january(1))]
        seq_date_range = self.env['ir.sequence.date_range'].search(domain)
        self.assertEqual(seq_date_range.date_to, january(17))

    def test_ir_sequence_date_range_3_unlink(self):
        seq = self.env['ir.sequence'].search([('code', '=', 'test_sequence_date_range_2')])
        seq.unlink()


class TestIrSequenceDateRangeChangeImplementation(SingleTransactionCase):
    """ Create sequence objects and change their ``implementation`` field. """

    def test_ir_sequence_date_range_1_create(self):
        """ Try to create a sequence object. """
        seq = self.env['ir.sequence'].create({
            'code': 'test_sequence_date_range_3',
            'name': 'Test sequence',
            'use_date_range': True,
        })
        self.assertTrue(seq)

        seq = self.env['ir.sequence'].create({
            'code': 'test_sequence_date_range_4',
            'name': 'Test sequence',
            'use_date_range': True,
            'implementation': 'no_gap',
        })
        self.assertTrue(seq)

    def test_ir_sequence_date_range_2_use(self):
        """ Make some use of the sequences to create some subsequences """
        year = date.today().year - 1
        january = lambda d: date(year, 1, d)

        seq = self.env['ir.sequence']
        seq16 = self.env['ir.sequence'].with_context({'ir_sequence_date': january(16)})

        for i in range(1, 5):
            n = seq.next_by_code('test_sequence_date_range_3')
            self.assertEqual(n, str(i))
        for i in range(1, 5):
            n = seq16.next_by_code('test_sequence_date_range_3')
            self.assertEqual(n, str(i))
        for i in range(1, 5):
            n = seq.next_by_code('test_sequence_date_range_4')
            self.assertEqual(n, str(i))
        for i in range(1, 5):
            n = seq16.next_by_code('test_sequence_date_range_4')
            self.assertEqual(n, str(i))

    def test_ir_sequence_date_range_3_write(self):
        """swap the implementation method on both"""
        domain = [('code', 'in', ['test_sequence_date_range_3', 'test_sequence_date_range_4'])]
        seqs = self.env['ir.sequence'].search(domain)
        seqs.write({'implementation': 'standard'})
        seqs.write({'implementation': 'no_gap'})

    def test_ir_sequence_date_range_4_unlink(self):
        domain = [('code', 'in', ['test_sequence_date_range_3', 'test_sequence_date_range_4'])]
        seqs = self.env['ir.sequence'].search(domain)
        seqs.unlink()

```

  File: tests/test_mail.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from markupsafe import Markup

import re

from odoo.addons.base.models.ir_mail_server import extract_rfc2822_addresses
from odoo.addons.base.models.ir_qweb_fields import nl2br_enclose
from odoo.tests import tagged
from odoo.tests.common import BaseCase
from odoo.tools import (
    is_html_empty, html_to_inner_content, html_sanitize, append_content_to_html, plaintext2html,
    email_domain_normalize, email_normalize, email_re,
    email_split, email_split_and_format, email_split_tuples,
    single_email_re, html2plaintext,
    misc, formataddr,
    prepend_html_content,
)

from . import test_mail_examples


@tagged('mail_sanitize')
class TestSanitizer(BaseCase):
    """ Test the html sanitizer that filters html to remove unwanted attributes """

    def test_abrupt_close(self):
        payload = """<!--> <script> alert(1) </script> -->"""
        html_result = html_sanitize(payload)
        self.assertNotIn('alert(1)', html_result)

        payload = """<!---> <script> alert(1) </script> -->"""
        html_result = html_sanitize(payload)
        self.assertNotIn('alert(1)', html_result)

    def test_abrut_malformed(self):
        payload = """<!--!> <script> alert(1) </script> -->"""
        html_result = html_sanitize(payload)
        self.assertNotIn('alert(1)', html_result)

        payload = """<!---!> <script> alert(1) </script> -->"""
        html_result = html_sanitize(payload)
        self.assertNotIn('alert(1)', html_result)

    def test_basic_sanitizer(self):
        cases = [
            ("yop", "<p>yop</p>"),  # simple
            ("lala<p>yop</p>xxx", "<p>lala</p><p>yop</p>xxx"),  # trailing text
            ("Merci à l'intérêt pour notre produit.nous vous contacterons bientôt. Merci",
                u"<p>Merci à l'intérêt pour notre produit.nous vous contacterons bientôt. Merci</p>"),  # unicode
        ]
        for content, expected in cases:
            html = html_sanitize(content)
            self.assertEqual(html, expected, 'html_sanitize is broken')

    def test_comment_malformed(self):
        html = '''<!-- malformed-close --!> <img src='x' onerror='alert(1)'></img> --> comment <!-- normal comment --> --> out of context balise --!>'''
        html_result = html_sanitize(html)
        self.assertNotIn('alert(1)', html_result)

    def test_comment_multiline(self):
        payload = """
            <div> <!--
                multi line comment
                --!> </div> <script> alert(1) </script> -->
        """
        html_result = html_sanitize(payload)
        self.assertNotIn('alert(1)', html_result)

    def test_evil_malicious_code(self):
        # taken from https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Tests
        cases = [
            ("<IMG SRC=javascript:alert('XSS')>"),  # no quotes and semicolons
            ("<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>"),  # UTF-8 Unicode encoding
            ("<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>"),  # hex encoding
            ("<IMG SRC=\"jav&#x0D;ascript:alert('XSS');\">"),  # embedded carriage return
            ("<IMG SRC=\"jav&#x0A;ascript:alert('XSS');\">"),  # embedded newline
            ("<IMG SRC=\"jav   ascript:alert('XSS');\">"),  # embedded tab
            ("<IMG SRC=\"jav&#x09;ascript:alert('XSS');\">"),  # embedded encoded tab
            ("<IMG SRC=\" &#14;  javascript:alert('XSS');\">"),  # spaces and meta-characters
            ("<IMG SRC=\"javascript:alert('XSS')\""),  # half-open html
            ("<IMG \"\"\"><SCRIPT>alert(\"XSS\")</SCRIPT>\">"),  # malformed tag
            ("<SCRIPT/XSS SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>"),  # non-alpha-non-digits
            ("<SCRIPT/SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>"),  # non-alpha-non-digits
            ("<<SCRIPT>alert(\"XSS\");//<</SCRIPT>"),  # extraneous open brackets
            ("<SCRIPT SRC=http://ha.ckers.org/xss.js?< B >"),  # non-closing script tags
            ("<INPUT TYPE=\"IMAGE\" SRC=\"javascript:alert('XSS');\">"),  # input image
            ("<BODY BACKGROUND=\"javascript:alert('XSS')\">"),  # body image
            ("<IMG DYNSRC=\"javascript:alert('XSS')\">"),  # img dynsrc
            ("<IMG LOWSRC=\"javascript:alert('XSS')\">"),  # img lowsrc
            ("<TABLE BACKGROUND=\"javascript:alert('XSS')\">"),  # table
            ("<TABLE><TD BACKGROUND=\"javascript:alert('XSS')\">"),  # td
            ("<DIV STYLE=\"background-image: url(javascript:alert('XSS'))\">"),  # div background
            ("<DIV STYLE=\"background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029\">"),  # div background with unicoded exploit
            ("<DIV STYLE=\"background-image: url(&#1;javascript:alert('XSS'))\">"),  # div background + extra characters
            ("<IMG SRC='vbscript:msgbox(\"XSS\")'>"),  # VBscrip in an image
            ("<BODY ONLOAD=alert('XSS')>"),  # event handler
            ("<BR SIZE=\"&{alert('XSS')}\\>"),  # & javascript includes
            ("<LINK REL=\"stylesheet\" HREF=\"javascript:alert('XSS');\">"),  # style sheet
            ("<LINK REL=\"stylesheet\" HREF=\"http://ha.ckers.org/xss.css\">"),  # remote style sheet
            ("<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>"),  # remote style sheet 2
            ("<META HTTP-EQUIV=\"Link\" Content=\"<http://ha.ckers.org/xss.css>; REL=stylesheet\">"),  # remote style sheet 3
            ("<STYLE>BODY{-moz-binding:url(\"http://ha.ckers.org/xssmoz.xml#xss\")}</STYLE>"),  # remote style sheet 4
            ("<IMG STYLE=\"xss:expr/*XSS*/ession(alert('XSS'))\">"),  # style attribute using a comment to break up expression
        ]
        for content in cases:
            html = html_sanitize(content)
            self.assertNotIn('javascript', html, 'html_sanitize did not remove a malicious javascript')
            self.assertTrue('ha.ckers.org' not in html or 'http://ha.ckers.org/xss.css' in html, 'html_sanitize did not remove a malicious code in %s (%s)' % (content, html))

        content = "<!--[if gte IE 4]><SCRIPT>alert('XSS');</SCRIPT><![endif]-->"  # down-level hidden block
        self.assertEqual(html_sanitize(content, silent=False), '')

    def test_html(self):
        sanitized_html = html_sanitize(test_mail_examples.MISC_HTML_SOURCE)
        for tag in ['<div', '<b', '<i', '<u', '<strike', '<li', '<blockquote', '<a href']:
            self.assertIn(tag, sanitized_html, 'html_sanitize stripped too much of original html')
        for attr in ['javascript']:
            self.assertNotIn(attr, sanitized_html, 'html_sanitize did not remove enough unwanted attributes')

    def test_outlook_mail_sanitize(self):
        case = """<div class="WordSection1">
<p class="MsoNormal">Here is a test mail<o:p></o:p></p>
<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
<p class="MsoNormal">With a break line<o:p></o:p></p>
<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
<p class="MsoNormal">Then two<o:p></o:p></p>
<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
<div>
<div style="border:none;border-top:solid #E1E1E1 1.0pt;padding:3.0pt 0in 0in 0in">
<p class="MsoNormal"><b>From:</b> Mitchell Admin &lt;dummy@example.com&gt;
<br>
<b>Sent:</b> Monday, November 20, 2023 8:34 AM<br>
<b>To:</b> test user &lt;dummy@example.com&gt;<br>
<b>Subject:</b> test (#23)<o:p></o:p></p>
</div>
</div>"""

        expected = """<div class="WordSection1">
<p class="MsoNormal">Here is a test mail</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">With a break line</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal">Then two</p>
<p class="MsoNormal">&nbsp;</p>
<div>
<div style="border:none;border-top:solid #E1E1E1 1.0pt;padding:3.0pt 0in 0in 0in">
<p class="MsoNormal"><b>From:</b> Mitchell Admin &lt;dummy@example.com&gt;
<br>
<b>Sent:</b> Monday, November 20, 2023 8:34 AM<br>
<b>To:</b> test user &lt;dummy@example.com&gt;<br>
<b>Subject:</b> test (#23)</p>
</div>
</div></div>"""

        result = html_sanitize(case)
        self.assertEqual(result, expected)

    def test_sanitize_unescape_emails(self):
        not_emails = [
            '<blockquote cite="mid:CAEJSRZvWvud8c6Qp=wfNG6O1+wK3i_jb33qVrF7XyrgPNjnyUA@mail.gmail.com" type="cite">cat</blockquote>',
            '<img alt="@github-login" class="avatar" src="/web/image/pi" height="36" width="36">']
        for not_email in not_emails:
            sanitized = html_sanitize(not_email)
            left_part = not_email.split('>')[0]  # take only left part, as the sanitizer could add data information on node
            self.assertNotIn(misc.html_escape(not_email), sanitized, 'html_sanitize stripped emails of original html')
            self.assertIn(left_part, sanitized)

    def test_style_parsing(self):
        test_data = [
            (
                '<span style="position: fixed; top: 0px; left: 50px; width: 40%; height: 50%; background-color: red;">Coin coin </span>',
                ['background-color:red', 'Coin coin'],
                ['position', 'top', 'left']
            ), (
                """<div style='before: "Email Address; coincoin cheval: lapin";  
   font-size: 30px; max-width: 100%; after: "Not sure
    
          this; means: anything ?#ùµ"
    ; some-property: 2px; top: 3'>youplaboum</div>""",
                ['font-size:30px', 'youplaboum'],
                ['some-property', 'top', 'cheval']
            ), (
                '<span style="width">Coincoin</span>',
                [],
                ['width']
            )
        ]

        for test, in_lst, out_lst in test_data:
            new_html = html_sanitize(test, sanitize_attributes=False, sanitize_style=True, strip_style=False, strip_classes=False)
            for text in in_lst:
                self.assertIn(text, new_html)
            for text in out_lst:
                self.assertNotIn(text, new_html)

        # style should not be sanitized if removed
        new_html = html_sanitize(test_data[0][0], sanitize_attributes=False, strip_style=True, strip_classes=False)
        self.assertEqual(new_html, u'<span>Coin coin </span>')

    def test_style_class(self):
        html = html_sanitize(test_mail_examples.REMOVE_CLASS, sanitize_attributes=True, sanitize_style=True, strip_classes=True)
        for ext in test_mail_examples.REMOVE_CLASS_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.REMOVE_CLASS_OUT:
            self.assertNotIn(ext, html,)

    def test_style_class_only(self):
        html = html_sanitize(test_mail_examples.REMOVE_CLASS, sanitize_attributes=False, sanitize_style=True, strip_classes=True)
        for ext in test_mail_examples.REMOVE_CLASS_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.REMOVE_CLASS_OUT:
            self.assertNotIn(ext, html,)

    def test_edi_source(self):
        html = html_sanitize(test_mail_examples.EDI_LIKE_HTML_SOURCE)
        self.assertIn(
            'font-family: \'Lucida Grande\', Ubuntu, Arial, Verdana, sans-serif;', html,
            'html_sanitize removed valid styling')
        self.assertIn(
            'src="https://www.paypal.com/en_US/i/btn/btn_paynowCC_LG.gif"', html,
            'html_sanitize removed valid img')
        self.assertNotIn('</body></html>', html, 'html_sanitize did not remove extra closing tags')

    def test_quote_blockquote(self):
        html = html_sanitize(test_mail_examples.QUOTE_BLOCKQUOTE)
        for ext in test_mail_examples.QUOTE_BLOCKQUOTE_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_BLOCKQUOTE_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s' % misc.html_escape(ext), html)

    def test_quote_thunderbird(self):
        html = html_sanitize(test_mail_examples.QUOTE_THUNDERBIRD_1)
        for ext in test_mail_examples.QUOTE_THUNDERBIRD_1_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_THUNDERBIRD_1_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)

    def test_quote_hotmail_html(self):
        html = html_sanitize(test_mail_examples.QUOTE_HOTMAIL_HTML)
        for ext in test_mail_examples.QUOTE_HOTMAIL_HTML_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_HOTMAIL_HTML_OUT:
            self.assertIn(ext, html)

        html = html_sanitize(test_mail_examples.HOTMAIL_1)
        for ext in test_mail_examples.HOTMAIL_1_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.HOTMAIL_1_OUT:
            self.assertIn(ext, html)

    def test_quote_outlook_html(self):
        html = html_sanitize(test_mail_examples.QUOTE_OUTLOOK_HTML)
        for ext in test_mail_examples.QUOTE_OUTLOOK_HTML_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_OUTLOOK_HTML_OUT:
            self.assertIn(ext, html)

    def test_quote_thunderbird_html(self):
        html = html_sanitize(test_mail_examples.QUOTE_THUNDERBIRD_HTML)
        for ext in test_mail_examples.QUOTE_THUNDERBIRD_HTML_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_THUNDERBIRD_HTML_OUT:
            self.assertIn(ext, html)

    def test_quote_yahoo_html(self):
        html = html_sanitize(test_mail_examples.QUOTE_YAHOO_HTML)
        for ext in test_mail_examples.QUOTE_YAHOO_HTML_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.QUOTE_YAHOO_HTML_OUT:
            self.assertIn(ext, html)

    def test_quote_basic_text(self):
        test_data = [
            (
                """This is Sparta!\n--\nAdministrator\n+9988776655""",
                ['This is Sparta!'],
                ['\n--\nAdministrator\n+9988776655']
            ), (
                """<p>This is Sparta!\n--\nAdministrator</p>""",
                [],
                ['\n--\nAdministrator']
            ), (
                """<p>This is Sparta!<br/>--<br>Administrator</p>""",
                ['This is Sparta!'],
                []
            ), (
                """This is Sparta!\n>Ah bon ?\nCertes\n> Chouette !\nClair""",
                ['This is Sparta!', 'Certes', 'Clair'],
                ['\n>Ah bon ?', '\n> Chouette !']
            )
        ]
        for test, in_lst, out_lst in test_data:
            new_html = html_sanitize(test)
            for text in in_lst:
                self.assertIn(text, new_html)
            for text in out_lst:
                self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(text), new_html)

    def test_quote_signature(self):
        test_data = [
            (
                """<div>Hello<pre>--<br />Administrator</pre></div>""",
                ["<pre data-o-mail-quote=\"1\">--", "<br data-o-mail-quote=\"1\">"],
            )
        ]
        for test, in_lst in test_data:
            new_html = html_sanitize(test)
            for text in in_lst:
                self.assertIn(text, new_html)

    def test_quote_gmail(self):
        html = html_sanitize(test_mail_examples.GMAIL_1)
        for ext in test_mail_examples.GMAIL_1_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.GMAIL_1_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)

    def test_quote_text(self):
        html = html_sanitize(test_mail_examples.TEXT_1)
        for ext in test_mail_examples.TEXT_1_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.TEXT_1_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)

        html = html_sanitize(test_mail_examples.TEXT_2)
        for ext in test_mail_examples.TEXT_2_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.TEXT_2_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)

    def test_quote_bugs(self):
        html = html_sanitize(test_mail_examples.BUG1)
        for ext in test_mail_examples.BUG_1_IN:
            self.assertIn(ext, html)
        for ext in test_mail_examples.BUG_1_OUT:
            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)

    def test_misc(self):
        # False / void should not crash
        html = html_sanitize('')
        self.assertEqual(html, '')
        html = html_sanitize(False)
        self.assertEqual(html, False)

        # Message with xml and doctype tags don't crash
        html = html_sanitize(u'<?xml version="1.0" encoding="iso-8859-1"?>\n<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">\n <head>\n  <title>404 - Not Found</title>\n </head>\n <body>\n  <h1>404 - Not Found</h1>\n </body>\n</html>\n')
        self.assertNotIn('encoding', html)
        self.assertNotIn('<title>404 - Not Found</title>', html)
        self.assertIn('<h1>404 - Not Found</h1>', html)

    def test_cid_with_at(self):
        img_tag = '<img src="@">'
        sanitized = html_sanitize(img_tag, sanitize_tags=False, strip_classes=True)
        self.assertEqual(img_tag, sanitized, "img with can have cid containing @ and shouldn't be escaped")

    # ms office is currently not supported, have to find a way to support it
    # def test_30_email_msoffice(self):
    #     new_html = html_sanitize(test_mail_examples.MSOFFICE_1, remove=True)
    #     for ext in test_mail_examples.MSOFFICE_1_IN:
    #         self.assertIn(ext, new_html)
    #     for ext in test_mail_examples.MSOFFICE_1_OUT:
    #         self.assertNotIn(ext, new_html)


@tagged('mail_sanitize')
class TestHtmlTools(BaseCase):
    """ Test some of our generic utility functions about html """

    def test_plaintext2html(self):
        cases = [
            ("First \nSecond \nThird\n \nParagraph\n\r--\nSignature paragraph", 'div',
             "<div><p>First <br/>Second <br/>Third</p><p>Paragraph</p><p>--<br/>Signature paragraph</p></div>"),
            ("First<p>It should be escaped</p>\nSignature", False,
             "<p>First&lt;p&gt;It should be escaped&lt;/p&gt;<br/>Signature</p>")
        ]
        for content, container_tag, expected in cases:
            html = plaintext2html(content, container_tag)
            self.assertEqual(html, expected, 'plaintext2html is broken')

    def test_html_html_to_inner_content(self):
        cases = [
            ('<div><p>First <br/>Second <br/>Third Paragraph</p><p>--<br/>Signature paragraph with a <a href="./link">link</a></p></div>',
             'First Second Third Paragraph -- Signature paragraph with a link'),
            ('<p>Now =&gt; processing&nbsp;entities&#8203;and extra whitespace too.  </p>',
             'Now => processing\xa0entities\u200band extra whitespace too.'),
            ('<div>Look what happens with <p>unmatched tags</div>', 'Look what happens with unmatched tags'),
            ('<div>Look what happens with <p unclosed tags</div> Are we good?', 'Look what happens with Are we good?')
        ]
        for content, expected in cases:
            text = html_to_inner_content(content)
            self.assertEqual(text, expected, 'html_html_to_inner_content is broken')

    def test_append_to_html(self):
        test_samples = [
            ('<!DOCTYPE...><HTML encoding="blah">some <b>content</b></HtMl>', '--\nYours truly', True, True, False,
             '<!DOCTYPE...><html encoding="blah">some <b>content</b>\n<pre>--\nYours truly</pre>\n</html>'),
            ('<!DOCTYPE...><HTML encoding="blah">some <b>content</b></HtMl>', '--\nYours truly', True, False, False,
             '<!DOCTYPE...><html encoding="blah">some <b>content</b>\n<p>--<br/>Yours truly</p>\n</html>'),
            ('<html><body>some <b>content</b></body></html>', '--\nYours & <truly>', True, True, False,
             '<html><body>some <b>content</b>\n<pre>--\nYours &amp; &lt;truly&gt;</pre>\n</body></html>'),
            ('<html><body>some <b>content</b></body></html>', '<!DOCTYPE...>\n<html><body>\n<p>--</p>\n<p>Yours truly</p>\n</body>\n</html>', False, False, False,
             '<html><body>some <b>content</b>\n\n\n<p>--</p>\n<p>Yours truly</p>\n\n\n</body></html>'),
        ]
        for html, content, plaintext_flag, preserve_flag, container_tag, expected in test_samples:
            self.assertEqual(append_content_to_html(html, content, plaintext_flag, preserve_flag, container_tag), expected, 'append_content_to_html is broken')

    def test_is_html_empty(self):
        void_strings_samples = ['', False, ' ']
        for content in void_strings_samples:
            self.assertTrue(is_html_empty(content))

        void_html_samples = [
            '<section><br /> <b><i/></b></section>',
            '<p><br></p>', '<p><br> </p>', '<p><br /></p >',
            '<p style="margin: 4px"></p>',
            '<div style="margin: 4px"></div>',
            '<p class="oe_testing"><br></p>',
            '<p><span style="font-weight: bolder;"><font style="color: rgb(255, 0, 0);" class=" "></font></span><br></p>',
        ]
        for content in void_html_samples:
            self.assertTrue(is_html_empty(content), 'Failed with %s' % content)

        valid_html_samples = [
            '<p><br>1</p>', '<p>1<br > </p>', '<p style="margin: 4px">Hello World</p>',
            '<div style="margin: 4px"><p>Hello World</p></div>',
            '<p><span style="font-weight: bolder;"><font style="color: rgb(255, 0, 0);" class=" ">W</font></span><br></p>',
        ]
        for content in valid_html_samples:
            self.assertFalse(is_html_empty(content))

    def test_nl2br_enclose(self):
        """ Test formatting of nl2br when using Markup: consider new <br> tags
        as trusted without validating the whole input content. """
        source_all = [
            'coucou',
            '<p>coucou</p>',
            'coucou\ncoucou',
            'coucou\n\ncoucou',
            '<p>coucou\ncoucou\n\nzbouip</p>\n',
        ]
        expected_all = [
            Markup('<div>coucou</div>'),
            Markup('<div>&lt;p&gt;coucou&lt;/p&gt;</div>'),
            Markup('<div>coucou<br>\ncoucou</div>'),
            Markup('<div>coucou<br>\n<br>\ncoucou</div>'),
            Markup('<div>&lt;p&gt;coucou<br>\ncoucou<br>\n<br>\nzbouip&lt;/p&gt;<br>\n</div>'),
        ]
        for source, expected in zip(source_all, expected_all):
            with self.subTest(source=source, expected=expected):
                self.assertEqual(
                    nl2br_enclose(source, "div"),
                    expected,
                )

    def test_prepend_html_content(self):
        body = """
            <html>
                <body>
                    <div>test</div>
                </body>
            </html>
        """

        content = "<span>content</span>"

        result = prepend_html_content(body, content)
        result = re.sub(r'[\s\t]', '', result)
        self.assertEqual(result, "<html><body><span>content</span><div>test</div></body></html>")

        body = "<div>test</div>"
        content = "<span>content</span>"

        result = prepend_html_content(body, content)
        result = re.sub(r'[\s\t]', '', result)
        self.assertEqual(result, "<span>content</span><div>test</div>")

        body = """
            <body>
                <div>test</div>
            </body>
        """

        result = prepend_html_content(body, content)
        result = re.sub(r'[\s\t]', '', result)
        self.assertEqual(result, "<body><span>content</span><div>test</div></body>")

        body = """
            <html>
                <body>
                    <div>test</div>
                </body>
            </html>
        """

        content = """
            <html>
                <body>
                    <div>test</div>
                </body>
            </html>
        """
        result = prepend_html_content(body, content)
        result = re.sub(r'[\s\t]', '', result)
        self.assertEqual(result, "<html><body><div>test</div><div>test</div></body></html>")


@tagged('mail_tools')
class TestEmailTools(BaseCase):
    """ Test some of our generic utility functions for emails """

    @classmethod
    def setUpClass(cls):
        super(TestEmailTools, cls).setUpClass()

        cls.sources = [
            # single email
            'alfred.astaire@test.example.com',
            ' alfred.astaire@test.example.com ',
            'Fredo The Great <alfred.astaire@test.example.com>',
            '"Fredo The Great" <alfred.astaire@test.example.com>',
            'Fredo "The Great" <alfred.astaire@test.example.com>',
            # multiple emails
            'alfred.astaire@test.example.com, evelyne.gargouillis@test.example.com',
            'Fredo The Great <alfred.astaire@test.example.com>, Evelyne The Goat <evelyne.gargouillis@test.example.com>',
            '"Fredo The Great" <alfred.astaire@test.example.com>, evelyne.gargouillis@test.example.com',
            '"Fredo The Great" <alfred.astaire@test.example.com>, <evelyne.gargouillis@test.example.com>',
            # text containing email
            'Hello alfred.astaire@test.example.com how are you ?',
            '<p>Hello alfred.astaire@test.example.com</p>',
            # text containing emails
            'Hello "Fredo" <alfred.astaire@test.example.com>, evelyne.gargouillis@test.example.com',
            'Hello "Fredo" <alfred.astaire@test.example.com> and evelyne.gargouillis@test.example.com',
            # falsy
            '<p>Hello Fredo</p>',
            'j\'adore écrire des @gmail.com ou "@gmail.com" a bit randomly',
            '',
        ]

    def test_email_domain_normalize(self):
        cases = [
            ("Test.Com", "test.com", "Should have normalized domain"),
            ("email@test.com", False, "Domain is not valid, should return False"),
            (False, False, "Domain is not valid, should retunr False"),
        ]
        for source, expected, msg in cases:
            self.assertEqual(email_domain_normalize(source), expected, msg)

    def test_email_normalize(self):
        """ Test 'email_normalize'. Note that it is built on 'email_split' so
        some use cases are already managed in 'test_email_split(_and_format)'
        hence having more specific test cases here about normalization itself. """
        format_name = 'My Super Prénom'
        format_name_ascii = '=?utf-8?b?TXkgU3VwZXIgUHLDqW5vbQ==?='
        sources = [
            '"Super Déboulonneur" <deboulonneur@example.com>',  # formatted
            'Déboulonneur deboulonneur@example.com',  # wrong formatting
            'deboulonneur@example.com Déboulonneur',  # wrong formatting (happens, alas)
            '"Super Déboulonneur" <DEBOULONNEUR@example.com>, "Super Déboulonneur 2" <deboulonneur2@EXAMPLE.com>',  # multi + case
            ' Déboulonneur deboulonneur@example.com déboulonneur deboulonneur2@example.com',  # wrong formatting + wrong multi
            '"Déboulonneur 😊" <deboulonneur.😊@example.com>',  # unicode in name and email left-part
            '"Déboulonneur" <déboulonneur@examplé.com>',  # utf-8
            '"Déboulonneur" <DéBoulonneur@Examplé.com>',  # utf-8
        ]
        expected_list = [
            'deboulonneur@example.com',
            'deboulonneur@example.com',
            'deboulonneur@example.comdéboulonneur',
            False,
            False,  # need fix over 'getadresses'
            'deboulonneur.😊@example.com',
            'déboulonneur@examplé.com',
            'DéBoulonneur@examplé.com',
        ]
        expected_fmt_utf8_list = [
            f'"{format_name}" <deboulonneur@example.com>',
            f'"{format_name}" <deboulonneur@example.com>',
            f'"{format_name}" <deboulonneur@example.comdéboulonneur>',
            f'"{format_name}" <@>',
            f'"{format_name}" <@>',
            f'"{format_name}" <deboulonneur.😊@example.com>',
            f'"{format_name}" <déboulonneur@examplé.com>',
            f'"{format_name}" <DéBoulonneur@examplé.com>',
        ]
        expected_fmt_ascii_list = [
            f'{format_name_ascii} <deboulonneur@example.com>',
            f'{format_name_ascii} <deboulonneur@example.com>',
            f'{format_name_ascii} <deboulonneur@example.xn--comdboulonneur-ekb>',
            f'{format_name_ascii} <@>',
            f'{format_name_ascii} <@>',
            f'{format_name_ascii} <deboulonneur.😊@example.com>',
            f'{format_name_ascii} <déboulonneur@xn--exampl-gva.com>',
            f'{format_name_ascii} <DéBoulonneur@xn--exampl-gva.com>',
        ]
        for source, expected, expected_utf8_fmt, expected_ascii_fmt in zip(sources, expected_list, expected_fmt_utf8_list, expected_fmt_ascii_list):
            with self.subTest(source=source):
                self.assertEqual(email_normalize(source, strict=True), expected)
                # standard usage of formataddr
                self.assertEqual(formataddr((format_name, (expected or '')), charset='utf-8'), expected_utf8_fmt)
                # check using INDA at format time, using ascii charset as done when
                # sending emails (see extract_rfc2822_addresses)
                self.assertEqual(formataddr((format_name, (expected or '')), charset='ascii'), expected_ascii_fmt)

    def test_email_re(self):
        """ Test 'email_re', finding emails in a given text """
        expected = [
            # single email
            ['alfred.astaire@test.example.com'],
            ['alfred.astaire@test.example.com'],
            ['alfred.astaire@test.example.com'],
            ['alfred.astaire@test.example.com'],
            ['alfred.astaire@test.example.com'],
            # multiple emails
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            # text containing email
            ['alfred.astaire@test.example.com'],
            ['alfred.astaire@test.example.com'],
            # text containing emails
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            ['alfred.astaire@test.example.com', 'evelyne.gargouillis@test.example.com'],
            # falsy
            [], [], [],
        ]

        for src, exp in zip(self.sources, expected):
            res = email_re.findall(src)
            self.assertEqual(
                res, exp,
                'Seems email_re is broken with %s (expected %r, received %r)' % (src, exp, res)
            )

    def test_email_split(self):
        """ Test 'email_split' """
        cases = [
            ("John <12345@gmail.com>", ['12345@gmail.com']),  # regular form
            ("d@x; 1@2", ['d@x', '1@2']),  # semi-colon + extra space
            ("'(ss)' <123@gmail.com>, 'foo' <foo@bar>", ['123@gmail.com', 'foo@bar']),  # comma + single-quoting
            ('"john@gmail.com"<johnny@gmail.com>', ['johnny@gmail.com']),  # double-quoting
            ('"<jg>" <johnny@gmail.com>', ['johnny@gmail.com']),  # double-quoting with brackets
            ('@gmail.com', ['@gmail.com']),  # no left-part
            # '@domain' corner cases -- all those return a '@gmail.com' (or equivalent)
            # email address when going through 'getaddresses'
            # - multi @
            ('fr@ncois.th@notgmail.com', ['fr@ncois.th']),
            ('f@r@nc.gz,ois@notgmail.com', ['r@nc.gz', 'ois@notgmail.com']),  # still failing, but differently from 'getaddresses' alone
            ('@notgmail.com esteban_gnole@coldmail.com@notgmail.com', ['esteban_gnole@coldmail.com']),
            # - multi emails (with invalid)
            (
                'Ivan@dezotos.com Cc iv.an@notgmail.com',
                ['Ivan@dezotos.com', 'iv.an@notgmail.com']
            ),
            (
                'ivan-dredi@coldmail.com ivan.dredi@notgmail.com',
                ['ivan-dredi@coldmail.com', 'ivan.dredi@notgmail.com']
            ),
            (
                '@notgmail.com ivan@coincoin.com.ar jeanine@coincoin.com.ar',
                ['ivan@coincoin.com.ar', 'jeanine@coincoin.com.ar']
            ),
            (
                '@notgmail.com whoareyou@youhou.com.   ivan.dezotos@notgmail.com',
                ['whoareyou@youhou.com', 'ivan.dezotos@notgmail.com']
            ),
            (
                'francois@nc.gz CC: ois@notgmail.com ivan@dezotos.com',
                ['francois@nc.gz', 'ois@notgmail.com', 'ivan@dezotos.com']
            ),
            (
                'francois@nc.gz CC: ois@notgmail.com,ivan@dezotos.com',
                ['francois@nc.gzCC', 'ois@notgmail.com', 'ivan@dezotos.com']
            ),
            # - separated with '/''
            (
                'ivan.plein@dezotos.com / ivan.plu@notgmail.com',
                ['ivan.plein@dezotos.com', 'ivan.plu@notgmail.com']
            ),
            (
                '@notgmail.com ivan.parfois@notgmail.com/ ivan.souvent@notgmail.com',
                ['ivan.parfois@notgmail.com', 'ivan.souvent@notgmail.com']
            ),
            # - separated with '-''
            ('ivan@dezotos.com - ivan.dezotos@notgmail.com', ['ivan@dezotos.com', 'ivan.dezotos@notgmail.com']),
            (
                'car.pool@notgmail.com - co (TAMBO) Registration car.warsh@notgmail.com',
                ['car.pool@notgmail.com', 'car.warsh@notgmail.com']
            ),
        ]
        for source, expected in cases:
            with self.subTest(source=source):
                self.assertEqual(email_split(source), expected)

    def test_email_split_and_format(self):
        """ Test 'email_split_and_format', notably in case of multi encapsulation
        or multi emails. """
        sources = [
            'deboulonneur@example.com',
            '"Super Déboulonneur" <deboulonneur@example.com>',  # formatted
            # wrong formatting
            'Déboulonneur <deboulonneur@example.com',  # with a final typo
            'Déboulonneur deboulonneur@example.com',  # wrong formatting
            'deboulonneur@example.com Déboulonneur',  # wrong formatting (happens, alas)
            # multi
            'Déboulonneur, deboulonneur@example.com',  # multi-like with errors
            'deboulonneur@example.com, deboulonneur2@example.com',  # multi
            ' Déboulonneur deboulonneur@example.com déboulonneur deboulonneur2@example.com',  # wrong formatting + wrong multi
            # format / misc
            '"Déboulonneur" <"Déboulonneur Encapsulated" <deboulonneur@example.com>>',  # double formatting
            '"Super Déboulonneur" <deboulonneur@example.com>, "Super Déboulonneur 2" <deboulonneur2@example.com>',
            '"Super Déboulonneur" <deboulonneur@example.com>, wrong, ',
            '"Déboulonneur 😊" <deboulonneur@example.com>',  # unicode in name
            '"Déboulonneur 😊" <deboulonneur.😊@example.com>',  # unicode in name and email left-part
            '"Déboulonneur" <déboulonneur@examplé.com>',  # utf-8
        ]
        expected_list = [
            ['deboulonneur@example.com'],
            ['"Super Déboulonneur" <deboulonneur@example.com>'],
            # wrong formatting
            ['"Déboulonneur" <deboulonneur@example.com>'],
            ['"Déboulonneur" <deboulonneur@example.com>'],  # extra part correctly considered as a name
            ['deboulonneur@example.comDéboulonneur'],  # concatenated, not sure why
            # multi
            ['deboulonneur@example.com'],
            ['deboulonneur@example.com', 'deboulonneur2@example.com'],
            ['deboulonneur@example.com', 'deboulonneur2@example.com'],  # need fix over 'getadresses'
            # format / misc
            ['deboulonneur@example.com'],
            ['"Super Déboulonneur" <deboulonneur@example.com>', '"Super Déboulonneur 2" <deboulonneur2@example.com>'],
            ['"Super Déboulonneur" <deboulonneur@example.com>'],
            ['"Déboulonneur 😊" <deboulonneur@example.com>'],
            ['"Déboulonneur 😊" <deboulonneur.😊@example.com>'],
            ['"Déboulonneur" <déboulonneur@examplé.com>'],
        ]
        for source, expected in zip(sources, expected_list):
            with self.subTest(source=source):
                self.assertEqual(email_split_and_format(source), expected)

    def test_email_split_tuples(self):
        """ Test 'email_split_and_format' that returns (name, email) pairs
        found in text input """
        expected = [
            # single email
            [('', 'alfred.astaire@test.example.com')],
            [('', 'alfred.astaire@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com')],
            # multiple emails
            [('', 'alfred.astaire@test.example.com'), ('', 'evelyne.gargouillis@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com'), ('Evelyne The Goat', 'evelyne.gargouillis@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com'), ('', 'evelyne.gargouillis@test.example.com')],
            [('Fredo The Great', 'alfred.astaire@test.example.com'), ('', 'evelyne.gargouillis@test.example.com')],
            # text containing email -> fallback on parsing to extract text from email
            [('Hello', 'alfred.astaire@test.example.comhowareyou?')],
            [('Hello', 'alfred.astaire@test.example.com')],
            [('Hello Fredo', 'alfred.astaire@test.example.com'), ('', 'evelyne.gargouillis@test.example.com')],
            [('Hello Fredo', 'alfred.astaire@test.example.com'), ('and', 'evelyne.gargouillis@test.example.com')],
            # falsy -> probably not designed for that
            [],
            [('j\'adore écrire', "des@gmail.comou"), ('', '@gmail.com')], [],
        ]

        for src, exp in zip(self.sources, expected):
            res = email_split_tuples(src)
            self.assertEqual(
                res, exp,
                'Seems email_split_tuples is broken with %s (expected %r, received %r)' % (src, exp, res)
            )

    def test_email_formataddr(self):
        """ Test custom 'formataddr', notably with IDNA support """
        email_base = 'joe@example.com'
        email_idna = 'joe@examplé.com'
        cases = [
            # (name, address),          charsets            expected
            (('', email_base),          ['ascii', 'utf-8'], 'joe@example.com'),
            (('joe', email_base),       ['ascii', 'utf-8'], '"joe" <joe@example.com>'),
            (('joe doe', email_base),   ['ascii', 'utf-8'], '"joe doe" <joe@example.com>'),
            (('joe"doe', email_base),   ['ascii', 'utf-8'], '"joe\\"doe" <joe@example.com>'),
            (('joé', email_base),       ['ascii'],          '=?utf-8?b?am/DqQ==?= <joe@example.com>'),
            (('joé', email_base),       ['utf-8'],          '"joé" <joe@example.com>'),
            (('', email_idna),          ['ascii'],          'joe@xn--exampl-gva.com'),
            (('', email_idna),          ['utf-8'],          'joe@examplé.com'),
            (('joé', email_idna),       ['ascii'],          '=?utf-8?b?am/DqQ==?= <joe@xn--exampl-gva.com>'),
            (('joé', email_idna),       ['utf-8'],          '"joé" <joe@examplé.com>'),
            (('', 'joé@example.com'),   ['ascii', 'utf-8'], 'joé@example.com'),
        ]

        for pair, charsets, expected in cases:
            for charset in charsets:
                with self.subTest(pair=pair, charset=charset):
                    self.assertEqual(formataddr(pair, charset), expected)

    def test_extract_rfc2822_addresses(self):
        cases = [
            ('"Admin" <admin@example.com>', ['admin@example.com']),
            ('"Admin" <admin@example.com>, Demo <demo@test.com>', ['admin@example.com', 'demo@test.com']),
            ('admin@example.com', ['admin@example.com']),
            ('"Admin" <admin@example.com>, Demo <malformed email>', ['admin@example.com']),
            ('admin@éxample.com', ['admin@xn--xample-9ua.com']),
            # formatted input containing email
            ('"admin@éxample.com" <admin@éxample.com>', ['admin@xn--xample-9ua.com', 'admin@xn--xample-9ua.com']),
            ('"Robert Le Grand" <robert@notgmail.com>', ['robert@notgmail.com']),
            ('"robert@notgmail.com" <robert@notgmail.com>', ['robert@notgmail.com', 'robert@notgmail.com']),
            # accents
            ('DéBoulonneur@examplé.com', ['DéBoulonneur@xn--exampl-gva.com']),
        ]

        for source, expected in cases:
            with self.subTest(source=source):
                self.assertEqual(extract_rfc2822_addresses(source), expected)

    def test_single_email_re(self):
        """ Test 'single_email_re', matching text input containing only one email """
        expected = [
            # single email
            ['alfred.astaire@test.example.com'],
            [], [], [], [], # formatting issue for single email re
            # multiple emails -> couic
            [], [], [], [],
            # text containing email -> couic
            [], [],
            # text containing emails -> couic
            [], [],
            # falsy
            [], [], [],
        ]

        for src, exp in zip(self.sources, expected):
            res = single_email_re.findall(src)
            self.assertEqual(
                res, exp,
                'Seems single_email_re is broken with %s (expected %r, received %r)' % (src, exp, res)
            )


class TestMailTools(BaseCase):
    """ Test mail utility methods. """

    def test_html2plaintext(self):
        self.assertEqual(html2plaintext(False), 'False')
        self.assertEqual(html2plaintext('\t'), '')
        self.assertEqual(html2plaintext('  '), '')
        self.assertEqual(html2plaintext("""<h1>Title</h1>
<h2>Sub title</h2>
<br/>
<h3>Sub sub title</h3>
<h4>Sub sub sub title</h4>
<p>Paragraph <em>with</em> <b>bold</b></p>
<table><tr><td>table element 1</td></tr><tr><td>table element 2</td></tr></table>
<p><special-chars>0 &lt; 10 &amp;  &nbsp; 10 &gt; 0</special-chars></p>"""),
                         """**Title**
**Sub title**

*Sub sub title*
Sub sub sub title
Paragraph /with/ *bold*

table element 1
table element 2
0 < 10 & \N{NO-BREAK SPACE} 10 > 0""")
        self.assertEqual(html2plaintext('<p><img src="/web/image/428-c064ab1b/test-image.jpg?access_token=f72b5ec5-a363-45fb-b9ad-81fc794d6d7b" class="img img-fluid o_we_custom_image"><br></p>'),
                         """test-image [1]


[1] /web/image/428-c064ab1b/test-image.jpg?access_token=f72b5ec5-a363-45fb-b9ad-81fc794d6d7b""")

```

  File: tests/test_mail_examples.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

MISC_HTML_SOURCE = u"""
<font size="2" style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; ">test1</font>
<div style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; font-size: 12px; font-style: normal; ">
<b>test2</b></div><div style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; font-size: 12px; ">
<i>test3</i></div><div style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; font-size: 12px; ">
<u>test4</u></div><div style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; font-size: 12px; ">
<strike>test5</strike></div><div style="color: rgb(31, 31, 31); font-family: monospace; font-variant: normal; line-height: normal; ">
<font size="5">test6</font></div><div><ul><li><font color="#1f1f1f" face="monospace" size="2">test7</font></li><li>
<font color="#1f1f1f" face="monospace" size="2">test8</font></li></ul><div><ol><li><font color="#1f1f1f" face="monospace" size="2">test9</font>
</li><li><font color="#1f1f1f" face="monospace" size="2">test10</font></li></ol></div></div>
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div><div><div><font color="#1f1f1f" face="monospace" size="2">
test11</font></div></div></div></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;">
<blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div><font color="#1f1f1f" face="monospace" size="2">
test12</font></div><div><font color="#1f1f1f" face="monospace" size="2"><br></font></div></blockquote></blockquote>
<font color="#1f1f1f" face="monospace" size="2"><a href="http://google.com">google</a></font>
<a href="javascript:alert('malicious code')">test link</a>
"""

EDI_LIKE_HTML_SOURCE = u"""<div style="font-family: 'Lucida Grande', Ubuntu, Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: #FFF; ">
    <p>Hello {{ object.partner_id.name }},</p>
    <p>A new invoice is available for you: </p>
    <p style="border-left: 1px solid #8e0000; margin-left: 30px;">
       &nbsp;&nbsp;<strong>REFERENCES</strong><br />
       &nbsp;&nbsp;Invoice number: <strong>{{ object.number }}</strong><br />
       &nbsp;&nbsp;Invoice total: <strong>{{ object.amount_total }} {{ object.currency_id.name }}</strong><br />
       &nbsp;&nbsp;Invoice date: {{ object.invoice_date }}<br />
       &nbsp;&nbsp;Order reference: {{ object.origin }}<br />
       &nbsp;&nbsp;Your contact: <a href="mailto:{{ object.user_id.email or '' }}?subject=Invoice%20{{ object.number }}">{{ object.user_id.name }}</a>
    </p>
    <br/>
    <p>It is also possible to directly pay with Paypal:</p>
    <a style="margin-left: 120px;" href="{{ object.paypal_url }}">
        <img class="oe_edi_paypal_button" src="https://www.paypal.com/en_US/i/btn/btn_paynowCC_LG.gif"/>
    </a>
    <br/>
    <p>If you have any question, do not hesitate to contact us.</p>
    <p>Thank you for choosing {{ object.company_id.name or 'us' }}!</p>
    <br/>
    <br/>
    <div style="width: 375px; margin: 0px; padding: 0px; background-color: #8E0000; border-top-left-radius: 5px 5px; border-top-right-radius: 5px 5px; background-repeat: repeat no-repeat;">
        <h3 style="margin: 0px; padding: 2px 14px; font-size: 12px; color: #DDD;">
            <strong style="text-transform:uppercase;">{{ object.company_id.name }}</strong></h3>
    </div>
    <div style="width: 347px; margin: 0px; padding: 5px 14px; line-height: 16px; background-color: #F2F2F2;">
        <span style="color: #222; margin-bottom: 5px; display: block; ">
        {{ object.company_id.street }}<br/>
        {{ object.company_id.street2 }}<br/>
        {{ object.company_id.zip }} {{ object.company_id.city }}<br/>
        {{ object.company_id.state_id and ('%s, ' % object.company_id.state_id.name) or '' }} {{ object.company_id.country_id.name or '' }}<br/>
        </span>
        <div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">
            Phone:&nbsp; {{ object.company_id.phone }}
        </div>
        <div>
            Web :&nbsp;<a href="{{ object.company_id.website }}">{{ object.company_id.website }}</a>
        </div>
    </div>
</div></body></html>"""


# QUOTES

QUOTE_BLOCKQUOTE = u"""<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  </head>
  <body text="#000000" bgcolor="#FFFFFF">
    <div class="moz-cite-prefix">On 05-01-16 05:52, Andreas Becker
      wrote:<br>
    </div>
    <blockquote
cite="mid:CAEJSRZvWvud8c6Qp=wfNG6O1+wK3i_jb33qVrF7XyrgPNjnyUA@mail.gmail.com"
      type="cite"><base href="https://www.odoo.com">
      <div dir="ltr">Yep Dominique that is true, as Postgres was the
        base of all same as Odoo and MySQL etc came much later.Â 
        <div><br>
        </div>
        <div>Unfortunately many customers who ask for and ERP are with
          hosters which still don't provide Postgres and MySQL is
          available everywhere. Additionally Postgres seems for many
          like a big black box while MySQL is very well documented and
          understandable and it has PHPmyAdmin which is far ahead of any
          tool managing postgres DBs.</div>
        <br>
      </div>
    </blockquote>
    <br>
    I don't care how much you are highlighting the advantages of Erpnext
    on this Odoo mailinglist, but when you start implying that Postgres
    is not well documented it really hurts.<br>
    <br>
    <pre class="moz-signature" cols="72">-- 
Opener B.V. - Business solutions driven by open source collaboration

Stefan Rijnhart - Consultant/developer

mail: <a class="moz-txt-link-abbreviated" href="mailto:stefan@opener.am">stefan@opener.am</a>
tel: +31 (0) 20 3090 139
web: <a class="moz-txt-link-freetext" href="https://opener.am">https://opener.am</a></pre>
  </body>
</html>"""

QUOTE_BLOCKQUOTE_IN = [u"""<blockquote cite="mid:CAEJSRZvWvud8c6Qp=wfNG6O1+wK3i_jb33qVrF7XyrgPNjnyUA@mail.gmail.com" type="cite" data-o-mail-quote-node="1" data-o-mail-quote="1">"""]
QUOTE_BLOCKQUOTE_OUT = [u"""-- 
Opener B.V. - Business solutions driven by open source collaboration

Stefan Rijnhart - Consultant/developer"""]


QUOTE_THUNDERBIRD_HTML = u"""<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  </head>
  <body text="#000000" bgcolor="#FFFFFF">
    <div class="moz-cite-prefix">On 01/05/2016 10:24 AM, Raoul
      Poilvache wrote:<br>
    </div>
    <blockquote
cite="mid:CAP76m_WWFH2KVrbjOxbaozvkmbzZYLWJnQ0n0sy9XpGaCWRf1g@mail.gmail.com"
      type="cite">
      <div dir="ltr"><b><i>Test reply. The suite.</i></b><br clear="all">
        <div><br>
        </div>
        -- <br>
        <div class="gmail_signature">Raoul Poilvache</div>
      </div>
    </blockquote>
    Top cool !!!<br>
    <br>
    <pre class="moz-signature" cols="72">-- 
Raoul Poilvache
</pre>
  </body>
</html>"""


QUOTE_THUNDERBIRD_HTML_IN = [u"""<blockquote cite="mid:CAP76m_WWFH2KVrbjOxbaozvkmbzZYLWJnQ0n0sy9XpGaCWRf1g@mail.gmail.com" type="cite" data-o-mail-quote-node="1" data-o-mail-quote="1">"""]
QUOTE_THUNDERBIRD_HTML_OUT = [u"""<pre class="moz-signature" cols="72"><span data-o-mail-quote="1">-- 
Raoul Poilvache
</span></pre>"""]


QUOTE_HOTMAIL_HTML = u"""
<html>
<head>
<style><!--
.hmmessage P
{
margin:0px=3B
padding:0px
}
body.hmmessage
{
font-size: 12pt=3B
font-family:Calibri
}
--></style></head>
<body class='hmmessage'>
<div dir='ltr'>I don't like that.<br><br>
<div><hr id="stopSpelling">
Date: Tue=2C 5 Jan 2016 10:24:48 +0100<br>
Subject: Test from gmail<br>
From: poilvache@example.com<br>
To: tartelette@example.com grosbedon@example.com<br><br>
<div dir="ltr"><b><i>Test reply. The suite.</i></b>
<br clear="all"><div><br>
</div>-- <br><div class="ecxgmail_signature">
Raoul Poilvache</div>
</div></div></div></body></html>"""
QUOTE_HOTMAIL_HTML_IN = [u"""I don't like that.<br><br>"""]
QUOTE_HOTMAIL_HTML_OUT = [
    u"""<hr id="stopSpelling" data-o-mail-quote="1">""",
    u"""<div dir="ltr" data-o-mail-quote="1"><b data-o-mail-quote="1"><i data-o-mail-quote="1">Test reply. The suite.</i></b>"""]


QUOTE_OUTLOOK_HTML = """
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=3Diso-8859-=
         1">
      <style type="text/css" style="display:none;"> P {margin-top:0;margin-bo=
         ttom:0;}
      </style>
   </head>
   <body dir="ltr">
      <div id="mail_body">
         Reply from outlook
      </div>
      <div style="font-family: Calibri, Helvetica, sans-serif; font-size: 12pt;=
         color: rgb(0, 0, 0);">
         <br>
      </div>
      <div id="testing_id">
         <div id="appendonsend"></div>
         <div style="font-family:Calibri,Helvetica,sans-serif; font-size:12pt; col=
            or:rgb(0,0,0)">
            <br>
         </div>
         <hr tabindex="-1" style="display:inline-block; width:98%">
         <div id="divRplyFwdMsg" dir="ltr">
            <font face="Calibri, sans-serif" color="#000000" style="font-size:11pt"><b>De :</b> test@example.com<br>
            <b>=C0 :</b> test@example.com &lt;test@example.com&gt;<br>
            <b>Objet :</b> Parent message</font>
            <div>&nbsp;</div>
         </div>
         <div>
            <div dir="ltr">Parent email body</div>
         </div>
      </div>
   </body>
</html>
"""

QUOTE_OUTLOOK_HTML_IN = [
    """Reply from outlook""",
    """<div id="mail_body">""",
]
QUOTE_OUTLOOK_HTML_OUT = [
    """<div id="testing_id" data-o-mail-quote-container="1">""",
    """<div id="divRplyFwdMsg" dir="ltr" data-o-mail-quote="1">""",
]


QUOTE_THUNDERBIRD_1 = u"""<div>On 11/08/2012 05:29 PM,
      <a href="mailto:dummy@example.com">dummy@example.com</a> wrote:<br></div>
    <blockquote>
      <div>I contact you about our meeting for tomorrow. Here is the
        schedule I propose:</div>
      <div>
        <ul><li>9 AM: brainstorming about our new amazing business
            app&lt;/span&gt;&lt;/li&gt;</li>
          <li>9.45 AM: summary</li>
          <li>10 AM: meeting with Fabien to present our app</li>
        </ul></div>
      <div>Is everything ok for you?</div>
      <div>
        <p>--<br>
          Administrator</p>
      </div>
      <div>
        <p>Log in our portal at:
<a href="http://localhost:8069#action=login&amp;db=mail_1&amp;token=rHdWcUART5PhEnJRaXjH">http://localhost:8069#action=login&amp;db=mail_1&amp;token=rHdWcUART5PhEnJRaXjH</a></p>
      </div>
    </blockquote>
    Ok for me. I am replying directly below your mail, using Thunderbird, with a signature.<br><br>
    Did you receive my email about my new laptop, by the way?<br><br>
    Raoul.<br><pre>-- 
Raoul Grosbedonn&#233;e
</pre>"""

QUOTE_THUNDERBIRD_1_IN = [
    u'<a href="mailto:dummy@example.com">dummy@example.com</a> ',
    u'<blockquote data-o-mail-quote-node="1" data-o-mail-quote="1">',
    u'Ok for me. I am replying directly below your mail, using Thunderbird, with a signature.']
QUOTE_THUNDERBIRD_1_OUT = [u"""-- 
Raoul Grosbedonnée
"""]

QUOTE_YAHOO_HTML = """
<html>
   <head></head>
   <body>
      <div class="ydpf6e951dcyahoo-style-wrap">
      <div></div>
      <div dir="ltr" data-setdir="false">Reply from Yahoo</div>
      </div>
      <div id="yahoo_quoted_8820595126" class="yahoo_quoted">
         <div style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:13px;color:#26282a;">
            =20
            <div>
               Bob a dit:
            </div>
            <div><br></div>
            <div><br></div>
            <div>
               <div id="yiv3215395356">
                  <div dir="ltr">Parent email body</div>
               </div>
            </div>
         </div>
      </div>
   </body>
</html>
"""

QUOTE_YAHOO_HTML_IN = [
    """Reply from Yahoo""",
    """<div dir="ltr" data-setdir="false">""",
    """<div class="ydpf6e951dcyahoo-style-wrap">""",
]
QUOTE_YAHOO_HTML_OUT = [
    """<div id="yahoo_quoted_8820595126" class="yahoo_quoted" data-o-mail-quote="1">""",
]


TEXT_1 = u"""I contact you about our meeting tomorrow. Here is the schedule I propose:
9 AM: brainstorming about our new amazing business app
9.45 AM: summary
10 AM: meeting with Ignasse to present our app
Is everything ok for you?
--
MySignature"""

TEXT_1_IN = [u"""I contact you about our meeting tomorrow. Here is the schedule I propose:
9 AM: brainstorming about our new amazing business app
9.45 AM: summary
10 AM: meeting with Ignasse to present our app
Is everything ok for you?"""]
TEXT_1_OUT = [u"""
--
MySignature"""]

TEXT_2 = u"""Salut Raoul!
Le 28 oct. 2012 à 00:02, Raoul Grosbedon a écrit :

> I contact you about our meeting tomorrow. Here is the schedule I propose: (quote)

Of course. This seems viable.

> 2012/10/27 Bert Tartopoils :
>> blahblahblah (quote)?
>> 
>> blahblahblah (quote)
>> 
>> Bert TARTOPOILS
>> bert.tartopoils@miam.miam
>> 
> 
> 
> -- 
> RaoulSignature

--
Bert TARTOPOILS
bert.tartopoils@miam.miam
"""

TEXT_2_IN = [u"Salut Raoul!", "Of course. This seems viable."]
TEXT_2_OUT = [u"""
> I contact you about our meeting tomorrow. Here is the schedule I propose: (quote)""",
"""
> 2012/10/27 Bert Tartopoils :
>> blahblahblah (quote)?
>> 
>> blahblahblah (quote)
>> 
>> Bert TARTOPOILS
>> bert.tartopoils@miam.miam
>> 
> 
> 
> -- 
> RaoulSignature"""]

# MISC

GMAIL_1 = u"""Hello,<div><br></div><div>Ok for me. I am replying directly in gmail, without signature.</div><div><br></div><div>Kind regards,</div><div><br></div><div>Demo.<br><br><div>On Thu, Nov 8, 2012 at 5:29 PM,  <span>&lt;<a href="mailto:dummy@example.com">dummy@example.com</a>&gt;</span> wrote:<br><blockquote><div>I contact you about our meeting for tomorrow. Here is the schedule I propose:</div><div><ul><li>9 AM: brainstorming about our new amazing business app&lt;/span&gt;&lt;/li&gt;</li>
<li>9.45 AM: summary</li><li>10 AM: meeting with Fabien to present our app</li></ul></div><div>Is everything ok for you?</div>
<div><p>-- <br>Administrator</p></div>

<div><p>Log in our portal at: <a href="http://localhost:8069#action=login&amp;db=mail_1&amp;login=demo">http://localhost:8069#action=login&amp;db=mail_1&amp;login=demo</a></p></div>
</blockquote></div><br></div>"""

GMAIL_1_IN = [u'Ok for me. I am replying directly in gmail, without signature.', '<blockquote data-o-mail-quote-node="1" data-o-mail-quote="1">']
GMAIL_1_OUT = []

HOTMAIL_1 = u"""<div>
    <div dir="ltr"><br>
        I have an amazing company, i'm learning OpenERP, it is a small company yet, but plannig to grow up quickly.
        <br><br>Kindest regards,<br>xxx<br>
        <div>
            <div id="SkyDrivePlaceholder">
            </div>
            <hr id="stopSpelling">
            Subject: Re: your OpenERP.com registration<br>From: xxx@xxx.xxx<br>To: xxx@xxx.xxx<br>Date: Wed, 27 Mar 2013 17:12:12 +0000
            <br><br>
            Hello xxx,
            <br>
            I noticed you recently created an OpenERP.com account to access OpenERP Apps.
            <br>
            You indicated that you wish to use OpenERP in your own company.
            We would like to know more about your your business needs and requirements, and see how
            we can help you. When would you be available to discuss your project?<br>
            Best regards,<br>
            <pre>
                <a href="http://openerp.com" target="_blank">http://openerp.com</a>
                Belgium: +32.81.81.37.00
                U.S.: +1 (650) 307-6736
                India: +91 (79) 40 500 100
            </pre>
        </div>
    </div>
</div>"""
HOTMAIL_1_IN = [u"""<div dir="ltr"><br>
        I have an amazing company, i'm learning OpenERP, it is a small company yet, but plannig to grow up quickly.
        <br><br>Kindest regards,<br>xxx<br>"""]
HOTMAIL_1_OUT = [
    u"""<hr id="stopSpelling" data-o-mail-quote="1">""",
    u"""<pre data-o-mail-quote="1">
                <a href="http://openerp.com" target="_blank" data-o-mail-quote="1">http://openerp.com</a>
                Belgium: +32.81.81.37.00
                U.S.: +1 (650) 307-6736
                India: +91 (79) 40 500 100
            </pre>"""]

MSOFFICE_1 = u"""
<div>
<div class="WordSection1">
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
                Our requirements are simple. Just looking to replace some spreadsheets for tracking quotes and possibly using the timecard module.
                We are a company of 25 engineers providing product design services to clients.
            </span>
        </p>
        <p></p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
                I’ll install on a windows server and run a very limited trial to see how it works.
                If we adopt OpenERP we will probably move to Linux or look for a hosted SaaS option.
            </span>
        </p>
        <p></p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
                <br>
                I am also evaluating Adempiere and maybe others.
            </span>
        </p>
        <p></p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
            </span>
        </p>
        <p>&nbsp;</p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
                I expect the trial will take 2-3 months as this is not a high priority for us.
            </span>
        </p>
        <p></p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
            </span>
        </p>
        <p>&nbsp;</p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
                Alan
            </span>
        </p>
        <p></p>
        <p></p>
        <p class="MsoNormal">
            <span style="font-size:11.0pt;font-family:&quot;Calibri&quot;,&quot;sans-serif&quot;;color:#1F497D">
            </span>
        </p>
        <p>&nbsp;</p>
        <p></p>
        <div>
            <div style="border:none;border-top:solid #B5C4DF 1.0pt;padding:3.0pt 0in 0in 0in">
                <p class="MsoNormal">
                    <b><span style="font-size:10.0pt;font-family:&quot;Tahoma&quot;,&quot;sans-serif&quot;">
                        From:
                    </span></b>
                    <span style="font-size:10.0pt;font-family:&quot;Tahoma&quot;,&quot;sans-serif&quot;">
                        OpenERP Enterprise [mailto:sales@openerp.com]
                        <br><b>Sent:</b> Monday, 11 March, 2013 14:47<br><b>To:</b> Alan Widmer<br><b>Subject:</b> Re: your OpenERP.com registration
                    </span>
                </p>
                <p></p>
                <p></p>
            </div>
        </div>
        <p class="MsoNormal"></p>
        <p>&nbsp;</p>
        <p>Hello Alan Widmer, </p>
        <p></p>
        <p>I noticed you recently downloaded OpenERP. </p>
        <p></p>
        <p>
            Uou mentioned you wish to use OpenERP in your own company. Please let me more about your
            business needs and requirements? When will you be available to discuss about your project?
        </p>
        <p></p>
        <p>Thanks for your interest in OpenERP, </p>
        <p></p>
        <p>Feel free to contact me if you have any questions, </p>
        <p></p>
        <p>Looking forward to hear from you soon. </p>
        <p></p>
        <pre><p>&nbsp;</p></pre>
        <pre>--<p></p></pre>
        <pre>Nicolas<p></p></pre>
        <pre><a href="http://openerp.com">http://openerp.com</a><p></p></pre>
        <pre>Belgium: +32.81.81.37.00<p></p></pre>
        <pre>U.S.: +1 (650) 307-6736<p></p></pre>
        <pre>India: +91 (79) 40 500 100<p></p></pre>
        <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p></p></pre>
    </div>
</div>"""

MSOFFICE_1_IN = [u'Our requirements are simple. Just looking to replace some spreadsheets for tracking quotes and possibly using the timecard module.']
MSOFFICE_1_OUT = [u'I noticed you recently downloaded OpenERP.', 'Uou mentioned you wish to use OpenERP in your own company.', 'Belgium: +32.81.81.37.00']


# ------------------------------------------------------------
# Test cases coming from bugs
# ------------------------------------------------------------

# bug: read more not apparent, strange message in read more span
BUG1 = u"""<pre>Hi Migration Team,

Paragraph 1, blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah.

Paragraph 2, blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah.

Paragraph 3, blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah blah blah blah blah blah blah 
blah blah blah blah blah blah blah blah.

Thanks.

Regards,

-- 
Olivier Laurent
Migration Manager
OpenERP SA
Chaussée de Namur, 40
B-1367 Gérompont
Tel: +32.81.81.37.00
Web: http://www.openerp.com</pre>"""

BUG_1_IN = [
    u'Hi Migration Team',
    u'Paragraph 1'
]
BUG_1_OUT = [u"""
-- 
Olivier Laurent
Migration Manager
OpenERP SA
Chaussée de Namur, 40
B-1367 Gérompont
Tel: +32.81.81.37.00
Web: http://www.openerp.com"""]


REMOVE_CLASS = u"""
<div style="FONT-SIZE: 12pt; FONT-FAMILY: 'Times New Roman'; COLOR: #000000">
    <div>Hello</div>
    <div>I have just installed Odoo 9 and I've got the following error:</div>
    <div>&nbsp;</div>
    <div class="openerp openerp_webclient_container oe_webclient">
        <div class="oe_loading" style="DISPLAY: none">&nbsp;</div>
    </div>
    <div class="modal-backdrop in"></div>
    <div role="dialog" tabindex="-1" aria-hidden="false" class="modal in" style="DISPLAY: block" data-backdrop="static">
        <div class="modal-dialog modal-lg">
            <div class="modal-content openerp">
                <div class="modal-header"> 
                    <h4 class="modal-title">Odoo Error<span class="o_subtitle text-muted"></span></h4>
                </div>
                <div class="o_error_detail modal-body">
                    <pre>An error occurred in a modal and I will send you back the html to try opening one on your end</pre>
                </div>
            </div>
        </div>
    </div>
</div>
"""
REMOVE_CLASS_IN = [
    u'<div style="font-size:12pt; font-family:\'Times New Roman\'; color:#000000">',
    u'An error occurred in a modal and I will send you back the html to try opening one on your end']
REMOVE_CLASS_OUT = [
    u'<div class="modal-backdrop in">',
    u'<div class="modal-content openerp">',
    u'<div class="modal-header">']

```

  File: tests/test_menu.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase


class TestMenu(TransactionCase):

    def test_00_menu_deletion(self):
        """Verify that menu deletion works properly when there are child menus, and those
           are indeed made orphans"""
        Menu = self.env['ir.ui.menu']
        root = Menu.create({'name': 'Test root'})
        child1 = Menu.create({'name': 'Test child 1', 'parent_id': root.id})
        child2 = Menu.create({'name': 'Test child 2', 'parent_id': root.id})
        child21 = Menu.create({'name': 'Test child 2-1', 'parent_id': child2.id})
        all_ids = [root.id, child1.id, child2.id, child21.id]

        # delete and check that direct children are promoted to top-level
        # cfr. explanation in menu.unlink()
        root.unlink()

        # Generic trick necessary for search() calls to avoid hidden menus 
        Menu = self.env['ir.ui.menu'].with_context({'ir.ui.menu.full_list': True})

        remaining = Menu.search([('id', 'in', all_ids)], order="id")
        self.assertEqual([child1.id, child2.id, child21.id], remaining.ids)

        orphans =  Menu.search([('id', 'in', all_ids), ('parent_id', '=', False)], order="id")
        self.assertEqual([child1.id, child2.id], orphans.ids)

```

  File: tests/test_mimetypes.py
  Content:
```
import base64
import unittest

try:
    import magic
except ImportError:
    magic = None

from odoo.tests.common import BaseCase
from odoo.tools.mimetypes import get_extension, guess_mimetype

PNG = b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVQI12P4//8/AAX+Av7czFnnAAAAAElFTkSuQmCC'
GIF = b"R0lGODdhAQABAIAAAP///////ywAAAAAAQABAAACAkQBADs="
BMP = b"""Qk1+AAAAAAAAAHoAAABsAAAAAQAAAAEAAAABABgAAAAAAAQAAAATCwAAEwsAAAAAAAAAAAAAQkdScwAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAD///8A"""
JPG = """/9j/4AAQSkZJRgABAQEASABIAAD//gATQ3JlYXRlZCB3aXRoIEdJTVD/2wBDAP
//////////////////////////////////////////////////////////////////////////////////////2wBDAf///////
///////////////////////////////////////////////////////////////////////////////wgARCAABAAEDAREAAhEB
AxEB/8QAFAABAAAAAAAAAAAAAAAAAAAAAv/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAUf/xAAUEAEAAAAAAAA
AAAAAAAAAAAAA/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/AX//xAAUEQEAAAAAAAAAAAAAAAAAAA
AA/9oACAECAQE/AX//xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBAAY/An//xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBA
AE/IX//2gAMAwEAAgADAAAAEB//xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDAQE/EH//xAAUEQEAAAAAAAAAAAAAAAAAAAAA
/9oACAECAQE/EH//xAAUEAEAAAAAAAAAAAAAAAAAAAAA/9oACAEBAAE/EH//2Q=="""
SVG = b"""PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMjAwMDExMDIvL0VOIlxuICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL0NSLVNWRy0yMDAwMTEwMi9EVEQvc3ZnLTIwMDAxMTAyLmR0ZCI+PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MCw1MCkiPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNTAiIGhlaWdodD0iNTAiIHN0eWxlPSJmaWxsOnJlZDsiIC8+PC9nPjwvc3ZnPg=="""
NAMESPACED_SVG = b"""<svg:svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <svg:rect x="10" y="10" width="80" height="80" fill="green" />
</svg:svg>"""

# single pixel webp image
WEBP = b"""UklGRjoAAABXRUJQVlA4IC4AAAAwAQCdASoBAAEAAUAmJaAAA3AA/u/uY//8s//2W/7LeM///5Bj
/dl/pJxGAAAA"""

# minimal zip file with an empty `t.txt` file
ZIP = b"""UEsDBBQACAAIAGFva1AAAAAAAAAAAAAAAAAFACAAdC50eHRVVA0AB5bgaF6W4GheluBoXnV4CwABBOgDAAAE6AMAAA
MAUEsHCAAAAAACAAAAAAAAAFBLAQIUAxQACAAIAGFva1AAAAAAAgAAAAAAAAAFACAAAAAAAAAAAACkgQAAAAB0LnR4dFVUDQAHlu
BoXpbgaF6W4GhedXgLAAEE6AMAAAToAwAAUEsFBgAAAAABAAEAUwAAAFUAAAAAAA=="""

XML = b"""<?xml version='1.0' encoding='utf-8'?>
<Document xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:iso:std:iso:20022:tech:xsd:pain.001.001.03">
  <CstmrCdtTrfInitn>
    <GrpHdr>
      <MsgId>123456Odoo S.A.893873733</MsgId>
      <CreDtTm>2018-11-21T09:47:32</CreDtTm>
      <NbOfTxs>0</NbOfTxs>
      <CtrlSum>0.0</CtrlSum>
      <InitgPty>
        <Nm>Odoo S.A.</Nm>
        <Id>
          <OrgId>
            <Othr>
              <Id>BE0477472701</Id>
              <Issr>KBO-BCE</Issr>
            </Othr>
          </OrgId>
        </Id>
      </InitgPty>
    </GrpHdr>
  </CstmrCdtTrfInitn>
</Document>
"""

class test_guess_mimetype(BaseCase):

    def test_default_mimetype_empty(self):
        mimetype = guess_mimetype(b'')
        # odoo implementation returns application/octet-stream by default
        # if available, python-magic returns application/x-empty
        self.assertIn(mimetype, ('application/octet-stream', 'application/x-empty'))

    def test_default_mimetype(self):
        mimetype = guess_mimetype(b'', default='test')
        # if available, python-magic returns application/x-empty
        self.assertIn(mimetype, ('test', 'application/x-empty'))

    def test_mimetype_octet_stream(self):
        mimetype = guess_mimetype(b'\0')
        self.assertEqual(mimetype, 'application/octet-stream')

    def test_mimetype_png(self):
        content = base64.b64decode(PNG)
        mimetype = guess_mimetype(content, default='test')
        self.assertEqual(mimetype, 'image/png')

    def test_mimetype_bmp(self):
        content = base64.b64decode(BMP)
        mimetype = guess_mimetype(content, default='test')
        # mimetype should match image/bmp, image/x-ms-bmp, ...
        self.assertRegex(mimetype, r'image/.*\bbmp')

    def test_mimetype_jpg(self):
        content = base64.b64decode(JPG)
        mimetype = guess_mimetype(content, default='test')
        self.assertEqual(mimetype, 'image/jpeg')

    def test_mimetype_gif(self):
        content = base64.b64decode(GIF)
        mimetype = guess_mimetype(content, default='test')
        self.assertEqual(mimetype, 'image/gif')

    def test_mimetype_svg(self):
        content = base64.b64decode(SVG)
        mimetype = guess_mimetype(content, default='test')
        self.assertTrue(mimetype.startswith('image/svg'))

        mimetype = guess_mimetype(NAMESPACED_SVG, default='test')
        self.assertTrue(mimetype.startswith('image/svg'))
        # Tests that whitespace padded SVG are not detected as SVG in odoo implementation
        if not magic:
            mimetype = guess_mimetype(b"   " + content, default='test')
            self.assertNotIn("svg", mimetype)


    def test_mimetype_webp(self):
        content = base64.b64decode(WEBP)
        mimetype = guess_mimetype(content, default='test')
        self.assertEqual(mimetype, 'image/webp')

    def test_mimetype_zip(self):
        content = base64.b64decode(ZIP)
        mimetype = guess_mimetype(content, default='test')
        self.assertEqual(mimetype, 'application/zip')

    def test_mimetype_xml(self):
        mimetype = guess_mimetype(XML, default='test')
        self.assertEqual(mimetype, 'application/xml')

    def test_mimetype_get_extension(self):
        self.assertEqual(get_extension('filename.Abc'), '.abc')
        self.assertEqual(get_extension('filename.scss'), '.scss')
        self.assertEqual(get_extension('filename.torrent'), '.torrent')
        self.assertEqual(get_extension('.htaccess'), '')
        # enough to suppose that extension is present and don't suffix the filename
        self.assertEqual(get_extension('filename.tar.gz'), '.gz')
        self.assertEqual(get_extension('filename'), '')
        self.assertEqual(get_extension('filename.'), '')
        self.assertEqual(get_extension('filename.not_alnum'), '')
        self.assertEqual(get_extension('filename.with space'), '')
        self.assertEqual(get_extension('filename.notAnExtension'), '')

```

  File: tests/test_misc.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import datetime
from dateutil.relativedelta import relativedelta
import os.path
import pytz

from odoo.tools import (
    config,
    date_utils,
    file_open,
    file_path,
    merge_sequences,
    misc,
    remove_accents,
    validate_url,
)
from odoo.tests.common import TransactionCase, BaseCase


class TestCountingStream(BaseCase):
    def test_empty_stream(self):
        s = misc.CountingStream(iter([]))
        self.assertEqual(s.index, -1)
        self.assertIsNone(next(s, None))
        self.assertEqual(s.index, 0)

    def test_single(self):
        s = misc.CountingStream(range(1))
        self.assertEqual(s.index, -1)
        self.assertEqual(next(s, None), 0)
        self.assertIsNone(next(s, None))
        self.assertEqual(s.index, 1)

    def test_full(self):
        s = misc.CountingStream(range(42))
        for _ in s:
            pass
        self.assertEqual(s.index, 42)

    def test_repeated(self):
        """ Once the CountingStream has stopped iterating, the index should not
        increase anymore (the internal state should not be allowed to change)
        """
        s = misc.CountingStream(iter([]))
        self.assertIsNone(next(s, None))
        self.assertEqual(s.index, 0)
        self.assertIsNone(next(s, None))
        self.assertEqual(s.index, 0)


class TestMergeSequences(BaseCase):
    def test_merge_sequences(self):
        # base case
        seq = merge_sequences(['A', 'B', 'C'])
        self.assertEqual(seq, ['A', 'B', 'C'])

        # 'Z' can be anywhere
        seq = merge_sequences(['A', 'B', 'C'], ['Z'])
        self.assertEqual(seq, ['A', 'B', 'C', 'Z'])

        # 'Y' must precede 'C';
        seq = merge_sequences(['A', 'B', 'C'], ['Y', 'C'])
        self.assertEqual(seq, ['A', 'B', 'Y', 'C'])

        # 'X' must follow 'A' and precede 'C'
        seq = merge_sequences(['A', 'B', 'C'], ['A', 'X', 'C'])
        self.assertEqual(seq, ['A', 'B', 'X', 'C'])

        # all cases combined
        seq = merge_sequences(
            ['A', 'B', 'C'],
            ['Z'],                  # 'Z' can be anywhere
            ['Y', 'C'],             # 'Y' must precede 'C';
            ['A', 'X', 'Y'],        # 'X' must follow 'A' and precede 'Y'
        )
        self.assertEqual(seq, ['A', 'B', 'X', 'Y', 'C', 'Z'])


class TestDateRangeFunction(BaseCase):
    """ Test on date_range generator. """

    def test_date_range_with_naive_datetimes(self):
        """ Check date_range with naive datetimes. """
        start = datetime.datetime(1985, 1, 1)
        end = datetime.datetime(1986, 1, 1)

        expected = [
            datetime.datetime(1985, 1, 1, 0, 0),
            datetime.datetime(1985, 2, 1, 0, 0),
            datetime.datetime(1985, 3, 1, 0, 0),
            datetime.datetime(1985, 4, 1, 0, 0),
            datetime.datetime(1985, 5, 1, 0, 0),
            datetime.datetime(1985, 6, 1, 0, 0),
            datetime.datetime(1985, 7, 1, 0, 0),
            datetime.datetime(1985, 8, 1, 0, 0),
            datetime.datetime(1985, 9, 1, 0, 0),
            datetime.datetime(1985, 10, 1, 0, 0),
            datetime.datetime(1985, 11, 1, 0, 0),
            datetime.datetime(1985, 12, 1, 0, 0),
            datetime.datetime(1986, 1, 1, 0, 0)
        ]

        dates = [date for date in date_utils.date_range(start, end)]

        self.assertEqual(dates, expected)

    def test_date_range_with_date(self):
        """ Check date_range with naive datetimes. """
        start = datetime.date(1985, 1, 1)
        end = datetime.date(1986, 1, 1)

        expected = [
            datetime.date(1985, 1, 1),
            datetime.date(1985, 2, 1),
            datetime.date(1985, 3, 1),
            datetime.date(1985, 4, 1),
            datetime.date(1985, 5, 1),
            datetime.date(1985, 6, 1),
            datetime.date(1985, 7, 1),
            datetime.date(1985, 8, 1),
            datetime.date(1985, 9, 1),
            datetime.date(1985, 10, 1),
            datetime.date(1985, 11, 1),
            datetime.date(1985, 12, 1),
            datetime.date(1986, 1, 1),
        ]

        self.assertEqual(list(date_utils.date_range(start, end)), expected)

    def test_date_range_with_timezone_aware_datetimes_other_than_utc(self):
        """ Check date_range with timezone-aware datetimes other than UTC."""
        timezone = pytz.timezone('Europe/Brussels')

        start = datetime.datetime(1985, 1, 1)
        end = datetime.datetime(1986, 1, 1)
        start = timezone.localize(start)
        end = timezone.localize(end)

        expected = [datetime.datetime(1985, 1, 1, 0, 0),
                    datetime.datetime(1985, 2, 1, 0, 0),
                    datetime.datetime(1985, 3, 1, 0, 0),
                    datetime.datetime(1985, 4, 1, 0, 0),
                    datetime.datetime(1985, 5, 1, 0, 0),
                    datetime.datetime(1985, 6, 1, 0, 0),
                    datetime.datetime(1985, 7, 1, 0, 0),
                    datetime.datetime(1985, 8, 1, 0, 0),
                    datetime.datetime(1985, 9, 1, 0, 0),
                    datetime.datetime(1985, 10, 1, 0, 0),
                    datetime.datetime(1985, 11, 1, 0, 0),
                    datetime.datetime(1985, 12, 1, 0, 0),
                    datetime.datetime(1986, 1, 1, 0, 0)]

        expected = [timezone.localize(e) for e in expected]

        dates = [date for date in date_utils.date_range(start, end)]

        self.assertEqual(expected, dates)

    def test_date_range_with_mismatching_zones(self):
        """ Check date_range with mismatching zone should raise an exception."""
        start_timezone = pytz.timezone('Europe/Brussels')
        end_timezone = pytz.timezone('America/Recife')

        start = datetime.datetime(1985, 1, 1)
        end = datetime.datetime(1986, 1, 1)
        start = start_timezone.localize(start)
        end = end_timezone.localize(end)

        with self.assertRaises(ValueError):
            dates = [date for date in date_utils.date_range(start, end)]

    def test_date_range_with_inconsistent_datetimes(self):
        """ Check date_range with a timezone-aware datetime and a naive one."""
        context_timezone = pytz.timezone('Europe/Brussels')

        start = datetime.datetime(1985, 1, 1)
        end = datetime.datetime(1986, 1, 1)
        end = context_timezone.localize(end)

        with self.assertRaises(ValueError):
            dates = [date for date in date_utils.date_range(start, end)]

    def test_date_range_with_hour(self):
        """ Test date range with hour and naive datetime."""
        start = datetime.datetime(2018, 3, 25)
        end = datetime.datetime(2018, 3, 26)
        step = relativedelta(hours=1)

        expected = [
            datetime.datetime(2018, 3, 25, 0, 0),
            datetime.datetime(2018, 3, 25, 1, 0),
            datetime.datetime(2018, 3, 25, 2, 0),
            datetime.datetime(2018, 3, 25, 3, 0),
            datetime.datetime(2018, 3, 25, 4, 0),
            datetime.datetime(2018, 3, 25, 5, 0),
            datetime.datetime(2018, 3, 25, 6, 0),
            datetime.datetime(2018, 3, 25, 7, 0),
            datetime.datetime(2018, 3, 25, 8, 0),
            datetime.datetime(2018, 3, 25, 9, 0),
            datetime.datetime(2018, 3, 25, 10, 0),
            datetime.datetime(2018, 3, 25, 11, 0),
            datetime.datetime(2018, 3, 25, 12, 0),
            datetime.datetime(2018, 3, 25, 13, 0),
            datetime.datetime(2018, 3, 25, 14, 0),
            datetime.datetime(2018, 3, 25, 15, 0),
            datetime.datetime(2018, 3, 25, 16, 0),
            datetime.datetime(2018, 3, 25, 17, 0),
            datetime.datetime(2018, 3, 25, 18, 0),
            datetime.datetime(2018, 3, 25, 19, 0),
            datetime.datetime(2018, 3, 25, 20, 0),
            datetime.datetime(2018, 3, 25, 21, 0),
            datetime.datetime(2018, 3, 25, 22, 0),
            datetime.datetime(2018, 3, 25, 23, 0),
            datetime.datetime(2018, 3, 26, 0, 0)
        ]

        dates = [date for date in date_utils.date_range(start, end, step)]

        self.assertEqual(dates, expected)


class TestFormatLangDate(TransactionCase):
    def test_00_accepted_types(self):
        self.env.user.tz = 'Europe/Brussels'
        datetime_str = '2017-01-31 12:00:00'
        date_datetime = datetime.datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")
        date_date = date_datetime.date()
        date_str = '2017-01-31'
        time_part = datetime.time(16, 30, 22)
        t_medium = 'h:mm:ss a'
        medium = f'MMM d, YYYY, {t_medium}'

        self.assertEqual(misc.format_date(self.env, date_datetime), '01/31/2017')
        self.assertEqual(misc.format_date(self.env, date_date), '01/31/2017')
        self.assertEqual(misc.format_date(self.env, date_str), '01/31/2017')
        self.assertEqual(misc.format_date(self.env, ''), '')
        self.assertEqual(misc.format_date(self.env, False), '')
        self.assertEqual(misc.format_date(self.env, None), '')

        self.assertEqual(misc.format_datetime(self.env, date_datetime, dt_format=medium), 'Jan 31, 2017, 1:00:00 PM')
        self.assertEqual(misc.format_datetime(self.env, datetime_str, dt_format=medium), 'Jan 31, 2017, 1:00:00 PM')
        self.assertEqual(misc.format_datetime(self.env, '', dt_format=medium), '')
        self.assertEqual(misc.format_datetime(self.env, False, dt_format=medium), '')
        self.assertEqual(misc.format_datetime(self.env, None, dt_format=medium), '')

        self.assertEqual(misc.format_time(self.env, time_part, time_format=t_medium), '4:30:22 PM')
        self.assertEqual(misc.format_time(self.env, '', time_format=t_medium), '')
        self.assertEqual(misc.format_time(self.env, False, time_format=t_medium), '')
        self.assertEqual(misc.format_time(self.env, None, time_format=t_medium), '')

    def test_01_code_and_format(self):
        date_str = '2017-01-31'
        lang = self.env['res.lang']

        # Activate French and Simplified Chinese (test with non-ASCII characters)
        lang._activate_lang('fr_FR')
        lang._activate_lang('zh_CN')

        # -- test `date`
        # Change a single parameter
        self.assertEqual(misc.format_date(lang.with_context(lang='fr_FR').env, date_str), '31/01/2017')
        self.assertEqual(misc.format_date(lang.env, date_str, lang_code='fr_FR'), '31/01/2017')
        self.assertEqual(misc.format_date(lang.env, date_str, date_format='MMM d, y'), 'Jan 31, 2017')

        # Change 2 parameters
        self.assertEqual(misc.format_date(lang.with_context(lang='zh_CN').env, date_str, lang_code='fr_FR'), '31/01/2017')
        self.assertEqual(misc.format_date(lang.with_context(lang='zh_CN').env, date_str, date_format='MMM d, y'), u'1\u6708 31, 2017')
        self.assertEqual(misc.format_date(lang.env, date_str, lang_code='fr_FR', date_format='MMM d, y'), 'janv. 31, 2017')

        # Change 3 parameters
        self.assertEqual(misc.format_date(lang.with_context(lang='zh_CN').env, date_str, lang_code='en_US', date_format='MMM d, y'), 'Jan 31, 2017')

        # -- test `datetime`
        datetime_str = '2017-01-31 10:33:00'
        # Change languages and timezones
        datetime_us_str = misc.format_datetime(lang.with_context(lang='en_US').env, datetime_str, tz='Europe/Brussels')
        self.assertNotEqual(misc.format_datetime(lang.with_context(lang='fr_FR').env, datetime_str, tz='Europe/Brussels'), datetime_us_str)
        self.assertNotEqual(misc.format_datetime(lang.with_context(lang='zh_CN').env, datetime_str, tz='America/New_York'), datetime_us_str)

        # Change language, timezone and format
        self.assertEqual(misc.format_datetime(lang.with_context(lang='fr_FR').env, datetime_str, tz='America/New_York', dt_format='dd/MM/YYYY HH:mm'), '31/01/2017 05:33')
        self.assertEqual(misc.format_datetime(lang.with_context(lang='en_US').env, datetime_str, tz='Europe/Brussels', dt_format='MMM d, y'), 'Jan 31, 2017')

        # Check given `lang_code` overwites context lang
        fmt_fr = 'dd MMMM YYYY à HH:mm:ss Z'
        fmt_us = "MMMM dd, YYYY 'at' hh:mm:ss a Z"
        self.assertEqual(misc.format_datetime(lang.env, datetime_str, tz='Europe/Brussels', dt_format=fmt_fr, lang_code='fr_FR'), '31 janvier 2017 à 11:33:00 +0100')
        self.assertEqual(misc.format_datetime(lang.with_context(lang='zh_CN').env, datetime_str, tz='Europe/Brussels', dt_format=fmt_us, lang_code='en_US'), 'January 31, 2017 at 11:33:00 AM +0100')

        # -- test `time`
        time_part = datetime.time(16, 30, 22)
        time_part_tz = datetime.time(16, 30, 22, tzinfo=pytz.timezone('America/New_York'))  # 4:30 PM timezoned

        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, time_part, time_format='HH:mm:ss'), '16:30:22')
        self.assertEqual(misc.format_time(lang.with_context(lang='zh_CN').env, time_part, time_format="ah:m:ss"), '\u4e0b\u53484:30:22')

        # Check format in different languages
        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, time_part, time_format='HH:mm'), '16:30')
        self.assertEqual(misc.format_time(lang.with_context(lang='zh_CN').env, time_part, time_format='ah:mm'), '\u4e0b\u53484:30')

        # Check timezoned time part
        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, time_part_tz, time_format='HH:mm:ss Z'), '16:30:22 -0504')
        self.assertEqual(misc.format_time(lang.with_context(lang='zh_CN').env, time_part_tz, time_format='zzzz ah:mm:ss'), '\u5317\u7f8e\u4e1c\u90e8\u6807\u51c6\u65f6\u95f4\u0020\u4e0b\u53484:30:22')

        #Check timezone conversion in format_time
        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, datetime_str, 'Europe/Brussels', time_format='HH:mm:ss Z'), '11:33:00 +0100')
        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, datetime_str, 'America/New_York', time_format='HH:mm:ss Z'), '05:33:00 -0500')

        # Check given `lang_code` overwites context lang
        self.assertEqual(misc.format_time(lang.with_context(lang='fr_FR').env, time_part, time_format='ah:mm', lang_code='zh_CN'), '\u4e0b\u53484:30')
        self.assertEqual(misc.format_time(lang.with_context(lang='zh_CN').env, time_part, time_format='ah:mm', lang_code='fr_FR'), 'PM4:30')

    def test_02_tz(self):
        self.env.user.tz = 'Europe/Brussels'
        datetime_str = '2016-12-31 23:55:00'
        date_datetime = datetime.datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")

        # While London is still in 2016, Brussels is already in 2017
        self.assertEqual(misc.format_date(self.env, date_datetime), '01/01/2017')

        # Force London timezone
        date_datetime = date_datetime.replace(tzinfo=pytz.UTC)
        self.assertEqual(misc.format_date(self.env, date_datetime), '12/31/2016', "User's tz must be ignored when tz is specifed in datetime object")


class TestCallbacks(BaseCase):
    def test_callback(self):
        log = []
        callbacks = misc.Callbacks()

        # add foo
        def foo():
            log.append("foo")

        callbacks.add(foo)

        # add bar
        @callbacks.add
        def bar():
            log.append("bar")

        # add foo again
        callbacks.add(foo)

        # this should call foo(), bar(), foo()
        callbacks.run()
        self.assertEqual(log, ["foo", "bar", "foo"])

        # this should do nothing
        callbacks.run()
        self.assertEqual(log, ["foo", "bar", "foo"])

    def test_aggregate(self):
        log = []
        callbacks = misc.Callbacks()

        # register foo once
        @callbacks.add
        def foo():
            log.append(callbacks.data["foo"])

        # aggregate data
        callbacks.data.setdefault("foo", []).append(1)
        callbacks.data.setdefault("foo", []).append(2)
        callbacks.data.setdefault("foo", []).append(3)

        # foo() is called once
        callbacks.run()
        self.assertEqual(log, [[1, 2, 3]])
        self.assertFalse(callbacks.data)

        callbacks.run()
        self.assertEqual(log, [[1, 2, 3]])

    def test_reentrant(self):
        log = []
        callbacks = misc.Callbacks()

        # register foo that runs callbacks
        @callbacks.add
        def foo():
            log.append("foo1")
            callbacks.run()
            log.append("foo2")

        @callbacks.add
        def bar():
            log.append("bar")

        # both foo() and bar() are called once
        callbacks.run()
        self.assertEqual(log, ["foo1", "bar", "foo2"])

        callbacks.run()
        self.assertEqual(log, ["foo1", "bar", "foo2"])


class TestRemoveAccents(BaseCase):
    def test_empty_string(self):
        self.assertEqual(remove_accents(False), False)
        self.assertEqual(remove_accents(''), '')
        self.assertEqual(remove_accents(None), None)

    def test_latin(self):
        self.assertEqual(remove_accents('Niño Hernández'), 'Nino Hernandez')
        self.assertEqual(remove_accents('Anaïs Clémence'), 'Anais Clemence')

    def test_non_latin(self):
        self.assertEqual(remove_accents('العربية'), 'العربية')
        self.assertEqual(remove_accents('русский алфавит'), 'русскии алфавит')


class TestAddonsFileAccess(BaseCase):

    def assertCannotAccess(self, path, ExceptionType=FileNotFoundError, filter_ext=None):
        with self.assertRaises(ExceptionType):
            file_path(path, filter_ext=filter_ext)

    def assertCanRead(self, path, needle='', mode='r', filter_ext=None):
        with file_open(path, mode, filter_ext) as f:
            self.assertIn(needle, f.read())

    def assertCannotRead(self, path, ExceptionType=FileNotFoundError, filter_ext=None):
        with self.assertRaises(ExceptionType):
            file_open(path, filter_ext=filter_ext)

    def test_file_path(self):
        # absolute path
        self.assertEqual(__file__, file_path(__file__))
        self.assertEqual(__file__, file_path(__file__, filter_ext=None)) # means "no filter" too
        self.assertEqual(__file__, file_path(__file__, filter_ext=('.py',)))

        # directory target is ok
        self.assertEqual(os.path.dirname(__file__), file_path(os.path.join(__file__, '..')))

        # relative path
        relpath = os.path.join(*(__file__.split(os.sep)[-3:])) # 'base/tests/test_misc.py'
        self.assertEqual(__file__, file_path(relpath))
        self.assertEqual(__file__, file_path(relpath, filter_ext=('.py',)))

        # leading 'addons/' is ignored if present
        self.assertTrue(file_path("addons/web/__init__.py"))
        relpath = os.path.join('addons', relpath) # 'addons/base/tests/test_misc.py'
        self.assertEqual(__file__, file_path(relpath))

        # files in root_path are allowed
        self.assertTrue(file_path('tools/misc.py'))

        # errors when outside addons_paths
        self.assertCannotAccess('/doesnt/exist')
        self.assertCannotAccess('/tmp')
        self.assertCannotAccess('../../../../../../../../../tmp')
        self.assertCannotAccess(os.path.join(__file__, '../../../../../'))

        # data_dir is forbidden
        self.assertCannotAccess(config['data_dir'])

        # errors for illegal extensions
        self.assertCannotAccess(__file__, ValueError, filter_ext=('.png',))
        # file doesnt exist but has wrong extension
        self.assertCannotAccess(__file__.replace('.py', '.foo'), ValueError, filter_ext=('.png',))

    def test_file_open(self):
        # The needle includes UTF8 so we test reading non-ASCII files at the same time.
        # This depends on the system locale and is harder to unit test, but if you manage to run the
        # test with a non-UTF8 locale (`LC_ALL=fr_FR.iso8859-1 python3...`) it should not crash ;-)
        test_needle = "A needle with non-ascii bytes: ♥"

        # absolute path
        self.assertCanRead(__file__, test_needle)
        self.assertCanRead(__file__, test_needle.encode(), mode='rb')
        self.assertCanRead(__file__, test_needle.encode(), mode='rb', filter_ext=('.py',))

        # directory target *is* an error
        with self.assertRaises(FileNotFoundError):
            file_open(os.path.join(__file__, '..'))

        # relative path
        relpath = os.path.join(*(__file__.split(os.sep)[-3:])) # 'base/tests/test_misc.py'
        self.assertCanRead(relpath, test_needle)
        self.assertCanRead(relpath, test_needle.encode(), mode='rb')
        self.assertCanRead(relpath, test_needle.encode(), mode='rb', filter_ext=('.py',))

        # leading 'addons/' is ignored if present
        self.assertCanRead("addons/web/__init__.py", "import")
        relpath = os.path.join('addons', relpath) # 'addons/base/tests/test_misc.py'
        self.assertCanRead(relpath, test_needle)

        # files in root_path are allowed
        self.assertCanRead('tools/misc.py')

        # errors when outside addons_paths
        self.assertCannotRead('/doesnt/exist')
        self.assertCannotRead('')
        self.assertCannotRead('/tmp')
        self.assertCannotRead('../../../../../../../../../tmp')
        self.assertCannotRead(os.path.join(__file__, '../../../../../'))

        # data_dir is forbidden
        self.assertCannotRead(config['data_dir'])

        # errors for illegal extensions
        self.assertCannotRead(__file__, ValueError, filter_ext=('.png',))
        # file doesnt exist but has wrong extension
        self.assertCannotRead(__file__.replace('.py', '.foo'), ValueError, filter_ext=('.png',))


class TestDictTools(BaseCase):
    def test_readonly_dict(self):
        d = misc.ReadonlyDict({'foo': 'bar'})
        with self.assertRaises(TypeError):
            d['baz'] = 'xyz'
        with self.assertRaises(AttributeError):
            d.update({'baz': 'xyz'})
        with self.assertRaises(TypeError):
            dict.update(d, {'baz': 'xyz'})


class TestFormatLang(TransactionCase):
    def test_value_and_digits(self):
        self.assertEqual(misc.formatLang(self.env, 100.23, digits=1), '100.2')
        self.assertEqual(misc.formatLang(self.env, 100.23, digits=3), '100.230')

        self.assertEqual(misc.formatLang(self.env, ''), '', 'If value is an empty string, it should return an empty string (not 0)')

        self.assertEqual(misc.formatLang(self.env, 100), '100.00', 'If digits is None (default value), it should default to 2')

        # Default rounding is 'HALF_EVEN'
        self.assertEqual(misc.formatLang(self.env, 100.205), '100.20')
        self.assertEqual(misc.formatLang(self.env, 100.215), '100.22')

    def test_grouping(self):
        self.env["res.lang"].create({
            "name": "formatLang Lang",
            "code": "fLT",
            "grouping": "[3,2,-1]",
            "decimal_point": "!",
            "thousands_sep": "?",
        })

        self.env['res.lang']._activate_lang('fLT')

        self.assertEqual(misc.formatLang(self.env['res.lang'].with_context(lang='fLT').env, 1000000000, grouping=True), '10000?00?000!00')
        self.assertEqual(misc.formatLang(self.env['res.lang'].with_context(lang='fLT').env, 1000000000, grouping=False), '1000000000.00')

    def test_decimal_precision(self):
        decimal_precision = self.env['decimal.precision'].create({
            'name': 'formatLang Decimal Precision',
            'digits': 3,  # We want .001 decimals to make sure the decimal precision parameter 'dp' is chosen.
        })

        self.assertEqual(misc.formatLang(self.env, 100, dp=decimal_precision.name), '100.000')

    def test_currency_object(self):
        currency_object = self.env['res.currency'].create({
            'name': 'formatLang Currency',
            'symbol': 'fL',
            'rounding': 0.1,  # We want .1 decimals to make sure 'currency_obj' is chosen.
            'position': 'after',
        })

        self.assertEqual(misc.formatLang(self.env, 100, currency_obj=currency_object), '100.0%sfL' % u'\N{NO-BREAK SPACE}')

        currency_object.write({'position': 'before'})

        self.assertEqual(misc.formatLang(self.env, 100, currency_obj=currency_object), 'fL%s100.0' % u'\N{NO-BREAK SPACE}')

    def test_decimal_precision_and_currency_object(self):
        decimal_precision = self.env['decimal.precision'].create({
            'name': 'formatLang Decimal Precision',
            'digits': 3,
        })

        currency_object = self.env['res.currency'].create({
            'name': 'formatLang Currency',
            'symbol': 'fL',
            'rounding': 0.1,
            'position': 'after',
        })

        # If we have a 'dp' and 'currency_obj', we use the decimal precision of 'dp' and the format of 'currency_obj'.
        self.assertEqual(misc.formatLang(self.env, 100, dp=decimal_precision.name, currency_obj=currency_object), '100.000%sfL' % u'\N{NO-BREAK SPACE}')

    def test_rounding_method(self):
        self.assertEqual(misc.formatLang(self.env, 100.205), '100.20')  # Default is 'HALF-EVEN'
        self.assertEqual(misc.formatLang(self.env, 100.215), '100.22')  # Default is 'HALF-EVEN'

        self.assertEqual(misc.formatLang(self.env, 100.205, rounding_method='HALF-UP'), '100.21')
        self.assertEqual(misc.formatLang(self.env, 100.215, rounding_method='HALF-UP'), '100.22')

        self.assertEqual(misc.formatLang(self.env, 100.205, rounding_method='HALF-DOWN'), '100.20')
        self.assertEqual(misc.formatLang(self.env, 100.215, rounding_method='HALF-DOWN'), '100.21')

    def test_rounding_unit(self):
        self.assertEqual(misc.formatLang(self.env, 1000000.00), '1,000,000.00')
        self.assertEqual(misc.formatLang(self.env, 1000000.00, rounding_unit='units'), '1,000,000')
        self.assertEqual(misc.formatLang(self.env, 1000000.00, rounding_unit='thousands'), '1,000')
        self.assertEqual(misc.formatLang(self.env, 1000000.00, rounding_unit='lakhs'), '10')
        self.assertEqual(misc.formatLang(self.env, 1000000.00, rounding_unit="millions"), '1')

    def test_rounding_method_and_rounding_unit(self):
        self.assertEqual(misc.formatLang(self.env, 1822060000, rounding_method='HALF-UP', rounding_unit='lakhs'), '18,221')
        self.assertEqual(misc.formatLang(self.env, 1822050000, rounding_method='HALF-UP', rounding_unit='lakhs'), '18,221')
        self.assertEqual(misc.formatLang(self.env, 1822049900, rounding_method='HALF-UP', rounding_unit='lakhs'), '18,220')


class TestUrlValidate(BaseCase):
    def test_url_validate(self):
        for case, truth in [
            # full URLs should be preserved
            ('http://example.com', 'http://example.com'),
            ('http://example.com/index.html', 'http://example.com/index.html'),
            ('http://example.com?debug=1', 'http://example.com?debug=1'),
            ('http://example.com#h3', 'http://example.com#h3'),

            # URLs with a domain should get a http scheme
            ('example.com', 'http://example.com'),
            ('example.com/index.html', 'http://example.com/index.html'),
            ('example.com?debug=1', 'http://example.com?debug=1'),
            ('example.com#h3', 'http://example.com#h3'),
        ]:
            with self.subTest(case=case):
                self.assertEqual(validate_url(case), truth)

        # broken cases, do we really want that?
        self.assertEqual(validate_url('/index.html'), 'http:///index.html')
        self.assertEqual(validate_url('?debug=1'), 'http://?debug=1')
        self.assertEqual(validate_url('#model=project.task&id=3603607'), 'http://#model=project.task&id=3603607')

```

  File: tests/test_module.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import os.path
import tempfile
from os.path import join as opj
from unittest.mock import patch

import odoo.addons
from odoo.modules.module import load_manifest
from odoo.modules.module import get_manifest
from odoo.release import major_version
from odoo.tests.common import BaseCase


class TestModuleManifest(BaseCase):
    @classmethod
    def setUpClass(cls):
        cls._tmp_dir = tempfile.TemporaryDirectory(prefix='odoo-test-addons-')
        cls.addClassCleanup(cls._tmp_dir.cleanup)
        cls.addons_path = cls._tmp_dir.name

        patcher = patch.object(odoo.addons, '__path__', [cls.addons_path])
        cls.startClassPatcher(patcher)

    def setUp(self):
        self.module_root = tempfile.mkdtemp(prefix='odoo-test-module-', dir=self.addons_path)
        self.module_name = os.path.basename(self.module_root)

    def test_default_manifest(self):
        with open(opj(self.module_root, '__manifest__.py'), 'w') as file:
            file.write(str({'name': f'Temp {self.module_name}', 'license': 'MIT'}))

        with self.assertNoLogs('odoo.modules.module', 'WARNING'):
            manifest = load_manifest(self.module_name)

        self.maxDiff = None
        self.assertDictEqual(manifest, {
            'addons_path': self.addons_path,
            'application': False,
            'assets': {},
            'author': 'Odoo S.A.',
            'auto_install': False,
            'bootstrap': False,
            'category': 'Uncategorized',
            'configurator_snippets': {},
            'countries': [],
            'data': [],
            'demo': [],
            'demo_xml': [],
            'depends': [],
            'description': '',
            'external_dependencies': {},
            'icon': '/base/static/description/icon.png',
            'init_xml': [],
            'installable': True,
            'images': [],
            'images_preview_theme': {},
            'license': 'MIT',
            'live_test_url': '',
            'name': f'Temp {self.module_name}',
            'new_page_templates': {},
            'post_init_hook': '',
            'post_load': '',
            'pre_init_hook': '',
            'sequence': 100,
            'summary': '',
            'test': [],
            'update_xml': [],
            'uninstall_hook': '',
            'version': f'{major_version}.1.0',
            'web': False,
            'website': '',
        })

    def test_change_manifest(self):
        module_name = 'base'
        new_manifest = get_manifest(module_name)
        orig_auto_install = new_manifest['auto_install']
        new_manifest['auto_install'] = not orig_auto_install
        self.assertNotEqual(new_manifest, get_manifest(module_name))
        self.assertEqual(orig_auto_install, get_manifest(module_name)['auto_install'])

    def test_missing_manifest(self):
        with self.assertLogs('odoo.modules.module', 'DEBUG') as capture:
            manifest = load_manifest(self.module_name)
        self.assertEqual(manifest, {})
        self.assertIn("no manifest file found", capture.output[0])

    def test_missing_license(self):
        with open(opj(self.module_root, '__manifest__.py'), 'w') as file:
            file.write(str({'name': f'Temp {self.module_name}'}))
        with self.assertLogs('odoo.modules.module', 'WARNING') as capture:
            manifest = load_manifest(self.module_name)
        self.assertEqual(manifest['license'], 'LGPL-3')
        self.assertIn("Missing `license` key", capture.output[0])

```

  File: tests/test_neutralize.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.modules import neutralize

from odoo.tests import tagged
from odoo.tests.common import TransactionCase


@tagged('post_install', '-at_install', 'neutralize')
class TestNeutralize(TransactionCase):
    def test_10_neutralize(self):
        """ Simply testing that none of the SQL neutralize crashes """
        installed_modules = neutralize.get_installed_modules(self.cr)
        queries = neutralize.get_neutralization_queries(installed_modules)
        for query in queries:
            self.cr.execute(query)

```

  File: tests/test_num2words_ar.py
  Content:
```
from num2words import num2words

from odoo.tests.common import TransactionCase


class TestNum2WordsAr(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

    def test_multiple_of_thousands(self):
        """Test num2words function with a multiple of thousands number."""
        thousand = num2words(1234, lang="ar")
        million = num2words(1234567, lang="ar")
        billion = num2words(1234567890, lang="ar")

        self.assertEqual(thousand, "ألف و مئتان و أربعة و ثلاثون")
        self.assertEqual(
            million, "مليون و مئتان و أربعة و ثلاثون ألفاً و خمسمائة و سبعة و ستون")
        self.assertEqual(
            billion, "مليار و مئتان و أربعة و ثلاثون مليوناً و خمسمائة و سبعة و ستون ألفاً و ثمانمائة و تسعون")

    def test_decimal_multiple_of_thousands(self):
        """Test num2words function with a multiple of thousands number."""
        thousand = num2words(1234.1, lang="ar")
        million = num2words(1234567.23, lang="ar")
        billion = num2words(1234567890.9, lang="ar")

        self.assertEqual(thousand, "ألف و مئتان و أربعة و ثلاثون  , عشر")
        self.assertEqual(
            million, "مليون و مئتان و أربعة و ثلاثون ألفاً و خمسمائة و سبعة و ستون  , ثلاث و عشرون")
        self.assertEqual(
            billion, "مليار و مئتان و أربعة و ثلاثون مليوناً و خمسمائة و سبعة و ستون ألفاً و ثمانمائة و تسعون  , تسعون")

```

  File: tests/test_orm.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from collections import defaultdict

import psycopg2

from odoo.exceptions import AccessError, MissingError
from odoo.tests.common import TransactionCase
from odoo.tools import mute_logger
from odoo import Command


class TestORM(TransactionCase):
    """ test special behaviors of ORM CRUD functions """

    @mute_logger('odoo.models')
    def test_access_deleted_records(self):
        """ Verify that accessing deleted records works as expected """
        c1 = self.env['res.partner.category'].create({'name': 'W'})
        c2 = self.env['res.partner.category'].create({'name': 'Y'})
        c1.unlink()

        # read() is expected to skip deleted records because our API is not
        # transactional for a sequence of search()->read() performed from the
        # client-side... a concurrent deletion could therefore cause spurious
        # exceptions even when simply opening a list view!
        # /!\ Using unprileged user to detect former side effects of ir.rules!
        user = self.env['res.users'].create({
            'name': 'test user',
            'login': 'test2',
            'groups_id': [Command.set([self.ref('base.group_user')])],
        })
        cs = (c1 + c2).with_user(user)
        self.assertEqual([{'id': c2.id, 'name': 'Y'}], cs.read(['name']), "read() should skip deleted records")
        self.assertEqual([], cs[0].read(['name']), "read() should skip deleted records")

        # Deleting an already deleted record should be simply ignored
        self.assertTrue(c1.unlink(), "Re-deleting should be a no-op")

    @mute_logger('odoo.models')
    def test_access_partial_deletion(self):
        """ Check accessing a record from a recordset where another record has been deleted. """
        Model = self.env['res.country']
        self.assertTrue(type(Model).display_name.automatic, "test assumption not satisfied")

        # access regular field when another record from the same prefetch set has been deleted
        records = Model.create([{'name': name[0], 'code': name[1]} for name in (['Foo', 'ZV'], ['Bar', 'ZX'], ['Baz', 'ZY'])])
        for record in records:
            record.name
            record.unlink()

        # access computed field when another record from the same prefetch set has been deleted
        records = Model.create([{'name': name[0], 'code': name[1]} for name in (['Foo', 'ZV'], ['Bar', 'ZX'], ['Baz', 'ZY'])])
        for record in records:
            record.display_name
            record.unlink()

    @mute_logger('odoo.models', 'odoo.addons.base.models.ir_rule')
    def test_access_filtered_records(self):
        """ Verify that accessing filtered records works as expected for non-admin user """
        p1 = self.env['res.partner'].create({'name': 'W'})
        p2 = self.env['res.partner'].create({'name': 'Y'})
        user = self.env['res.users'].create({
            'name': 'test user',
            'login': 'test2',
            'groups_id': [Command.set([self.ref('base.group_user')])],
        })

        partner_model = self.env['ir.model'].search([('model','=','res.partner')])
        self.env['ir.rule'].create({
            'name': 'Y is invisible',
            'domain_force': [('id', '!=', p1.id)],
            'model_id': partner_model.id,
        })

        # search as unprivileged user
        partners = self.env['res.partner'].with_user(user).search([])
        self.assertNotIn(p1, partners, "W should not be visible...")
        self.assertIn(p2, partners, "... but Y should be visible")

        # read as unprivileged user
        with self.assertRaises(AccessError):
            p1.with_user(user).read(['name'])
        # write as unprivileged user
        with self.assertRaises(AccessError):
            p1.with_user(user).write({'name': 'foo'})
        # unlink as unprivileged user
        with self.assertRaises(AccessError):
            p1.with_user(user).unlink()

        # Prepare mixed case 
        p2.unlink()
        # read mixed records: some deleted and some filtered
        with self.assertRaises(AccessError):
            (p1 + p2).with_user(user).read(['name'])
        # delete mixed records: some deleted and some filtered
        with self.assertRaises(AccessError):
            (p1 + p2).with_user(user).unlink()

    def test_read(self):
        partner = self.env['res.partner'].create({'name': 'MyPartner1'})
        result = partner.read()
        self.assertIsInstance(result, list)

    @mute_logger('odoo.models')
    def test_search_read(self):
        partner = self.env['res.partner']

        # simple search_read
        partner.create({'name': 'MyPartner1'})
        found = partner.search_read([('name', '=', 'MyPartner1')], ['name'])
        self.assertEqual(len(found), 1)
        self.assertEqual(found[0]['name'], 'MyPartner1')
        self.assertIn('id', found[0])

        # search_read correct order
        partner.create({'name': 'MyPartner2'})
        found = partner.search_read([('name', 'like', 'MyPartner')], ['name'], order="name")
        self.assertEqual(len(found), 2)
        self.assertEqual(found[0]['name'], 'MyPartner1')
        self.assertEqual(found[1]['name'], 'MyPartner2')
        found = partner.search_read([('name', 'like', 'MyPartner')], ['name'], order="name desc")
        self.assertEqual(len(found), 2)
        self.assertEqual(found[0]['name'], 'MyPartner2')
        self.assertEqual(found[1]['name'], 'MyPartner1')

        # search_read that finds nothing
        found = partner.search_read([('name', '=', 'Does not exists')], ['name'])
        self.assertEqual(len(found), 0)

        # search_read with an empty array of fields
        found = partner.search_read([], [], limit=1)
        self.assertEqual(len(found), 1)
        self.assertTrue(field in list(found[0]) for field in ['id', 'name', 'display_name', 'email'])

        # search_read without fields
        found = partner.search_read([], False, limit=1)
        self.assertEqual(len(found), 1)
        self.assertTrue(field in list(found[0]) for field in ['id', 'name', 'display_name', 'email'])

    @mute_logger('odoo.sql_db')
    def test_exists(self):
        partner = self.env['res.partner']

        # check that records obtained from search exist
        recs = partner.search([])
        self.assertTrue(recs)
        self.assertEqual(recs.exists(), recs)

        # check that new records exist by convention
        recs = partner.new({})
        self.assertTrue(recs.exists())

        # check that there is no record with id 0
        recs = partner.browse([0])
        self.assertFalse(recs.exists())

    def test_groupby_date(self):
        partners_data = dict(
            A='2012-11-19',
            B='2012-12-17',
            C='2012-12-31',
            D='2013-01-07',
            E='2013-01-14',
            F='2013-01-28',
            G='2013-02-11',
        )

        partner_ids = []
        partner_ids_by_day = defaultdict(list)
        partner_ids_by_month = defaultdict(list)
        partner_ids_by_year = defaultdict(list)

        partners = self.env['res.partner']
        for name, date in partners_data.items():
            p = partners.create(dict(name=name, date=date))
            partner_ids.append(p.id)
            partner_ids_by_day[date].append(p.id)
            partner_ids_by_month[date.rsplit('-', 1)[0]].append(p.id)
            partner_ids_by_year[date.split('-', 1)[0]].append(p.id)

        def read_group(interval):
            domain = [('id', 'in', partner_ids)]
            result = {}
            for grp in partners.read_group(domain, ['date'], ['date:' + interval]):
                result[grp['date:' + interval]] = partners.search(grp['__domain'])
            return result

        self.assertEqual(len(read_group('day')), len(partner_ids_by_day))
        self.assertEqual(len(read_group('month')), len(partner_ids_by_month))
        self.assertEqual(len(read_group('year')), len(partner_ids_by_year))

        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
                                  ['date:month', 'date:day'], lazy=False)
        self.assertEqual(len(res), len(partner_ids))

        # combine groupby and orderby
        months = ['February 2013', 'January 2013', 'December 2012', 'November 2012']
        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
                                  groupby=['date:month'], orderby='date:month DESC')
        self.assertEqual([item['date:month'] for item in res], months)

        # order by date should reorder by date:month
        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
                                  groupby=['date:month'], orderby='date DESC')
        self.assertEqual([item['date:month'] for item in res], months)

        # order by date should reorder by date:day
        days = ['11 Feb 2013', '28 Jan 2013', '14 Jan 2013', '07 Jan 2013',
                '31 Dec 2012', '17 Dec 2012', '19 Nov 2012']
        res = partners.read_group([('id', 'in', partner_ids)], ['date'],
                                  groupby=['date:month', 'date:day'],
                                  orderby='date DESC', lazy=False)
        self.assertEqual([item['date:day'] for item in res], days)

    def test_write_duplicate(self):
        p1 = self.env['res.partner'].create({'name': 'W'})
        (p1 + p1).write({'name': 'X'})

    def test_m2m_store_trigger(self):
        group_user = self.env.ref('base.group_user')

        user = self.env['res.users'].create({
            'name': 'test',
            'login': 'test_m2m_store_trigger',
            'groups_id': [Command.set([])],
        })
        self.assertTrue(user.share)

        group_user.write({'users': [Command.link(user.id)]})
        self.assertFalse(user.share)

        group_user.write({'users': [Command.unlink(user.id)]})
        self.assertTrue(user.share)

    @mute_logger('odoo.models')
    def test_unlink_with_property(self):
        """ Verify that unlink removes the related ir.property as unprivileged user """
        user = self.env['res.users'].create({
            'name': 'Justine Bridou',
            'login': 'saucisson',
            'groups_id': [Command.set([self.ref('base.group_partner_manager')])],
        })
        p1 = self.env['res.partner'].with_user(user).create({'name': 'Zorro'})
        self.env['ir.property'].with_user(user)._set_multi("ref", "res.partner", {p1.id: "Nain poilu"})
        p1_prop = self.env['ir.property'].with_user(user)._get("ref", "res.partner", res_id=p1.id)
        self.assertEqual(
            p1_prop, "Nain poilu", 'p1_prop should have been created')

        # Unlink with unprivileged user
        p1.unlink()

        # ir.property is deleted
        p1_prop = self.env['ir.property'].with_user(user)._get("ref", "res.partner", res_id=p1.id)
        self.assertEqual(
            p1_prop, False, 'p1_prop should have been deleted')

    def test_create_multi(self):
        """ create for multiple records """
        # assumption: 'res.bank' does not override 'create'
        vals_list = [{'name': name} for name in ('Foo', 'Bar', 'Baz')]
        vals_list[0]['email'] = 'foo@example.com'
        for vals in vals_list:
            record = self.env['res.bank'].create(vals)
            self.assertEqual(len(record), 1)
            self.assertEqual(record.name, vals['name'])
            self.assertEqual(record.email, vals.get('email', False))

        records = self.env['res.bank'].create([])
        self.assertFalse(records)

        records = self.env['res.bank'].create(vals_list)
        self.assertEqual(len(records), len(vals_list))
        for record, vals in zip(records, vals_list):
            self.assertEqual(record.name, vals['name'])
            self.assertEqual(record.email, vals.get('email', False))

        # create countries and states
        vals_list = [{
            'name': 'Foo',
            'state_ids': [
                Command.create({'name': 'North Foo', 'code': 'NF'}),
                Command.create({'name': 'South Foo', 'code': 'SF'}),
                Command.create({'name': 'West Foo', 'code': 'WF'}),
                Command.create({'name': 'East Foo', 'code': 'EF'}),
            ],
            'code': 'ZV',
        }, {
            'name': 'Bar',
            'state_ids': [
                Command.create({'name': 'North Bar', 'code': 'NB'}),
                Command.create({'name': 'South Bar', 'code': 'SB'}),
            ],
            'code': 'ZX',
        }]
        foo, bar = self.env['res.country'].create(vals_list)
        self.assertEqual(foo.name, 'Foo')
        self.assertCountEqual(foo.mapped('state_ids.code'), ['NF', 'SF', 'WF', 'EF'])
        self.assertEqual(bar.name, 'Bar')
        self.assertCountEqual(bar.mapped('state_ids.code'), ['NB', 'SB'])


class TestInherits(TransactionCase):
    """ test the behavior of the orm for models that use _inherits;
        specifically: res.users, that inherits from res.partner
    """

    def test_default(self):
        """ `default_get` cannot return a dictionary or a new id """
        defaults = self.env['res.users'].default_get(['partner_id'])
        if 'partner_id' in defaults:
            self.assertIsInstance(defaults['partner_id'], (bool, int))

    def test_create(self):
        """ creating a user should automatically create a new partner """
        partners_before = self.env['res.partner'].search([])
        user_foo = self.env['res.users'].create({'name': 'Foo', 'login': 'foo'})

        self.assertNotIn(user_foo.partner_id, partners_before)

    def test_create_with_ancestor(self):
        """ creating a user with a specific 'partner_id' should not create a new partner """
        partner_foo = self.env['res.partner'].create({'name': 'Foo'})
        partners_before = self.env['res.partner'].search([])
        user_foo = self.env['res.users'].create({'partner_id': partner_foo.id, 'login': 'foo'})
        partners_after = self.env['res.partner'].search([])

        self.assertEqual(partners_before, partners_after)
        self.assertEqual(user_foo.name, 'Foo')
        self.assertEqual(user_foo.partner_id, partner_foo)

    @mute_logger('odoo.models')
    def test_read(self):
        """ inherited fields should be read without any indirection """
        user_foo = self.env['res.users'].create({'name': 'Foo', 'login': 'foo'})
        user_values, = user_foo.read()
        partner_values, = user_foo.partner_id.read()

        self.assertEqual(user_values['name'], partner_values['name'])
        self.assertEqual(user_foo.name, user_foo.partner_id.name)

    @mute_logger('odoo.models')
    def test_copy(self):
        """ copying a user should automatically copy its partner, too """
        user_foo = self.env['res.users'].create({
            'name': 'Foo',
            'login': 'foo',
            'employee': True,
        })
        foo_before, = user_foo.read()
        del foo_before['create_date']
        del foo_before['write_date']
        user_bar = user_foo.copy({'login': 'bar'})
        foo_after, = user_foo.read()
        del foo_after['create_date']
        del foo_after['write_date']
        self.assertEqual(foo_before, foo_after)

        self.assertEqual(user_bar.name, 'Foo (copy)')
        self.assertEqual(user_bar.login, 'bar')
        self.assertEqual(user_foo.employee, user_bar.employee)
        self.assertNotEqual(user_foo.id, user_bar.id)
        self.assertNotEqual(user_foo.partner_id.id, user_bar.partner_id.id)

    @mute_logger('odoo.models')
    def test_copy_with_ancestor(self):
        """ copying a user with 'parent_id' in defaults should not duplicate the partner """
        user_foo = self.env['res.users'].create({'login': 'foo', 'name': 'Foo', 'signature': 'Foo'})
        partner_bar = self.env['res.partner'].create({'name': 'Bar'})

        foo_before, = user_foo.read()
        del foo_before['create_date']
        del foo_before['write_date']
        del foo_before['login_date']
        partners_before = self.env['res.partner'].search([])
        user_bar = user_foo.copy({'partner_id': partner_bar.id, 'login': 'bar'})
        foo_after, = user_foo.read()
        del foo_after['create_date']
        del foo_after['write_date']
        del foo_after['login_date']
        partners_after = self.env['res.partner'].search([])

        self.assertEqual(foo_before, foo_after)
        self.assertEqual(partners_before, partners_after)

        self.assertNotEqual(user_foo.id, user_bar.id)
        self.assertEqual(user_bar.partner_id.id, partner_bar.id)
        self.assertEqual(user_bar.login, 'bar', "login is given from copy parameters")
        self.assertFalse(user_bar.password, "password should not be copied from original record")
        self.assertEqual(user_bar.name, 'Bar', "name is given from specific partner")
        self.assertEqual(user_bar.signature, user_foo.signature, "signature should be copied")

    @mute_logger('odoo.models')
    def test_write_date(self):
        """ modifying inherited fields must update write_date """
        user = self.env.user
        write_date_before = user.write_date

        # write base64 image
        user.write({'image_1920': 'R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='})
        write_date_after = user.write_date
        self.assertNotEqual(write_date_before, write_date_after)

```

  File: tests/test_ormcache.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo.tools import get_cache_key_counter
from threading import Thread, Barrier

class TestOrmcache(TransactionCase):
    def test_ormcache(self):
        """ Test the effectiveness of the ormcache() decorator. """
        IMD = self.env['ir.model.data']
        XMLID = 'base.group_no_one'

        # retrieve the cache, its key and stat counter
        cache, key, counter = get_cache_key_counter(IMD._xmlid_lookup, XMLID)
        hit = counter.hit
        miss = counter.miss

        # clear the caches of ir.model.data, retrieve its key and
        self.env.registry.clear_cache()
        self.assertNotIn(key, cache)

        # lookup some reference
        self.env.ref(XMLID)
        self.assertEqual(counter.hit, hit)
        self.assertEqual(counter.miss, miss + 1)
        self.assertIn(key, cache)

        # lookup again
        self.env.ref(XMLID)
        self.assertEqual(counter.hit, hit + 1)
        self.assertEqual(counter.miss, miss + 1)
        self.assertIn(key, cache)

        # lookup again
        self.env.ref(XMLID)
        self.assertEqual(counter.hit, hit + 2)
        self.assertEqual(counter.miss, miss + 1)
        self.assertIn(key, cache)

    def test_invalidation(self):
        self.assertEqual(self.env.registry.cache_invalidated, set())
        self.env.registry.clear_cache()
        self.env.registry.clear_cache('templates')
        self.assertEqual(self.env.registry.cache_invalidated, {'default', 'templates'})
        self.env.registry.reset_changes()
        self.assertEqual(self.env.registry.cache_invalidated, set())
        self.env.registry.clear_cache('assets')
        self.assertEqual(self.env.registry.cache_invalidated, {'assets'})
        self.env.registry.reset_changes()
        self.assertEqual(self.env.registry.cache_invalidated, set())

    def test_invalidation_thread_local(self):
        # this test ensures that the registry.cache_invalidated set is thread local

        caches = ['default', 'templates', 'assets']
        nb_treads = len(caches)

        # use barriers to ensure threads synchronization
        sync_clear_cache = Barrier(nb_treads, timeout=5)
        sync_assert_equal = Barrier(nb_treads, timeout=5)
        sync_reset = Barrier(nb_treads, timeout=5)

        operations = []
        def run(cache):
            self.assertEqual(self.env.registry.cache_invalidated, set())

            self.env.registry.clear_cache(cache)
            operations.append('clear_cache')
            sync_clear_cache.wait()

            self.assertEqual(self.env.registry.cache_invalidated, {cache})
            operations.append('assert_contains')
            sync_assert_equal.wait()

            self.env.registry.reset_changes()
            operations.append('reset_changes')
            sync_reset.wait()

            self.assertEqual(self.env.registry.cache_invalidated, set())
            operations.append('assert_empty')

        # run all threads
        threads = []
        for cache in caches:
            threads.append(Thread(target=run, args=(cache,)))
        for thread in threads:
            thread.start()
        for thread in threads:
            thread.join()

        # ensure that the threads operations where executed in the expected order
        self.assertEqual(
            operations,
            ['clear_cache'] * nb_treads +
            ['assert_contains'] * nb_treads +
            ['reset_changes'] * nb_treads +
            ['assert_empty'] * nb_treads
        )

    def test_signaling_01_single(self):
        self.assertFalse(self.registry.test_cr)
        self.registry.cache_invalidated.clear()
        registry = self.registry
        old_sequences = dict(registry.cache_sequences)
        with self.assertLogs('odoo.modules.registry') as logs:
            registry.cache_invalidated.add('assets')
            self.assertEqual(registry.cache_invalidated, {'assets'})
            registry.signal_changes()
            self.assertFalse(registry.cache_invalidated)

        self.assertEqual(
            logs.output,
            ["INFO:odoo.modules.registry:Caches invalidated, signaling through the database: ['assets']"],
        )

        for key, value in old_sequences.items():
            if key == 'assets':
                self.assertEqual(value + 1, registry.cache_sequences[key], "Assets cache sequence should have changed")
            else:
                self.assertEqual(value, registry.cache_sequences[key], "other registry sequence shouldn't have changed")

        with self.assertNoLogs(None, None):  # the registry sequence should be up to date on the same worker
            registry.check_signaling()

        # simulate other worker state

        registry.cache_sequences.update(old_sequences)

        with self.assertLogs() as logs:
            registry.check_signaling()
        self.assertEqual(
            logs.output,
            ["INFO:odoo.modules.registry:Invalidating caches after database signaling: ['assets', 'templates.cached_values']"],
        )

    def test_signaling_01_multiple(self):
        self.assertFalse(self.registry.test_cr)
        self.registry.cache_invalidated.clear()
        registry = self.registry
        old_sequences = dict(registry.cache_sequences)
        with self.assertLogs('odoo.modules.registry') as logs:
            registry.cache_invalidated.add('assets')
            registry.cache_invalidated.add('default')
            self.assertEqual(registry.cache_invalidated, {'assets', 'default'})
            registry.signal_changes()
            self.assertFalse(registry.cache_invalidated)

        self.assertEqual(
            logs.output,
            [
                "INFO:odoo.modules.registry:Caches invalidated, signaling through the database: ['assets', 'default']",
            ],
        )

        for key, value in old_sequences.items():
            if key in ('assets', 'default'):
                self.assertEqual(value + 1, registry.cache_sequences[key], "Assets and default cache sequence should have changed")
            else:
                self.assertEqual(value, registry.cache_sequences[key], "other registry sequence shouldn't have changed")

        with self.assertNoLogs(None, None):  # the registry sequence should be up to date on the same worker
            registry.check_signaling()

        # simulate other worker state

        registry.cache_sequences.update(old_sequences)

        with self.assertLogs() as logs:
            registry.check_signaling()
        self.assertEqual(
            logs.output,
            ["INFO:odoo.modules.registry:Invalidating caches after database signaling: ['assets', 'default', 'templates.cached_values']"],
        )

```

  File: tests/test_osv.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import BaseCase, TransactionCase
from odoo.tools import Query


class QueryTestCase(BaseCase):

    def test_basic_query(self):
        query = Query(None, 'product_product')
        query.add_table('product_template')
        query.add_where("product_product.template_id = product_template.id")
        # add inner join
        alias = query.join("product_template", "categ_id", "product_category", "id", "categ_id")
        self.assertEqual(alias, 'product_template__categ_id')
        # add left join
        alias = query.left_join("product_product", "user_id", "res_user", "id", "user_id")
        self.assertEqual(alias, 'product_product__user_id')

        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause,
            '"product_product", "product_template" JOIN "product_category" AS "product_template__categ_id" ON ("product_template"."categ_id" = "product_template__categ_id"."id") LEFT JOIN "res_user" AS "product_product__user_id" ON ("product_product"."user_id" = "product_product__user_id"."id")')
        self.assertEqual(where_clause, "product_product.template_id = product_template.id")

    def test_query_chained_explicit_joins(self):
        query = Query(None, 'product_product')
        query.add_table('product_template')
        query.add_where("product_product.template_id = product_template.id")
        # add inner join
        alias = query.join("product_template", "categ_id", "product_category", "id", "categ_id")
        self.assertEqual(alias, 'product_template__categ_id')
        # add CHAINED left join
        alias = query.left_join("product_template__categ_id", "user_id", "res_user", "id", "user_id")
        self.assertEqual(alias, 'product_template__categ_id__user_id')

        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause,
            '"product_product", "product_template" JOIN "product_category" AS "product_template__categ_id" ON ("product_template"."categ_id" = "product_template__categ_id"."id") LEFT JOIN "res_user" AS "product_template__categ_id__user_id" ON ("product_template__categ_id"."user_id" = "product_template__categ_id__user_id"."id")')
        self.assertEqual(where_clause, "product_product.template_id = product_template.id")

    def test_mixed_query_chained_explicit_implicit_joins(self):
        query = Query(None, 'product_product')
        query.add_table('product_template')
        query.add_where("product_product.template_id = product_template.id")
        # add inner join
        alias = query.join("product_template", "categ_id", "product_category", "id", "categ_id")
        self.assertEqual(alias, 'product_template__categ_id')
        # add CHAINED left join
        alias = query.left_join("product_template__categ_id", "user_id", "res_user", "id", "user_id")
        self.assertEqual(alias, 'product_template__categ_id__user_id')
        # additional implicit join
        query.add_table('account_account')
        query.add_where("product_category.expense_account_id = account_account.id")

        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause,
            '"product_product", "product_template", "account_account" JOIN "product_category" AS "product_template__categ_id" ON ("product_template"."categ_id" = "product_template__categ_id"."id") LEFT JOIN "res_user" AS "product_template__categ_id__user_id" ON ("product_template__categ_id"."user_id" = "product_template__categ_id__user_id"."id")')
        self.assertEqual(where_clause, "product_product.template_id = product_template.id AND product_category.expense_account_id = account_account.id")

    def test_raise_missing_lhs(self):
        query = Query(None, 'product_product')
        with self.assertRaises(AssertionError):
            query.join("product_template", "categ_id", "product_category", "id", "categ_id")

    def test_long_aliases(self):
        query = Query(None, 'product_product')
        tmp = query.join('product_product', 'product_tmpl_id', 'product_template', 'id', 'product_tmpl_id')
        self.assertEqual(tmp, 'product_product__product_tmpl_id')
        # no hashing
        tmp_cat = query.join(tmp, 'product_category_id', 'product_category', 'id', 'product_category_id')
        self.assertEqual(tmp_cat, 'product_product__product_tmpl_id__product_category_id')
        # hashing to limit identifier length
        tmp_cat_cmp = query.join(tmp_cat, 'company_id', 'res_company', 'id', 'company_id')
        self.assertEqual(tmp_cat_cmp, 'product_product__product_tmpl_id__product_category_id__9f0ddff7')
        tmp_cat_stm = query.join(tmp_cat, 'salesteam_id', 'res_company', 'id', 'salesteam_id')
        self.assertEqual(tmp_cat_stm, 'product_product__product_tmpl_id__product_category_id__953a466f')
        # extend hashed identifiers
        tmp_cat_cmp_par = query.join(tmp_cat_cmp, 'partner_id', 'res_partner', 'id', 'partner_id')
        self.assertEqual(tmp_cat_cmp_par, 'product_product__product_tmpl_id__product_category_id__56d55687')
        tmp_cat_stm_par = query.join(tmp_cat_stm, 'partner_id', 'res_partner', 'id', 'partner_id')
        self.assertEqual(tmp_cat_stm_par, 'product_product__product_tmpl_id__product_category_id__00363fdd')

    def test_table_expression(self):
        query = Query(None, 'foo')
        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause, '"foo"')

        query = Query(None, 'bar', 'SELECT id FROM foo')
        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause, '(SELECT id FROM foo) AS "bar"')

        query = Query(None, 'foo')
        query.add_table('bar', 'SELECT id FROM foo')
        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause, '"foo", (SELECT id FROM foo) AS "bar"')

        query = Query(None, 'foo')
        query.join('foo', 'bar_id', 'SELECT id FROM foo', 'id', 'bar')
        from_clause, where_clause, where_params = query.get_sql()
        self.assertEqual(from_clause, '"foo" JOIN (SELECT id FROM foo) AS "foo__bar" ON ("foo"."bar_id" = "foo__bar"."id")')


class TestQuery(TransactionCase):
    def test_auto(self):
        model = self.env['res.partner.category']
        model.create([{'name': 'Test Category 1'}, {'name': 'Test Category 2'}])
        query = model._search([])
        self.assertIsInstance(query, Query)

        ids = list(query)
        self.assertGreater(len(ids), 1)

    def test_records_as_query(self):
        records = self.env['res.partner.category']
        query = records._as_query()
        self.assertEqual(list(query), records.ids)
        self.cr.execute(*query.select())
        self.assertEqual([row[0] for row in self.cr.fetchall()], records.ids)

        records = self.env['res.partner.category'].search([])
        query = records._as_query()
        self.assertEqual(list(query), records.ids)
        self.cr.execute(*query.select())
        self.assertEqual([row[0] for row in self.cr.fetchall()], records.ids)

        records = records.browse(reversed(records.ids))
        query = records._as_query()
        self.assertEqual(list(query), records.ids)
        self.cr.execute(*query.select())
        self.assertEqual([row[0] for row in self.cr.fetchall()], records.ids)

```

  File: tests/test_overrides.py
  Content:
```
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.exceptions import UserError
from odoo.tests import TransactionCase, tagged


@tagged('-at_install', 'post_install')
class TestOverrides(TransactionCase):

    # Ensure all main ORM methods behavior works fine even on empty recordset
    # and that their returned value(s) follow the expected format.

    def test_creates(self):
        for model_env in self.env.values():
            if model_env._abstract:
                continue
            # with self.assertQueryCount(0):
            self.assertEqual(
                model_env.create([]), model_env.browse(),
                "Invalid create return value for model %s" % model_env._name)

    def test_writes(self):
        for model_env in self.env.values():
            if model_env._abstract:
                continue
            try:
                # with self.assertQueryCount(0):
                self.assertEqual(
                    model_env.browse().write({}), True,
                    "Invalid write return value for model %s" % model_env._name)
            except UserError:
                # skip models that should never be modified
                continue

    def test_default_get(self):
        for model_env in self.env.values():
            if model_env._transient:
                continue
            try:
                # with self.assertQueryCount(1):  # allow one query for the call to get_model_defaults.
                self.assertEqual(
                    model_env.browse().default_get([]), {},
                    "Invalid default_get return value for model %s" % model_env._name)
            except UserError:
                # skip "You must be logged in a Belgian company to use this feature" errors
                continue

    def test_unlink(self):
        for model_env in self.env.values():
            if model_env._abstract:
                continue
            # with self.assertQueryCount(0):
            self.assertEqual(
                model_env.browse().unlink(), True,
                "Invalid unlink return value for model %s" % model_env._name)

```

  File: tests/test_pdf.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo.tools import pdf
from odoo.tools.misc import file_open
import io


class TestPdf(TransactionCase):
    """ Tests on pdf. """

    def setUp(self):
        super().setUp()
        self.file = file_open('base/tests/minimal.pdf', 'rb').read()
        self.minimal_reader_buffer = io.BytesIO(self.file)
        self.minimal_pdf_reader = pdf.OdooPdfFileReader(self.minimal_reader_buffer)

    def test_odoo_pdf_file_reader(self):
        attachments = list(self.minimal_pdf_reader.getAttachments())
        self.assertEqual(len(attachments), 0)

        pdf_writer = pdf.PdfFileWriter()
        pdf_writer.cloneReaderDocumentRoot(self.minimal_pdf_reader)
        pdf_writer.addAttachment('test_attachment.txt', b'My awesome attachment')

        attachments = list(self.minimal_pdf_reader.getAttachments())
        self.assertEqual(len(attachments), 1)

    def test_odoo_pdf_file_writer(self):
        attachments = list(self.minimal_pdf_reader.getAttachments())
        self.assertEqual(len(attachments), 0)

        pdf_writer = pdf.OdooPdfFileWriter()
        pdf_writer.cloneReaderDocumentRoot(self.minimal_pdf_reader)

        pdf_writer.addAttachment('test_attachment.txt', b'My awesome attachment')
        attachments = list(self.minimal_pdf_reader.getAttachments())
        self.assertEqual(len(attachments), 1)

        pdf_writer.addAttachment('another_attachment.txt', b'My awesome OTHER attachment')
        attachments = list(self.minimal_pdf_reader.getAttachments())
        self.assertEqual(len(attachments), 2)

    def test_odoo_pdf_file_reader_with_owner_encryption(self):
        pdf_writer = pdf.OdooPdfFileWriter()
        pdf_writer.cloneReaderDocumentRoot(self.minimal_pdf_reader)

        pdf_writer.addAttachment('test_attachment.txt', b'My awesome attachment')
        pdf_writer.addAttachment('another_attachment.txt', b'My awesome OTHER attachment')

        pdf_writer.encrypt("", "foo")

        with io.BytesIO() as writer_buffer:
            pdf_writer.write(writer_buffer)
            encrypted_content = writer_buffer.getvalue()

        with io.BytesIO(encrypted_content) as reader_buffer:
            pdf_reader = pdf.OdooPdfFileReader(reader_buffer)
            attachments = list(pdf_reader.getAttachments())

        self.assertEqual(len(attachments), 2)

    def test_merge_pdf(self):
        self.assertEqual(self.minimal_pdf_reader.getNumPages(), 1)
        page = self.minimal_pdf_reader.getPage(0)

        merged_pdf = pdf.merge_pdf([self.file, self.file])
        merged_reader_buffer = io.BytesIO(merged_pdf)
        merged_pdf_reader = pdf.OdooPdfFileReader(merged_reader_buffer)
        self.assertEqual(merged_pdf_reader.getNumPages(), 2)
        merged_reader_buffer.close()

    def test_branded_file_writer(self):
        # It's not easy to create a PDF with PyPDF2, so instead we copy minimal.pdf with our custom pdf writer
        pdf_writer = pdf.PdfFileWriter()  # BrandedFileWriter
        pdf_writer.cloneReaderDocumentRoot(self.minimal_pdf_reader)
        writer_buffer = io.BytesIO()
        pdf_writer.write(writer_buffer)
        branded_content = writer_buffer.getvalue()
        writer_buffer.close()

        # Read the metadata of the newly created pdf.
        reader_buffer = io.BytesIO(branded_content)
        pdf_reader = pdf.PdfFileReader(reader_buffer)
        pdf_info = pdf_reader.getDocumentInfo()
        self.assertEqual(pdf_info['/Producer'], 'Odoo')
        self.assertEqual(pdf_info['/Creator'], 'Odoo')
        reader_buffer.close()

    def tearDown(self):
        super().tearDown()
        self.minimal_reader_buffer.close()

```

  File: tests/test_profiler.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import time

from odoo.exceptions import AccessError
from odoo.tests.common import BaseCase, TransactionCase, tagged, new_test_user
from odoo.tools import profiler
from odoo.tools.profiler import Profiler, ExecutionContext
from odoo.tools.speedscope import Speedscope


@tagged('post_install', '-at_install', 'profiling')
# post_install to ensure mail is already loaded if installed (new_test_user would fail otherwise because of notification_type)
class TestProfileAccess(TransactionCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.test_profile = cls.env['ir.profile'].create({})

    def test_admin_has_access(self):
        self.assertEqual(self.env['ir.profile'].search([('id', '=', self.test_profile.id)]), self.test_profile)
        self.test_profile.read(['name'])

    def test_user_no_access(self):
        user = new_test_user(self.env, login='noProfile', groups='base.group_user')
        with self.with_user('noProfile'), self.assertRaises(AccessError):
            self.env['ir.profile'].search([])
        with self.assertRaises(AccessError):
            self.test_profile.with_user(user).read(['name'])


@tagged('post_install', '-at_install', 'profiling')
class TestSpeedscope(BaseCase):
    def example_profile(self):
        return {
            'init_stack_trace': [['/path/to/file_1.py', 135, '__main__', 'main()']],
            'result': [{  # init frame
                'start': 2.0,
                'exec_context': (),
                'stack': [
                    ['/path/to/file_1.py', 10, 'main', 'do_stuff1(test=do_tests)'],
                    ['/path/to/file_1.py', 101, 'do_stuff1', 'cr.execute(query, params)'],
                ],
            }, {
                'start': 3.0,
                'exec_context': (),
                'stack': [
                    ['/path/to/file_1.py', 10, 'main', 'do_stuff1(test=do_tests)'],
                    ['/path/to/file_1.py', 101, 'do_stuff1', 'cr.execute(query, params)'],
                    ['/path/to/sql_db.py', 650, 'execute', 'res = self._obj.execute(query, params)'],
                ],
            }, {  # duplicate frame
                'start': 4.0,
                'exec_context': (),
                'stack': [
                    ['/path/to/file_1.py', 10, 'main', 'do_stuff1(test=do_tests)'],
                    ['/path/to/file_1.py', 101, 'do_stuff1', 'cr.execute(query, params)'],
                    ['/path/to/sql_db.py', 650, 'execute', 'res = self._obj.execute(query, params)'],
                ],
            }, {  # other frame
                'start': 6.0,
                'exec_context': (),
                'stack': [
                    ['/path/to/file_1.py', 10, 'main', 'do_stuff1(test=do_tests)'],
                    ['/path/to/file_1.py', 101, 'do_stuff1', 'check'],
                    ['/path/to/sql_db.py', 650, 'check', 'assert x = y'],
                ],
            }, {  # out of frame
                'start': 10.0,
                'exec_context': (),
                'stack': [
                    ['/path/to/file_1.py', 10, 'main', 'do_stuff1(test=do_tests)'],
                    ['/path/to/file_1.py', 101, 'do_stuff1', 'for i in range(10):'],
                ],
            }, {  # final frame
                'start': 10.35,
                'exec_context': (),
                'stack': None,
            }],
        }

    def test_convert_empty(self):
        Speedscope().make()

    def test_converts_profile_simple(self):
        profile = self.example_profile()

        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=False)
        res = sp.make()

        frames = res['shared']['frames']
        self.assertEqual(len(frames), 4)

        profile_combined = res['profiles'][0]
        events = [(e['type'], e['frame']) for e in profile_combined['events']]
        self.assertEqual(events, [
            ('O', 0),  # /main
            ('O', 1),  # /main/do_stuff1
            ('O', 2),  # /main/do_stuff1/execute
            ('C', 2),  # /main/do_stuff1
            ('O', 3),  # /main/do_stuff1/check
            ('C', 3),  # /main/do_stuff1
            ('C', 1),  # /main
            ('C', 0),  # /
        ])
        self.assertEqual(profile_combined['events'][0]['at'], 0.0)
        self.assertEqual(profile_combined['events'][-1]['at'], 8.35)

    def test_converts_profile_no_end(self):
        profile = self.example_profile()
        profile['result'].pop()

        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=False)
        res = sp.make()
        profile_combined = res['profiles'][0]
        events = [(e['type'], e['frame']) for e in profile_combined['events']]

        self.assertEqual(events, [
            ('O', 0),  # /main
            ('O', 1),  # /main/do_stuff1
            ('O', 2),  # /main/do_stuff1/execute
            ('C', 2),  # /main/do_stuff1
            ('O', 3),  # /main/do_stuff1/check
            ('C', 3),  # /main/do_stuff1
            ('C', 1),  # /main
            ('C', 0),  # /
        ])
        self.assertEqual(profile_combined['events'][-1]['at'], 8)

    def test_converts_init_stack_trace(self):
        profile = self.example_profile()

        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=True)
        res = sp.make()

        profile_combined = res['profiles'][0]
        events = [(e['type'], e['frame']) for e in profile_combined['events']]

        self.assertEqual(events, [
            ('O', 4),  # /__main__/
            ('O', 0),  # /__main__/main
            ('O', 1),  # /__main__/main/do_stuff1
            ('O', 2),  # /__main__/main/do_stuff1/execute
            ('C', 2),  # /__main__/main/do_stuff1
            ('O', 3),  # /__main__/main/do_stuff1/check
            ('C', 3),  # /__main__/main/do_stuff1
            ('C', 1),  # /__main__/main
            ('C', 0),  # /__main__/
            ('C', 4),  # /
        ])
        self.assertEqual(profile_combined['events'][-1]['at'], 8.35)

    def test_end_priority(self):
        """
        If a sample as a time (usually a query) we expect to keep the complete frame
        even if another concurent frame tics before the end of the current one:
        frame duration should always be more reliable.
        """

        async_profile = self.example_profile()['result']
        sql_profile = self.example_profile()['result']
        # make sql_profile a single frame from 2.5 to 5.5
        sql_profile = [sql_profile[1]]
        sql_profile[0]['start'] = 2.5
        sql_profile[0]['time'] = 3
        sql_profile[0]['query'] = 'SELECT 1'
        sql_profile[0]['full_query'] = 'SELECT 1'
        # some check to ensure the take makes sence
        self.assertEqual(async_profile[1]['start'], 3)
        self.assertEqual(async_profile[2]['start'], 4)

        self.assertNotIn('query', async_profile[1]['stack'])
        self.assertNotIn('time', async_profile[1]['stack'])
        self.assertEqual(async_profile[1]['stack'], async_profile[2]['stack'])
        # this last assertion is not really useful but ensures that the samples
        # are consistent with the sql one, just missing tue query

        sp = Speedscope(init_stack_trace=[])
        sp.add('sql', async_profile)
        sp.add('traces', sql_profile)
        sp.add_output(['sql', 'traces'], complete=False)
        res = sp.make()
        profile_combined = res['profiles'][0]
        events = [
            (e['at']+2, e['type'], res['shared']['frames'][e['frame']]['name'])
            for e in profile_combined['events']
        ]
        self.assertEqual(events, [
            # pylint: disable=bad-continuation
            (2.0, 'O', 'main'),
                (2.0, 'O', 'do_stuff1'),
                    (2.5, 'O', 'execute'),
                        (2.5, 'O', "sql('SELECT 1')"),
                        (5.5, 'C', "sql('SELECT 1')"),  # select ends at 5.5 as expected despite another concurent frame at 3 and 4
                    (5.5, 'C', 'execute'),
                    (6.0, 'O', 'check'),
                    (10.0, 'C', 'check'),
                (10.35, 'C', 'do_stuff1'),
            (10.35, 'C', 'main'),
        ])

    def test_converts_context(self):
        stack = [
            ['file.py', 10, 'level1', 'level1'],
            ['file.py', 11, 'level2', 'level2'],
        ]
        profile = {
            'init_stack_trace': [['file.py', 1, 'level0', 'level0)']],
            'result': [{  # init frame
                'start': 2.0,
                'exec_context': ((2, {'a': '1'}), (3, {'b': '1'})),
                'stack': list(stack),
            }, {
                'start': 3.0,
                'exec_context': ((2, {'a': '1'}), (3, {'b': '2'})),
                'stack': list(stack),
            }, {  # final frame
                'start': 10.35,
                'exec_context': (),
                'stack': None,
            }],
        }
        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=True)
        res = sp.make()
        events = [
            (e['type'], res['shared']['frames'][e['frame']]['name'])
            for e in res['profiles'][0]['events']
        ]
        self.assertEqual(events, [
            # pylint: disable=bad-continuation
            ('O', 'level0'),
                ('O', 'a=1'),
                    ('O', 'level1'),
                        ('O', 'b=1'),
                            ('O', 'level2'),
                            ('C', 'level2'),
                        ('C', 'b=1'),
                        ('O', 'b=2'),
                            ('O', 'level2'),
                            ('C', 'level2'),
                        ('C', 'b=2'),
                    ('C', 'level1'),
                ('C', 'a=1'),
            ('C', 'level0'),
        ])

    def test_converts_context_nested(self):
        stack = [
            ['file.py', 10, 'level1', 'level1'],
            ['file.py', 11, 'level2', 'level2'],
        ]
        profile = {
            'init_stack_trace': [['file.py', 1, 'level0', 'level0)']],
            'result': [{  # init frame
                'start': 2.0,
                'exec_context': ((3, {'a': '1'}), (3, {'b': '1'})),  # two contexts at the same level
                'stack': list(stack),
            }, {  # final frame
                'start': 10.35,
                'exec_context': (),
                'stack': None,
            }],
        }
        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=True)
        res = sp.make()
        events = [
            (e['type'], res['shared']['frames'][e['frame']]['name'])
            for e in res['profiles'][0]['events']
        ]
        self.assertEqual(events, [
            # pylint: disable=bad-continuation
            ('O', 'level0'),
                ('O', 'level1'),
                    ('O', 'a=1'),
                        ('O', 'b=1'),
                            ('O', 'level2'),
                            ('C', 'level2'),
                        ('C', 'b=1'),
                    ('C', 'a=1'),
                ('C', 'level1'),
            ('C', 'level0'),
        ])

    def test_converts_context_lower(self):
        stack = [
            ['file.py', 10, 'level4', 'level4'],
            ['file.py', 11, 'level5', 'level5'],
        ]
        profile = {
            'init_stack_trace': [
                ['file.py', 1, 'level0', 'level0'],
                ['file.py', 1, 'level1', 'level1'],
                ['file.py', 1, 'level2', 'level2'],
                ['file.py', 1, 'level3', 'level3'],
            ],
            'result': [{  # init frame
                'start': 2.0,
                'exec_context': ((2, {'a': '1'}), (6, {'b': '1'})),
                'stack': list(stack),
            }, {  # final frame
                'start': 10.35,
                'exec_context': (),
                'stack': None,
            }],
        }
        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=False)
        res = sp.make()
        events = [
            (e['type'], res['shared']['frames'][e['frame']]['name'])
            for e in res['profiles'][0]['events']
        ]
        self.assertEqual(events, [
            # pylint: disable=bad-continuation
            ('O', 'level4'),
                ('O', 'b=1'),
                    ('O', 'level5'),
                    ('C', 'level5'),
                ('C', 'b=1'),
            ('C', 'level4'),
        ])

    def test_converts_no_context(self):
        stack = [
            ['file.py', 10, 'level4', 'level4'],
            ['file.py', 11, 'level5', 'level5'],
        ]
        profile = {
            'init_stack_trace': [
                ['file.py', 1, 'level0', 'level0'],
                ['file.py', 1, 'level1', 'level1'],
                ['file.py', 1, 'level2', 'level2'],
                ['file.py', 1, 'level3', 'level3'],
            ],
            'result': [{  # init frame
                'start': 2.0,
                'exec_context': ((2, {'a': '1'}), (6, {'b': '1'})),
                'stack': list(stack),
            }, {  # final frame
                'start': 10.35,
                'exec_context': (),
                'stack': None,
            }],
        }
        sp = Speedscope(init_stack_trace=profile['init_stack_trace'])
        sp.add('profile', profile['result'])
        sp.add_output(['profile'], complete=False, use_context=False)
        res = sp.make()
        events = [
            (e['type'], res['shared']['frames'][e['frame']]['name'])
            for e in res['profiles'][0]['events']
        ]
        self.assertEqual(events, [
            # pylint: disable=bad-continuation
            ('O', 'level4'),
                ('O', 'level5'),
                ('C', 'level5'),
            ('C', 'level4'),
        ])


@tagged('post_install', '-at_install', 'profiling')
class TestProfiling(TransactionCase):

    def test_default_values(self):
        p = Profiler()
        self.assertEqual(p.db, self.env.cr.dbname)

    def test_env_profiler_database(self):
        p = Profiler(collectors=[])
        self.assertEqual(p.db, self.env.cr.dbname)

    def test_env_profiler_description(self):
        with Profiler(collectors=[], db=None) as p:
            self.assertIn('test_env_profiler_description', p.description)

    def test_execution_context_save(self):
        with Profiler(db=None, collectors=['sql']) as p:
            for letter in ('a', 'b'):
                stack_level = profiler.stack_size()
                with ExecutionContext(letter=letter):
                    self.env.cr.execute('SELECT 1')
        entries = p.collectors[0].entries
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'a'}),))
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'b'}),))

    def test_execution_context_nested(self):
        """
        This test checks that an execution can be nested at the same level of the stack.
        """
        with Profiler(db=None, collectors=['sql']) as p:
            stack_level = profiler.stack_size()
            with ExecutionContext(letter='a'):
                self.env.cr.execute('SELECT 1')
                with ExecutionContext(letter='b'):
                    self.env.cr.execute('SELECT 1')
                with ExecutionContext(letter='c'):
                    self.env.cr.execute('SELECT 1')
                self.env.cr.execute('SELECT 1')
        entries = p.collectors[0].entries
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'a'}),))
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'a'}), (stack_level, {'letter': 'b'})))
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'a'}), (stack_level, {'letter': 'c'})))
        self.assertEqual(entries.pop(0)['exec_context'], ((stack_level, {'letter': 'a'}),))

    def test_sync_recorder(self):
        def a():
            b()
            c()

        def b():
            pass

        def c():
            d()
            d()

        def d():
            pass

        with Profiler(description='test', collectors=['traces_sync'], db=None) as p:
            a()

        stacks = [r['stack'] for r in p.collectors[0].entries]

        # map stack frames to their function name, and check
        stacks_methods = [[frame[2] for frame in stack] for stack in stacks]
        self.assertEqual(stacks_methods[:-2], [
            ['a'],
            ['a', 'b'],
            ['a'],
            ['a', 'c'],
            ['a', 'c', 'd'],
            ['a', 'c'],
            ['a', 'c', 'd'],
            ['a', 'c'],
            ['a'],
            [],
        ])

        # map stack frames to their line number, and check
        stacks_lines = [[frame[1] for frame in stack] for stack in stacks]
        self.assertEqual(stacks_lines[1][0] + 1, stacks_lines[3][0],
                         "Call of b() in a() should be one line before call of c()")

    def test_qweb_recorder(self):
        template = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'key': 'root',
            'arch_db': '''<t t-name="root">
                <t t-foreach="{'a': 3, 'b': 2, 'c': 1}" t-as="item">
                    [<t t-out="item_index"/>: <t t-set="record" t-value="item"/><t t-call="base.dummy"/> <t t-out="item_value"/>]
                    <b t-out="add_one_query()"/></t>
            </t>'''
        })
        child_template = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'key': 'dummy',
            'arch_db': '<t t-name="dummy"><span t-attf-class="myclass"><t t-out="record"/> <t t-out="add_one_query()"/></span></t>'
        })
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')", [child_template.id])

        values = {'add_one_query': lambda: self.env.cr.execute('SELECT id FROM ir_ui_view LIMIT 1') or 'query'}
        result = u"""
                    [0: <span class="myclass">a query</span> 3]
                    <b>query</b>
                    [1: <span class="myclass">b query</span> 2]
                    <b>query</b>
                    [2: <span class="myclass">c query</span> 1]
                    <b>query</b>
        """

        # test rendering without profiling
        rendered = self.env['ir.qweb']._render(template.id, values)
        self.assertEqual(rendered.strip(), result.strip(), 'Without profiling')

        # This rendering is used to cache the compiled template method so as
        # not to have a number of requests that vary according to the modules
        # installed.
        with Profiler(description='test', collectors=['qweb'], db=None):
            self.env['ir.qweb']._render(template.id, values)

        with Profiler(description='test', collectors=['qweb'], db=None) as p:
            rendered = self.env['ir.qweb']._render(template.id, values)
            # check if qweb is ok
            self.assertEqual(rendered.strip(), result.strip())

        # check if the arch of all used templates is includes in the result
        self.assertEqual(p.collectors[0].entries[0]['results']['archs'], {
            template.id: template.arch_db,
            child_template.id: child_template.arch_db,
        })

        # check all directives without duration information
        for data in p.collectors[0].entries[0]['results']['data']:
            data.pop('delay')

        data = p.collectors[0].entries[0]['results']['data']
        expected = [
            # pylint: disable=bad-whitespace
            # first template and first directive
            {'view_id': template.id,       'xpath': '/t/t',         'directive': """t-foreach="{'a': 3, 'b': 2, 'c': 1}" t-as='item'""", 'query': 0},
            # first pass in the loop
            {'view_id': template.id,       'xpath': '/t/t/t[1]',    'directive': "t-out='item_index'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[2]',    'directive': "t-set='record' t-value='item'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[3]',    'directive': "t-call='base.dummy'", 'query': 0}, # 0 because the template is in ir.ui.view cache
            # first pass in the loop: content of the child template
            {'view_id': child_template.id, 'xpath': '/t/span',      'directive': "t-attf-class='myclass'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[1]', 'directive': "t-out='record'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[2]', 'directive': "t-out='add_one_query()'", 'query': 1},
            {'view_id': template.id,       'xpath': '/t/t/t[4]',    'directive': "t-out='item_value'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/b',       'directive': "t-out='add_one_query()'", 'query':1},
            # second pass in the loop
            {'view_id': template.id,       'xpath': '/t/t/t[1]',    'directive': "t-out='item_index'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[2]',    'directive': "t-set='record' t-value='item'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[3]',    'directive': "t-call='base.dummy'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span',      'directive': "t-attf-class='myclass'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[1]', 'directive': "t-out='record'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[2]', 'directive': "t-out='add_one_query()'", 'query': 1},
            {'view_id': template.id,       'xpath': '/t/t/t[4]',    'directive': "t-out='item_value'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/b',       'directive': "t-out='add_one_query()'", 'query':1},
            # third pass in the loop
            {'view_id': template.id,       'xpath': '/t/t/t[1]',    'directive': "t-out='item_index'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[2]',    'directive': "t-set='record' t-value='item'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/t[3]',    'directive': "t-call='base.dummy'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span',      'directive': "t-attf-class='myclass'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[1]', 'directive': "t-out='record'", 'query': 0},
            {'view_id': child_template.id, 'xpath': '/t/span/t[2]', 'directive': "t-out='add_one_query()'", 'query': 1},
            {'view_id': template.id,       'xpath': '/t/t/t[4]',    'directive': "t-out='item_value'", 'query': 0},
            {'view_id': template.id,       'xpath': '/t/t/b',       'directive': "t-out='add_one_query()'", 'query':1},
        ]
        self.assertEqual(data, expected)

    def test_default_recorders(self):
        with Profiler(db=None) as p:
            queries_start = self.env.cr.sql_log_count
            for i in range(10):
                self.env['res.partner'].create({'name': 'snail%s' % i})
            self.env.flush_all()
            total_queries = self.env.cr.sql_log_count - queries_start

        rq = next(r for r in p.collectors if r.name == "sql").entries
        self.assertEqual(p.init_stack_trace[-1][2], 'test_default_recorders')
        self.assertEqual(p.init_stack_trace[-1][0].split('/')[-1], 'test_profiler.py')

        self.assertEqual(len(rq), total_queries)
        first_query = rq[0]
        self.assertEqual(first_query['stack'][0][2], 'create')
        #self.assertIn("self.env['res.partner'].create({", first_query['stack'][0][3])

        self.assertGreater(first_query['time'], 0)
        self.assertEqual(first_query['stack'][-1][2], 'execute')
        self.assertEqual(first_query['stack'][-1][0].split('/')[-1], 'sql_db.py')


def deep_call(func, depth):
    """ Call the given function at the given call depth. """
    if depth > 0:
        deep_call(func, depth - 1)
    else:
        func()


@tagged('-standard', 'profiling_performance')
class TestPerformance(BaseCase):

    def test_collector_max_frequency(self):
        """
        Check the creation time of an entry
        """
        collector = profiler.Collector()
        p = Profiler(collectors=[collector], db=None)

        def collect():
            collector.add()

        # collect on changing stack
        with p:
            start = time.time()
            while start + 1 > time.time():
                deep_call(collect, 20)

        self.assertGreater(len(collector.entries), 20000)  # ~40000

        # collect on identical stack
        collector = profiler.Collector()
        p = Profiler(collectors=[collector], db=None)

        def collect_1_s():
            start = time.time()
            while start + 1 > time.time():
                collector.add()

        with p:
            deep_call(collect_1_s, 20)

        self.assertGreater(len(collector.entries), 50000)  # ~70000

    def test_frequencies_1ms_sleep(self):
        """
        Check the number of entries generated in 1s at 1kHz
        we need to artificially change the frame as often as possible to avoid
        triggering the memory optimisation skipping identical frames
        """
        def sleep_1():
            time.sleep(0.0001)

        def sleep_2():
            time.sleep(0.0001)

        with Profiler(collectors=['traces_async'], db=None) as res:
            start = time.time()
            while start + 1 > time.time():
                sleep_1()
                sleep_2()

        entry_count = len(res.collectors[0].entries)
        self.assertGreater(entry_count, 700)  # ~920

    def test_traces_async_memory_optimisation(self):
        """
        Identical frames should be saved only once.
        We should only have a few entries on a 1 second sleep.
        """
        with Profiler(collectors=['traces_async'], db=None) as res:
            time.sleep(1)
        entry_count = len(res.collectors[0].entries)
        self.assertLess(entry_count, 5)  # ~3

```

  File: tests/test_qweb.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import collections
import json
import os.path
import re
import markupsafe

from lxml import etree, html
from lxml.builder import E
from copy import deepcopy
from textwrap import dedent

from odoo.tests.common import TransactionCase
from odoo.addons.base.models.ir_qweb import QWebException, render
from odoo.tools import misc, mute_logger
from odoo.tools.json import scriptsafe as json_scriptsafe
from odoo.exceptions import UserError, ValidationError, MissingError

unsafe_eval = eval


class TestQWebTField(TransactionCase):
    def setUp(self):
        super(TestQWebTField, self).setUp()
        self.env_branding = self.env(context={'inherit_branding': True})
        self.engine = self.env_branding['ir.qweb']

    def test_trivial(self):
        field = etree.Element('span', {'t-field': 'company.name'})
        company = self.env['res.company'].create({'name': "My Test Company"})

        result = self.engine._render(field, {'company': company})
        self.assertEqual(
            etree.fromstring(result),
            etree.fromstring('<span data-oe-model="res.company" data-oe-id="%d" '
                  'data-oe-field="name" data-oe-type="char" '
                  'data-oe-expression="company.name">%s</span>' % (
                company.id,
                "My Test Company",
            )),
        )

    def test_i18n(self):
        field = etree.Element('span', {'t-field': 'company.name'})
        s = "Testing «ταБЬℓσ»: 1<2 & 4+1>3, now 20% off!"
        company = self.env['res.company'].create({'name': s})

        result = self.engine._render(field, {'company': company})
        self.assertEqual(
            etree.fromstring(result),
            etree.fromstring('<span data-oe-model="res.company" data-oe-id="%d" '
                  'data-oe-field="name" data-oe-type="char" '
                  'data-oe-expression="company.name">%s</span>' % (
                company.id,
                misc.html_escape(s),
            )),
        )

    def test_reject_crummy_tags(self):
        field = etree.Element('td', {'t-field': 'company.name'})

        with self.assertRaisesRegex(QWebException, r'QWeb widgets do not work correctly'):
            self.engine._render(field, {'company': None})

    def test_reject_t_tag(self):
        field = etree.Element('t', {'t-field': 'company.name'})

        with self.assertRaisesRegex(QWebException, r't-field can not be used on a t element'):
            self.engine._render(field, {'company': None})

    def test_render_t_options(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy"><root><span t-esc="5" t-options="{'widget': 'char'}" t-options-widget="'float'" t-options-precision="4"/></root></t>
            """
        })
        text = etree.fromstring(self.env['ir.qweb']._render(view1.id)).find('span').text
        self.assertEqual(text, '5.0000')

    def test_xss_breakout(self):
        view = self.env['ir.ui.view'].create({
            'name': 'dummy', 'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <root>
                        <script type="application/javascript">
                            var s = <t t-esc="json.dumps({'key': malicious})"/>;
                        </script>
                    </root>
                </t>
            """
        })
        rendered = self.env['ir.qweb']._render(view.id, {'malicious': '1</script><script>alert("pwned")</script><script>'})
        self.assertIn('alert', rendered, "%r doesn't seem to be rendered" % rendered)
        doc = etree.fromstring(rendered)
        self.assertEqual(len(doc.xpath('//script')), 1)

    def test_default_value(self):
        Partner = self.env['res.partner']
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="out-field-default">
                <div t-field="record.name">
                    DEFAULT
                    <t t-out="'Text'" />
                </div>
            </t>''',
        })

        # record.name is non-empty
        result = """
                <div>My Company</div>
        """
        rendered = self.env['ir.qweb']._render(t.id, {
            'record': Partner.new({'name': 'My Company'})
        })
        self.assertEqual(str(rendered.strip()), result.strip(), "")

        # record.name is empty but not False or None, we should render depending on force_display
        result = """
                <div></div>
        """
        rendered = self.env['ir.qweb']._render(t.id, {
            'record': Partner.new({'name': ''})
        })
        self.assertEqual(str(rendered.strip()), result.strip())

        # record.name is False or None, we should render field default value
        result = """
                <div>
                    DEFAULT
                    Text
                </div>
        """
        rendered = self.env['ir.qweb']._render(t.id, {
            'record': Partner.new({})
        })
        self.assertEqual(str(rendered.strip()), result.strip())

    def test_no_value_no_default_value(self):
        # no value, no default value with attributes on t-field
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="out-field-default">
                <div t-field="record.name"/>
            </t>''',
        })
        result = """
                <div data-oe-xpath="/t[1]/div[1]" data-oe-model="res.partner" data-oe-field="name" data-oe-type="char" data-oe-expression="record.name"></div>
        """
        # inherit_branding puts attribute on the field tag as well as force the display in case the field is empty
        rendered = self.env['ir.qweb'].with_context(inherit_branding=True)._render(t.id, {
            'record': self.env['res.partner'].new({}),
        })
        self.assertEqual(str(rendered.strip()), result.strip())


class TestQWebNS(TransactionCase):
    def test_render_static_xml_with_namespace(self):
        """ Test the rendering on a namespaced view with no static content. The resulting string should be untouched.
        """
        expected_result = """
            <root>
                <h:table xmlns:h="http://www.example.org/table">
                    <h:tr>
                        <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
                <f:table xmlns:f="http://www.example.org/furniture">
                    <f:width>80</f:width>
                </f:table>
            </root>
        """

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % expected_result
        })

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), etree.fromstring(expected_result))

    def test_render_static_xml_with_namespace_2(self):
        """ Test the rendering on a namespaced view with no static content. The resulting string should be untouched.
        """
        expected_result = """
            <html xmlns="http://www.w3.org/HTML/1998/html4" xmlns:xdc="http://www.xml.com/books">
                <head>
                    <title>Book Review</title>
                </head>
                <body>
                    <xdc:bookreview>
                        <xdc:title>XML: A Primer</xdc:title>
                        <table>
                            <tr align="center">
                                <td>Author</td><td>Price</td>
                                <td>Pages</td><td>Date</td>
                            </tr>
                            <tr align="left">
                                <td><xdc:author>Simon St. Laurent</xdc:author></td>
                                <td><xdc:price>31.98</xdc:price></td>
                                <td><xdc:pages>352</xdc:pages></td>
                                <td><xdc:date>1998/01</xdc:date></td>
                            </tr>
                        </table>
                    </xdc:bookreview>
                </body>
            </html>
        """

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % expected_result
        })

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), etree.fromstring(expected_result))

    def test_render_static_xml_with_useless_distributed_namespace(self):
        """ Test that redundant namespaces are stripped upon rendering.
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <root>
                        <h:table xmlns:h="http://www.example.org/table">
                            <h:tr xmlns:h="http://www.example.org/table">
                                <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                                <h:td xmlns:h="http://www.example.org/table">Bananas</h:td>
                            </h:tr>
                        </h:table>
                    </root>
                </t>
            """
        })

        expected_result = etree.fromstring("""
            <root>
                <h:table xmlns:h="http://www.example.org/table">
                    <h:tr>
                        <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
            </root>
        """)

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_static_xml_with_namespace_3(self):
        expected_result = """
            <cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd"></cfdi:Comprobante>
        """

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % expected_result
        })

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), etree.fromstring(expected_result))

    def test_render_static_xml_with_namespace_dynamic(self):
        """ Test the rendering on a namespaced view with dynamic URI (need default namespace uri).
        """
        tempate = """
            <root xmlns:h="https://default.namespace.url/h">
                <h:table t-att="{'xmlns:h': h1}">
                    <h:tr>
                        <h:td t-att="{'xmlns:h': h2}">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
            </root>
        """
        expected_result = """
            <root xmlns:h="https://default.namespace.url/h">
                <h:table xmlns:h="%(h1)s">
                    <h:tr>
                        <h:td xmlns:h="%(h2)s">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
            </root>
        """

        values = dict(h1="http://www.example.org/table", h2="http://www.w3.org/TD/html4/")

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % tempate
        })

        rendering = self.env['ir.qweb']._render(view1.id, values)

        self.assertEqual(etree.fromstring(rendering), etree.fromstring(expected_result % values))

    def test_render_static_xml_with_namespace_dynamic_2(self):
        """ Test the rendering on a namespaced view with dynamic URI (need default namespace uri).
        Default URIs must be differents.
        """
        tempate = """
            <root xmlns:f="https://default.namespace.url/f" xmlns:h="https://default.namespace.url/h" >
                <h:table t-att="{'xmlns:h': h1}">
                    <h:tr>
                        <h:td t-att="{'xmlns:h': h2}">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
                <f:table t-att="{'xmlns:f': f}">
                    <f:width>80</f:width>
                </f:table>
            </root>
        """
        expected_result = """
            <root xmlns:f="https://default.namespace.url/f" xmlns:h="https://default.namespace.url/h">
                <h:table xmlns:h="%(h1)s">
                    <h:tr>
                        <h:td xmlns:h="%(h2)s">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
                <f:table xmlns:f="%(f)s">
                    <f:width>80</f:width>
                </f:table>
            </root>
        """

        values = dict(h1="http://www.example.org/table", h2="http://www.w3.org/TD/html4/", f="http://www.example.org/furniture")

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % tempate
        })

        rendering = self.env['ir.qweb']._render(view1.id, values)

        self.assertEqual(etree.fromstring(rendering), etree.fromstring(expected_result % values))

    def test_render_dynamic_xml_with_namespace_t_esc(self):
        """ Test that rendering a template containing a node having both an ns declaration and a t-esc attribute correctly
        handles the t-esc attribute and keep the ns declaration.
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" t-esc="'test'"/>
                </t>
            """
        })

        expected_result = etree.fromstring("""<Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">test</Invoice>""")

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_dynamic_xml_with_namespace_t_esc_with_useless_distributed_namespace(self):
        """ Test that rendering a template containing a node having both an ns declaration and a t-esc attribute correctly
        handles the t-esc attribute and keep the ns declaration, and distribute correctly the ns declaration to its children.
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" t-attf-test="test">
                        <cac:Test xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">blabla</cac:Test>
                    </Invoice>
                </t>
            """
        })

        expected_result = etree.fromstring("""
            <Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" test="test">
                <cac:Test>blabla</cac:Test>
            </Invoice>
        """)

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_dynamic_xml_with_namespace_t_attf(self):
        """ Test that rendering a template containing a node having both an ns declaration and a t-attf attribute correctly
        handles the t-attf attribute and keep the ns declaration.
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <root>
                        <h:table xmlns:h="http://www.example.org/table">
                            <h:tr>
                                <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                                <h:td>Bananas</h:td>
                            </h:tr>
                        </h:table>
                        <f:table xmlns:f="http://www.example.org/furniture">
                            <f:width t-attf-test="1">80</f:width>
                        </f:table>
                    </root>
                </t>
            """
        })

        expected_result = etree.fromstring("""
            <root>
                <h:table xmlns:h="http://www.example.org/table">
                    <h:tr>
                        <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                        <h:td>Bananas</h:td>
                    </h:tr>
                </h:table>
                <f:table xmlns:f="http://www.example.org/furniture">
                    <f:width test="1">80</f:width>
                </f:table>
            </root>
        """)

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_dynamic_xml_with_namespace_t_attf_with_useless_distributed_namespace(self):
        """ Test that rendering a template containing a node having both an ns declaration and a t-attf attribute correctly
        handles the t-attf attribute and that redundant namespaces are stripped upon rendering.
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                <root>
                    <h:table xmlns:h="http://www.example.org/table">
                        <h:tr>
                            <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                            <h:td>Bananas</h:td>
                        </h:tr>
                    </h:table>
                    <f:table xmlns:f="http://www.example.org/furniture">
                        <f:width xmlns:f="http://www.example.org/furniture" t-attf-test="1">80</f:width>
                    </f:table>
                </root>

                </t>
            """
        })

        expected_result = etree.fromstring("""
                <root>
                    <h:table xmlns:h="http://www.example.org/table">
                        <h:tr>
                            <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                            <h:td>Bananas</h:td>
                        </h:tr>
                    </h:table>
                    <f:table xmlns:f="http://www.example.org/furniture">
                        <f:width test="1">80</f:width>
                    </f:table>
                </root>

        """)

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_dynamic_xml_with_namespace_2(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2">
                        <cbc:UBLVersionID t-esc="version_id"/>
                        <t t-foreach="[1, 2, 3, 4]" t-as="value">
                            Oasis <cac:Test t-esc="value"/>
                        </t>
                    </Invoice>
                </t>
            """
        })

        expected_result = etree.fromstring("""
            <Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2">
                <cbc:UBLVersionID>1.0</cbc:UBLVersionID>

                    Oasis <cac:Test>1</cac:Test>

                    Oasis <cac:Test>2</cac:Test>

                    Oasis <cac:Test>3</cac:Test>

                    Oasis <cac:Test>4</cac:Test>

            </Invoice>
        """)

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id, {'version_id': 1.0})), expected_result)

    def test_render_static_xml_with_namespaced_attributes(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>
                </t>
            """
        })

        expected_result = etree.fromstring("""<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>""")

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_dynamic_xml_with_namespaced_attributes(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd" t-esc="'abc'"/>
                </t>
            """
        })

        expected_result = etree.fromstring("""<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>""")

        self.assertEqual(etree.fromstring(self.env['ir.qweb']._render(view1.id)), expected_result)

    def test_render_static_xml_with_t_call(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <cac:fruit xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
                               xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
                        <cac:table>
                            <cbc:td>Appel</cbc:td>
                            <cbc:td>Pineappel</cbc:td>
                        </cac:table>
                    </cac:fruit>
                </t>
            """
        })
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')", [view1.id])

        # view2 will t-call view1
        view2 = self.env['ir.ui.view'].create({
            'name': "dummy2",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy2">
                    <root xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2" xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
                        <cac:line t-foreach="[1, 2]" t-as="i" t-call="base.dummy"/>
                    </root>
                </t>
            """
        })

        result = self.env['ir.qweb']._render(view2.id)
        result_etree = etree.fromstring(result)

        # check that the root tag has all its xmlns
        expected_ns = {
            (None, 'urn:oasis:names:specification:ubl:schema:xsd:Invoice-2'),
            ('cac', 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2'),
            ('cbc', 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2'),
        }
        self.assertEqual(set(result_etree.nsmap.items()), expected_ns)

        # check that the t-call did its work
        cac_lines = result_etree.findall('.//cac:line', namespaces={'cac': 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2'})
        self.assertEqual(len(cac_lines), 2)
        self.assertEqual(result.count('Appel'), 2)

        # check that the t-call dit not output again the xmlns declaration
        self.assertEqual(result.count('xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"'), 1)

    def test_render_static_xml_with_extension(self):
        """ Test the extension of a view by an xpath expression on a ns prefixed element.
        """
        # primary view
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <root>
                        <h:table xmlns:h="http://www.example.org/table">
                            <h:tr>
                                <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                                <h:td>Bananas</h:td>
                            </h:tr>
                        </h:table>
                    </root>
                </t>
            """
        })
        # extension patching the primary view
        view2 = self.env['ir.ui.view'].create({
            'name': "dummy_ext",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <xpath expr="//{http://www.example.org/table}table/{http://www.example.org/table}tr">
                        <h:td xmlns:h="http://www.example.org/table">Oranges</h:td>
                </xpath>
            """
        })

        expected_result = etree.fromstring("""
            <root>
                <h:table xmlns:h="http://www.example.org/table">
                    <h:tr>
                        <h:td xmlns:h="http://www.w3.org/TD/html4/">Apples</h:td>
                        <h:td>Bananas</h:td>
                        <h:td>Oranges</h:td>
                    </h:tr>
                </h:table>
            </root>
        """)

        self.assertEqual(
            etree.fromstring(self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id])._render(view1.id)),
            expected_result
        )

    def test_render_dynamic_xml_with_code_error(self):
        """ Test that, when rendering a template containing a namespaced node
            that evaluates code with errors, the proper exception is raised
        """
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <Invoice xmlns:od="http://odoo.com/od">
                        <od:name t-att-test="'a' + 1"/>
                    </Invoice>
                </t>
            """
        })

        error_msg = None
        try:
            "" + 0
        except TypeError as e:
            error_msg = e.args[0]

        with self.assertRaises(QWebException, msg=error_msg):
            self.env['ir.qweb']._render(view1.id)


    def test_render_static_xml_with_void_element(self):
        """ Test the rendering on a namespaced view with dynamic URI (need default namespace uri).
        """
        tempate = """
            <rss xmlns:g="http://base.google.com/ns/1.0" version="2.0">
                <g:brand>Odoo</g:brand>
                <g:link>My Link</g:link>
            </rss>
        """
        expected_result = """
            <rss xmlns:g="http://base.google.com/ns/1.0" version="2.0">
                <g:brand>Odoo</g:brand>
                <g:link>My Link</g:link>
            </rss>

        """

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">%s</t>
            """ % tempate
        })

        rendering = self.env['ir.qweb']._render(view1.id)

        self.assertEqual(etree.fromstring(rendering), etree.fromstring(expected_result))

class TestQWebBasic(TransactionCase):
    def test_compile_expr(self):
        tests = [
            #pylint: disable=C0326
            # source,                                   values,                         result
            ("1 +2+ 3",                                 {},                             6),
            ("(((1 +2+ 3)))",                           {},                             6),
            ("(1) +(2+ (3))",                           {},                             6),
            ("a == 5",                                  {'a': 5},                       True),
            ("{'a': True}",                             {},                             {'a': True}),
            ("object.count(1)",                         {'object': [1, 2, 1 ,1]},       3),
            ("dict(a=True)",                            {},                             {'a': True}),
            ("fn(a=11, b=22) or a",                     {'a': 1, 'fn': lambda a,b: 0},  1),
            ("fn(a=11, b=22) or a",                     {'a': 1, 'fn': lambda a,b: b},  22),
            ("(lambda a: a)(5)",                        {},                             5),
            ("(lambda a: a[0])([5])",                   {},                             5),
            ("(lambda test: len(test))('aaa')",         {},                             3),
            ("{'a': lambda a: a[0], 'b': 3}['a']([5])", {},                             5),
            ("list(map(lambda a: a[0], r))",            {'r': [(1,11), (2,22)]},        [1, 2]),
            ("z + (head or 'z')",                       {'z': 'a'},                     "az"),
            ("z + (head or 'z')",                       {'z': 'a', 'head': 'b'},        "ab"),
            ("{a:b for a, b in [(1,11), (2, 22)]}",     {},                             {1: 11, 2: 22}),
            ("any({x == 2 for x in [1,2,3]})",          {},                             True),
            ("any({x == 5 for x in [1,2,3]})",          {},                             False),
            ("{x:y for x,y in [('a', 11),('b', 22)]}",  {},                             {'a': 11, 'b': 22}),
            ("[(y,x) for x,y in [(1, 11),(2, 22)]]",    {},                             [(11, 1), (22, 2)]),
            ("(lambda a: a + 5)(x)",                    {'x': 10},                      15),
            ("(lambda a: a + x)(5)",                    {'x': 10},                      15),
            ("sum(x for x in range(4)) + ((x))",        {'x': 10},                      16),
            ("['test_' + x for x in ['a', 'b']]",       {},                             ['test_a', 'test_b']),
            ("""1 and 2 and 0
                or 9""",                                {},                             9),
            ('[x for x in (1,2)]',                      {},                             [1, 2]),  # LOAD_FAST_AND_CLEAR
            ('list(x for x in (1,2))',                  {},                             [1, 2]),  # END_FOR, CALL_INTRINSIC_1
            ('v if v is None else w',                   {'v': False, 'w': 'foo'},       'foo'),  # POP_JUMP_IF_NONE
            ('v if v is not None else w',               {'v': None, 'w': 'foo'},        'foo'),  # POP_JUMP_IF_NOT_NONE
            ('{a for a in (1, 2)}',                     {},                             {1, 2}),  # RERAISE
        ]

        IrQweb = self.env['ir.qweb']
        for expr, q_values, result in tests:
            expr_namespace = IrQweb._compile_expr(expr)

            compiled = compile("""def test(values):\n  values['result'] = %s""" % expr_namespace, '<test>', 'exec')
            globals_dict = IrQweb._IrQWeb__prepare_globals()
            values = {}
            unsafe_eval(compiled, globals_dict, values)
            test = values['test']

            test(q_values)
            q_result = dict(q_values, result=result)
            self.assertDictEqual(q_values, q_result, "Should compile: %s" % expr)

    def test_foreach_as_error_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="iter-list">
                <t t-foreach="[3, 2, 1]">
                    [<t t-esc="item_index"/>: <t t-esc="item"/> <t t-esc="item_value"/>]</t>
            </t>'''
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn("KeyError: 't-as'", error)
            self.assertIn('<t t-foreach="[3, 2, 1]"/>', error)

    def test_foreach_as_error_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="iter-list">
                <t t-foreach="[3, 2, 1]" t-as="">
                    [<t t-esc="item_index"/>: <t t-esc="item"/> <t t-esc="item_value"/>]</t>
            </t>'''
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn("KeyError: 't-as'", error)
            self.assertIn('<t t-foreach="[3, 2, 1]" t-as=""/>', error)

    def test_foreach_as_error_3(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="iter-list">
                <t t-foreach="[3, 2, 1]" t-as="b-2">
                    [<t t-esc="item_index"/>: <t t-esc="item"/> <t t-esc="item_value"/>]</t>
            </t>'''
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn("The varname 'b-2' can only contain alphanumeric characters and underscores", error)
            self.assertIn('<t t-foreach="[3, 2, 1]" t-as="b-2"/>', error)

    def test_compile_expr_security(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <div>
                    <t t-set="o" t-value="(lambda a=open: a)()"/>
                    <t t-out="o('/etc/passwd').read()"/>
                </div>
            </t>'''
        })
        values = {'other': 'any value'}
        with self.assertRaises(Exception): # NotImplementedError for 'lambda a=open' and Undefined value 'open'.
            self.env['ir.qweb']._render(t.id, values)

    def test_foreach_iter_list(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="iter-list">
                <t t-foreach="[3, 2, 1]" t-as="item">
                    [<t t-esc="item_index"/>: <t t-esc="item"/> <t t-esc="item_value"/>]</t>
            </t>'''
        })
        result = """
                    [0: 3 3]
                    [1: 2 2]
                    [2: 1 1]
        """

        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_foreach_iter_dict(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="iter-dict">
                <t t-foreach="{'a': 3, 'b': 2, 'c': 1}" t-as="item">
                    [<t t-esc="item_index"/>: <t t-esc="item"/> <t t-esc="item_value"/>]</t>
            </t>'''
        })
        result = """
                    [0: a 3]
                    [1: b 2]
                    [2: c 1]
        """

        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_att_escaping_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <div t-att-bibi="json.dumps(bibi)">1</div>
                <div t-att-toto="toto">2</div>
            </t>'''
        })
        result = """
                <div bibi="{&#34;a&#34;: &#34;string&#34;, &#34;b&#34;: 1}">1</div>
                <div toto="a&#39;b&#34;c">2</div>
            """
        values = {'json': json_scriptsafe, 'bibi': dict(a='string', b=1), 'toto': "a'b\"c"}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_att_escaping_2(self):

        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <t t-set="abc"> <t t-if="add_abc"><t t-out="add_abc"/> <span a="b"> | </span></t><t t-out="efg"/> </t>
                <div t-att-abc="abc">123</div>
            </t>'''
        })
        result = """
                <div abc=" &amp;#34;yes&amp;#34; &lt;span a=&#34;b&#34;&gt; | &lt;/span&gt;-efg- ">123</div>
            """
        values = {'add_abc': '"yes"', 'efg': '-efg-'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_attf_escaping_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <div t-attf-bibi="a, b &gt; c &gt; #{d}">1</div>
            </t>'''
        })
        result = """
                <div bibi="a, b &gt; c &gt; a&#39; &gt; b&#34;c">1</div>
            """
        values = {'d': "a' > b\"c"}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_attf_escaping_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <a t-attf-href="/link/#{ url }/#{other and 'sub'}">link</a>
                <a t-attf-href="/link/#{ url }/#{(not other) and 'sub'}">link2</a>
            </t>'''
        })
        result = """
                <a href="/link/odoo/sub">link</a>
                <a href="/link/odoo/">link2</a>
            """
        values = {'url': 'odoo', 'other': True}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_attf_escaping_3(self):

        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-escaping">
                <div t-attf-abc="abc #{val} { other }">123</div>
            </t>'''
        })
        result = """
                <div abc="abc &#34;yes&#34; { other }">123</div>
            """
        values = {'val': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_att_no_propagation_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="bibi">
                <div t-foreach="[1, 2]" t-as="v" class="toto"/>
                <t class="remove_me" t-set="data">a</t>
                <div t-out="data"/>
            </t>'''
        })
        result = """
                <div class="toto"></div><div class="toto"></div>
                <div>a</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_att_no_propagation_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="bibi">
                <section>
                    <div t-foreach="[1, 2]" t-as="v">
                        <span t-att-test="v" t-esc="v_index"/>
                    </div>
                    <div t-foreach="[1, 2]" t-as="v" class="o">
                        <span t-att-test="v" t-esc="v_index"/>
                    </div>
                </section>
            </t>'''
        })
        result = """
                <section>
                    <div>
                        <span test="1">0</span>
                    </div>
                    <div>
                        <span test="2">1</span>
                    </div>
                    <div class="o">
                        <span test="1">0</span>
                    </div>
                    <div class="o">
                        <span test="2">1</span>
                    </div>
                </section>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(etree.fromstring(rendered), etree.fromstring(result))

    def test_set_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="a" t-value="'abc %s' % 1"/>
                <div t-out="a"/>
            </t>'''
        })
        result = """
                <div>abc 1</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_set_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="a" t-valuef="abc {{1}}"/>
                <div t-out="a"/>
            </t>'''
        })
        result = """
                <div>abc 1</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_set_3(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set='{"a": "abc %s" % 1,
                    "b": 2}'/>
                <div t-out="a"/>
            </t>'''
        })
        result = """
                <div>abc 1</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_set_body_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="abc"> <span a="b"> [%s] </span> </t>
                <div t-att-abc="abc % add_abc">123</div>
            </t>'''
        })
        result = """
                <div abc=" &lt;span a=&#34;b&#34;&gt; [&amp;#34;yes&amp;#34;] &lt;/span&gt; ">123</div>
            """
        values = {'add_abc': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_set_body_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="abc"> <span a="b"> toto </span> </t>
                <div t-att-abc="'[%s]' % abc">123</div>
                <div class="a1" t-out="abc"/>
                <div class="a2" t-out="'[%s]' % abc"/>
            </t>'''
        })
        result = """
                <div abc="[ &lt;span a=&#34;b&#34;&gt; toto &lt;/span&gt; ]">123</div>
                <div class="a1"> <span a="b"> toto </span> </div>
                <div class="a2">[ &lt;span a=&#34;b&#34;&gt; toto &lt;/span&gt; ]</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_set_error_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="" t-value="1"/>
            </t>'''
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn("KeyError: 't-set'", error)
            self.assertIn('<t t-set="" t-value="1"/>', error)

    def test_set_error_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="b-2" t-value="1"/>
            </t>'''
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn("The varname can only contain alphanumeric characters and underscores", error)
            self.assertIn('<t t-set="b-2" t-value="1"/>', error)

    def test_out(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="out-format"><div t-out="a">Default</div></t>'''
        })
        result = """<div>1</div>"""
        rendered = self.env['ir.qweb']._render(t.id, {'a': 1})
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="out-format">
                <t t-set="final_message">Powered by %s%s</t>
                <div t-out="final_message % (a, b and ('-%s' % b) or '')"/>
            </t>'''
        })
        result = """
                <div>Powered by 1-2</div>
        """
        rendered = self.env['ir.qweb']._render(t.id, {'a': 1, 'b': 2})
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="set">
                <t t-set="toto">Toto %s</t>
                <t t-set="abc"> <span a="b"> [%s , %s] </span> </t>
                <div t-out="(abc % (add_abc, toto)) % 5">123</div>
            </t>'''
        })
        result = """
                <div> <span a="b"> [&#34;yes&#34; , Toto 5] </span> </div>
            """
        values = {'add_abc': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_3(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-set">
                <t t-set="toto">Toto %s</t>
                <t t-set="abc"> <span a="b"> a </span> </t>
                <div t-out="(toto + abc) % v">123</div>
            </t>'''
        })
        result = """
                <div>Toto &#34;yes&#34; <span a="b"> a </span> </div>
            """
        values = {'v': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_4(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-set">
                <t t-set="abc"> <span a="b"> a </span> </t>
                <div t-out="(v + abc)">123</div>
            </t>'''
        })
        result = """
                <div>&#34;yes&#34; <span a="b"> a </span> </div>
            """
        values = {'v': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_5(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-set">
                <t t-set="abc"> <span a="b"> a </span> </t>
                <div t-out="(abc + v)">123</div>
            </t>'''
        })
        result = """
                <div> <span a="b"> a </span> &#34;yes&#34;</div>
            """
        values = {'v': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_format_6(self):
        # Use str method will use the string value. t-out will escape this str
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-set">
                <t t-set="abc"> <span a="b"> a </span> </t>
                <div t-out="(abc.strip() + v)">123</div>
            </t>'''
        })
        result = """
                <div><span a="b"> a </span>&#34;yes&#34;</div>
            """
        values = {'v': '"yes"'}
        rendered = self.env['ir.qweb']._render(t.id, values)
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_escape_text(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy"><root><span t-out="text" t-options-widget="'text'"/></root></t>
            """
        })
        html = self.env['ir.qweb']._render(view1.id, {'text': """a
        b <b>c</b>"""})
        self.assertEqual(html, """<root><span data-oe-type="text" data-oe-expression="text">a<br>
        b &lt;b&gt;c&lt;/b&gt;</span></root>""")

    def test_out_markup(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="esc-markup">
                <t t-set="content"><span>toto</span></t>
                <div t-out="content"/>
            </t>'''
        })
        result = """
                <div><span>toto</span></div>
        """
        rendered = self.env['ir.qweb']._render(t.id, {})
        self.assertEqual(rendered.strip(), result.strip())

    def test_out_default_value(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="out-default">
                <span rows="10" t-out="a">
                    DEFAULT
                    <t t-out="'Text'" />
                </span>
            </t>'''
        })
        result = """
                <span rows="10">Hello</span>
        """
        rendered = self.env['ir.qweb']._render(t.id, {'a': 'Hello'})
        self.assertEqual(str(rendered.strip()), result.strip())

        result = """
                <span rows="10">
                    DEFAULT
                    Text
                </span>
        """
        rendered = self.env['ir.qweb']._render(t.id, {})
        self.assertEqual(str(rendered.strip()), result.strip())

    def test_esc_markup(self):
        # t-esc is equal to t-out
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="esc-markup">
                <t t-set="content"><span>toto</span></t>
                <div t-esc="content"/>
            </t>'''
        })
        ref = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="esc-markup">
                <t t-set="content"><span>toto</span></t>
                <div t-out="content"/>
            </t>'''
        })
        rendered = self.env['ir.qweb']._render(t.id, {})
        result = self.env['ir.qweb']._render(ref.id, {})
        self.assertEqual(rendered.strip(), result.strip())

    def test_if_from_body(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="attr-set">
                <t t-set="abc"> <span a="b"> a </span> </t>
                <div t-if="abc">123</div>
                <div t-if="not abc">456</div>
            </t>'''
        })
        result = """
                <div>123</div>
            """
        rendered = self.env['ir.qweb']._render(t.id)
        self.assertEqual(rendered.strip(), result.strip())

    def test_if_spaces(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="test">
                <div>
                    0
                    <t>1</t>
                    <t t-if="True">2</t>
                    <t>3</t>
                    4
                    <t>5</t>
                    6
                    <t t-if="True">7</t>
                    8
                    <t t-if="False">9</t>
                    10
                    <t t-if="False">11</t>
                    <t t-else="">12</t>
                    13
                </div>
            </t>'''
        })
        result = """
                <div>
                    0
                    1
                    2
                    3
                    4
                    5
                    6
                    7
                    8
                    10
                    12
                    13
                </div>
            """
        rendered = str(self.env['ir.qweb']._render(t.id))
        self.assertEqual(rendered.strip(), result.strip())

    def test_error_message_1(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="test">
                <section>
                    <div t-esc="abc + def">
                        <span>content</span>
                    </div>
                </section>
            </t>'''
        })
        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn('<div t-esc="abc + def"/>', error)

    def test_error_message_2(self):
        t = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name="test">
                <section>
                    <div t-esc="abc + def + (">
                        <span>content</span>
                    </div>
                </section>
            </t>'''
        })
        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(t.id)

        try:
            self.env['ir.qweb']._render(t.id)
        except QWebException as e:
            error = str(e)
            self.assertIn('Can not compile expression', error)
            self.assertIn('<div t-esc="abc + def + ("/>', error)

    def test_error_message_3(self):
        # The format error tells the developer what to do.
        template = '''<section>
                    <div t-esc="1+2">
                        <span>content</span>
                    </div>
                </section>'''
        with self.assertRaises(ValueError):
            self.env['ir.qweb']._render(template)
        try:
            self.env['ir.qweb']._render(template)
        except ValueError as e:
            self.assertIn('Inline templates must be passed as `etree` documents', str(e))

        template = '''toto <t t-esc="content"/>'''
        with self.assertRaises(ValueError):
            self.env['ir.qweb']._render(template)
        try:
            self.env['ir.qweb']._render(template)
        except ValueError as e:
            self.assertIn('Inline templates must be passed as `etree` documents', str(e))

    def test_error_message_4(self):
        # Template record view not found.
        with self.assertRaises(MissingError):
            self.env['ir.qweb']._render(-999)
        try:
            self.env['ir.qweb']._render(-999)
        except MissingError as e:
            self.assertIn('Record does not exist or has been deleted.', str(e))

        with self.assertRaises(ValueError):
            self.env['ir.qweb']._render('not.wrong_template_xmlid')
        try:
            self.env['ir.qweb']._render('not.wrong_template_xmlid')
        except ValueError as e:
            self.assertIn('External ID not found in the system', str(e))

        with self.assertRaises(AssertionError):
            self.env['ir.qweb']._render(False)
        try:
            self.env['ir.qweb']._render(False)
        except AssertionError as e:
            self.assertIn('template is required', str(e))

    def test_error_message_5(self):
        # Error not found a first rendering.
        with self.assertRaises(MissingError, msg="Not Found"):
            self.env['ir.qweb']._render(-9999)

    @mute_logger('odoo.addons.base.models.ir_qweb') # warning for template not found
    def test_error_message_6(self):
        # Error not found a second rendering (first rendering with option hide this error).
        html = self.env['ir.qweb']._render(-9999, raise_if_not_found=False)
        self.assertEqual('', html)

        # re try this rendering without any error (use cached method)
        html = self.env['ir.qweb']._render(-9999, raise_if_not_found=False)
        self.assertEqual('', html)

        # re try this rendering but raise (use cached method)
        with self.assertRaises(MissingError, msg="Not Found"):
            self.env['ir.qweb']._render(-9999)

    def test_error_message_7(self):
        # UserError not found a first rendering.
        with self.assertRaises(UserError, msg="Not Found"):
            self.env['ir.qweb']._render(-9999)

    @mute_logger('odoo.addons.base.models.ir_qweb') # warning for template not found
    def test_error_message_8(self):
        # UserError not found a second rendering (first rendering with option hide this error).
        html = self.env['ir.qweb']._render(-9999, raise_if_not_found=False)
        self.assertEqual('', html)

        # re try this rendering without any error (use cached method)
        html = self.env['ir.qweb']._render(-9999, raise_if_not_found=False)
        self.assertEqual('', html)

        # re try this rendering but raise (use cached method)
        with self.assertRaises(UserError, msg="Not Found"):
            self.env['ir.qweb']._render(-9999)

    def test_call_set(self):
        view0 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <table>
                        <tr><td t-out="a"/></tr>
                        <t t-set="a">3</t>
                    </table>
                </t>
            """
        })
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')", [view0.id])

        view1 = self.env['ir.ui.view'].create({
            'name': "other",
            'type': 'qweb',
            'arch': """
                <t t-name="base.other">
                    <div>
                        <t t-set="a">1</t>
                        <t t-set="b">1</t>
                        <t t-call="base.dummy">
                            <t t-set="b">2</t>
                        </t>
                        <span t-out="a"/>
                        <span t-out="b"/>
                    </div>
                </t>
            """
        })

        result = self.env['ir.qweb']._render(view1.id, {})
        self.assertEqual(etree.fromstring(result), etree.fromstring("""
            <div>
                <table>
                    <tr><td>1</td></tr>
                </table>
                <span>1</span>
                <span>1</span>
            </div>
        """), 'render t-call use lexical scoping, t-call content use independant scoping')

    def test_call_error(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "other",
            'type': 'qweb',
            'arch': """
                <t t-name="base.other">
                    <div>
                        <t t-call="base.dummy"/>
                    </div>
                </t>
            """
        })

        with self.assertRaises(QWebException):
            self.env['ir.qweb']._render(view1.id)

        try:
            self.env['ir.qweb']._render(view1.id)
        except QWebException as e:
            error = str(e)
            self.assertIn('External ID not found in the system: base.dummy', error)
            self.assertIn('<t t-call="base.dummy"/>', error)

    def test_render_t_call_propagates_t_lang(self):
        current_lang = 'en_US'
        other_lang = 'fr_FR'

        lang = self.env['res.lang']._activate_lang(other_lang)
        lang.write({
            'decimal_point': '*',
            'thousands_sep': '/'
        })

        view1 = self.env['ir.ui.view'].create({
            'name': "callee",
            'type': 'qweb',
            'arch': """
                <t t-name="base.callee">
                    <t t-esc="9000000.00" t-options="{'widget': 'float', 'precision': 2}" />
                </t>
            """
        })
        self.env['ir.model.data'].create({
            'name': 'callee',
            'model': 'ir.ui.view',
            'module': 'base',
            'res_id': view1.id,
        })

        view2 = self.env['ir.ui.view'].create({
            'name': "calling",
            'type': 'qweb',
            'arch': """
                <t t-name="base.calling">
                    <t t-call="base.callee" t-lang="'%s'" />
                </t>
            """ % other_lang
        })

        rendered = self.env['ir.qweb'].with_context(lang=current_lang)._render(view2.id).strip()
        self.assertEqual(rendered, '9/000/000*00')

    def test_render_barcode(self):
        partner = self.env['res.partner'].create({
            'name': 'bacode_test',
            'barcode': 'test'
        })

        view = self.env['ir.ui.view'].create({
            'name': "a_barcode_view",
            'type': 'qweb',
        })

        view.arch = """<div t-field="partner.barcode" t-options="{'widget': 'barcode', 'width': 100, 'height': 30}"/>"""
        rendered = self.env['ir.qweb']._render(view.id, values={'partner': partner}).strip()
        self.assertRegex(rendered, r'<div><img alt="Barcode test" src="data:image/png;base64,\S+"></div>')

        partner.barcode = '4012345678901'
        view.arch = """<div t-field="partner.barcode" t-options="{'widget': 'barcode', 'symbology': 'EAN13', 'width': 100, 'height': 30, 'img_style': 'width:100%;', 'img_alt': 'Barcode'}"/>"""
        ean_rendered = self.env['ir.qweb']._render(view.id, values={'partner': partner}).strip()
        self.assertRegex(ean_rendered, r'<div><img style="width:100%;" alt="Barcode" src="data:image/png;base64,\S+"></div>')

        view.arch = """<div t-field="partner.barcode" t-options="{'widget': 'barcode', 'symbology': 'auto', 'width': 100, 'height': 30, 'img_style': 'width:100%;', 'img_alt': 'Barcode'}"/>"""
        auto_rendered = self.env['ir.qweb']._render(view.id, values={'partner': partner}).strip()
        self.assertRegex(auto_rendered, r'<div><img style="width:100%;" alt="Barcode" src="data:image/png;base64,\S+"></div>')

    def test_render_comment_tail(self):
        """ Test the rendering of a tail text, near a comment.
        """

        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': "qweb",
            'arch': """
            <t>
                <!-- it is a comment -->
                <!-- it is another comment -->
                Text 1
                <!-- it is still another comment -->
                Text 2
                <t>ok</t>
            </t>
            """
        })
        emptyline = '\n                '
        expected = markupsafe.Markup('Text 1' + emptyline + emptyline + 'Text 2' + emptyline + 'ok')
        self.assertEqual(self.env['ir.qweb']._render(view1.id).strip(), expected)

    def test_render_comments(self):
        """ Test the rendering of comments with and without the
            preserve_comments option.
        """
        comment = '<!-- Hello, world! -->'
        view = self.env['ir.ui.view'].create({
            'name': 'dummy',
            'type': 'qweb',
            'arch': f'<t><p>{comment}</p></t>'
        })
        QWeb = self.env['ir.qweb']
        self.assertEqual(
            QWeb.with_context(preserve_comments=False)._render(view.id),
            markupsafe.Markup('<p></p>'),
            "Should not have the comment")
        self.env.registry.clear_cache('templates')
        self.assertEqual(
            QWeb.with_context(preserve_comments=True)._render(view.id),
            markupsafe.Markup(f'<p>{comment}</p>'),
            "Should have the comment")

    def test_render_processing_instructions(self):
        """ Test the rendering of processing instructions with and without the
            preserve_comments option.
        """
        p_instruction = '<?hello world?>'
        view = self.env['ir.ui.view'].create({
            'name': 'dummy',
            'type': 'qweb',
            'arch': f'<t><p>{p_instruction}</p></t>'
        })
        QWeb = self.env['ir.qweb']
        self.assertEqual(
            QWeb.with_context(preserve_comments=False)._render(view.id),
            markupsafe.Markup('<p></p>'),
            "Should not have the processing instruction")
        self.env.registry.clear_cache('templates')
        self.assertEqual(
            QWeb.with_context(preserve_comments=True)._render(view.id),
            markupsafe.Markup(f'<p>{p_instruction}</p>'),
            "Should have the processing instruction")

    def test_render_widget_contact(self):
        u = self.env['res.users'].create({
            'name': 'Test',
            'login': 'test@example.com',
        })
        u.name = ""
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy"><root><span t-esc="user" t-options='{"widget": "contact", "fields": ["name"]}' /></root></t>
            """
        })
        self.env['ir.qweb']._render(view1.id, {'user': u})  # should not crash

    def test_render_widget_duration_fallback(self):
        self.env['res.lang'].with_context(active_test=False).search([('code', '=', 'pt_BR')]).active = True
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy"><root><span t-esc="3600" t-options='{"widget": "duration", "format": "short"}' /></root></t>
            """
        })
        self.env['ir.qweb'].with_context(lang='pt_BR')._render(view1.id, {})  # should not crash

    def test_void_element(self):
        view = self.env['ir.ui.view'].create({
            'name': 'master',
            'type': 'qweb',
            'arch_db': '''<t t-name='master'>
                <meta name="1"/>
                <t t-set="data" t-value="1"/>
                <meta groups="base.group_no_one" name="2"/>
                <meta t-if="False" name="3"/>
                <meta t-if="True" name="4"/>
                <span t-out="1"/>
            </t>'''
        })

        result = '''
                <meta name="1"/>
                <meta name="4"/>
                <span>1</span>
            '''
        rendered = self.env['ir.qweb']._render(view.id)

        self.assertEqual(str(rendered).strip(), result.strip())

    def test_space_remove_technical_space_t_foreach(self):
        view = self.env['ir.ui.view'].create({
            'name': 'master',
            'type': 'qweb',
            'arch_db': '''<t t-name='master'>
                    <section>
                        <article t-foreach="[0, 1, 2]" t-as="value" t-esc="value"/>
                        <t t-foreach="[0, 1, 2]" t-as="value">
                            <article t-esc="value"/>
                        </t>
                    </section>
                </t>'''})

        result = '''
                    <section>
                        <article>0</article><article>1</article><article>2</article>
                            <article>0</article>
                            <article>1</article>
                            <article>2</article>
                    </section>'''

        rendered = self.env['ir.qweb']._render(view.id)

        self.assertEqual(str(rendered), result)

    def test_space_remove_technical_all(self):
        test = self.env['ir.ui.view'].create({
            'name': 'test',
            'type': 'qweb',
            'arch_db': '''<t t-name='test'>
                <span t-out="value"/>
            </t>'''
        })
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('test', 'ir.ui.view', %s, 'base')", [test.id])

        view = self.env['ir.ui.view'].create({
            'name': 'master',
            'type': 'qweb',
            'arch_db': '''<t t-name='master'>

                    <section>
                        <meta name="1"/>
                        <t t-set="data" t-value="1"/>
                        <meta groups="base.group_no_one" name="2"/>
                        <meta t-if="False" name="3"/>
                        <meta t-if="True" name="4"/>

                        <article>
                            <t t-foreach="[0, 1]" t-as="value">
                                <t t-call="base.test"/>
                            </t>

                            <t t-if="False">
                                a
                            </t>
                    
                            b

                            <t t-if="True">
                                c <t t-out="1"/>  
                                d
                            </t>
                        </article>


                        <article>
                            <div t-foreach="[0, 1]" t-as="value">
                                <t t-call="base.test"/>
                            </div>

                            <i t-if="False">
                                a
                            </i>
                            <u t-if="False">
                                a
                            </u>
                    
                            b

                            <i t-if="True">
                                c <t t-out="1"/>  
                                d
                            </i>
                        </article>
                    </section>
                </t>'''
        })

        result = '''
                    <section>
                        <meta name="1"/>
                        <meta name="4"/>

                        <article>
                <span>0</span>
                <span>1</span>

                    
                            b

                                c 1  
                                d
                        </article>


                        <article>
                            <div>
                <span>0</span>
                            </div><div>
                <span>1</span>
                            </div>

                    
                            b

                            <i>
                                c 1  
                                d
                            </i>
                        </article>
                    </section>'''

        rendered = self.env['ir.qweb']._render(view.id)
        self.assertEqual(str(rendered), result)

class TestQwebCache(TransactionCase):
    def test_render_xml_cache_base(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="cache_id" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        expected_result = etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """)

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [1, 2, 3]}))
        self.assertEqual(result, expected_result, 'First rendering (add in cache)')

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [10, 20, 30]}))
        self.assertEqual(result, expected_result, 'Next rendering use cache')

    def test_render_xml_cache_different(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                        <table t-cache="cache_id2">
                            <tr><td><span t-esc="value2[0]"/></td></tr>
                            <tr><td><span t-esc="value2[1]"/></td></tr>
                            <tr><td><span t-esc="value2[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1,),
            'cache_id2': (1,),
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """), 'First rendering (add in cache with different cache)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (2, 5, 6),
            'cache_id2': (2, 5, 5),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>41</span></td></tr>
                    <tr><td><span>42</span></td></tr>
                    <tr><td><span>43</span></td></tr>
                </table>
                <table>
                    <tr><td><span>51</span></td></tr>
                    <tr><td><span>52</span></td></tr>
                    <tr><td><span>53</span></td></tr>
                </table>
            </div>
        """), 'Use different cache id')

    def test_render_xml_cache_contains_nocache(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="cache_id" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr t-nocache=""><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [1, 2, 3]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """), 'First rendering add compiled values in cache')

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [10, 20, 30]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """), 'Next rendering use cache exept for t-nocache=""')

    def test_render_xml_cache_nocache_cache(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><t t-esc="value[0]"/></td></tr>
                            <tr>
                                <td>
                                    <table t-nocache="The content is not used, we can put documentation in it." t-cache="cache_id2">
                                        <tr><td><t t-esc="value2[0]"/></td></tr>
                                        <tr><td><t t-esc="value2[1]"/></td></tr>
                                        <tr><td><t t-esc="value2[2]"/></td></tr>
                                    </table>
                                </td>
                            </tr>
                            <tr><td><t t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 0),
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'First rendering (add in cache)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 1),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'Second rendering (change inside cache id)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 1),
            'cache_id2': (2, 0),
            'value': [31, 32, 33],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>31</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>33</td></tr>
                </table>
            </div>
        """), 'Third rendering (change main cache id, old cache inside)')

    def test_render_xml_cache_nocache_cache_on_same_tag(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><t t-esc="value[0]"/></td></tr>
                            <tr t-nocache="">
                                <td>
                                    <table t-cache="cache_id2">
                                        <tr><td><t t-esc="value2[0]"/></td></tr>
                                        <tr><td><t t-esc="value2[1]"/></td></tr>
                                        <tr><td><t t-esc="value2[2]"/></td></tr>
                                    </table>
                                </td>
                            </tr>
                            <tr><td><t t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 0),
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'First rendering (add in cache)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 1),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'Second rendering (change inside cache id)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 1),
            'cache_id2': (2, 0),
            'value': [31, 32, 33],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>31</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>33</td></tr>
                </table>
            </div>
        """), 'Third rendering (change main cache id, old cache inside)')

    def test_render_xml_dont_use_cache_base(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="cache_id" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=True)

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [1, 2, 3]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """), 'First rendering')

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [10, 20, 30]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """), 'Next rendering cannot cache (use_qweb_t_cache is False)')

    def test_render_xml_dont_use_cache_different(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                        <table t-cache="cache_id2">
                            <tr><td><span t-esc="value2[0]"/></td></tr>
                            <tr><td><span t-esc="value2[1]"/></td></tr>
                            <tr><td><span t-esc="value2[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=True)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': 1,
            'cache_id2': 1,
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """), 'First rendering')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (2, 5, 6),
            'cache_id2': (2, 5, 5),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>41</span></td></tr>
                    <tr><td><span>42</span></td></tr>
                    <tr><td><span>43</span></td></tr>
                </table>
                <table>
                    <tr><td><span>51</span></td></tr>
                    <tr><td><span>52</span></td></tr>
                    <tr><td><span>53</span></td></tr>
                </table>
            </div>
        """), 'Use different cache id')

    def test_render_xml_dont_use_cache_contains_nocache(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="cache_id" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr t-nocache=""><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=True)

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [1, 2, 3]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """), 'First rendering')

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [10, 20, 30]}))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """), 'Next rendering cannot use cache (use_qweb_t_cache is False)')

    def test_render_xml_dont_use_cache_recursive(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><t t-esc="value[0]"/></td></tr>
                            <tr>
                                <td>
                                    <table t-nocache="" t-cache="cache_id2">
                                        <tr><td><t t-esc="value2[0]"/></td></tr>
                                        <tr><td><t t-esc="value2[1]"/></td></tr>
                                        <tr><td><t t-esc="value2[2]"/></td></tr>
                                    </table>
                                </td>
                            </tr>
                            <tr><td><t t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=True)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 0),
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'First rendering')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 1),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>41</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>43</td></tr>
                </table>
            </div>
        """), 'Next rendering cannot use cache (use_qweb_t_cache is False)')

        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 1),
            'cache_id2': (2, 0),
            'value': [31, 32, 33],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>31</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>33</td></tr>
                </table>
            </div>
        """), 'Third rendering cannot use cache (use_qweb_t_cache is False)')

    def test_render_xml_dont_use_cache_false_recursive(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div class="toto">
                        <table t-cache="cache_id">
                            <tr><td><t t-esc="value[0]"/></td></tr>
                            <tr t-nocache="">
                                <td>
                                    <table t-cache="cache_id2">
                                        <tr><td><t t-esc="value2[0]"/></td></tr>
                                        <tr><td><t t-esc="value2[1]"/></td></tr>
                                        <tr><td><t t-esc="value2[2]"/></td></tr>
                                    </table>
                                </td>
                            </tr>
                            <tr><td><t t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=True)

        # use same cache id, display the same content
        result = etree.fromstring(IrQweb._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 0),
            'value': [1, 2, 3],
            'value2': [10, 20, 30]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>1</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>10</td></tr>
                                <tr><td>20</td></tr>
                                <tr><td>30</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>3</td></tr>
                </table>
            </div>
        """), 'First rendering')

        result = etree.fromstring(self.env['ir.qweb']._render(view1.id, {
            'cache_id': (1, 0),
            'cache_id2': (2, 1),
            'value': [41, 42, 43],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>41</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>43</td></tr>
                </table>
            </div>
        """), 'Next rendering cannot use cache (use_qweb_t_cache is False)')

        result = etree.fromstring(self.env['ir.qweb']._render(view1.id, {
            'cache_id': (1, 1),
            'cache_id2': (2, 0),
            'value': [31, 32, 33],
            'value2': [51, 52, 53]
        }))
        self.assertEqual(result, etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td>31</td></tr>
                    <tr>
                        <td>
                            <table>
                                <tr><td>51</td></tr>
                                <tr><td>52</td></tr>
                                <tr><td>53</td></tr>
                            </table>
                        </td>
                    </tr>
                    <tr><td>33</td></tr>
                </table>
            </div>
        """), 'Third rendering cannot use cache (use_qweb_t_cache is False)')

    def test_render_xml_nocache_use_the_root_values(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <section t-cache="cache_id">
                        <t t-set="counter" t-value="counter + 100"/>
                        <article t-nocache=""><t t-out="counter"/></article>
                        <div>cache: <t t-out="counter"/></div>
                    </section>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 1,
        })
        result = """
            <section>
                <article>1</article>
                <div>cache: 101</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1 (101 != 1: cached t-set should never be applied on root rendering)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 2,
        })
        result = """
            <section>
                <article>2</article>
                <div>cache: 101</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2 (102 != 2: cached t-set should never be applied on root rendering)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 3,
            'counter': 3,
        })
        result = """
            <section>
                <article>3</article>
                <div>cache: 103</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3 (103 != 3: cached t-set should never be applied on root rendering)')

    def test_render_xml_nocache_use_the_root_values_and_cached_values(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <section t-cache="cache_id">
                        <t t-set="counter" t-value="counter + 100"/>
                        <article t-nocache="" t-nocache-counter="counter"><t t-out="counter"/></article>
                        <div>cache: <t t-out="counter"/></div>
                    </section>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 1,
        })
        result = """
            <section>
                <article>101</article>
                <div>cache: 101</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1 (1 != 101: new cached values should be add to the root rendering)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 2,
        })
        result = """
            <section>
                <article>101</article>
                <div>cache: 101</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2 (102 != 2: cached values should be used)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 3,
            'counter': 3,
        })
        result = """
            <section>
                <article>103</article>
                <div>cache: 103</div>
            </section>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3 (3 != 103: new cached values should be add to the root rendering)')

    def test_render_xml_nocache_use_the_root_values_and_cached_values_error(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <section t-cache="cache_id">
                        <article t-nocache="" t-nocache-record="view_record"><t t-out="view_record"/></article>
                    </section>
                </t>
            """
        })

        with self.assertRaisesRegex(QWebException, "The value type of 't-nocache-record' cannot be cached"):
            self.env['ir.qweb'].with_context(is_t_cache_disabled=False)._render(template_page.id, {
                'cache_id': 1,
                'view_record': self.env['ir.ui.view'].search([], limit=1),
            })

    def test_render_xml_cache_with_t_set_out_of_cache(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <root>
                        <t t-set="counter" t-value="counter + 100"/>
                        <section t-cache="cache_id">
                            <article t-nocache=""><t t-out="counter"/></article>
                            <div>cache: <t t-out="counter"/></div>
                        </section>
                    </root>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 1,
        })
        result = """
            <root>
                <section>
                    <article>1</article>
                    <div>cache: 101</div>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1 (1 != 101: cached t-set should is applied on first rendering)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 2,
        })
        result = """
            <root>
                <section>
                    <article>2</article>
                    <div>cache: 101</div>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2 (2 != 102: cached t-set should be applied the template part are rendered every time)')

        render = IrQweb._render(template_page.id, {
            'cache_id': 3,
            'counter': 3,
        })
        result = """
            <root>
                <section>
                    <article>3</article>
                    <div>cache: 103</div>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3 (3 != 103: cached t-set should applied because the new cache key is created)')

    def test_render_xml_cache_with_t_set_in_cache(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <root>
                        <section t-cache="cache_id">
                            <t t-set="counter" t-value="counter + 100"/>
                            <article t-nocache=""><t t-out="counter"/></article>
                            <div>cache: <t t-out="counter"/></div>
                        </section>
                        <div>out of cache: <t t-out="counter"/></div>
                    </root>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 1,
        })
        result = """
            <root>
                <section>
                    <article>1</article>
                    <div>cache: 101</div>
                </section>
                <div>out of cache: 1</div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1')

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 2,
        })
        result = """
            <root>
                <section>
                    <article>2</article>
                    <div>cache: 101</div>
                </section>
                <div>out of cache: 2</div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2')

        render = IrQweb._render(template_page.id, {
            'cache_id': 3,
            'counter': 3,
        })
        result = """
            <root>
                <section>
                    <article>3</article>
                    <div>cache: 103</div>
                </section>
                <div>out of cache: 3</div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3')

    def test_render_xml_cache_with_t_set_wrap_t_cache(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <root t-cache="cache_1">
                        <t t-set="a">
                            <section t-cache="cache_2">
                                <t t-set="counter" t-value="counter + 100"/>
                                <article t-nocache="" class="no_cache"><t t-out="counter"/></article>
                                <div>cache: <t t-out="counter"/></div>
                            </section>
                            <footer t-nocache="" class="no_cache"><t t-out="counter * 10"/></footer>
                        </t>
                        <div>
                            <t t-out="a"/>
                        </div>
                    </root>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_1': 1,
            'cache_2': 1,
            'counter': 1,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">1</article>
                        <div>cache: 101</div>
                    </section>
                    <footer class="no_cache">10</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1')

        render = IrQweb._render(template_page.id, {
            'cache_1': 2,
            'cache_2': 1,
            'counter': 2,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">2</article>
                        <div>cache: 101</div>
                    </section>
                    <footer class="no_cache">20</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2')

        render = IrQweb._render(template_page.id, {
            'cache_1': 2,
            'cache_2': 3,
            'counter': 3,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">2</article>
                        <div>cache: 101</div>
                    </section>
                    <footer class="no_cache">20</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3')

        render = IrQweb._render(template_page.id, {
            'cache_1': 3,
            'cache_2': 3,
            'counter': 3,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">3</article>
                        <div>cache: 103</div>
                    </section>
                    <footer class="no_cache">30</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 4')

    def test_render_xml_t_set_wrap_t_cache(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <root>
                        <t t-set="a">
                            <section t-cache="cache_id">
                                <t t-set="counter" t-value="counter + 100"/>
                                <article t-nocache="" class="no_cache"><t t-out="counter"/></article>
                                <div>cache: <t t-out="counter"/></div>
                            </section>
                            <footer t-nocache="" class="no_cache"><t t-out="counter * 10"/></footer>
                        </t>
                        <div>
                            <t t-out="a"/>
                        </div>
                    </root>
                </t>
            """
        })
        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 1,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">1</article>
                        <div>cache: 101</div>
                    </section>
                    <footer class="no_cache">10</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1')

        render = IrQweb._render(template_page.id, {
            'cache_id': 1,
            'counter': 2,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">2</article>
                        <div>cache: 101</div>
                    </section>
                    <footer class="no_cache">20</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2')

        render = IrQweb._render(template_page.id, {
            'cache_id': 3,
            'counter': 3,
        })
        result = """
            <root>
                <div>
                    <section>
                        <article class="no_cache">3</article>
                        <div>cache: 103</div>
                    </section>
                    <footer class="no_cache">30</footer>
                </div>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3')

    def test_render_xml_nocache_in_cache_in_cache(self):
        template_page = self.env['ir.ui.view'].create({
            'name': "template_page",
            'type': 'qweb',
            'arch': """
                <t t-name="template_page">
                    <root>
                        <section t-cache="key1">
                            <span t-out="val"/>
                            <article t-cache="key2">
                                <span t-nocache="" t-out="val"/>
                            </article>
                        </section>
                    </root>
                </t>
            """
        })

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        render = IrQweb._render(template_page.id, {
            'key1': (1,),
            'key2': (1,),
            'val': 1,
        })
        result = """
            <root>
                <section>
                    <span>1</span>
                    <article>
                        <span>1</span>
                    </article>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 1')

        render = IrQweb._render(template_page.id, {
            'key1': (1,),
            'key2': (1,),
            'val': 2,
        })
        result = """
            <root>
                <section>
                    <span>1</span>
                    <article>
                        <span>2</span>
                    </article>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 2')

        render = IrQweb._render(template_page.id, {
            'key1': (1,),
            'key2': (2,),
            'val': 3,
        })
        result = """
            <root>
                <section>
                    <span>1</span>
                    <article>
                        <span>3</span>
                    </article>
                </section>
            </root>
        """
        self.assertEqual(etree.fromstring(render), etree.fromstring(result), 'rendering 3')

    def test_render_xml_conditional_cache(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="cache_id if condition else None" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        expected_result = etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """)

        IrQweb = self.env['ir.qweb'].with_context(is_t_cache_disabled=False)

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'condition': True, 'value': [1, 2, 3]}))
        self.assertEqual(result, expected_result, 'First rendering (add in cache)')

        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'condition': True, 'value': [10, 20, 30]}))
        self.assertEqual(result, expected_result, 'Next rendering use cache')


        expected_result = etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """)
        result = etree.fromstring(IrQweb._render(view1.id, {'cache_id': 1, 'value': [10, 20, 30]}))
        self.assertEqual(result, expected_result, 'Next rendering use cache')

    def test_render_xml_cache_and_inherit_view(self):
        view1 = self.env['ir.ui.view'].create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div t-cache="True" class="toto">
                        <table>
                            <tr><td><span t-esc="value[0]"/></td></tr>
                            <tr><td><span t-esc="value[1]"/></td></tr>
                            <tr><td><span t-esc="value[2]"/></td></tr>
                        </table>
                    </div>
                </t>
            """
        })
        # t-cache value can be an interable then we can add value as a tuple (without parenthesis)
        view2 = self.env['ir.ui.view'].create({
            'name': 'Child View',
            'mode': 'extension',
            'inherit_id': view1.id,
            'arch': '''
                <xpath expr="//div[@t-cache]" position="attributes">
                    <attribute name="t-cache" add="company,value[0]" remove="True," separator=","/>
                </xpath>
            ''',
        })

        IrQweb = self.env['ir.qweb'].with_context(use_qweb_t_cache=True)

        expected_result = etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>1</span></td></tr>
                    <tr><td><span>2</span></td></tr>
                    <tr><td><span>3</span></td></tr>
                </table>
            </div>
        """)
        result = etree.fromstring(IrQweb._render(view2.id, {'value': [1, 2, 3]}))
        self.assertEqual(result, expected_result, 'First rendering create cache from company and the value 1')

        expected_result = etree.fromstring("""
            <div class="toto">
                <table>
                    <tr><td><span>10</span></td></tr>
                    <tr><td><span>20</span></td></tr>
                    <tr><td><span>30</span></td></tr>
                </table>
            </div>
        """)
        result = etree.fromstring(IrQweb._render(view2.id, {'value': [10, 20, 30]}))
        self.assertEqual(result, expected_result, 'Next rendering create cache from company and the value 10')

    def test_render_nodb(self):
        """ Render an html page without db ans wihtout registry
        """
        expected = dedent("""
            <html>
                <head>
                    <title>Odoo</title>
                </head>
                <body>
                    <section class="toto">
                        <div>3</div>
                    </section>
                </body>
            </html>
        """).strip()

        templates = {
            'html': html.document_fromstring("""
                <html t-name="html">
                    <head>
                        <title>Odoo</title>
                    </head>
                    <body>
                        <section class="toto">
                            <t t-call="content"/>
                        </section>
                    </body>
                </html>
            """),
            'content': html.fragment_fromstring("""
                <t t-name="content">
                        <div><t t-out="val"/></div>
                </t>
            """)
        }
        def load(template_name):
            return (templates[template_name], template_name)
        rendering = render('html', {'val': 3}, load).strip()

        self.assertEqual(html.document_fromstring(rendering), html.document_fromstring(expected))

```

  File: tests/test_qweb_field.py
  Content:
```
# -*- coding: utf-8 -*-

from odoo.tests import common


class TestQwebFieldTime(common.TransactionCase):
    def value_to_html(self, value, options=None):
        options = options or {}
        return self.env['ir.qweb.field.time'].value_to_html(value, options)

    def test_time_value_to_html(self):
        default_fmt = {'format': 'h:mm a'}
        self.assertEqual(
            self.value_to_html(0, default_fmt),
            "12:00 AM"
        )

        self.assertEqual(
            self.value_to_html(11.75, default_fmt),
            "11:45 AM"
        )

        self.assertEqual(
            self.value_to_html(12, default_fmt),
            "12:00 PM"
        )

        self.assertEqual(
            self.value_to_html(14.25, default_fmt),
            "2:15 PM"
        )

        self.assertEqual(
            self.value_to_html(15.1, {'format': 'HH:mm:SS'}),
            "15:06:00"
        )

        # Only positive values can be used
        with self.assertRaises(ValueError):
            self.value_to_html(-6.5)

        # Only values inferior to 24 can be used
        with self.assertRaises(ValueError):
            self.value_to_html(24)


class TestQwebFieldInteger(common.TransactionCase):
    def value_to_html(self, value, options=None):
        options = options or {}
        return self.env['ir.qweb.field.integer'].value_to_html(value, options)

    def test_integer_value_to_html(self):
        self.assertEqual(self.value_to_html(1000), "1,000")
        self.assertEqual(self.value_to_html(1000000, {'format_decimalized_number': True}), "1M")
        self.assertEqual(
            self.value_to_html(125125, {'format_decimalized_number': True, 'precision_digits': 3}),
            "125.125k"
        )

```

  File: tests/test_reports.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import io
import logging
from base64 import b64decode
from unittest import skipIf

import odoo
import odoo.tests

try:
    from pdfminer.converter import PDFPageAggregator
    from pdfminer.layout import LAParams, LTFigure, LTTextBox
    from pdfminer.pdfdocument import PDFDocument
    from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
    from pdfminer.pdfpage import PDFPage
    from pdfminer.pdfparser import PDFParser
    pdfminer = True
except ImportError:
    pdfminer = False

_logger = logging.getLogger(__name__)


@odoo.tests.tagged('post_install', '-at_install', 'post_install_l10n')
class TestReports(odoo.tests.TransactionCase):
    def test_reports(self):
        invoice_domain = [('move_type', 'in', ('out_invoice', 'out_refund', 'out_receipt', 'in_invoice', 'in_refund', 'in_receipt'))]
        specific_model_domains = {
            'account.report_original_vendor_bill': [('move_type', 'in', ('in_invoice', 'in_receipt'))],
            'account.report_invoice_with_payments': invoice_domain,
            'account.report_invoice': invoice_domain,
            'l10n_th.report_commercial_invoice': invoice_domain,
        }
        Report = self.env['ir.actions.report']
        for report in Report.search([('report_type', 'like', 'qweb')]):
            report_model = 'report.%s' % report.report_name
            try:
                self.env[report_model]
            except KeyError:
                # Only test the generic reports here
                _logger.info("testing report %s", report.report_name)
                report_model_domain = specific_model_domains.get(report.report_name, [])
                report_records = self.env[report.model].search(report_model_domain, limit=10)
                if not report_records:
                    _logger.info("no record found skipping report %s", report.report_name)

                # Test report generation
                if not report.multi:
                    for record in report_records:
                        Report._render_qweb_html(report.id, record.ids)
                else:
                    Report._render_qweb_html(report.id, report_records.ids)
            else:
                continue

    def test_report_reload_from_attachment(self):
        def get_attachments(res_id):
            return self.env["ir.attachment"].search([('res_model', "=", "res.partner"), ("res_id", "=", res_id)])

        Report = self.env['ir.actions.report'].with_context(force_report_rendering=True)

        report = Report.create({
            'name': 'test report',
            'report_name': 'base.test_report',
            'model': 'res.partner',
        })

        self.env['ir.ui.view'].create({
            'type': 'qweb',
            'name': 'base.test_report',
            'key': 'base.test_report',
            'arch': '''
                <main>
                    <div class="article" data-oe-model="res.partner" t-att-data-oe-id="docs.id">
                        <span t-field="docs.display_name" />
                    </div>
                </main>
            '''
        })

        pdf_text = "0"
        def _run_wkhtmltopdf(*args, **kwargs):
            return bytes(pdf_text, "utf-8")

        self.patch(type(Report), "_run_wkhtmltopdf", _run_wkhtmltopdf)

        # sanity check: the report is not set to save attachment
        # assert that there are no pre-existing attachment
        partner_id = self.env.user.partner_id.id
        self.assertFalse(get_attachments(partner_id))
        pdf = report._render_qweb_pdf(report.id, [partner_id])
        self.assertFalse(get_attachments(partner_id))
        self.assertEqual(pdf[0], b"0")

        # set the report to reload from attachment and make one
        pdf_text = "1"
        report.attachment = "'test_attach'"
        report.attachment_use = True
        report._render_qweb_pdf(report.id, [partner_id])
        attach_1 = get_attachments(partner_id)
        self.assertTrue(attach_1.exists())

        # use the context key to not reload from attachment
        # and not create another one
        pdf_text = "2"
        report = report.with_context(report_pdf_no_attachment=True)
        pdf = report._render_qweb_pdf(report.id, [partner_id])
        attach_2 = get_attachments(partner_id)
        self.assertEqual(attach_2.id, attach_1.id)

        self.assertEqual(b64decode(attach_1.datas), b"1")
        self.assertEqual(pdf[0], b"2")


# Some paper format examples
PAPER_SIZES = {
    (842, 1190): 'A3',
    (595, 842): 'A4',
    (420, 595): 'A5',
    (297, 420): 'A6',
    (612, 792): 'Letter',
    (612, 1008): 'Legal',
    (792, 1224): 'Ledger',
}

class Box:
    """
    Utility class to help assertions
    """
    def __init__(self, obj, page_height, page_width):
        self.x1 = round(obj.x0, 1)
        self.y1 = round(page_height-obj.y1, 1)
        self.x2 = round(obj.x1, 1)
        self.y2 = round(page_height-obj.y0, 1)
        self.page_height = page_height
        self.page_width = page_width

    @property
    def height(self):
        return self.y2 - self.y1

    @property
    def width(self):
        return self.x2 - self.x1

    @property
    def top(self):
        return self.y1

    @property
    def left(self):
        return self.x1

    @property
    def end_top(self):
        return self.y2

    @property
    def end_left(self):
        return self.x2

    @property
    def right(self):
        return self.page_width - self.x2

    @property
    def bottom(self):
        return self.page_height - self.y2

    def __lt__(self, other):
        return (self.y1, self.x1, self.y2, self.x2) < (other.y1, other.x1, other.y2, other.x2)


@skipIf(pdfminer is False, "pdfminer not installed")
class TestReportsRenderingCommon(odoo.tests.HttpCase):

    def setUp(self):
        super().setUp()
        self.report = self.env['ir.actions.report'].create({
            'name': 'Test Report Partner',
            'model': 'res.partner',
            'report_name': 'test_report.test_report_partner',
            'paperformat_id': self.env.ref('base.paperformat_euro').id,
        })

        self.partners = self.env['res.partner'].create([{
            'name': f'Report record {i}',
        } for i in range(2)])

        self.report_view = self.env['ir.ui.view'].create({
            'type': 'qweb',
            'name': 'test_report_partner',
            'key': 'test_report.test_report_partner',
            'arch': "<t></t>",
        })
        self.last_pdf_content = None
        self.last_pdf_content_saved = False

    def _addError(self, result, test, exc_info):
        if self.last_pdf_content and not self.last_pdf_content_saved:
            self.last_pdf_content_saved = True
            self.save_pdf()
        super()._addError(result, test, exc_info)

    def get_paper_format(self, mediabox):
        """
            :param: mediabox: a page mediabox. (Example: (0, 0, 595, 842))
            :return: a (format, orientation). Example ('A4', 'portait')
        """
        x, y, width, height = mediabox
        self.assertEqual((x, y), (0, 0), "Expecting top corner to be 0, 0 ")
        orientation = 'portait'
        paper_size = (width, height)
        if width > height:
            orientation = 'landscape'
            paper_size = (height, width)
        return PAPER_SIZES.get(paper_size, f'custom{paper_size}'), orientation

    def create_pdf(self, partners=None, header_content=None, page_content=None, footer_content=None):
        if header_content is None:
            header_content = '''
                <img t-if="company.logo" t-att-src="image_data_uri(company.logo)" style="max-height: 45px;" alt="Logo"/>
                <span>Some header Text</span>
            '''

        if footer_content is None:
            footer_content = '''
                <div style="text-align:center">Footer for <t t-esc="o.name"/> Page: <span class="page"/> / <span class="topage"/></div>
            '''

        if page_content is None:
            page_content = '''
                <div class="page">
                    <div style="background-color:red">
                        Name: <t t-esc="o.name"/>
                    </div>
                </div>
            '''

        self.report_view.arch = f'''
                <t t-name="test_report.test_report_partner">
                    <t t-set="company" t-value="res_company"/>
                    <t t-call="web.html_container">
                        <t t-foreach="docs" t-as="o">
                            <div class="header" style="font-family:Sans">
                                {header_content}
                            </div>
                            <div class="article" style="font-family:Sans">

                                {page_content}
                            </div>
                            <div class="footer" style="font-family:Sans">
                                {footer_content}
                            </div>
                        </t>
                    </t>
                </t>
            '''
        # this templates doesn't use the "web.external_layout" in order to simplify the final result and make the edition of footer and header easier
        # this test does not aims to test company base.document.layout, but the rendering only.
        if partners is None:
            partners = self.partners
        self.last_pdf_content = self.env['ir.actions.report'].with_context(force_report_rendering=True)._render_qweb_pdf(self.report, partners.ids)[0]
        return self.last_pdf_content

    def save_pdf(self):
        assert self.last_pdf_content
        odoo.tests.save_test_file(self._testMethodName, self.last_pdf_content, 'pdf_', 'pdf', document_type='Report PDF', logger=_logger)

    def _get_pdf_pages(self, pdf_content):
        ioBytes = io.BytesIO(pdf_content)
        parser = PDFParser(ioBytes)
        doc = PDFDocument(parser)
        return list(PDFPage.create_pages(doc))

    def _parse_pdf(self, pdf_content, expected_format=('A4', 'portait')):
        """
            :param: pdf_content: the bdf binary content
            :param: expected_format: a get_paper_format like format.
            :return: list[list[(box, Element)]] a list of element per page
            Note: box is a 4 float tuple based on the top left corner to ease ordering of elements.
            The result is also rounded to one digit
        """
        pages = self._get_pdf_pages(pdf_content)
        ressource_manager = PDFResourceManager()
        device = PDFPageAggregator(ressource_manager, laparams=LAParams())
        interpreter = PDFPageInterpreter(ressource_manager, device)

        parsed_pages = []
        for page in pages:
            self.assertEqual(
                self.get_paper_format(page.mediabox),
                expected_format,
                "Expecting pdf to be in A4 portait format",
            ) # this is the default expected format and other layout assertions are based on this one.
            interpreter.process_page(page)
            layout = device.get_result()
            elements = []
            parsed_pages.append(elements)
            for obj in layout:
                box = Box(
                    obj,
                    page_height=pages[0].mediabox[3],
                    page_width=pages[0].mediabox[2],
                )
                if isinstance(obj, LTTextBox):
                    #inverse x to start from top left corner
                    elements.append((box, obj.get_text().strip()))
                elif isinstance(obj, LTFigure):
                    elements.append((box, 'LTFigure'))
            elements.sort()

        return parsed_pages

    def assertPageFormat(self, paper_format, orientation):
        pdf_content = self.create_pdf()
        pages = self._get_pdf_pages(pdf_content)
        self.assertEqual(len(pages), 2)
        for page in pages:
            self.assertEqual(
                self.get_paper_format(page.mediabox),
                (paper_format, orientation),
                f"Expecting pdf to be in {paper_format} {orientation} format",
            )


@odoo.tests.tagged('post_install', '-at_install', 'pdf_rendering')
class TestReportsRendering(TestReportsRenderingCommon):
    """
        This test aims to test as much as possible the current pdf rendering,
        especially multipage headers and footers
        (the main reason why we are currently using wkhtmltopdf with patched qt)
        A custom template without web.external_layout is used on purpose in order to
        easily test headers and footer regarding rendering only,
        without using any comany document.layout logic
    """

    def test_format_A4(self):
        self.report.paperformat_id = self.env.ref('base.paperformat_euro')
        self.assertPageFormat('A4', 'portait')

    def test_format_letter(self):
        self.report.paperformat_id = self.env.ref('base.paperformat_us')
        self.assertPageFormat('Letter', 'portait')

    def test_format_landscape(self):
        paper_format = self.env.ref('base.paperformat_euro')
        paper_format.orientation = 'Landscape'
        self.report.paperformat_id = paper_format
        self.assertPageFormat('A4', 'landscape')

    def test_layout(self):
        pdf_content = self.create_pdf()
        pages = self._parse_pdf(pdf_content)
        self.assertEqual(len(pages), 2)

        page_contents = [[elem[1] for elem in page] for page in pages]

        expected_pages_content = [[
            'LTFigure',
            'Some header Text',
            f'Name: {partner.name}',
            f'Footer for {partner.name} Page: 1 / 1',
        ] for partner in self.partners]

        self.assertEqual(
            page_contents,
            expected_pages_content,
        )

        page_positions = [[elem[0] for elem in page] for page in pages]
        logo, header, content, footer = page_positions[0]

        # leaving this as reference but this is to fragile to make a strict assertion
        # 14.3, 29.6, 43.1, 137.2     # logo
        # 19.1, 137.2, 32.5, 214.2   # header
        # 111.3, 29.6, 124.8, 123.7   # content
        # 751.6, 220.1, 765.1, 375.0  # footer

        #
        #   \ \ / // _ \ | | | || _ \  | |
        #    \ V /| (_) || |_| ||   /  | |__ / _ \/ _` |/ _ \     Some header Text
        #     |_|  \___/  \___/ |_|_\  |____|\___/\__, |\___/
        #
        #
        #   Name: Report record 0
        #
        #
        #
        #
        #
        #
        #             Footer for Report record 0 Page: 1 / 1
        #
        #

        self.assertEqual(logo.left, content.left, 'Logo and content should have the same left margin')
        self.assertEqual(header.left, logo.end_left, 'Header starts after logo')
        self.assertGreaterEqual(header.top, logo.top, 'header is vertically centered on logo')
        self.assertGreaterEqual(logo.end_top, header.end_top, 'header is vertically centered on logo')
        self.assertGreaterEqual(content.top, logo.end_top, 'Content is bellow logo')
        self.assertGreaterEqual(footer.top, content.end_top, 'Footer is bellow content')
        self.assertGreaterEqual(100, footer.bottom, 'Footer is on the bottom of the page')
        self.assertAlmostEqual(footer.left, footer.right, -1, 'Footer is centered on the page')

    def test_report_pdf_page_break(self):

        partners = self.partners[:2]
        page_content = '''
                <div class="page">
                    <div style="background-color:red">
                        Name: <t t-esc="o.name"/>
                    </div>
                    <div style="page-break-before:always;background-color:blue">
                        Last page for <t t-esc="o.name"/>
                    </div>
                </div>
            '''

        pdf_content = self.create_pdf(partners=partners, page_content=page_content)

        pages = self._parse_pdf(pdf_content)

        self.assertEqual(len(pages), 4, "Expecting 2 pages * 2 partners")

        expected_pages_contents = []
        for partner in self.partners:
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                f'Name: {partner.name}',
                f'Footer for {partner.name} Page: 1 / 2',
            ])
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                f'Last page for {partner.name}',
                f'Footer for {partner.name} Page: 2 / 2',
            ])
        pages_contents = [[elem[1] for elem in page] for page in pages]
        self.assertEqual(pages_contents, expected_pages_contents)

    def test_pdf_render_page_overflow(self):
        nb_lines = 80

        page_content = f'''
            <div class="page">
                <div style="background-color:red">
                    Name: <t t-esc="o.name"/>
                    <div t-foreach="range({nb_lines})" t-as="pos" t-esc="pos"/>
                </div>
            </div>
        '''
        pdf_content = self.create_pdf(page_content=page_content)
        pages = self._parse_pdf(pdf_content)

        self.assertEqual(len(pages), 4, '4 pages are expected, 2 per record (you may ensure `nb_lines` has a correct value to generate an oveflow)')
        page_break_at = int(pages[1][2][1].split('\n')[0])  # This element should be the first line, 61 when this test was written

        expected_pages_contents = []
        for partner in self.partners:
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                f'Name: {partner.name}\n' + '\n'.join([str(i) for i in range(page_break_at)]),
                f'Footer for {partner.name} Page: 1 / 2',
            ])
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                '\n'.join([str(i) for i in range(page_break_at, nb_lines)]),
                f'Footer for {partner.name} Page: 2 / 2',
            ])
        pages_contents = [[elem[1] for elem in page] for page in pages]
        self.assertEqual(pages_contents, expected_pages_contents)

    def test_thead_tbody_repeat(self):
        """
            Check that thead and t-foot are repeated after page break inside a tbody
        """
        nb_lines = 50
        page_content = f'''
            <div class="page">
                <table class="table">
                    <thead><tr><th> T1 </th><th> T2 </th><th> T3 </th></tr></thead>
                    <tbody>
                    <t t-foreach="range({nb_lines})" t-as="pos">
                        <tr><td><t t-esc="pos"/></td><td><t t-esc="pos"/></td><td><t t-esc="pos"/></td></tr>
                    </t>
                    </tbody>
                    <tfoot><tr><th> T1 </th><th> T2 </th><th> T3 </th></tr></tfoot>
                </table>
            </div>
        '''

        pdf_content = self.create_pdf(page_content=page_content)
        pages = self._parse_pdf(pdf_content)

        self.assertEqual(len(pages), 4, '4 pages are expected, 2 per record (you may ensure `nb_lines` has a correct value to generate an oveflow)')
        page_break_at = int(pages[1][5][1])  # This element should be the first line of the table, 28 when this test was written

        def expected_table(start, end):
            table = ['T1', 'T2', 'T3'] # thead
            for i in range(start, end):
                table += [str(i), str(i), str(i)]
            table += ['T1', 'T2', 'T3'] # tfoot
            return table

        expected_pages_contents = []
        for partner in self.partners:
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                * expected_table(0, page_break_at),
                f'Footer for {partner.name} Page: 1 / 2',
            ])
            expected_pages_contents.append([
                'LTFigure', #logo
                'Some header Text',
                * expected_table(page_break_at, nb_lines),
                f'Footer for {partner.name} Page: 2 / 2',
            ])

        pages_contents = [[elem[1] for elem in page] for page in pages]
        self.assertEqual(pages_contents, expected_pages_contents)


@odoo.tests.tagged('post_install', '-at_install', '-standard', 'pdf_rendering')
class TestReportsRenderingLimitations(TestReportsRenderingCommon):
    def test_no_clip(self):
        """
            Current version will add a fixed margin on top of document
            This test demonstrates this limitation
        """
        header_content = '''
            <div style="background-color:blue">
                <div t-foreach="range(15)" t-as="pos" t-esc="'Header %s' % pos"/>
            </div>
        '''
        page_content = '''
            <div class="page">
                <div style="background-color:red; margin-left:100px">
                    <div t-foreach="range(10)" t-as="pos" t-esc="'Content %s' % pos"/>
                </div>
            </div>
        '''
        # adding a margin on page to avoid bot block to me considered as the same
        pdf_content = self.create_pdf(page_content=page_content, header_content=header_content)
        pages = self._parse_pdf(pdf_content)
        self.assertEqual(len(pages), 2, "2 partners")
        page = pages[0]
        self.assertEqual(len(page), 3, "Expecting 3 box per page, Header, body, footer")
        header = page[0][0]
        content = page[1][0]
        self.assertGreaterEqual(content.top, header.end_top, "EXISTING LIMITATION: large header shouldn't overflow on body, but they do")


@odoo.tests.tagged('post_install', '-at_install')
class TestAggregatePdfReports(odoo.tests.HttpCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.partners = cls.env["res.partner"].create([{
            "name": "Rodion Romanovich Raskolnikov"
        }, {
            "name": "Dmitri Prokofich Razumikhin"
        }, {
            "name": "Porfiry Petrovich"
        }])

        cls.env["ir.actions.report"].create({
            "name": "test report",
            "report_name": "base.test_report",
            "model": "res.partner",
        })

    def test_aggregate_report_with_some_resources_reloaded_from_attachment(self):
        """
        Test for opw-3827700, which caused reports generated for multiple records to fail if there was a record in
        the middle that had an attachment, and 'Reload from attachment' was enabled for the report. The misbehavior was
        caused by an indexing issue.
        """
        self.env["ir.ui.view"].create({
            "type": "qweb",
            "name": "base.test_report",
            "key": "base.test_report",
            "arch": """
                    <main>
                        <div t-foreach="docs" t-as="user">
                            <div class="article" data-oe-model="res.partner" t-att-data-oe-id="user.id">
                                <span t-esc="user.display_name"/>
                            </div>
                        </div>
                    </main>
                    """
        })
        self.assert_report_creation("base.test_report", self.partners, self.partners[1])

    def test_aggregate_report_with_some_resources_reloaded_from_attachment_with_multiple_page_report(self):
        """
        Same as @test_report_with_some_resources_reloaded_from_attachment, but tests the behavior for reports that
        span multiple pages per record.
        """
        self.env["ir.ui.view"].create({
            "type": "qweb",
            "name": "base.test_report",
            "key": "base.test_report",
            "arch": """
                    <main>
                        <div t-foreach="docs" t-as="user">
                            <div class="article" data-oe-model="res.partner" t-att-data-oe-id="user.id" >
                                <!-- This headline helps report generation to split pdfs per record after it generates
                                     the report in bulk by creating an outline. -->
                                <h1>Name</h1>
                                <!-- Make this a multipage report. -->
                                <div t-foreach="range(100)" t-as="i">
                                    <span t-esc="i"/> - <span t-esc="user.display_name"/>
                                </div>
                            </div>
                        </div>
                    </main>
                    """
        })
        self.assert_report_creation("base.test_report", self.partners, self.partners[1])

    def assert_report_creation(self, report_ref, records, record_to_report):
        self.assertIn(record_to_report, records, "Record to report must be in records list")

        reports = self.env['ir.actions.report'].with_context(force_report_rendering=True)

        # Make sure attachments are created.
        report = reports._get_report(report_ref)
        if not report.attachment:
            report.attachment = "object.name + '.pdf'"
        report.attachment_use = True

        # Generate report for chosen record to create an attachment.
        record_report, content_type = reports._render_qweb_pdf(report_ref, res_ids=record_to_report.id)
        self.assertEqual(content_type, "pdf", "Report is not a PDF")
        self.assertTrue(record_report, "PDF not generated")

        # Make sure the attachment is created.
        report = reports._get_report(report_ref)
        self.assertTrue(report.retrieve_attachment(record_to_report), "Attachment not generated")

        aggregate_report_content, content_type = reports._render_qweb_pdf(report_ref, res_ids=records.ids)
        self.assertEqual(content_type, "pdf", "Report is not a PDF")
        self.assertTrue(aggregate_report_content, "PDF not generated")
        for record in records:
            self.assertTrue(report.retrieve_attachment(record), "Attachment not generated")

```

  File: tests/test_res_company.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo import Command
from odoo.exceptions import UserError, ValidationError
from odoo.tests.common import TransactionCase


class TestCompany(TransactionCase):

    def test_check_active(self):
        """Tests the ability to archive a company whether or not it still has active users.
        Tests an archived user in an archived company cannot be unarchived
        without changing its company to an active company."""
        company = self.env['res.company'].create({'name': 'foo'})
        user = self.env['res.users'].create({
            'name': 'foo',
            'login': 'foo',
            'company_id': company.id,
            'company_ids': company.ids,
        })

        # The company cannot be archived because it still has active users
        with self.assertRaisesRegex(ValidationError, 'The company foo cannot be archived'):
            company.action_archive()

        # The company can be archived because it has no active users
        user.action_archive()
        company.action_archive()

        # The user cannot be unarchived because it's default company is archived
        with self.assertRaisesRegex(ValidationError, 'Company foo is not in the allowed companies'):
            user.action_unarchive()

        # The user can be unarchived once we set another, active, company
        main_company = self.env.ref('base.main_company')
        user.write({
            'company_id': main_company.id,
            'company_ids': main_company.ids,
        })
        user.action_unarchive()

    def test_logo_check(self):
        """Ensure uses_default_logo is properly (re-)computed."""
        company = self.env['res.company'].create({'name': 'foo'})

        self.assertTrue(company.logo, 'Should have a default logo')
        self.assertTrue(company.uses_default_logo)
        company.partner_id.image_1920 = False
        # No logo means we fall back to another default logo for the website route -> uses_default
        self.assertTrue(company.uses_default_logo)
        company.partner_id.image_1920 = "R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
        self.assertFalse(company.uses_default_logo)

    def test_unlink_company_with_children(self):
        """Ensure that companies with child companies cannot be deleted."""

        parent_company = self.env['res.company'].create({
            'name': 'Parent Company',
            'child_ids': [
                Command.create({'name': 'Child Company'}),
            ],
        })

        with self.assertRaises(UserError):
            parent_company.unlink()
        self.assertTrue(parent_company.exists())

```

  File: tests/test_res_config.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from collections import defaultdict
from lxml import etree
import logging

from odoo import exceptions, Command
from odoo.tests.common import Form, TransactionCase, tagged

_logger = logging.getLogger(__name__)


class TestResConfig(TransactionCase):

    def setUp(self):
        super(TestResConfig, self).setUp()
        self.ResConfig = self.env['res.config.settings']

        # Define the test values
        self.menu_xml_id = 'base.menu_action_res_users'
        self.full_field_name = 'res.partner.lang'
        self.error_msg = "WarningRedirect test string: %(field:res.partner.lang)s - %(menu:base.menu_action_res_users)s."
        self.error_msg_wo_menu = "WarningRedirect test string: %(field:res.partner.lang)s."
        # Note: see the get_config_warning() doc for a better example

        # Fetch the expected values
        menu = self.env.ref(self.menu_xml_id)

        model_name, field_name = self.full_field_name.rsplit('.', 1)

        self.expected_path = menu.complete_name
        self.expected_action_id = menu.action.id
        self.expected_name = self.env[model_name].fields_get([field_name])[field_name]['string']
        self.expected_final_error_msg = self.error_msg % {
            'field:res.partner.lang': self.expected_name,
            'menu:base.menu_action_res_users': self.expected_path
        }
        self.expected_final_error_msg_wo_menu = self.error_msg_wo_menu % {
            'field:res.partner.lang': self.expected_name,
        }

    def test_00_get_option_path(self):
        """ The get_option_path() method should return a tuple containing a string and an integer """
        res = self.ResConfig.get_option_path(self.menu_xml_id)

        # Check types
        self.assertIsInstance(res, tuple)
        self.assertEqual(len(res), 2, "The result should contain 2 elements")
        self.assertIsInstance(res[0], str)
        self.assertIsInstance(res[1], int)

        # Check returned values
        self.assertEqual(res[0], self.expected_path)
        self.assertEqual(res[1], self.expected_action_id)

    def test_10_get_option_name(self):
        """ The get_option_name() method should return a string """
        res = self.ResConfig.get_option_name(self.full_field_name)

        # Check type
        self.assertIsInstance(res, str)

        # Check returned value
        self.assertEqual(res, self.expected_name)

    def test_20_get_config_warning(self):
        """ The get_config_warning() method should return a RedirectWarning """
        res = self.ResConfig.get_config_warning(self.error_msg)

        # Check type
        self.assertIsInstance(res, exceptions.RedirectWarning)

        # Check returned value
        self.assertEqual(res.args[0], self.expected_final_error_msg)
        self.assertEqual(res.args[1], self.expected_action_id)

    def test_30_get_config_warning_wo_menu(self):
        """ The get_config_warning() method should return a Warning exception """
        res = self.ResConfig.get_config_warning(self.error_msg_wo_menu)

        # Check type
        self.assertIsInstance(res, exceptions.UserError)

        # Check returned value
        self.assertEqual(res.args[0], self.expected_final_error_msg_wo_menu)

    # TODO: ASK DLE if this test can be removed
    def test_40_view_expected_architecture(self):
        """Tests the res.config.settings form view architecture expected by the web client.
        The res.config.settings form view is handled with a custom widget expecting a very specific
        structure. This architecture is tested extensively in Javascript unit tests.
        Here we briefly ensure the view sent by the server to the web client has the right architecture,
        the right blocks with the right classes in the right order.
        This tests is to ensure the specification/requirements are listed and tested server side, and
        if a change occurs in future development, this test will need to be adapted to specify these changes."""
        view = self.env['ir.ui.view'].create({
            'name': 'foo',
            'type': 'form',
            'model': 'res.config.settings',
            'inherit_id': self.env.ref('base.res_config_settings_view_form').id,
            'arch': """
                <xpath expr="//form" position="inside">
                    <t groups="base.group_system">
                        <app data-string="Foo" string="Foo" name="foo">
                            <h2>Foo</h2>
                        </app>
                    </t>
                </xpath>
            """,
        })
        arch = self.env['res.config.settings'].get_view(view.id)['arch']
        tree = etree.fromstring(arch)
        self.assertTrue(tree.xpath("""
            //form[@class="oe_form_configuration"]
            /app[@name="foo"]
        """), 'The res.config.settings form view architecture is not what is expected by the web client.')

    # TODO: ASK DLE if this test can be removed
    def test_50_view_expected_architecture_t_node_groups(self):
        """Tests the behavior of the res.config.settings form view postprocessing when a block `app`
        is wrapped in a `<t groups="...">`, which is used when you need to display an app settings section
        only for users part of two groups at the same time."""
        view = self.env['ir.ui.view'].create({
            'name': 'foo',
            'type': 'form',
            'model': 'res.config.settings',
            'inherit_id': self.env.ref('base.res_config_settings_view_form').id,
            'arch': """
                <xpath expr="//form" position="inside">
                    <t groups="base.group_system">
                        <app data-string="Foo"
                            string="Foo" name="foo" groups="base.group_no_one">
                            <h2>Foo</h2>
                        </app>
                    </t>
                </xpath>
            """,
        })
        with self.debug_mode():
            arch = self.env['res.config.settings'].get_view(view.id)['arch']
            tree = etree.fromstring(arch)
            # The <t> must be removed from the structure
            self.assertFalse(tree.xpath('//t'), 'The `<t groups="...">` block must not remain in the view')
            self.assertTrue(tree.xpath("""
                //form
                /app[@name="foo"]
            """), 'The `app` block must be a direct child of the `form` block')


@tagged('post_install', '-at_install')
class TestResConfigExecute(TransactionCase):

    def test_01_execute_res_config(self):
        """
        Try to create and execute all res_config models. Target settings that can't be
        loaded or saved and avoid remaining methods `get_default_foo` or `set_foo` that
        won't be executed is foo != `fields`
        """
        all_config_settings = self.env['ir.model'].search([('name', 'like', 'config.settings')])
        for config_settings in all_config_settings:
            _logger.info("Testing %s" % (config_settings.name))
            self.env[config_settings.name].create({}).execute()

    def test_settings_access(self):
        """Check that settings user are able to open & save settings

        Also check that user with settings rights + any one of the groups restricting
        a conditional view inheritance of res.config.settings view is also able to
        open & save the settings (considering the added conditional content)
        """
        ResUsers = self.env['res.users']
        group_system = self.env.ref('base.group_system')
        self.settings_view = self.env.ref('base.res_config_settings_view_form')
        settings_only_user = ResUsers.create({
            'name': 'Sleepy Joe',
            'login': 'sleepy',
            'groups_id': [Command.link(group_system.id)],
        })

        # If not enabled (like in demo data), landing on res.config will try
        # to disable module_sale_quotation_builder and raise an issue
        group_order_template = self.env.ref('sale_management.group_sale_order_template', raise_if_not_found=False)
        if group_order_template:
            self.env.ref('base.group_user').write({"implied_ids": [(4, group_order_template.id)]})

        _logger.info("Testing settings access for group %s", group_system.full_name)
        forbidden_models = self._test_user_settings_fields_access(settings_only_user)
        self._test_user_settings_view_save(settings_only_user)

        for model in forbidden_models:
            _logger.warning("Settings user doesn\'t have read access to the model %s", model)

        settings_view_conditional_groups = self.env['ir.ui.view'].search([
            ('model', '=', 'res.config.settings'),
        ]).groups_id

        # Semi hack to recover part of the coverage lost when the groups_id
        # were moved from the views records to the view nodes (with groups attributes)
        groups_data = self.env['res.groups'].get_groups_by_application()
        for group_data in groups_data:
            if group_data[1] == 'selection' and group_data[3] != (100, 'Other'):
                manager_group = group_data[2][-1]
                settings_view_conditional_groups += manager_group
        settings_view_conditional_groups -= group_system  # Already tested above

        for group in settings_view_conditional_groups:
            group_name = group.full_name
            _logger.info("Testing settings access for group %s", group_name)
            create_values = {
                'name': f'Test {group_name}',
                'login': group_name,
                'groups_id': [Command.link(group_system.id), Command.link(group.id)]
            }
            user = ResUsers.create(create_values)
            self._test_user_settings_view_save(user)
            forbidden_models_fields = self._test_user_settings_fields_access(user)

            for model, fields in forbidden_models_fields.items():
                _logger.warning(
                    "Settings + %s user doesn\'t have read access to the model %s"
                    "linked to settings records by the field(s) %s",
                    group_name, model, ", ".join(str(field) for field in fields)
                )

    def _test_user_settings_fields_access(self, user):
        """Verify that settings user are able to create & save settings."""
        settings = self.env['res.config.settings'].with_user(user).create({})

        # Save the settings
        settings.set_values()

        # Check user has access to all models of relational fields in view
        # because the webclient makes a read of display_name request for all specified records
        # even if they are not shown to the user.
        settings_view_arch = etree.fromstring(settings.get_view(view_id=self.settings_view.id)['arch'])
        seen_fields = set()
        for node in settings_view_arch.iterdescendants(tag='field'):
            fname = node.get('name')
            if fname not in settings._fields:
                # fname isn't a settings fields, but the field of a model
                # linked to settings through a relational field
                continue
            seen_fields.add(fname)

        models_to_check = defaultdict(set)
        for field_name in seen_fields:
            field = settings._fields[field_name]
            if field.relational:
                models_to_check[field.comodel_name].add(field)

        forbidden_models_fields = defaultdict(set)
        for model in models_to_check:
            has_read_access = self.env[model].with_user(user).check_access_rights(
                'read', raise_exception=False)
            if not has_read_access:
                forbidden_models_fields[model] = models_to_check[model]

        return forbidden_models_fields

    def _test_user_settings_view_save(self, user):
        """Verify that settings user are able to save the settings form."""
        ResConfigSettings = self.env['res.config.settings'].with_user(user)

        settings_form = Form(ResConfigSettings)
        settings_form.save()

```

  File: tests/test_res_country.py
  Content:
```
from odoo.tests import TransactionCase, tagged


@tagged('-at_install', 'post_install')
class TestResCountryState(TransactionCase):
    def test_find_by_name(self):
        """It should be possible to find a state by its display name
        """
        glorious_arstotzka = self.env['res.country'].create({
            'name': 'Arstotzka',
            'code': 'AA',
        })
        altan = self.env['res.country.state'].create({
            'country_id': glorious_arstotzka.id,
            'code': 'AL',
            'name': 'Altan',
        })

        for name in [
            altan.name,
            altan.display_name,
            'Altan(AA)',
            'Altan ( AA )',
            'Altan (Arstotzka)',
            'Altan (Arst)', # dubious
        ]:
            with self.subTest(name):
                self.assertEqual(
                    self.env['res.country.state'].name_search(name, operator='='),
                    [(altan.id, altan.display_name)]
                )

        # imitates basque provinces
        vescillo = self.env['res.country.state'].create({
            'country_id': glorious_arstotzka.id,
            'code': 'VE',
            'name': "Vescillo (Vesilo)",
        })
        for name in [
            vescillo.name,
            vescillo.display_name,
            "vescillo",
            "vesilo",
            "vescillo (AA)",
            "vesilo (AA)",
            "vesilo (Arstotzka)",
        ]:
            with self.subTest(name):
                # note operator for more flexible state name matching
                self.assertEqual(
                    self.env['res.country.state'].name_search(name, operator='ilike'),
                    [(vescillo.id, vescillo.display_name)]
                )

        # search in state list
        for name in [
            [altan.name],
            [altan.display_name],
            ['Altan(AA)'],
            ['Altan ( AA )'],
            ['Altan (Arstotzka)'],
            ['Altan (Arst)'],
        ]:
            with self.subTest(name):
                self.assertEqual(
                    self.env['res.country.state'].name_search(name, operator='in'),
                    [(altan.id, altan.display_name)]
                )

```

  File: tests/test_res_currency.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from lxml import etree
from odoo import Command
from odoo.tests.common import TransactionCase


class TestResCurrency(TransactionCase):
    def test_view_company_rate_label(self):
        """Tests the label of the company_rate and inverse_company_rate fields
        are well set according to the company currency in the currency form view and the currency rate list view.
        e.g. in the currency rate list view of a company using EUR, the company_rate label must be `Unit per EUR`"""
        company_foo, company_bar = self.env['res.company'].create([
            {'name': 'foo', 'currency_id': self.env.ref('base.EUR').id},
            {'name': 'bar', 'currency_id': self.env.ref('base.USD').id},
        ])
        for company, expected_currency in [(company_foo, 'EUR'), (company_bar, 'USD')]:
            for model, view_type in [('res.currency', 'form'), ('res.currency.rate', 'tree')]:
                arch = self.env[model].with_company(company).get_view(view_type=view_type)['arch']
                tree = etree.fromstring(arch)
                node_company_rate = tree.xpath('//field[@name="company_rate"]')[0]
                node_inverse_company_rate = tree.xpath('//field[@name="inverse_company_rate"]')[0]
                self.assertEqual(node_company_rate.get('string'), f'Unit per {expected_currency}')
                self.assertEqual(node_inverse_company_rate.get('string'), f'{expected_currency} per Unit')

    def test_currency_cache(self):
        currencyA, currencyB = self.env['res.currency'].create([{
            'name': 'AAA',
            'symbol': 'AAA',
            'rate_ids': [Command.create({'name': '2009-09-09', 'rate': 1})]
        }, {
            'name': 'BBB',
            'symbol': 'BBB',
            'rate_ids': [
                Command.create({'name': '2009-09-09', 'rate': 1}),
                Command.create({'name': '2011-11-11', 'rate': 2}),
            ],
        }])

        self.assertEqual(currencyA._convert(
            from_amount=100,
            to_currency=currencyB,
            company=self.env.company,
            date='2010-10-10',
        ), 100)

        # update the (cached) rate of the to_currency used in the previous query
        self.env['res.currency.rate'].search([
            ('currency_id', '=', currencyB.id),
            ('name', '=', '2009-09-09')]
        ).rate = 3

        # repeat _convert call
        # the cached conversion rate is invalid due to the rate change -> query
        with self.assertQueryCount(1):
            self.assertEqual(currencyA._convert(
                from_amount=100,
                to_currency=currencyB,
                company=self.env.company,
                date='2010-10-10',
            ), 300)

        # create a new rate of the to_currency for the date used in the previous query
        self.env['res.currency.rate'].create({
            'name': '2010-10-10',
            'rate': 4,
            'currency_id': currencyB.id,
            'company_id': self.env.company.id,
        })

        # repeat _convert call
        # the cached conversion rate is invalid due to the new rate of the to_currency -> query
        with self.assertQueryCount(1):
            self.assertEqual(currencyA._convert(
                from_amount=100,
                to_currency=currencyB,
                company=self.env.company,
                date='2010-10-10',
            ), 400)

        # only one query is done when changing the convert params
        with self.assertQueryCount(1):
            self.assertEqual(currencyA._convert(
                from_amount=100,
                to_currency=currencyB,
                company=self.env.company,
                date='2011-11-11',
            ), 200)

        # cache holds multiple values
        with self.assertQueryCount(0):
            self.assertEqual(currencyA._convert(
                from_amount=100,
                to_currency=currencyB,
                company=self.env.company,
                date='2010-10-10',
            ), 400)
            self.assertEqual(currencyA._convert(
                from_amount=100,
                to_currency=currencyB,
                company=self.env.company,
                date='2011-11-11',
            ), 200)

```

  File: tests/test_res_lang.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo.exceptions import UserError

class test_res_lang(TransactionCase):

    def test_00_intersperse(self):
        from odoo.addons.base.models.res_lang import intersperse

        assert intersperse("", []) == ("", 0)
        assert intersperse("0", []) == ("0", 0)
        assert intersperse("012", []) == ("012", 0)
        assert intersperse("1", []) == ("1", 0)
        assert intersperse("12", []) == ("12", 0)
        assert intersperse("123", []) == ("123", 0)
        assert intersperse("1234", []) == ("1234", 0)
        assert intersperse("123456789", []) == ("123456789", 0)
        assert intersperse("&ab%#@1", []) == ("&ab%#@1", 0)

        assert intersperse("0", []) == ("0", 0)
        assert intersperse("0", [1]) == ("0", 0)
        assert intersperse("0", [2]) == ("0", 0)
        assert intersperse("0", [200]) == ("0", 0)

        assert intersperse("12345678", [1], '.') == ('1234567.8', 1)
        assert intersperse("12345678", [1], '.') == ('1234567.8', 1)
        assert intersperse("12345678", [2], '.') == ('123456.78', 1)
        assert intersperse("12345678", [2,1], '.') == ('12345.6.78', 2)
        assert intersperse("12345678", [2,0], '.') == ('12.34.56.78', 3)
        assert intersperse("12345678", [-1,2], '.') == ('12345678', 0)
        assert intersperse("12345678", [2,-1], '.') == ('123456.78', 1)
        assert intersperse("12345678", [2,0,1], '.') == ('12.34.56.78', 3)
        assert intersperse("12345678", [2,0,0], '.') == ('12.34.56.78', 3)
        assert intersperse("12345678", [2,0,-1], '.') == ('12.34.56.78', 3)
        assert intersperse("12345678", [3,3,3,3], '.') == ('12.345.678', 2)

        assert intersperse("abc1234567xy", [2], '.') == ('abc1234567.xy', 1)
        assert intersperse("abc1234567xy8", [2], '.') == ('abc1234567x.y8', 1) # ... w.r.t. here.
        assert intersperse("abc12", [3], '.') == ('abc12', 0)
        assert intersperse("abc12", [2], '.') == ('abc12', 0)
        assert intersperse("abc12", [1], '.') == ('abc1.2', 1)

    def test_inactive_users_lang_deactivation(self):
        # activate the language en_GB
        language = self.env['res.lang']._activate_lang('en_GB')

        # assign it to an inactive (new) user
        user = self.env['res.users'].create({
            'name': 'Foo',
            'login': 'foo@example.com',
            'lang': 'en_GB',
            'active': False,
        })

        # make sure it is only used by that user
        self.assertEqual(self.env['res.users'].with_context(active_test=False).search([('lang', '=', 'en_GB')]), user)

        with self.assertRaises(UserError):
            language.active = False

```

  File: tests/test_res_partner.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from contextlib import contextmanager
from unittest.mock import patch

from odoo import Command
from odoo.addons.base.models.res_partner import Partner
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.exceptions import AccessError, RedirectWarning, UserError, ValidationError
from odoo.tests import Form
from odoo.tests.common import tagged, TransactionCase

# samples use effective TLDs from the Mozilla public suffix
# list at http://publicsuffix.org
SAMPLES = [
    ('"Raoul Grosbedon" <raoul@chirurgiens-dentistes.fr> ', 'Raoul Grosbedon', 'raoul@chirurgiens-dentistes.fr'),
    ('ryu+giga-Sushi@aizubange.fukushima.jp', 'ryu+giga-sushi@aizubange.fukushima.jp', 'ryu+giga-sushi@aizubange.fukushima.jp'),
    ('Raoul chirurgiens-dentistes.fr', 'Raoul chirurgiens-dentistes.fr', ''),
    (" Raoul O'hara  <!@historicalsociety.museum>", "Raoul O'hara", '!@historicalsociety.museum'),
    ('Raoul Grosbedon <raoul@CHIRURGIENS-dentistes.fr> ', 'Raoul Grosbedon', 'raoul@chirurgiens-dentistes.fr'),
    ('Raoul megaraoul@chirurgiens-dentistes.fr', 'Raoul', 'megaraoul@chirurgiens-dentistes.fr'),
]


@tagged('res_partner')
class TestPartner(TransactionCaseWithUserDemo):

    @contextmanager
    def mockPartnerCalls(self):
        _original_create = Partner.create
        self._new_partners = self.env['res.partner']

        def _res_partner_create(model, *args, **kwargs):
            records = _original_create(model, *args, **kwargs)
            self._new_partners += records.sudo()
            return records

        with patch.object(Partner, 'create',
                          autospec=True, side_effect=_res_partner_create):
            yield

    def _check_find_or_create(self, test_string, expected_name, expected_email, expected_partner=False):
        with self.mockPartnerCalls():
            partner = self.env['res.partner'].find_or_create(test_string)
        if expected_partner:
            self.assertEqual(
                partner, expected_partner,
                f'Should have found {expected_partner.name} ({expected_partner.id}), found {partner.name} ({partner.id}) instead')
            self.assertFalse(self._new_partners)
        else:
            self.assertEqual(
                partner, self._new_partners,
                f'Should have created a partner, found {partner.name} ({partner.id}) instead'
            )
        self.assertEqual(partner.name, expected_name)
        self.assertEqual(partner.email or '', expected_email)
        return partner

    def test_archive_internal_partners(self):
        test_partner = self.env['res.partner'].create({'name':'test partner'})
        test_user = self.env['res.users'].create({
                                'login': 'test@odoo.com',
                                'partner_id': test_partner.id,
                                })
        # Cannot archive the partner
        with self.assertRaises(RedirectWarning):
            test_partner.with_user(self.env.ref('base.user_admin')).toggle_active()
        with self.assertRaises(ValidationError):
            test_partner.with_user(self.user_demo).toggle_active()

        # Can archive the user but the partner stays active
        test_user.toggle_active()
        self.assertTrue(test_partner.active, 'Parter related to user should remain active')

        # Now we can archive the partner
        test_partner.toggle_active()

        # Activate the user should reactivate the partner
        test_user.toggle_active()
        self.assertTrue(test_partner.active, 'Activating user must active related partner')

    def test_email_formatted(self):
        """ Test various combinations of name / email, notably to check result
        of email_formatted field. """
        # multi create
        new_partners = self.env['res.partner'].create([{
            'name': "Vlad the Impaler",
            'email': f'vlad.the.impaler.{idx:02d}@example.com',
        } for idx in range(2)])
        self.assertEqual(
            sorted(new_partners.mapped('email_formatted')),
            sorted([f'"Vlad the Impaler" <vlad.the.impaler.{idx:02d}@example.com>' for idx in range(2)]),
            'Email formatted should be "name" <email>'
        )

        # test name_create with formatting / multi emails
        for source, (exp_name, exp_email, exp_email_formatted) in [
            (
                'Balázs <vlad.the.negociator@example.com>, vlad.the.impaler@example.com',
                ("Balázs", "vlad.the.negociator@example.com", '"Balázs" <vlad.the.negociator@example.com>')
            ),
            (
                'Balázs <vlad.the.impaler@example.com>',
                ("Balázs", "vlad.the.impaler@example.com", '"Balázs" <vlad.the.impaler@example.com>')
            ),
        ]:
            with self.subTest(source=source):
                new_partner_id = self.env['res.partner'].name_create(source)[0]
                new_partner = self.env['res.partner'].browse(new_partner_id)
                self.assertEqual(new_partner.name, exp_name)
                self.assertEqual(new_partner.email, exp_email)
                self.assertEqual(
                    new_partner.email_formatted, exp_email_formatted,
                    'Name_create should take first found email'
                )

        # check name updates
        for source, exp_email_formatted in [
            ('Vlad the Impaler', '"Vlad the Impaler" <vlad.the.impaler@example.com>'),
            ('Balázs', '"Balázs" <vlad.the.impaler@example.com>'),
            ('Balázs <email.in.name@example.com>', '"Balázs <email.in.name@example.com>" <vlad.the.impaler@example.com>'),
        ]:
            with self.subTest(source=source):
                new_partner.write({'name': source})
                self.assertEqual(new_partner.email_formatted, exp_email_formatted)

        # check email updates
        new_partner.write({'name': 'Balázs'})
        for source, exp_email_formatted in [
            # encapsulated email
            (
                "Vlad the Impaler <vlad.the.impaler@example.com>",
                '"Balázs" <vlad.the.impaler@example.com>'
            ), (
                '"Balázs" <balazs@adam.hu>',
                '"Balázs" <balazs@adam.hu>'
            ),
            # multi email
            (
                "vlad.the.impaler@example.com, vlad.the.dragon@example.com",
                '"Balázs" <vlad.the.impaler@example.com,vlad.the.dragon@example.com>'
            ), (
                "vlad.the.impaler.com, vlad.the.dragon@example.com",
                '"Balázs" <vlad.the.dragon@example.com>'
            ), (
                'vlad.the.impaler.com, "Vlad the Dragon" <vlad.the.dragon@example.com>',
                '"Balázs" <vlad.the.dragon@example.com>'
            ),
            # falsy emails
            (False, False),
            ('', False),
            (' ', '"Balázs" <@ >'),
            ('notanemail', '"Balázs" <@notanemail>'),
        ]:
            with self.subTest(source=source):
                new_partner.write({'email': source})
                self.assertEqual(new_partner.email_formatted, exp_email_formatted)

    def test_find_or_create(self):
        original_partner = self.env['res.partner'].browse(
            self.env['res.partner'].name_create(SAMPLES[0][0])[0]
        )
        all_partners = []

        for (text_input, expected_name, expected_email), expected_partner, find_idx in zip(
            SAMPLES,
            [original_partner, False, False, False, original_partner, False,
             # patrick example
             False, False, False,
             # multi email
             False],
            [0, 0, 0, 0, 0, 0, 0, 6, 0, 0],
        ):
            with self.subTest(text_input=text_input):
                if not expected_partner and find_idx:
                    expected_partner = all_partners[find_idx]
                all_partners.append(
                    self._check_find_or_create(
                        text_input, expected_name, expected_email,
                        expected_partner=expected_partner,
                    )
                )

    def test_is_public(self):
        """ Check that base.partner_user is a public partner."""
        self.assertFalse(self.env.ref('base.public_user').active)
        self.assertFalse(self.env.ref('base.public_partner').active)
        self.assertTrue(self.env.ref('base.public_partner').is_public)

    def test_lang_computation_code(self):
        """ Check computation of lang: coming from installed languages, forced
        default value and propagation from parent."""
        default_lang_info = self.env['res.lang'].get_installed()[0]
        default_lang_code = default_lang_info[0]
        self.assertNotEqual(default_lang_code, 'de_DE')  # should not be the case, just to ease test
        self.assertNotEqual(default_lang_code, 'fr_FR')  # should not be the case, just to ease test

        # default is installed lang
        partner = self.env['res.partner'].create({'name': "Test Company"})
        self.assertEqual(partner.lang, default_lang_code)

        # check propagation of parent to child
        child = self.env['res.partner'].create({'name': 'First Child', 'parent_id': partner.id})
        self.assertEqual(child.lang, default_lang_code)

        # activate another languages to test language propagation when being in multi-lang
        self.env['res.lang']._activate_lang('de_DE')
        self.env['res.lang']._activate_lang('fr_FR')

        # default from context > default from installed
        partner = self.env['res.partner'].with_context(default_lang='de_DE').create({'name': "Test Company"})
        self.assertEqual(partner.lang, 'de_DE')
        first_child = self.env['res.partner'].create({'name': 'First Child', 'parent_id': partner.id})
        partner.write({'lang': 'fr_FR'})
        second_child = self.env['res.partner'].create({'name': 'Second Child', 'parent_id': partner.id})

        # check user input is kept
        self.assertEqual(partner.lang, 'fr_FR')
        self.assertEqual(first_child.lang, 'de_DE')
        self.assertEqual(second_child.lang, 'fr_FR')

    def test_name_create(self):
        res_partner = self.env['res.partner']
        for text, expected_name, expected_mail in SAMPLES:
            with self.subTest(text=text):
                partner_id, dummy = res_partner.name_create(text)
                partner = res_partner.browse(partner_id)
                self.assertEqual(expected_name or expected_mail.lower(), partner.name)
                self.assertEqual(expected_mail.lower() or False, partner.email)

        # name_create supports default_email fallback
        partner = self.env['res.partner'].browse(
            self.env['res.partner'].with_context(
                default_email='John.Wick@example.com'
            ).name_create('"Raoulette Vachette" <Raoul@Grosbedon.fr>')[0]
        )
        self.assertEqual(partner.name, 'Raoulette Vachette')
        self.assertEqual(partner.email, 'raoul@grosbedon.fr')

        partner = self.env['res.partner'].browse(
            self.env['res.partner'].with_context(
                default_email='John.Wick@example.com'
            ).name_create('Raoulette Vachette')[0]
        )
        self.assertEqual(partner.name, 'Raoulette Vachette')
        self.assertEqual(partner.email, 'John.Wick@example.com')

    def test_name_search(self):
        res_partner = self.env['res.partner']
        sources = [
            ('"A Raoul Grosbedon" <raoul@chirurgiens-dentistes.fr>', False),
            ('B Raoul chirurgiens-dentistes.fr', True),
            ("C Raoul O'hara  <!@historicalsociety.museum>", True),
            ('ryu+giga-Sushi@aizubange.fukushima.jp', True),
        ]
        for name, active in sources:
            _partner_id, dummy = res_partner.with_context(default_active=active).name_create(name)
        partners = res_partner.name_search('Raoul')
        self.assertEqual(len(partners), 2, 'Incorrect search number result for name_search')
        partners = res_partner.name_search('Raoul', limit=1)
        self.assertEqual(len(partners), 1, 'Incorrect search number result for name_search with a limit')
        self.assertEqual(partners[0][1], 'B Raoul chirurgiens-dentistes.fr', 'Incorrect partner returned, should be the first active')

    def test_name_search_with_user(self):
        """ Check name_search on partner, especially with domain based on auto_join
        user_ids field. Check specific SQL of name_search correctly handle joined tables. """
        test_partner = self.env['res.partner'].create({'name': 'Vlad the Impaler'})
        test_user = self.env['res.users'].create({'name': 'Vlad the Impaler', 'login': 'vlad', 'email': 'vlad.the.impaler@example.com'})

        ns_res = self.env['res.partner'].name_search('Vlad', operator='ilike')
        self.assertEqual(set(i[0] for i in ns_res), set((test_partner | test_user.partner_id).ids))

        ns_res = self.env['res.partner'].name_search('Vlad', args=[('user_ids.email', 'ilike', 'vlad')])
        self.assertEqual(set(i[0] for i in ns_res), set(test_user.partner_id.ids))

        # Check a partner may be searched when current user has no access but sudo is used
        public_user = self.env.ref('base.public_user')
        with self.assertRaises(AccessError):
            test_partner.with_user(public_user).check_access_rule('read')
        ns_res = self.env['res.partner'].with_user(public_user).sudo().name_search('Vlad', args=[('user_ids.email', 'ilike', 'vlad')])
        self.assertEqual(set(i[0] for i in ns_res), set(test_user.partner_id.ids))

    def test_partner_merge_wizard_dst_partner_id(self):
        """ Check that dst_partner_id in merge wizard displays id along with partner name """
        test_partner = self.env['res.partner'].create({'name': 'Radu the Handsome'})
        expected_partner_name = '%s (%s)' % (test_partner.name, test_partner.id)

        partner_merge_wizard = self.env['base.partner.merge.automatic.wizard'].with_context(
            {'partner_show_db_id': True, 'default_dst_partner_id': test_partner}).new()
        self.assertEqual(
            partner_merge_wizard.dst_partner_id.display_name, expected_partner_name,
            "'Destination Contact' name should contain db ID in brackets"
        )

    def test_read_group(self):
        title_sir = self.env['res.partner.title'].create({'name': 'Sir...'})
        title_lady = self.env['res.partner.title'].create({'name': 'Lady...'})
        user_vals_list = [
            {'name': 'Alice', 'login': 'alice', 'color': 1, 'function': 'Friend', 'date': '2015-03-28', 'title': title_lady.id},
            {'name': 'Alice', 'login': 'alice2', 'color': 0, 'function': 'Friend', 'date': '2015-01-28', 'title': title_lady.id},
            {'name': 'Bob', 'login': 'bob', 'color': 2, 'function': 'Friend', 'date': '2015-03-02', 'title': title_sir.id},
            {'name': 'Eve', 'login': 'eve', 'color': 3, 'function': 'Eavesdropper', 'date': '2015-03-20', 'title': title_lady.id},
            {'name': 'Nab', 'login': 'nab', 'color': -3, 'function': '5$ Wrench', 'date': '2014-09-10', 'title': title_sir.id},
            {'name': 'Nab', 'login': 'nab-she', 'color': 6, 'function': '5$ Wrench', 'date': '2014-01-02', 'title': title_lady.id},
        ]
        res_users = self.env['res.users']
        users = res_users.create(user_vals_list)
        domain = [('id', 'in', users.ids)]

        # group on local char field without domain and without active_test (-> empty WHERE clause)
        groups_data = res_users.with_context(active_test=False).read_group([], fields=['login'], groupby=['login'], orderby='login DESC')
        self.assertGreater(len(groups_data), 6, "Incorrect number of results when grouping on a field")

        # group on local char field with limit
        groups_data = res_users.read_group(domain, fields=['login'], groupby=['login'], orderby='login DESC', limit=3, offset=3)
        self.assertEqual(len(groups_data), 3, "Incorrect number of results when grouping on a field with limit")
        self.assertEqual([g['login'] for g in groups_data], ['bob', 'alice2', 'alice'], 'Result mismatch')

        # group on inherited char field, aggregate on int field (second groupby ignored on purpose)
        groups_data = res_users.read_group(domain, fields=['name', 'color', 'function'], groupby=['function', 'login'])
        self.assertEqual(len(groups_data), 3, "Incorrect number of results when grouping on a field")
        self.assertEqual(['5$ Wrench', 'Eavesdropper', 'Friend'], [g['function'] for g in groups_data], 'incorrect read_group order')
        for group_data in groups_data:
            self.assertIn('color', group_data, "Aggregated data for the column 'color' is not present in read_group return values")
            self.assertEqual(group_data['color'], 3, "Incorrect sum for aggregated data for the column 'color'")

        # group on inherited char field, reverse order
        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby='name', orderby='name DESC')
        self.assertEqual([g['name'] for g in groups_data], ['Nab', 'Eve', 'Bob', 'Alice'], 'Incorrect ordering of the list')

        # group on int field, default ordering
        groups_data = res_users.read_group(domain, fields=['color'], groupby='color')
        self.assertEqual([g['color'] for g in groups_data], [-3, 0, 1, 2, 3, 6], 'Incorrect ordering of the list')

        # multi group, second level is int field, should still be summed in first level grouping
        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby=['name', 'color'], orderby='name DESC')
        self.assertEqual([g['name'] for g in groups_data], ['Nab', 'Eve', 'Bob', 'Alice'], 'Incorrect ordering of the list')
        self.assertEqual([g['color'] for g in groups_data], [3, 3, 2, 1], 'Incorrect ordering of the list')

        # group on inherited char field, multiple orders with directions
        groups_data = res_users.read_group(domain, fields=['name', 'color'], groupby='name', orderby='color DESC, name')
        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
        self.assertEqual([g['name'] for g in groups_data], ['Eve', 'Nab', 'Bob', 'Alice'], 'Incorrect ordering of the list')
        self.assertEqual([g['name_count'] for g in groups_data], [1, 2, 1, 2], 'Incorrect number of results')

        # group on inherited date column (res_partner.date) -> Year-Month, default ordering
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date'])
        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
        self.assertEqual([g['date'] for g in groups_data], ['January 2014', 'September 2014', 'January 2015', 'March 2015'], 'Incorrect ordering of the list')
        self.assertEqual([g['date_count'] for g in groups_data], [1, 1, 1, 3], 'Incorrect number of results')

        # group on inherited date column (res_partner.date) specifying the :year -> Year default ordering
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date:year'])
        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
        self.assertEqual([g['date:year'] for g in groups_data], ['2014', '2015'], 'Incorrect ordering of the list')
        self.assertEqual([g['date_count'] for g in groups_data], [2, 4], 'Incorrect number of results')

        # group on inherited date column (res_partner.date) -> Year-Month, custom order
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'date'], groupby=['date'], orderby='date DESC')
        self.assertEqual(len(groups_data), 4, "Incorrect number of results when grouping on a field")
        self.assertEqual([g['date'] for g in groups_data], ['March 2015', 'January 2015', 'September 2014', 'January 2014'], 'Incorrect ordering of the list')
        self.assertEqual([g['date_count'] for g in groups_data], [3, 1, 1, 1], 'Incorrect number of results')

        # group on inherited many2one (res_partner.title), default order
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'])
        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
        # m2o is returned as a (id, label) pair
        self.assertEqual([g['title'] for g in groups_data], [(title_lady.id, 'Lady...'), (title_sir.id, 'Sir...')], 'Incorrect ordering of the list')
        self.assertEqual([g['title_count'] for g in groups_data], [4, 2], 'Incorrect number of results')
        self.assertEqual([g['color'] for g in groups_data], [10, -1], 'Incorrect aggregation of int column')

        # group on inherited many2one (res_partner.title), reversed natural order
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby="title desc")
        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
        # m2o is returned as a (id, label) pair
        self.assertEqual([(title_sir.id, 'Sir...'), (title_lady.id, 'Lady...')], [g['title'] for g in groups_data], 'Incorrect ordering of the list')
        self.assertEqual([g['title_count'] for g in groups_data], [2, 4], 'Incorrect number of results')
        self.assertEqual([g['color'] for g in groups_data], [-1, 10], 'Incorrect aggregation of int column')

        # group on inherited many2one (res_partner.title), multiple orders with m2o in second position
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby="color desc, title desc")
        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
        # m2o is returned as a (id, label) pair
        self.assertEqual([g['title'] for g in groups_data], [(title_lady.id, 'Lady...'), (title_sir.id, 'Sir...')], 'Incorrect ordering of the result')
        self.assertEqual([g['title_count'] for g in groups_data], [4, 2], 'Incorrect number of results')
        self.assertEqual([g['color'] for g in groups_data], [10, -1], 'Incorrect aggregation of int column')

        # group on inherited many2one (res_partner.title), ordered by other inherited field (color)
        groups_data = res_users.read_group(domain, fields=['function', 'color', 'title'], groupby=['title'], orderby='color')
        self.assertEqual(len(groups_data), 2, "Incorrect number of results when grouping on a field")
        # m2o is returned as a (id, label) pair
        self.assertEqual([g['title'] for g in groups_data], [(title_sir.id, 'Sir...'), (title_lady.id, 'Lady...')], 'Incorrect ordering of the list')
        self.assertEqual([g['title_count'] for g in groups_data], [2, 4], 'Incorrect number of results')
        self.assertEqual([g['color'] for g in groups_data], [-1, 10], 'Incorrect aggregation of int column')

    def test_display_name_translation(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env.ref('base.module_base')._update_translations(['fr_FR'])

        res_partner = self.env['res.partner']

        parent_contact = res_partner.create({
            'name': 'Parent',
            'type': 'contact',
        })

        child_contact = res_partner.create({
            'type': 'other',
            'parent_id': parent_contact.id,
        })

        self.assertEqual(child_contact.with_context(lang='en_US').display_name, 'Parent, Other Address')

        self.assertEqual(child_contact.with_context(lang='fr_FR').display_name, 'Parent, Autre adresse')


@tagged('res_partner')
class TestPartnerAddressCompany(TransactionCase):

    def test_address(self):
        res_partner = self.env['res.partner']
        ghoststep = res_partner.create({
            'name': 'GhostStep',
            'is_company': True,
            'street': 'Main Street, 10',
            'phone': '123456789',
            'email': 'info@ghoststep.com',
            'vat': 'BE0477472701',
            'type': 'contact',
        })
        p1 = res_partner.browse(res_partner.name_create('Denis Bladesmith <denis.bladesmith@ghoststep.com>')[0])
        self.assertEqual(p1.type, 'contact', 'Default type must be "contact"')
        p1phone = '123456789#34'
        p1.write({'phone': p1phone,
                  'parent_id': ghoststep.id})
        self.assertEqual(p1.street, ghoststep.street, 'Address fields must be synced')
        self.assertEqual(p1.phone, p1phone, 'Phone should be preserved after address sync')
        self.assertEqual(p1.type, 'contact', 'Type should be preserved after address sync')
        self.assertEqual(p1.email, 'denis.bladesmith@ghoststep.com', 'Email should be preserved after sync')

        # turn off sync
        p1street = 'Different street, 42'
        p1.write({'street': p1street,
                  'type': 'invoice'})
        self.assertEqual(p1.street, p1street, 'Address fields must not be synced after turning sync off')
        self.assertNotEqual(ghoststep.street, p1street, 'Parent address must never be touched')

        # turn on sync again
        p1.write({'type': 'contact'})
        self.assertEqual(p1.street, ghoststep.street, 'Address fields must be synced again')
        self.assertEqual(p1.phone, p1phone, 'Phone should be preserved after address sync')
        self.assertEqual(p1.type, 'contact', 'Type should be preserved after address sync')
        self.assertEqual(p1.email, 'denis.bladesmith@ghoststep.com', 'Email should be preserved after sync')

        # Modify parent, sync to children
        ghoststreet = 'South Street, 25'
        ghoststep.write({'street': ghoststreet})
        self.assertEqual(p1.street, ghoststreet, 'Address fields must be synced automatically')
        self.assertEqual(p1.phone, p1phone, 'Phone should not be synced')
        self.assertEqual(p1.email, 'denis.bladesmith@ghoststep.com', 'Email should be preserved after sync')

        p1street = 'My Street, 11'
        p1.write({'street': p1street})
        self.assertEqual(ghoststep.street, ghoststreet, 'Touching contact should never alter parent')

    def test_address_first_contact_sync(self):
        """ Test initial creation of company/contact pair where contact address gets copied to
        company """
        res_partner = self.env['res.partner']
        ironshield = res_partner.browse(res_partner.name_create('IronShield')[0])
        self.assertFalse(ironshield.is_company, 'Partners are not companies by default')
        self.assertEqual(ironshield.type, 'contact', 'Default type must be "contact"')
        ironshield.write({'type': 'contact'})

        p1 = res_partner.create({
            'name': 'Isen Hardearth',
            'street': 'Strongarm Avenue, 12',
            'parent_id': ironshield.id,
        })
        self.assertEqual(p1.type, 'contact', 'Default type must be "contact", not the copied parent type')
        self.assertEqual(ironshield.street, p1.street, 'Address fields should be copied to company')

    def test_address_get(self):
        """ Test address_get address resolution mechanism: it should first go down through descendants,
        stopping when encountering another is_copmany entity, then go up, stopping again at the first
        is_company entity or the root ancestor and if nothing matches, it should use the provided partner
        itself """
        res_partner = self.env['res.partner']
        elmtree = res_partner.browse(res_partner.name_create('Elmtree')[0])
        branch1 = res_partner.create({'name': 'Branch 1',
                                      'parent_id': elmtree.id,
                                      'is_company': True})
        leaf10 = res_partner.create({'name': 'Leaf 10',
                                     'parent_id': branch1.id,
                                     'type': 'invoice'})
        branch11 = res_partner.create({'name': 'Branch 11',
                                       'parent_id': branch1.id,
                                       'type': 'other'})
        leaf111 = res_partner.create({'name': 'Leaf 111',
                                      'parent_id': branch11.id,
                                      'type': 'delivery'})
        branch11.write({'is_company': False})  # force is_company after creating 1rst child
        branch2 = res_partner.create({'name': 'Branch 2',
                                      'parent_id': elmtree.id,
                                      'is_company': True})
        leaf21 = res_partner.create({'name': 'Leaf 21',
                                     'parent_id': branch2.id,
                                     'type': 'delivery'})
        leaf22 = res_partner.create({'name': 'Leaf 22',
                                     'parent_id': branch2.id})
        leaf23 = res_partner.create({'name': 'Leaf 23',
                                     'parent_id': branch2.id,
                                     'type': 'contact'})

        # go up, stop at branch1
        self.assertEqual(leaf111.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf111.id,
                          'invoice': leaf10.id,
                          'contact': branch1.id,
                          'other': branch11.id}, 'Invalid address resolution')
        self.assertEqual(branch11.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf111.id,
                          'invoice': leaf10.id,
                          'contact': branch1.id,
                          'other': branch11.id}, 'Invalid address resolution')

        # go down, stop at at all child companies
        self.assertEqual(elmtree.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': elmtree.id,
                          'invoice': elmtree.id,
                          'contact': elmtree.id,
                          'other': elmtree.id}, 'Invalid address resolution')

        # go down through children
        self.assertEqual(branch1.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf111.id,
                          'invoice': leaf10.id,
                          'contact': branch1.id,
                          'other': branch11.id}, 'Invalid address resolution')

        self.assertEqual(branch2.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf21.id,
                          'invoice': branch2.id,
                          'contact': branch2.id,
                          'other': branch2.id}, 'Invalid address resolution. Company is the first encountered contact, therefore default for unfound addresses.')

        # go up then down through siblings
        self.assertEqual(leaf21.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf21.id,
                          'invoice': branch2.id,
                          'contact': branch2.id,
                          'other': branch2.id}, 'Invalid address resolution, should scan commercial entity ancestor and its descendants')
        self.assertEqual(leaf22.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf21.id,
                          'invoice': leaf22.id,
                          'contact': leaf22.id,
                          'other': leaf22.id}, 'Invalid address resolution, should scan commercial entity ancestor and its descendants')
        self.assertEqual(leaf23.address_get(['delivery', 'invoice', 'contact', 'other']),
                         {'delivery': leaf21.id,
                          'invoice': leaf23.id,
                          'contact': leaf23.id,
                          'other': leaf23.id}, 'Invalid address resolution, `default` should only override if no partner with specific type exists')

        # empty adr_pref means only 'contact'
        self.assertEqual(elmtree.address_get([]),
                        {'contact': elmtree.id}, 'Invalid address resolution, no contact means commercial entity ancestor')
        self.assertEqual(leaf111.address_get([]),
                        {'contact': branch1.id}, 'Invalid address resolution, no contact means finding contact in ancestors')
        branch11.write({'type': 'contact'})
        self.assertEqual(leaf111.address_get([]),
                        {'contact': branch11.id}, 'Invalid address resolution, branch11 should now be contact')

    def test_commercial_partner_nullcompany(self):
        """ The commercial partner is the first/nearest ancestor-or-self which
        is a company or doesn't have a parent
        """
        P = self.env['res.partner']
        p0 = P.create({'name': '0', 'email': '0'})
        self.assertEqual(p0.commercial_partner_id, p0, "partner without a parent is their own commercial partner")

        p1 = P.create({'name': '1', 'email': '1', 'parent_id': p0.id})
        self.assertEqual(p1.commercial_partner_id, p0, "partner's parent is their commercial partner")
        p12 = P.create({'name': '12', 'email': '12', 'parent_id': p1.id})
        self.assertEqual(p12.commercial_partner_id, p0, "partner's GP is their commercial partner")

        p2 = P.create({'name': '2', 'email': '2', 'parent_id': p0.id, 'is_company': True})
        self.assertEqual(p2.commercial_partner_id, p2, "partner flagged as company is their own commercial partner")
        p21 = P.create({'name': '21', 'email': '21', 'parent_id': p2.id})
        self.assertEqual(p21.commercial_partner_id, p2, "commercial partner is closest ancestor with themselves as commercial partner")

        p3 = P.create({'name': '3', 'email': '3', 'is_company': True})
        self.assertEqual(p3.commercial_partner_id, p3, "being both parent-less and company should be the same as either")

        notcompanies = p0 | p1 | p12 | p21
        self.env.cr.execute('update res_partner set is_company=null where id = any(%s)', [notcompanies.ids])
        for parent in notcompanies:
            p = P.create({
                'name': parent.name + '_sub',
                'email': parent.email + '_sub',
                'parent_id': parent.id,
            })
            self.assertEqual(
                p.commercial_partner_id,
                parent.commercial_partner_id,
                "check that is_company=null is properly handled when looking for ancestor"
            )

    def test_commercial_field_sync(self):
        """Check if commercial fields are synced properly: testing with VAT field"""
        Partner = self.env['res.partner']
        company_1 = Partner.create({'name': 'company 1', 'is_company': True, 'vat': 'BE0123456789'})
        company_2 = Partner.create({'name': 'company 2', 'is_company': True, 'vat': 'BE9876543210'})

        partner = Partner.create({'name': 'someone', 'is_company': False, 'parent_id': company_1.id})
        Partner.flush_recordset()
        self.assertEqual(partner.vat, company_1.vat, "VAT should be inherited from the company 1")

        # create a delivery address for the partner
        delivery = Partner.create({'name': 'somewhere', 'type': 'delivery', 'parent_id': partner.id})
        self.assertEqual(delivery.commercial_partner_id.id, company_1.id, "Commercial partner should be recomputed")
        self.assertEqual(delivery.vat, company_1.vat, "VAT should be inherited from the company 1")

        # move the partner to another company
        partner.write({'parent_id': company_2.id})
        partner.flush_recordset()
        self.assertEqual(partner.commercial_partner_id.id, company_2.id, "Commercial partner should be recomputed")
        self.assertEqual(partner.vat, company_2.vat, "VAT should be inherited from the company 2")
        self.assertEqual(delivery.commercial_partner_id.id, company_2.id, "Commercial partner should be recomputed on delivery")
        self.assertEqual(delivery.vat, company_2.vat, "VAT should be inherited from the company 2 to delivery")

    def test_commercial_sync(self):
        res_partner = self.env['res.partner']
        p0 = res_partner.create({'name': 'Sigurd Sunknife',
                                 'email': 'ssunknife@gmail.com'})
        sunhelm = res_partner.create({'name': 'Sunhelm',
                                      'is_company': True,
                                      'street': 'Rainbow Street, 13',
                                      'phone': '1122334455',
                                      'email': 'info@sunhelm.com',
                                      'vat': 'BE0477472701',
                                      'child_ids': [Command.link(p0.id),
                                                    Command.create({'name': 'Alrik Greenthorn',
                                                            'email': 'agr@sunhelm.com'})]})
        p1 = res_partner.create({'name': 'Otto Blackwood',
                                 'email': 'otto.blackwood@sunhelm.com',
                                 'parent_id': sunhelm.id})
        p11 = res_partner.create({'name': 'Gini Graywool',
                                  'email': 'ggr@sunhelm.com',
                                  'parent_id': p1.id})
        p2 = res_partner.search([('email', '=', 'agr@sunhelm.com')], limit=1)
        sunhelm.write({'child_ids': [Command.create({'name': 'Ulrik Greenthorn',
                                             'email': 'ugr@sunhelm.com'})]})
        p3 = res_partner.search([('email', '=', 'ugr@sunhelm.com')], limit=1)

        for p in (p0, p1, p11, p2, p3):
            self.assertEqual(p.commercial_partner_id, sunhelm, 'Incorrect commercial entity resolution')
            self.assertEqual(p.vat, sunhelm.vat, 'Commercial fields must be automatically synced')
        sunhelmvat = 'BE0123456749'
        sunhelm.write({'vat': sunhelmvat})
        for p in (p0, p1, p11, p2, p3):
            self.assertEqual(p.vat, sunhelmvat, 'Commercial fields must be automatically and recursively synced')

        p1vat = 'BE0987654394'
        p1.write({'vat': p1vat})
        for p in (sunhelm, p0, p11, p2, p3):
            self.assertEqual(p.vat, sunhelmvat, 'Sync to children should only work downstream and on commercial entities')

        # promote p1 to commercial entity
        p1.write({'parent_id': sunhelm.id,
                  'is_company': True,
                  'name': 'Sunhelm Subsidiary'})
        self.assertEqual(p1.vat, p1vat, 'Setting is_company should stop auto-sync of commercial fields')
        self.assertEqual(p1.commercial_partner_id, p1, 'Incorrect commercial entity resolution after setting is_company')

        # writing on parent should not touch child commercial entities
        sunhelmvat2 = 'BE0112233453'
        sunhelm.write({'vat': sunhelmvat2})
        self.assertEqual(p1.vat, p1vat, 'Setting is_company should stop auto-sync of commercial fields')
        self.assertEqual(p0.vat, sunhelmvat2, 'Commercial fields must be automatically synced')

    def test_company_change_propagation(self):
        """ Check propagation of company_id across children """
        User = self.env['res.users']
        Partner = self.env['res.partner']
        Company = self.env['res.company']

        company_1 = Company.create({'name': 'company_1'})
        company_2 = Company.create({'name': 'company_2'})

        test_partner_company = Partner.create({'name': 'This company'})
        test_user = User.create({'name': 'This user', 'login': 'thisu', 'email': 'this.user@example.com', 'company_id': company_1.id, 'company_ids': [company_1.id]})
        test_user.partner_id.write({'parent_id': test_partner_company.id})

        test_partner_company.write({'company_id': company_1.id})
        self.assertEqual(test_user.partner_id.company_id.id, company_1.id, "The new company_id of the partner company should be propagated to its children")

        test_partner_company.write({'company_id': False})
        self.assertFalse(test_user.partner_id.company_id.id, "If the company_id is deleted from the partner company, it should be propagated to its children")

        with self.assertRaises(UserError, msg="You should not be able to update the company_id of the partner company if the linked user of a child partner is not an allowed to be assigned to that company"), self.cr.savepoint():
            test_partner_company.write({'company_id': company_2.id})

    def test_display_address_missing_key(self):
        """ Check _display_address when some keys are missing. As a defaultdict is used, missing keys should be
        filled with empty strings. """
        country = self.env["res.country"].create({"name": "TestCountry", "address_format": "%(city)s %(zip)s", "code": "ZV"})
        partner = self.env["res.partner"].create({
            "name": "TestPartner",
            "country_id": country.id,
            "city": "TestCity",
            "zip": "12345",
        })
        before = partner._display_address()
        # Manually update the country address_format because placeholders are checked by create
        self.env.cr.execute(
            "UPDATE res_country SET address_format ='%%(city)s %%(zip)s %%(nothing)s' WHERE id=%s",
            [country.id]
        )
        self.env["res.country"].invalidate_model()
        self.assertEqual(before, partner._display_address().strip())

    def test_display_name(self):
        """ Check display_name on partner, especially with different context
        Check display_name correctly return name with context. """
        test_partner_jetha = self.env['res.partner'].create({'name': 'Jethala', 'street': 'Powder gali', 'street2': 'Gokuldham Society'})
        test_partner_bhide = self.env['res.partner'].create({'name': 'Atmaram Bhide'})

        res_jetha = test_partner_jetha.with_context(show_address=1).display_name
        self.assertEqual(res_jetha, "Jethala\nPowder gali\nGokuldham Society", "name should contain comma separated name and address")
        res_bhide = test_partner_bhide.with_context(show_address=1).display_name
        self.assertEqual(res_bhide, "Atmaram Bhide", "name should contain only name if address is not available, without extra commas")

        res_jetha = test_partner_jetha.with_context(show_address=1, address_inline=1).display_name
        self.assertEqual(res_jetha, "Jethala, Powder gali, Gokuldham Society", "name should contain comma separated name and address")
        res_bhide = test_partner_bhide.with_context(show_address=1, address_inline=1).display_name
        self.assertEqual(res_bhide, "Atmaram Bhide", "name should contain only name if address is not available, without extra commas")

    def test_accessibility_of_company_partner_from_branch(self):
        """ Check accessibility of company partner from branch. """
        company = self.env['res.company'].create({'name': 'company'})
        branch = self.env['res.company'].create({
            'name': 'branch',
            'parent_id': company.id
        })
        partner = self.env['res.partner'].create({
            'name': 'partner',
            'company_id': company.id
        })
        user = self.env['res.users'].create({
            'name': 'user',
            'login': 'user',
            'company_id': branch.id,
            'company_ids': [branch.id]
        })
        record = self.env['res.partner'].with_user(user).search([('id', '=', partner.id)])
        self.assertEqual(record.id, partner.id)


@tagged('res_partner', 'post_install', '-at_install')
class TestPartnerForm(TransactionCase):
    # those tests are made post-install because they need module 'web' for the
    # form view to work properly

    def test_lang_computation_form_view(self):
        """ Check computation of lang: coming from installed languages, forced
        default value and propagation from parent."""
        default_lang_info = self.env['res.lang'].get_installed()[0]
        default_lang_code = default_lang_info[0]
        self.assertNotEqual(default_lang_code, 'de_DE')  # should not be the case, just to ease test
        self.assertNotEqual(default_lang_code, 'fr_FR')  # should not be the case, just to ease test

        # default is installed lang
        partner_form = Form(self.env['res.partner'], 'base.view_partner_form')
        partner_form.name = "Test Company"
        self.assertEqual(partner_form.lang, default_lang_code, "New partner's lang should be default one")
        partner = partner_form.save()
        self.assertEqual(partner.lang, default_lang_code)

        # check propagation of parent to child
        with partner_form.child_ids.new() as child:
            child.name = "First Child"
            self.assertEqual(child.lang, default_lang_code, "Child contact's lang should have the same as its parent")
        partner = partner_form.save()
        self.assertEqual(partner.child_ids.lang, default_lang_code)

        # activate another languages to test language propagation when being in multi-lang
        self.env['res.lang']._activate_lang('de_DE')
        self.env['res.lang']._activate_lang('fr_FR')

        # default from context > default from installed
        partner_form = Form(
            self.env['res.partner'].with_context(default_lang='de_DE'),
            'base.view_partner_form'
        )
        # <field name="is_company" invisible="1"/>
        # <field name="company_type" widget="radio" options="{'horizontal': true}"/>
        # @api.onchange('company_type')
        # def onchange_company_type(self):
        #     self.is_company = (self.company_type == 'company')
        partner_form.company_type = 'company'
        partner_form.name = "Test Company"
        self.assertEqual(partner_form.lang, 'de_DE', "New partner's lang should take default from context")
        with partner_form.child_ids.new() as child:
            child.name = "First Child"
            self.assertEqual(child.lang, 'de_DE', "Child contact's lang should be the same as its parent.")
        partner_form.lang = 'fr_FR'
        self.assertEqual(partner_form.lang, 'fr_FR', "New partner's lang should take user input")
        with partner_form.child_ids.new() as child:
            child.name = "Second Child"
            self.assertEqual(child.lang, 'fr_FR', "Child contact's lang should be the same as its parent.")
        partner = partner_form.save()

        # check final values (kept from form input)
        self.assertEqual(partner.lang, 'fr_FR')
        self.assertEqual(partner.child_ids.filtered(lambda p: p.name == "First Child").lang, 'de_DE')
        self.assertEqual(partner.child_ids.filtered(lambda p: p.name == "Second Child").lang, 'fr_FR')

    def test_onchange_parent_sync_user(self):
        company_1 = self.env['res.company'].create({'name': 'company_1'})
        test_user = self.env['res.users'].create({
            'name': 'This user',
            'login': 'thisu',
            'email': 'this.user@example.com',
            'company_id': company_1.id,
            'company_ids': [company_1.id],
        })
        test_parent_partner = self.env['res.partner'].create({
            'company_type': 'company',
            'name': 'Micheline',
            'user_id': test_user.id,
        })
        with Form(self.env['res.partner']) as partner_form:
            partner_form.parent_id = test_parent_partner
            partner_form.company_type = 'person'
            partner_form.name = 'Philip'
            self.assertEqual(partner_form.user_id, test_parent_partner.user_id)


@tagged('res_partner')
class TestPartnerRecursion(TransactionCase):

    def setUp(self):
        super(TestPartnerRecursion, self).setUp()
        res_partner = self.env['res.partner']
        self.p1 = res_partner.browse(res_partner.name_create('Elmtree')[0])
        self.p2 = res_partner.create({'name': 'Elmtree Child 1', 'parent_id': self.p1.id})
        self.p3 = res_partner.create({'name': 'Elmtree Grand-Child 1.1', 'parent_id': self.p2.id})

    def test_100_res_partner_recursion(self):
        self.assertTrue(self.p3._check_recursion())
        self.assertTrue((self.p1 + self.p2 + self.p3)._check_recursion())

    # split 101, 102, 103 tests to force SQL rollback between them

    def test_101_res_partner_recursion(self):
        with self.assertRaises(ValidationError):
            self.p1.write({'parent_id': self.p3.id})

    def test_102_res_partner_recursion(self):
        with self.assertRaises(ValidationError):
            self.p2.write({'parent_id': self.p3.id})

    def test_103_res_partner_recursion(self):
        with self.assertRaises(ValidationError):
            self.p3.write({'parent_id': self.p3.id})

    def test_104_res_partner_recursion_indirect_cycle(self):
        """ Indirect hacky write to create cycle in children """
        p3b = self.p1.create({'name': 'Elmtree Grand-Child 1.2', 'parent_id': self.p2.id})
        with self.assertRaises(ValidationError):
            self.p2.write({'child_ids': [Command.update(self.p3.id, {'parent_id': p3b.id}),
                                         Command.update(p3b.id, {'parent_id': self.p3.id})]})

    def test_110_res_partner_recursion_multi_update(self):
        """ multi-write on several partners in same hierarchy must not trigger a false cycle detection """
        ps = self.p1 + self.p2 + self.p3
        self.assertTrue(ps.write({'phone': '123456'}))

    def test_111_res_partner_recursion_infinite_loop(self):
        """ The recursion check must not loop forever """
        self.p2.parent_id = False
        self.p3.parent_id = False
        self.p1.parent_id = self.p2
        with self.assertRaises(ValidationError):
            (self.p3|self.p2).write({'parent_id': self.p1.id})

```

  File: tests/test_res_partner_bank.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

# Copyright (c) 2015 ACSONE SA/NV (<http://acsone.eu>)

from odoo.addons.base.tests.common import SavepointCaseWithUserDemo


class TestResPartnerBank(SavepointCaseWithUserDemo):
    """Tests acc_number
    """

    def test_sanitized_acc_number(self):
        partner_bank_model = self.env['res.partner.bank']
        acc_number = " BE-001 2518823 03 "
        vals = partner_bank_model.search([('acc_number', '=', acc_number)])
        self.assertEqual(0, len(vals))
        partner_bank = partner_bank_model.create({
            'acc_number': acc_number,
            'partner_id': self.env['res.partner'].create({'name': 'Pepper Test'}).id,
            'acc_type': 'bank',
        })
        vals = partner_bank_model.search([('acc_number', '=', acc_number)])
        self.assertEqual(1, len(vals))
        self.assertEqual(partner_bank, vals[0])
        vals = partner_bank_model.search([('acc_number', 'in', [acc_number])])
        self.assertEqual(1, len(vals))
        self.assertEqual(partner_bank, vals[0])

        self.assertEqual(partner_bank.acc_number, acc_number)

        # sanitaze the acc_number
        sanitized_acc_number = 'BE001251882303'
        vals = partner_bank_model.search(
            [('acc_number', '=', sanitized_acc_number)])
        self.assertEqual(1, len(vals))
        self.assertEqual(partner_bank, vals[0])
        vals = partner_bank_model.search(
            [('acc_number', 'in', [sanitized_acc_number])])
        self.assertEqual(1, len(vals))
        self.assertEqual(partner_bank, vals[0])
        self.assertEqual(partner_bank.sanitized_acc_number,
                         sanitized_acc_number)

        # search is case insensitive
        vals = partner_bank_model.search(
            [('acc_number', '=', sanitized_acc_number.lower())])
        self.assertEqual(1, len(vals))
        vals = partner_bank_model.search(
            [('acc_number', '=', acc_number.lower())])
        self.assertEqual(1, len(vals))

```

  File: tests/test_res_users.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from types import SimpleNamespace
from unittest.mock import patch

from odoo import SUPERUSER_ID
from odoo.addons.base.models.res_users import is_selection_groups, get_selection_groups, name_selection_groups
from odoo.exceptions import UserError
from odoo.tests.common import Form, TransactionCase, new_test_user, tagged
from odoo.tools import mute_logger


class TestUsers(TransactionCase):

    def test_name_search(self):
        """ Check name_search on user. """
        User = self.env['res.users']

        test_user = User.create({'name': 'Flad the Impaler', 'login': 'vlad'})
        like_user = User.create({'name': 'Wlad the Impaler', 'login': 'vladi'})
        other_user = User.create({'name': 'Nothing similar', 'login': 'nothing similar'})
        all_users = test_user | like_user | other_user

        res = User.name_search('vlad', operator='ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, test_user)

        res = User.name_search('vlad', operator='not ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, all_users)

        res = User.name_search('', operator='ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, all_users)

        res = User.name_search('', operator='not ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, User)

        res = User.name_search('lad', operator='ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, test_user | like_user)

        res = User.name_search('lad', operator='not ilike')
        self.assertEqual(User.browse(i[0] for i in res) & all_users, other_user)

    def test_user_partner(self):
        """ Check that the user partner is well created """

        User = self.env['res.users']
        Partner = self.env['res.partner']
        Company = self.env['res.company']

        company_1 = Company.create({'name': 'company_1'})
        company_2 = Company.create({'name': 'company_2'})

        partner = Partner.create({
            'name': 'Bob Partner',
            'company_id': company_2.id
        })

        # case 1 : the user has no partner
        test_user = User.create({
            'name': 'John Smith',
            'login': 'jsmith',
            'company_ids': [company_1.id],
            'company_id': company_1.id
        })

        self.assertFalse(
            test_user.partner_id.company_id,
            "The partner_id linked to a user should be created without any company_id")

        # case 2 : the user has a partner
        test_user = User.create({
            'name': 'Bob Smith',
            'login': 'bsmith',
            'company_ids': [company_1.id],
            'company_id': company_1.id,
            'partner_id': partner.id
        })

        self.assertEqual(
            test_user.partner_id.company_id,
            company_1,
            "If the partner_id of a user has already a company, it is replaced by the user company"
        )


    def test_change_user_company(self):
        """ Check the partner company update when the user company is changed """

        User = self.env['res.users']
        Company = self.env['res.company']

        test_user = User.create({'name': 'John Smith', 'login': 'jsmith'})
        company_1 = Company.create({'name': 'company_1'})
        company_2 = Company.create({'name': 'company_2'})

        test_user.company_ids += company_1
        test_user.company_ids += company_2

        # 1: the partner has no company_id, no modification
        test_user.write({
            'company_id': company_1.id
        })

        self.assertFalse(
            test_user.partner_id.company_id,
            "On user company change, if its partner_id has no company_id,"
            "the company_id of the partner_id shall NOT be updated")

        # 2: the partner has a company_id different from the new one, update it
        test_user.partner_id.write({
            'company_id': company_1.id
        })

        test_user.write({
            'company_id': company_2.id
        })

        self.assertEqual(
            test_user.partner_id.company_id,
            company_2,
            "On user company change, if its partner_id has already a company_id,"
            "the company_id of the partner_id shall be updated"
        )

    @mute_logger('odoo.sql_db')
    def test_deactivate_portal_users_access(self):
        """Test that only a portal users can deactivate his account."""
        user_internal = self.env['res.users'].create({
            'name': 'Internal',
            'login': 'user_internal',
            'password': 'password',
            'groups_id': [self.env.ref('base.group_user').id],
        })

        with self.assertRaises(UserError, msg='Internal users should not be able to deactivate their account'):
            user_internal._deactivate_portal_user()

    @mute_logger('odoo.sql_db', 'odoo.addons.base.models.res_users_deletion')
    def test_deactivate_portal_users_archive_and_remove(self):
        """Test that if the account can not be removed, it's archived instead
        and sensitive information are removed.

        In this test, the deletion of "portal_user" will succeed,
        but the deletion of "portal_user_2" will fail.
        """
        User = self.env['res.users']
        portal_user = User.create({
            'name': 'Portal',
            'login': 'portal_user',
            'password': 'password',
            'groups_id': [self.env.ref('base.group_portal').id],
        })
        portal_partner = portal_user.partner_id

        portal_user_2 = User.create({
            'name': 'Portal',
            'login': 'portal_user_2',
            'password': 'password',
            'groups_id': [self.env.ref('base.group_portal').id],
        })
        portal_partner_2 = portal_user_2.partner_id

        (portal_user | portal_user_2)._deactivate_portal_user()

        self.assertTrue(portal_user.exists() and not portal_user.active, 'Should have archived the user 1')

        self.assertEqual(portal_user.name, 'Portal', 'Should have kept the user name')
        self.assertEqual(portal_user.partner_id.name, 'Portal', 'Should have kept the partner name')
        self.assertNotEqual(portal_user.login, 'portal_user', 'Should have removed the user login')

        asked_deletion_1 = self.env['res.users.deletion'].search([('user_id', '=', portal_user.id)])
        asked_deletion_2 = self.env['res.users.deletion'].search([('user_id', '=', portal_user_2.id)])

        self.assertTrue(asked_deletion_1, 'Should have added the user 1 in the deletion queue')
        self.assertTrue(asked_deletion_2, 'Should have added the user 2 in the deletion queue')

        # The deletion will fail for "portal_user_2",
        # because of the absence of "ondelete=cascade"
        self.cron = self.env['ir.cron'].create({
            'name': 'Test Cron',
            'user_id': portal_user_2.id,
            'model_id': self.env.ref('base.model_res_partner').id,
        })

        self.env['res.users.deletion']._gc_portal_users()

        self.assertFalse(portal_user.exists(), 'Should have removed the user')
        self.assertFalse(portal_partner.exists(), 'Should have removed the partner')
        self.assertEqual(asked_deletion_1.state, 'done', 'Should have marked the deletion as done')

        self.assertTrue(portal_user_2.exists(), 'Should have kept the user')
        self.assertTrue(portal_partner_2.exists(), 'Should have kept the partner')
        self.assertEqual(asked_deletion_2.state, 'fail', 'Should have marked the deletion as failed')

    def test_context_get_lang(self):
        self.env['res.lang'].with_context(active_test=False).search([
            ('code', 'in', ['fr_FR', 'es_ES', 'de_DE', 'en_US'])
        ]).write({'active': True})

        user = new_test_user(self.env, 'jackoneill')
        user = user.with_user(user)
        user.lang = 'fr_FR'

        company = user.company_id.partner_id.sudo()
        company.lang = 'de_DE'

        request = SimpleNamespace()
        request.best_lang = 'es_ES'
        request_patch = patch('odoo.addons.base.models.res_users.request', request)
        self.addCleanup(request_patch.stop)
        request_patch.start()

        self.assertEqual(user.context_get()['lang'], 'fr_FR')
        self.env.registry.clear_cache()
        user.lang = False

        self.assertEqual(user.context_get()['lang'], 'es_ES')
        self.env.registry.clear_cache()
        request_patch.stop()

        self.assertEqual(user.context_get()['lang'], 'de_DE')
        self.env.registry.clear_cache()
        company.lang = False

        self.assertEqual(user.context_get()['lang'], 'en_US')

@tagged('post_install', '-at_install')
class TestUsers2(TransactionCase):

    def test_reified_groups(self):
        """ The groups handler doesn't use the "real" view with pseudo-fields
        during installation, so it always works (because it uses the normal
        groups_id field).
        """
        # use the specific views which has the pseudo-fields
        f = Form(self.env['res.users'], view='base.view_users_form')
        f.name = "bob"
        f.login = "bob"
        user = f.save()

        self.assertIn(self.env.ref('base.group_user'), user.groups_id)

        # all template user groups are copied
        default_user = self.env.ref('base.default_user')
        self.assertEqual(default_user.groups_id, user.groups_id)

    def test_selection_groups(self):
        # create 3 groups that should be in a selection
        app = self.env['ir.module.category'].create({'name': 'Foo'})
        group1, group2, group0 = self.env['res.groups'].create([
            {'name': name, 'category_id': app.id}
            for name in ('User', 'Manager', 'Visitor')
        ])
        # THIS PART IS NECESSARY TO REPRODUCE AN ISSUE: group1.id < group2.id < group0.id
        self.assertLess(group1.id, group2.id)
        self.assertLess(group2.id, group0.id)
        # implication order is group0 < group1 < group2
        group2.implied_ids = group1
        group1.implied_ids = group0
        groups = group0 + group1 + group2

        # determine the name of the field corresponding to groups
        fname = next(
            name
            for name in self.env['res.users'].fields_get()
            if is_selection_groups(name) and group0.id in get_selection_groups(name)
        )
        self.assertCountEqual(get_selection_groups(fname), groups.ids)

        # create a user
        user = self.env['res.users'].create({'name': 'foo', 'login': 'foo'})

        # put user in group0, and check field value
        user.write({fname: group0.id})
        self.assertEqual(user.groups_id & groups, group0)
        self.assertEqual(user.read([fname])[0][fname], group0.id)

        # put user in group1, and check field value
        user.write({fname: group1.id})
        self.assertEqual(user.groups_id & groups, group0 + group1)
        self.assertEqual(user.read([fname])[0][fname], group1.id)

        # put user in group2, and check field value
        user.write({fname: group2.id})
        self.assertEqual(user.groups_id & groups, groups)
        self.assertEqual(user.read([fname])[0][fname], group2.id)

        normalized_values = user._remove_reified_groups({fname: group0.id})
        self.assertEqual(sorted(normalized_values['groups_id']), [(3, group1.id), (3, group2.id), (4, group0.id)])

        normalized_values = user._remove_reified_groups({fname: group1.id})
        self.assertEqual(sorted(normalized_values['groups_id']), [(3, group2.id), (4, group1.id)])

        normalized_values = user._remove_reified_groups({fname: group2.id})
        self.assertEqual(normalized_values['groups_id'], [(4, group2.id)])

    def test_read_list_with_reified_field(self):
        """ Check that read_group and search_read get rid of reified fields"""
        User = self.env['res.users']
        fnames = ['name', 'email', 'login']

        # find some reified field name
        reified_fname = next(
            fname
            for fname in User.fields_get()
            if fname.startswith(('in_group_', 'sel_groups_'))
        )

        # check that the reified field name has no effect in fields
        res_with_reified = User.read_group([], fnames + [reified_fname], ['company_id'])
        res_without_reified = User.read_group([], fnames, ['company_id'])
        self.assertEqual(res_with_reified, res_without_reified, "Reified fields should be ignored in read_group")

        # check that the reified fields are not considered invalid in search_read
        # and are ignored
        res_with_reified = User.search_read([], fnames + [reified_fname])
        res_without_reified = User.search_read([], fnames)
        self.assertEqual(res_with_reified, res_without_reified, "Reified fields should be ignored in search_read")

        # Verify that the read_group is raising an error if reified field is used as groupby
        with self.assertRaises(ValueError):
            User.read_group([], fnames + [reified_fname], [reified_fname])

    def test_reified_groups_on_change(self):
        """Test that a change on a reified fields trigger the onchange of groups_id."""
        group_public = self.env.ref('base.group_public')
        group_portal = self.env.ref('base.group_portal')
        group_user = self.env.ref('base.group_user')

        # Build the reified group field name
        user_groups = group_public | group_portal | group_user
        user_groups_ids = [str(group_id) for group_id in sorted(user_groups.ids)]
        group_field_name = f"sel_groups_{'_'.join(user_groups_ids)}"

        # <group col="4" invisible="sel_groups_1_9_10 != 1" groups="base.group_no_one" class="o_label_nowrap">
        with self.debug_mode():
            user_form = Form(self.env['res.users'], view='base.view_users_form')
        user_form.name = "Test"
        user_form.login = "Test"
        self.assertFalse(user_form.share)

        user_form[group_field_name] = group_portal.id
        self.assertTrue(user_form.share, 'The groups_id onchange should have been triggered')

        user_form[group_field_name] = group_user.id
        self.assertFalse(user_form.share, 'The groups_id onchange should have been triggered')

        user_form[group_field_name] = group_public.id
        self.assertTrue(user_form.share, 'The groups_id onchange should have been triggered')


@tagged('post_install', '-at_install', 'res_groups')
class TestUsersGroupWarning(TransactionCase):

    @classmethod
    def setUpClass(cls):
        """
            These are the Groups and their Hierarchy we have Used to test Group warnings.

            Category groups hierarchy:
                Sales
                ├── User: All Documents
                └── Administrator
                Timesheets
                ├── User: own timesheets only
                ├── User: all timesheets
                └── Administrator
                Project
                ├── User
                └── Administrator
                Field Service
                ├── User
                └── Administrator

            Implied groups hierarchy:
                Sales / Administrator
                └── Sales / User: All Documents

                Timesheets / Administrator
                └── Timesheets / User: all timesheets
                    └── Timehseets / User: own timesheets only

                Project / Administrator
                ├── Project / User
                └── Timesheets / User: all timesheets

                Field Service / Administrator
                ├── Sales / Administrator
                ├── Project / Administrator
                └── Field Service / User
        """
        super().setUpClass()
        ResGroups = cls.env['res.groups']
        IrModuleCategory = cls.env['ir.module.category']
        categ_sales = IrModuleCategory.create({'name': 'Sales'})
        categ_project = IrModuleCategory.create({'name': 'Project'})
        categ_field_service = IrModuleCategory.create({'name': 'Field Service'})
        categ_timesheets = IrModuleCategory.create({'name': 'Timesheets'})

        # Sales
        cls.group_sales_user, cls.group_sales_administrator = ResGroups.create([
            {'name': 'User: All Documents', 'category_id': categ_sales.id},
            {'name': 'Administrator', 'category_id': categ_sales.id},
        ])
        cls.sales_categ_field = name_selection_groups((cls.group_sales_user | cls.group_sales_administrator).ids)
        cls.group_sales_administrator.implied_ids = cls.group_sales_user

        # Timesheets
        cls.group_timesheets_user_own_timesheet = ResGroups.create([
            {'name': 'User: own timesheets only', 'category_id': categ_timesheets.id}
        ])
        cls.group_timesheets_user_all_timesheet = ResGroups.create([
            {'name': 'User: all timesheets', 'category_id': categ_timesheets.id}
        ])
        cls.group_timesheets_administrator = ResGroups.create([
            {'name': 'Administrator', 'category_id': categ_timesheets.id}
        ])
        cls.timesheets_categ_field = name_selection_groups((cls.group_timesheets_user_own_timesheet |
                                                            cls.group_timesheets_user_all_timesheet |
                                                            cls.group_timesheets_administrator).ids
                                                           )
        cls.group_timesheets_administrator.implied_ids += cls.group_timesheets_user_all_timesheet
        cls.group_timesheets_user_all_timesheet.implied_ids += cls.group_timesheets_user_own_timesheet

        # Project
        cls.group_project_user, cls.group_project_admnistrator = ResGroups.create([
            {'name': 'User', 'category_id': categ_project.id},
            {'name': 'Administrator', 'category_id': categ_project.id},
        ])
        cls.project_categ_field = name_selection_groups((cls.group_project_user | cls.group_project_admnistrator).ids)
        cls.group_project_admnistrator.implied_ids = (cls.group_project_user | cls.group_timesheets_user_all_timesheet)

        # Field Service
        cls.group_field_service_user, cls.group_field_service_administrator = ResGroups.create([
            {'name': 'User', 'category_id': categ_field_service.id},
            {'name': 'Administrator', 'category_id': categ_field_service.id},
        ])
        cls.field_service_categ_field = name_selection_groups((cls.group_field_service_user | cls.group_field_service_administrator).ids)
        cls.group_field_service_administrator.implied_ids = (cls.group_sales_administrator |
                                                             cls.group_project_admnistrator |
                                                             cls.group_field_service_user).ids

        # User
        cls.test_group_user = cls.env['res.users'].create({
            'name': 'Test Group User',
            'login': 'TestGroupUser',
            'groups_id': (
                cls.env.ref('base.group_user') |
                cls.group_timesheets_administrator |
                cls.group_field_service_administrator).ids,
        })


    def test_user_group_empty_group_warning(self):
        """ User changes Empty Sales access from 'Sales: Administrator'. The
        warning should be there since 'Sales: Administrator' is required when
        user is having 'Field Service: Administrator'. When user reverts the
        changes, warning should disappear. """
        with Form(self.test_group_user.with_context(show_user_group_warning=True), view='base.view_users_form') as UserForm:
            UserForm[self.sales_categ_field] = False
            self.assertEqual(
                UserForm.user_group_warning,
                'Since Test Group User is a/an "Field Service: Administrator", they will at least obtain the right "Sales: Administrator"'
            )

            UserForm[self.sales_categ_field] = self.group_sales_administrator.id
            self.assertFalse(UserForm.user_group_warning)

    def test_user_group_inheritance_warning(self):
        """ User changes 'Sales: User' from 'Sales: Administrator'. The warning
        should be there since 'Sales: Administrator' is required when user is
        having 'Field Service: Administrator'. When user reverts the changes,
        warning should disappear. """
        with Form(self.test_group_user.with_context(show_user_group_warning=True), view='base.view_users_form') as UserForm:
            UserForm[self.sales_categ_field] = self.group_sales_user.id
            self.assertEqual(
                UserForm.user_group_warning,
                'Since Test Group User is a/an "Field Service: Administrator", they will at least obtain the right "Sales: Administrator"'
            )

            UserForm[self.sales_categ_field] = self.group_sales_administrator.id
            self.assertFalse(UserForm.user_group_warning)

    def test_user_group_inheritance_warning_multi(self):
        """ User changes 'Sales: User' from 'Sales: Administrator' and
        'Project: User' from 'Project: Administrator'. The warning should
        be there since 'Sales: Administrator' and 'Project: Administrator'
        are required when user is havning 'Field Service: Administrator'.
        When user reverts the changes For 'Sales: Administrator', warning
        should disappear for Sales Access."""
        with Form(self.test_group_user.with_context(show_user_group_warning=True), view='base.view_users_form') as UserForm:
            UserForm[self.sales_categ_field] = self.group_sales_user.id
            UserForm[self.project_categ_field] = self.group_project_user.id
            self.assertTrue(
                UserForm.user_group_warning,
                'Since Test Group User is a/an "Field Service: Administrator", they will at least obtain the right "Sales: Administrator", Project: Administrator"',
            )

            UserForm[self.sales_categ_field] = self.group_sales_administrator.id
            self.assertEqual(
                UserForm.user_group_warning,
                'Since Test Group User is a/an "Field Service: Administrator", they will at least obtain the right "Project: Administrator"'
            )

    def test_user_group_least_possible_inheritance_warning(self):
        """ User changes 'Timesheets: User: own timesheets only ' from
        'Timesheets: Administrator'. The warning should be there since
        'Timesheets: User: all timesheets' is at least required when user is
        having 'Project: Administrator'. When user reverts the changes For
        'Timesheets: User: all timesheets', warning should disappear."""
        with Form(self.test_group_user.with_context(show_user_group_warning=True), view='base.view_users_form') as UserForm:
            UserForm[self.timesheets_categ_field] = self.group_timesheets_user_own_timesheet.id
            self.assertEqual(
                UserForm.user_group_warning,
                'Since Test Group User is a/an "Project: Administrator", they will at least obtain the right "Timesheets: User: all timesheets"'
            )

            UserForm[self.timesheets_categ_field] = self.group_timesheets_user_all_timesheet.id
            self.assertFalse(UserForm.user_group_warning)

    def test_user_group_parent_inheritance_no_warning(self):
        """ User changes 'Field Service: User' from 'Field Service: Administrator'.
        The warning should not be there since 'Field Service: User' is not affected
        by any other groups."""
        with Form(self.test_group_user.with_context(show_user_group_warning=True), view='base.view_users_form') as UserForm:
            UserForm[self.field_service_categ_field] = self.group_field_service_user.id
            self.assertFalse(UserForm.user_group_warning)


class TestUsersTweaks(TransactionCase):
    def test_superuser(self):
        """ The superuser is inactive and must remain as such. """
        user = self.env['res.users'].browse(SUPERUSER_ID)
        self.assertFalse(user.active)
        with self.assertRaises(UserError):
            user.write({'active': True})

```

  File: tests/test_search.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo import Command


class test_search(TransactionCase):

    def patch_order(self, model, order):
        self.patch(self.registry[model], '_order', order)

    def test_00_search_order(self):
        # Create 6 partners with a given name, and a given creation order to
        # ensure the order of their ID. Some are set as inactive to verify they
        # are by default excluded from the searches and to provide a second
        # `order` argument.

        Partner = self.env['res.partner']
        c = Partner.create({'name': 'test_search_order_C'})
        d = Partner.create({'name': 'test_search_order_D', 'active': False})
        a = Partner.create({'name': 'test_search_order_A'})
        b = Partner.create({'name': 'test_search_order_B'})
        ab = Partner.create({'name': 'test_search_order_AB'})
        e = Partner.create({'name': 'test_search_order_E', 'active': False})

        # The tests.

        # The basic searches should exclude records that have active = False.
        # The order of the returned ids should be given by the `order`
        # parameter of search().

        name_asc = Partner.search([('name', 'like', 'test_search_order%')], order="name asc")
        self.assertEqual([a, ab, b, c], list(name_asc), "Search with 'NAME ASC' order failed.")
        name_desc = Partner.search([('name', 'like', 'test_search_order%')], order="name desc")
        self.assertEqual([c, b, ab, a], list(name_desc), "Search with 'NAME DESC' order failed.")
        id_asc = Partner.search([('name', 'like', 'test_search_order%')], order="id asc")
        self.assertEqual([c, a, b, ab], list(id_asc), "Search with 'ID ASC' order failed.")
        id_desc = Partner.search([('name', 'like', 'test_search_order%')], order="id desc")
        self.assertEqual([ab, b, a, c], list(id_desc), "Search with 'ID DESC' order failed.")

        # The inactive records shouldn't be excluded as soon as a condition on
        # that field is present in the domain. The `order` parameter of
        # search() should support any legal coma-separated values.

        active_asc_id_asc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="active asc, id asc")
        self.assertEqual([d, e, c, a, b, ab], list(active_asc_id_asc), "Search with 'ACTIVE ASC, ID ASC' order failed.")
        active_desc_id_asc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="active desc, id asc")
        self.assertEqual([c, a, b, ab, d, e], list(active_desc_id_asc), "Search with 'ACTIVE DESC, ID ASC' order failed.")
        active_asc_id_desc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="active asc, id desc")
        self.assertEqual([e, d, ab, b, a, c], list(active_asc_id_desc), "Search with 'ACTIVE ASC, ID DESC' order failed.")
        active_desc_id_desc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="active desc, id desc")
        self.assertEqual([ab, b, a, c, e, d], list(active_desc_id_desc), "Search with 'ACTIVE DESC, ID DESC' order failed.")
        id_asc_active_asc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="id asc, active asc")
        self.assertEqual([c, d, a, b, ab, e], list(id_asc_active_asc), "Search with 'ID ASC, ACTIVE ASC' order failed.")
        id_asc_active_desc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="id asc, active desc")
        self.assertEqual([c, d, a, b, ab, e], list(id_asc_active_desc), "Search with 'ID ASC, ACTIVE DESC' order failed.")
        id_desc_active_asc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="id desc, active asc")
        self.assertEqual([e, ab, b, a, d, c], list(id_desc_active_asc), "Search with 'ID DESC, ACTIVE ASC' order failed.")
        id_desc_active_desc = Partner.search([('name', 'like', 'test_search_order%'), '|', ('active', '=', True), ('active', '=', False)], order="id desc, active desc")
        self.assertEqual([e, ab, b, a, d, c], list(id_desc_active_desc), "Search with 'ID DESC, ACTIVE DESC' order failed.")

        a.ref = "ref1"
        c.ref = "ref2"
        ids = (a | b | c).ids
        for order, result in [
            ('ref', a | c | b),
            ('ref desc', b | c | a),
            ('ref asc nulls first', b | a | c),
            ('ref asc nulls last', a | c | b),
            ('ref desc nulls first', b | c | a),
            ('ref desc nulls last', c | a | b)
        ]:
            with self.subTest(order):
                self.assertEqual(
                    Partner.search([('id', 'in', ids)], order=order).mapped('name'),
                    result.mapped('name'))

        # sorting by an m2o should alias to the natural order of the m2o
        self.patch_order('res.country', 'phone_code')
        a.country_id, c.country_id = self.env['res.country'].create([{
            'name': "Country 1",
            'code': 'C1',
            'phone_code': '01',
        }, {
            'name': 'Country 2',
            'code': 'C2',
            'phone_code': '02'
        }])

        for order, result in [
            ('country_id', a | c | b),
            ('country_id desc', b | c | a),
            ('country_id asc nulls first', b | a | c),
            ('country_id asc nulls last', a | c | b),
            ('country_id desc nulls first', b | c | a),
            ('country_id desc nulls last', c | a | b)
        ]:
            with self.subTest(order):
                self.assertEqual(
                    Partner.search([('id', 'in', ids)], order=order).mapped('name'),
                    result.mapped('name'))

        # NULLS applies to the m2o itself, not its sub-fields, so a null `phone_code`
        # will sort normally (larger than non-null codes)
        b.country_id = self.env['res.country'].create({'name': "Country X", 'code': 'C3'})

        for order, result in [
            ('country_id', a | c | b),
            ('country_id desc', b | c | a),
            ('country_id asc nulls first', a | c | b),
            ('country_id asc nulls last', a | c | b),
            ('country_id desc nulls first', b | c | a),
            ('country_id desc nulls last', b | c | a)
        ]:
            with self.subTest(order):
                self.assertEqual(
                    Partner.search([('id', 'in', ids)], order=order).mapped('name'),
                    result.mapped('name'))

        # a field DESC should reverse the nested behaviour (and thus the inner
        # NULLS clauses), but the outer NULLS clause still has no effect
        self.patch_order('res.country', 'phone_code NULLS FIRST')
        for order, result in [
            ('country_id', b | a | c),
            ('country_id desc', c | a | b),
            ('country_id asc nulls first', b | a | c),
            ('country_id asc nulls last', b | a | c),
            ('country_id desc nulls first', c | a | b),
            ('country_id desc nulls last', c | a | b)
        ]:
            with self.subTest(order):
                self.assertEqual(
                    Partner.search([('id', 'in', ids)], order=order).mapped('name'),
                    result.mapped('name'))

    def test_10_inherits_m2order(self):
        Users = self.env['res.users']

        # Find Employee group
        group_employee = self.env.ref('base.group_user')

        # Get country/state data
        country_be = self.env.ref('base.be')
        country_us = self.env.ref('base.us')
        states_us = country_us.state_ids[:2]

        # Create test users
        u = Users.create({'name': '__search', 'login': '__search', 'groups_id': [Command.set([group_employee.id])]})
        a = Users.create({'name': '__test_A', 'login': '__test_A', 'country_id': country_be.id, 'state_id': country_be.id})
        b = Users.create({'name': '__test_B', 'login': '__a_test_B', 'country_id': country_us.id, 'state_id': states_us[1].id})
        c = Users.create({'name': '__test_B', 'login': '__z_test_B', 'country_id': country_us.id, 'state_id': states_us[0].id})

        # Search as search user
        Users = Users.with_user(u)

        # Do: search on res.users, order on a field on res.partner to try inherits'd fields, then res.users
        expected_ids = [u.id, a.id, c.id, b.id]
        user_ids = Users.search([('id', 'in', expected_ids)], order='name asc, login desc').ids
        self.assertEqual(user_ids, expected_ids, 'search on res_users did not provide expected ids or expected order')

        # Do: order on many2one and inherits'd fields
        expected_ids = [c.id, b.id, a.id, u.id]
        user_ids = Users.search([('id', 'in', expected_ids)], order='state_id asc, country_id desc, name asc, login desc').ids
        self.assertEqual(user_ids, expected_ids, 'search on res_users did not provide expected ids or expected order')

        # Do: order on many2one and inherits'd fields
        expected_ids = [u.id, b.id, c.id, a.id]
        user_ids = Users.search([('id', 'in', expected_ids)], order='country_id desc, state_id desc, name asc, login desc').ids
        self.assertEqual(user_ids, expected_ids, 'search on res_users did not provide expected ids or expected order')

        # Do: order on many2one, but not by specifying in order parameter of search, but by overriding _order of res_users
        self.patch_order('res.users', 'country_id desc, name asc, login desc')
        expected_ids = [u.id, c.id, b.id, a.id]
        user_ids = Users.search([('id', 'in', expected_ids)]).ids
        self.assertEqual(user_ids, expected_ids, 'search on res_users did not provide expected ids or expected order')

    def test_11_indirect_inherits_m2o_order(self):
        Cron = self.env['ir.cron']
        Users = self.env['res.users']

        user_ids = {}
        cron_ids = {}
        for u in 'BAC':
            user_ids[u] = Users.create({'name': u, 'login': u}).id
            cron_ids[u] = Cron.create({'name': u, 'model_id': self.env.ref('base.model_res_partner').id, 'user_id': user_ids[u]}).id

        ids = Cron.search([('id', 'in', list(cron_ids.values()))], order='user_id').ids
        expected_ids = [cron_ids[l] for l in 'ABC']
        self.assertEqual(ids, expected_ids)

    def test_12_m2o_order_loop_self(self):
        Cats = self.env['ir.module.category']
        cat_ids = {}
        def create(name, **kw):
            cat_ids[name] = Cats.create(dict(kw, name=name)).id

        self.patch_order('ir.module.category', 'parent_id desc, name')

        create('A')
        create('B', parent_id=cat_ids['A'])
        create('C', parent_id=cat_ids['A'])
        create('D')
        create('E', parent_id=cat_ids['D'])
        create('F', parent_id=cat_ids['D'])

        expected_ids = [cat_ids[x] for x in 'ADEFBC']
        found_ids = Cats.search([('id', 'in', list(cat_ids.values()))]).ids
        self.assertEqual(found_ids, expected_ids)

    def test_13_m2o_order_loop_multi(self):
        Users = self.env['res.users']

        # will sort by login desc of the creator, then by name
        self.patch_order('res.partner', 'create_uid, name')
        self.patch_order('res.users', 'partner_id, login desc')

        kw = dict(groups_id=[Command.set([self.ref('base.group_system'),
                                     self.ref('base.group_partner_manager')])])

        u1 = Users.create(dict(name='Q', login='m', **kw)).id
        u2 = Users.with_user(u1).create(dict(name='B', login='f', **kw)).id
        u3 = Users.create(dict(name='C', login='c', **kw)).id
        u4 = Users.with_user(u2).create(dict(name='D', login='z', **kw)).id

        expected_ids = [u2, u4, u3, u1]
        found_ids = Users.search([('id', 'in', expected_ids)]).ids
        self.assertEqual(found_ids, expected_ids)

    def test_20_x_active(self):
        """Check the behaviour of the x_active field."""
        # test that a custom field x_active filters like active
        # we take the model res.country as a test model as it is included in base and does
        # not have an active field
        model_country = self.env['res.country']
        self.assertNotIn('active', model_country._fields)  # just in case someone adds the active field in the model
        self.env['ir.model.fields'].create({
            'name': 'x_active',
            'model_id': self.env.ref('base.model_res_country').id,
            'ttype': 'boolean',
        })
        self.assertEqual('x_active', model_country._active_name)
        country_ussr = model_country.create({'name': 'USSR', 'x_active': False, 'code': 'ZV'})
        ussr_search = model_country.search([('name', '=', 'USSR')])
        self.assertFalse(ussr_search)
        ussr_search = model_country.with_context(active_test=False).search([('name', '=', 'USSR')])
        self.assertIn(country_ussr, ussr_search, "Search with active_test on a custom x_active field failed")
        ussr_search = model_country.search([('name', '=', 'USSR'), ('x_active', '=', False)])
        self.assertIn(country_ussr, ussr_search, "Search with active_test on a custom x_active field failed")
        # test that a custom field x_active on a model with the standard active
        # field does not interfere with the standard behaviour
        # use res.bank since it has an active field and is simple to use
        model_bank = self.env['res.bank']
        self.env['ir.model.fields'].create({
            'name': 'x_active',
            'model_id': self.env.ref('base.model_res_bank').id,
            'ttype': 'boolean',
        })
        self.assertEqual('active', model_bank._active_name)
        bank_credit_communal = model_bank.create({'name': 'Crédit Communal', 'x_active': False, 'active': True})
        cc_search = model_bank.search([('name', '=', 'Crédit Communal')])
        self.assertIn(bank_credit_communal, cc_search, "Search for active record with x_active set to False has failed")
        bank_credit_communal.write({
            'active': False,
            'x_active': True,
        })
        cc_search = model_bank.search([('name', '=', 'Crédit Communal')])
        self.assertNotIn(bank_credit_communal, cc_search, "Search for inactive record with x_active set to True has failed")

    def test_21_search_count(self):
        Partner = self.env['res.partner']
        count_partner_before = Partner.search_count([])
        partners = Partner.create([
            {'name': 'abc'},
            {'name': 'zer'},
            {'name': 'christope'},
            {'name': 'runbot'},
        ])
        self.assertEqual(len(partners) + count_partner_before, Partner.search_count([]))
        self.assertEqual(3, Partner.search_count([], limit=3))

    def test_22_large_domain(self):
        """ Ensure search and its unerlying SQL mechanism is able to handle large domains"""
        N = 9500
        domain = ['|'] * (N - 1) + [('login', '=', 'admin')] * N
        self.env['res.users'].search(domain)

```

  File: tests/test_split_table.py
  Content:
```
from odoo.tests.common import TransactionCase
from odoo.tools import file_open
from odoo.addons.base.models.ir_actions_report import _split_table
from lxml import etree

def cleanup_string(s):
    return ''.join(s.split())

class TestSplitTable(TransactionCase):
    def test_split_table(self):
        # NOTE: All the tests's xml are in split_table/ relative to this file
        CASES = (
            ("Table's len is equal to max_rows and should not be split", "simple", "simple", 3),
            ("Table's len is greater to max_rows and should not be split", "simple", "simple", 4),
            ("max_rows is 1 and every table should be split", "simple", "simple.split1", 1),
            ("max_row is 2 and the table should be split", "simple", "simple.split2", 2),
            ("Nested tables should be split", "nested", "nested.split2", 2),
            ("Nested tables at the start should be split", "first_nested", "first_nested.split2", 2),
            ("Attributes should be copied", "copy_attributes", "copy_attributes.split1", 1),
        )

        for description, actual, expected, max_rows in CASES:
            with self.subTest(description), \
                file_open(f"base/tests/split_table/{actual}.xml") as actual, \
                file_open(f"base/tests/split_table/{expected}.xml") as expected:

                tree = etree.fromstring(actual.read())
                _split_table(tree, max_rows)
                processed = etree.tostring(tree, encoding='unicode')
                self.assertEqual(cleanup_string(processed), cleanup_string(expected.read()))

```

  File: tests/test_sql.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import BaseCase
from odoo.tools import SQL


class TestSQL(BaseCase):

    def test_sql_empty(self):
        sql = SQL()
        self.assertEqual(sql.code, "")
        self.assertEqual(sql.params, [])

    def test_sql_bool(self):
        self.assertFalse(SQL())
        self.assertFalse(SQL(""))
        self.assertTrue(SQL("anything"))
        self.assertTrue(SQL("%s", 42))

    def test_sql_with_no_parameter(self):
        sql = SQL("SELECT id FROM table WHERE foo=bar")
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=bar")
        self.assertEqual(sql.params, [])

    def test_sql_with_literal_parameters(self):
        sql = SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 42, 'baz')
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(sql.params, [42, 'baz'])

    def test_sql_with_wrong_pattern(self):
        with self.assertRaises(TypeError):
            SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 42)

        with self.assertRaises(TypeError):
            SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 1, 2, 3)

        with self.assertRaises(TypeError):
            SQL("SELECT id FROM table WHERE foo=%s AND bar=%(two)s", 1, two=2)

        with self.assertRaises(KeyError):
            SQL("SELECT id FROM table WHERE foo=%(one)s AND bar=%(two)s", one=1, to=2)

    def test_sql_equality(self):
        sql1 = SQL("SELECT id FROM table WHERE foo=%s", 42)
        sql2 = SQL("SELECT id FROM table WHERE foo=%s", 42)
        self.assertEqual(sql1, sql2)

        sql1 = SQL("SELECT id FROM table WHERE foo=%s", 42)
        sql2 = SQL("SELECT id FROM table WHERE bar=%s", 42)
        self.assertNotEqual(sql1, sql2)

        sql1 = SQL("SELECT id FROM table WHERE foo=%s", 42)
        sql2 = SQL("SELECT id FROM table WHERE foo=%s", 421)
        self.assertNotEqual(sql1, sql2)

    def test_sql_idempotence(self):
        sql1 = SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 42, 'baz')
        sql2 = SQL(sql1)
        self.assertIs(sql1, sql2)

    def test_sql_unpacking(self):
        sql = SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 42, 'baz')
        string, params = sql
        self.assertEqual(string, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(params, [42, 'baz'])

    def test_sql_join(self):
        sql = SQL(" AND ").join([])
        self.assertEqual(sql.code, "")
        self.assertEqual(sql.params, [])
        self.assertEqual(sql, SQL(""))

        sql = SQL(" AND ").join([SQL("foo=%s", 1)])
        self.assertEqual(sql.code, "foo=%s")
        self.assertEqual(sql.params, [1])

        sql = SQL(" AND ").join([
            SQL("foo=%s", 1),
            SQL("bar=%s", 2),
            SQL("baz=%s", 3),
        ])
        self.assertEqual(sql.code, "foo=%s AND bar=%s AND baz=%s")
        self.assertEqual(sql.params, [1, 2, 3])

        sql = SQL(", ").join([1, 2, 3])
        self.assertEqual(sql.code, "%s, %s, %s")
        self.assertEqual(sql.params, [1, 2, 3])

    def test_sql_identifier(self):
        sql = SQL.identifier('foo')
        self.assertEqual(sql.code, '"foo"')
        self.assertEqual(sql.params, [])

        sql = SQL.identifier('foo', 'bar')
        self.assertEqual(sql.code, '"foo"."bar"')
        self.assertEqual(sql.params, [])

        with self.assertRaises(AssertionError):
            sql = SQL.identifier('foo"')

        with self.assertRaises(AssertionError):
            sql = SQL.identifier('(SELECT 42)')

        with self.assertRaises(AssertionError):
            sql = SQL.identifier('foo', 'ba"r')

    def test_sql_with_sql_parameters(self):
        sql = SQL("SELECT id FROM table WHERE foo=%s AND %s", 1, SQL("bar=%s", 2))
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 1, 2))

        sql = SQL("SELECT id FROM table WHERE %s AND bar=%s", SQL("foo=%s", 1), 2)
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 1, 2))

        sql = SQL("SELECT id FROM table WHERE %s AND %s", SQL("foo=%s", 1), SQL("bar=%s", 2))
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 1, 2))

    def test_sql_with_named_parameters(self):
        sql = SQL("SELECT id FROM table WHERE %(one)s AND bar=%(two)s", one=SQL("foo=%s", 1), two=2)
        self.assertEqual(sql.code, "SELECT id FROM table WHERE foo=%s AND bar=%s")
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL("SELECT id FROM table WHERE foo=%s AND bar=%s", 1, 2))

        # the parameters are bound locally
        sql = SQL(
            "%s AND %s",
            SQL("foo=%(value)s", value=1),
            SQL("bar=%(value)s", value=2),
        )
        self.assertEqual(sql.code, "foo=%s AND bar=%s")
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL("foo=%s AND bar=%s", 1, 2))

    def test_complex_sql(self):
        sql = SQL(
            "SELECT %s FROM %s WHERE %s",
            SQL.identifier('id'),
            SQL.identifier('table'),
            SQL(" AND ").join([
                SQL("%s=%s", SQL.identifier('table', 'foo'), 1),
                SQL("%s=%s", SQL.identifier('table', 'bar'), 2),
            ]),
        )
        self.assertEqual(sql.code, 'SELECT "id" FROM "table" WHERE "table"."foo"=%s AND "table"."bar"=%s')
        self.assertEqual(sql.params, [1, 2])
        self.assertEqual(sql, SQL('SELECT "id" FROM "table" WHERE "table"."foo"=%s AND "table"."bar"=%s', 1, 2))
        self.assertEqual(
            repr(sql),
            """SQL('SELECT "id" FROM "table" WHERE "table"."foo"=%s AND "table"."bar"=%s', 1, 2)"""
        )

```

  File: tests/test_test_retry.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from odoo.tests import BaseCase, tagged

import logging
import os

_logger = logging.getLogger(__name__)


class TestRetryCommon(BaseCase):
    def get_tests_run_count(self):
        return int(os.environ.get('ODOO_TEST_FAILURE_RETRIES', 0)) + 1

    def update_count(self):
        self.count = getattr(self, 'count', 0) + 1


@tagged('-standard', 'test_retry', 'test_retry_success')
class TestRetry(TestRetryCommon):
    """ Check some tests behaviour when ODOO_TEST_FAILURE_RETRIES is set"""

    def test_log_levels(self):
        _logger.debug('test debug')
        _logger.info('test info')
        _logger.runbot('test 25')

    def test_retry_success(self):
        tests_run_count = self.get_tests_run_count()
        self.update_count()
        if tests_run_count != self.count:
            _logger.error('Failure')
        self.assertEqual(tests_run_count, self.count)


@tagged('-standard', 'test_retry', 'test_retry_failures')
class TestRetryFailures(TestRetryCommon):
    def test_retry_failure_assert(self):
        self.assertFalse(1 == 1)

    def test_retry_failure_log(self):
        _logger.error('Failure')


@tagged('-standard', 'test_retry', 'test_retry_success')
class TestRetrySubtest(TestRetryCommon):

    def test_retry_subtest_success_one(self):
        tests_run_count = self.get_tests_run_count()
        self.update_count()
        for i in range(3):
            if i == 1:
                with self.subTest():
                    if tests_run_count != self.count:
                        _logger.error('Failure')
                    self.assertEqual(tests_run_count, self.count)

    def test_retry_subtest_success_all(self):
        tests_run_count = self.get_tests_run_count()
        self.update_count()
        for _ in range(3):
            with self.subTest():
                if tests_run_count != self.count:
                    _logger.error('Failure')
                self.assertEqual(tests_run_count, self.count)


@tagged('-standard', 'test_retry', 'test_retry_failures')
class TestRetrySubtestFailures(TestRetryCommon):

    def test_retry_subtest_failure_one(self):
        for i in range(3):
            if i == 1:
                with self.subTest():
                    _logger.error('Failure')
                    self.assertFalse(1 == 1)

    def test_retry_subtest_failure_all(self):
        for _ in range(3):
            with self.subTest():
                _logger.error('Failure')
                self.assertFalse(1 == 1)

```

  File: tests/test_test_suite.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import contextlib
import difflib
import logging
import re
import sys
from contextlib import contextmanager
from pathlib import PurePath
from unittest import SkipTest, skip
from unittest.mock import patch

from odoo.tests.case import TestCase
from odoo.tests.common import BaseCase, TransactionCase, users, warmup
from odoo.tests.result import OdooTestResult

_logger = logging.getLogger(__name__)

from odoo.tests import MetaCase


if sys.version_info >= (3, 8):
    # this is mainly to ensure that simple tests will continue to work even if BaseCase should be used
    # this only works if doClassCleanup is available on testCase because of the vendoring of suite.py.
    # this test will only work in python 3.8 +
    class TestTestSuite(TestCase, metaclass=MetaCase):

        def test_test_suite(self):
            """ Check that OdooSuite handles unittest.TestCase correctly. """


class TestRunnerLoggingCommon(TransactionCase):
    """
    The purpose of this class is to do some "metatesting": it actually checks
    that on error, the runner logged the error with the right file reference.
    This is mainly to avoid having errors in test/common.py or test/runner.py`.
    This kind of metatesting is tricky; in this case the logs are made outside
    of the test method, after the teardown actually.
    """

    def setUp(self):
        self.expected_logs = None
        self.expected_first_frame_methods = None
        return super().setUp()

    def _addError(self, result, test, exc_info):
        # We use this hook to catch the logged error. It is initially called
        # post tearDown, and logs the actual errors. Because of our hack
        # tests.common._ErrorCatcher, the errors are logged directly. This is
        # still useful to test errors raised from tests. We cannot assert what
        # was logged after the test inside the test, though. This method can be
        # temporary renamed to test the real failure.
        try:
            self.test_result = result
            # while we are here, let's check that the first frame of the stack
            # is always inside the test method

            if exc_info:
                tb = exc_info[2]
                self._check_first_frame(tb)

            # intercept all ir_logging. We cannot use log catchers or other
            # fancy stuff because makeRecord is too low level.
            log_records = []

            def makeRecord(logger, name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None):
                log_records.append({
                    'logger': logger, 'name': name, 'level': level, 'fn': fn, 'lno': lno,
                    'msg': msg % args, 'exc_info': exc_info, 'func': func, 'extra': extra, 'sinfo': sinfo,
                })

            def handle(logger, record):
                # disable error logging
                return

            fake_result = OdooTestResult()
            with patch('logging.Logger.makeRecord', makeRecord), patch('logging.Logger.handle', handle):
                super()._addError(fake_result, test, exc_info)

            self._check_log_records(log_records)

        except Exception as e:
            # we don't expect _feedErrorsToResult() to raise any exception, this
            # will make it more robust to future changes and eventual mistakes
            _logger.exception(e)

    def _check_first_frame(self, tb):
        """ Check that the first frame of the given traceback is the expected method name. """
        # the list expected_first_frame_methods allow to define a list of first
        # expected frame (useful for setup/teardown tests)
        if self.expected_first_frame_methods is None:
            expected_first_frame_method = self._testMethodName
        else:
            expected_first_frame_method = self.expected_first_frame_methods.pop(0)
        first_frame_method = tb.tb_frame.f_code.co_name
        if first_frame_method != expected_first_frame_method:
            self._log_error(f"Checking first tb frame: {first_frame_method} is not equal to {expected_first_frame_method}")

    def _check_log_records(self, log_records):
        """ Check that what was logged is what was expected. """
        for log_record in log_records:
            self._assert_log_equal(log_record, 'logger', _logger)
            self._assert_log_equal(log_record, 'name', 'odoo.addons.base.tests.test_test_suite')
            self._assert_log_equal(log_record, 'fn', __file__)
            self._assert_log_equal(log_record, 'func', self._testMethodName)

        if self.expected_logs is not None:
            for log_record in log_records:
                level, msg = self.expected_logs.pop(0)
                self._assert_log_equal(log_record, 'level', level)
                self._assert_log_equal(log_record, 'msg', msg)

    def _assert_log_equal(self, log_record, key, expected):
        """ Check the content of a log record. """
        value = log_record[key]
        if key == 'msg':
            value = self._clean_message(value)
        if value != expected:
            if key != 'msg':
                self._log_error(f"Key `{key}` => `{value}` is not equal to `{expected}` \n {log_record['msg']}")
            else:
                diff = '\n'.join(difflib.ndiff(expected.splitlines(), value.splitlines()))
                self._log_error(f"Key `{key}` did not matched expected:\n{diff}")

    def _log_error(self, message):
        """ Log an actual error (about a log in a test that doesn't match expectations) """
        # we would just log, but using the test_result will help keeping the tests counters correct
        self.test_result.addError(self, (AssertionError, AssertionError(message), None))

    def _clean_message(self, message):
        root_path = PurePath(__file__).parents[4]  # removes /odoo/addons/base/tests/test_test_suite.py
        python_path = PurePath(contextlib.__file__).parent  # /usr/lib/pythonx.x, C:\\python\\Lib, ...
        message = re.sub(r'line \d+', 'line $line', message)
        message = re.sub(r'py:\d+', 'py:$line', message)
        message = re.sub(r'decorator-gen-\d+', 'decorator-gen-xxx', message)
        message = message.replace(f'"{root_path}', '"/root_path/odoo')
        message = message.replace(f'"{python_path}', '"/usr/lib/python')
        message = message.replace('\\', '/')
        return message


class TestRunnerLogging(TestRunnerLoggingCommon):

    def test_has_add_error(self):
        self.assertTrue(hasattr(self, '_addError'))

    def test_raise(self):
        raise Exception('This is an error')

    def test_raise_subtest(self):
        """
        with subtest, we expect to have multiple errors, one per subtest
        """
        def make_message(message):
            return (
f'''ERROR: Subtest TestRunnerLogging.test_raise_subtest (<subtest>)
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_raise_subtest
    raise Exception('{message}')
Exception: {message}
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, make_message('This is an error')),
        ]
        with self.subTest():
            raise Exception('This is an error')

        self.assertFalse(self.expected_logs, "Error should have been logged immediatly")

        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, make_message('This is an error2')),
        ]

        with self.subTest():
            raise Exception('This is an error2')

        self.assertFalse(self.expected_logs, "Error should have been logged immediatly")

    @users('__system__')
    @warmup
    def test_with_decorators(self):
        # note, this test may be broken with a decorator in decorator=5.0.5 since the behaviour changed
        # but decoratorx was not introduced yet.
        message = (
'''ERROR: Subtest TestRunnerLogging.test_with_decorators (login='__system__')
Traceback (most recent call last):
  File "<decorator-gen-xxx>", line $line, in test_with_decorators
  File "/root_path/odoo/odoo/tests/common.py", line $line, in _users
    func(*args, **kwargs)
  File "<decorator-gen-xxx>", line $line, in test_with_decorators
  File "/root_path/odoo/odoo/tests/common.py", line $line, in warmup
    func(*args, **kwargs)
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_with_decorators
    raise Exception('This is an error')
Exception: This is an error
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]
        raise Exception('This is an error')

    def test_traverse_contextmanager(self):
        @contextmanager
        def assertSomething():
            yield
            raise Exception('This is an error')

        with assertSomething():
            pass

    def test_subtest_sub_call(self):
        def func():
            with self.subTest():
                raise Exception('This is an error')

        func()

    def test_call_stack(self):
        message = (
'''ERROR: TestRunnerLogging.test_call_stack
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_call_stack
    alpha()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    beta()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in beta
    gamma()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in gamma
    raise Exception('This is an error')
Exception: This is an error
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]

        def alpha():
            beta()

        def beta():
            gamma()

        def gamma():
            raise Exception('This is an error')

        alpha()

    def test_call_stack_context_manager(self):
        message = (
'''ERROR: TestRunnerLogging.test_call_stack_context_manager
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_call_stack_context_manager
    alpha()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    beta()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in beta
    gamma()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in gamma
    raise Exception('This is an error')
Exception: This is an error
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]

        def alpha():
            beta()

        def beta():
            with self.with_user('admin'):
                gamma()
                return 0

        def gamma():
            raise Exception('This is an error')

        alpha()

    def test_call_stack_subtest(self):
        message = (
'''ERROR: Subtest TestRunnerLogging.test_call_stack_subtest (<subtest>)
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_call_stack_subtest
    alpha()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    beta()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in beta
    gamma()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in gamma
    raise Exception('This is an error')
Exception: This is an error
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]

        def alpha():
            beta()

        def beta():
            with self.subTest():
                gamma()

        def gamma():
            raise Exception('This is an error')

        alpha()

    def test_assertQueryCount(self):
        message = (
'''FAIL: Subtest TestRunnerLogging.test_assertQueryCount (<subtest>)
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_assertQueryCount
    with self.assertQueryCount(system=0):
  File "/usr/lib/python/contextlib.py", line $line, in __exit__
    next(self.gen)
  File "/root_path/odoo/odoo/tests/common.py", line $line, in assertQueryCount
    self.fail(msg % (login, count, expected, funcname, filename, linenum))
AssertionError: Query count more than expected for user __system__: 1 > 0 in test_assertQueryCount at base/tests/test_test_suite.py:$line
''')
        if self._python_version < (3, 10, 0):
            message = message.replace("with self.assertQueryCount(system=0):", "self.env.cr.execute('SELECT 1')")

        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]
        with self.assertQueryCount(system=0):
            self.env.cr.execute('SELECT 1')

    @users('__system__')
    @warmup
    def test_assertQueryCount_with_decorators(self):
        with self.assertQueryCount(system=0):
            self.env.cr.execute('SELECT 1')

    def test_reraise(self):
        message = (
'''ERROR: TestRunnerLogging.test_reraise
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_reraise
    alpha()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    beta()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in beta
    raise Exception('This is an error')
Exception: This is an error
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]

        def alpha():
            # pylint: disable=try-except-raise
            try:
                beta()
            except Exception:
                raise

        def beta():
            raise Exception('This is an error')

        alpha()

    def test_handle_error(self):
        message = (
'''ERROR: TestRunnerLogging.test_handle_error
Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    beta()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in beta
    raise Exception('This is an error')
Exception: This is an error

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in test_handle_error
    alpha()
  File "/root_path/odoo/odoo/addons/base/tests/test_test_suite.py", line $line, in alpha
    raise Exception('This is an error2')
Exception: This is an error2
''')
        self.expected_logs = [
            (logging.INFO, '=' * 70),
            (logging.ERROR, message),
        ]

        def alpha():
            try:
                beta()
            except Exception:
                raise Exception('This is an error2')

        def beta():
            raise Exception('This is an error')

        alpha()


class TestRunnerLoggingSetup(TestRunnerLoggingCommon):

    def setUp(self):
        super().setUp()
        self.expected_first_frame_methods = [
            'setUp',
            'cleanupError2',
            'cleanupError',
        ]

        def cleanupError():
            raise Exception("This is a cleanup error")
        self.addCleanup(cleanupError)

        def cleanupError2():
            raise Exception("This is a second cleanup error")
        self.addCleanup(cleanupError2)

        raise Exception('This is a setup error')

    def test_raises_setup(self):
        _logger.error("This shouldn't be executed")

    def tearDown(self):
        _logger.error("This shouldn't be executed since setup failed")


class TestRunnerLoggingTeardown(TestRunnerLoggingCommon):
    def setUp(self):
        super().setUp()
        self.expected_first_frame_methods = [
            'test_raises_teardown',
            'test_raises_teardown',
            'test_raises_teardown',
            'tearDown',
            'cleanupError2',
            'cleanupError',
        ]

        def cleanupError():
            raise Exception("This is a cleanup error")
        self.addCleanup(cleanupError)

        def cleanupError2():
            raise Exception("This is a second cleanup error")
        self.addCleanup(cleanupError2)

    def tearDown(self):
        raise Exception('This is a tearDown error')

    def test_raises_teardown(self):
        with self.subTest():
            raise Exception('This is a subTest error')
        with self.subTest():
            raise Exception('This is a second subTest error')
        raise Exception('This is a test error')


class TestSubtests(BaseCase):

    def test_nested_subtests(self):
        with self.subTest(a=1, x=2):
            with self.subTest(b=3, x=4):
                self.assertEqual(self._subtest._subDescription(), '(b=3, x=4, a=1)')
            with self.subTest(b=5, x=6):
                self.assertEqual(self._subtest._subDescription(), '(b=5, x=6, a=1)')


class TestClassSetup(BaseCase):

    @classmethod
    def setUpClass(cls):
        raise SkipTest('Skip this class')

    def test_method(self):
        pass


class TestClassTeardown(BaseCase):

    @classmethod
    def tearDownClass(cls):
        raise SkipTest('Skip this class')

    def test_method(self):
        pass


class Test01ClassCleanups(BaseCase):
    """
    The purpose of this test combined with Test02ClassCleanupsCheck is to check that
    class cleanup work. class cleanup where introduced in python3.8 but tests should
    remain compatible with python 3.7
    """
    executed = False
    cleanup = False

    @classmethod
    def setUpClass(cls):
        cls.executed = True

        def doCleanup():
            cls.cleanup = True
        cls.addClassCleanup(doCleanup)

    def test_dummy(self):
        pass


class Test02ClassCleanupsCheck(BaseCase):
    def test_classcleanups(self):
        self.assertTrue(Test01ClassCleanups.executed, "This test only makes sence when executed after Test01ClassCleanups")
        self.assertTrue(Test01ClassCleanups.cleanup, "TestClassCleanup shoudl have been cleanuped")


@skip
class TestSkipClass(BaseCase):
    def test_classcleanups(self):
        raise Exception('This should be skipped')


class TestSkipMethof(BaseCase):
    @skip
    def test_skip_method(self):
        raise Exception('This should be skipped')

```

  File: tests/test_tests_tags.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase, tagged, BaseCase
from odoo.tests.tag_selector import TagsSelector


@tagged('nodatabase')
class TestSetTags(TransactionCase):

    def test_set_tags_empty(self):
        """Test the set_tags decorator with an empty set of tags"""

        @tagged()
        class FakeClass(TransactionCase):
            pass

        fc = FakeClass()

        self.assertTrue(hasattr(fc, 'test_tags'))
        self.assertEqual(fc.test_tags, {'at_install', 'standard'})
        self.assertEqual(fc.test_module, 'base')

    def test_set_tags_not_decorated(self):
        """Test that a TransactionCase has some test_tags by default"""

        class FakeClass(TransactionCase):
            pass

        fc = FakeClass()

        self.assertTrue(hasattr(fc, 'test_tags'))
        self.assertEqual(fc.test_tags, {'at_install', 'standard'})
        self.assertEqual(fc.test_module, 'base')

    def test_set_tags_single_tag(self):
        """Test the set_tags decorator with a single tag"""

        @tagged('slow')
        class FakeClass(TransactionCase):
            pass

        fc = FakeClass()

        self.assertEqual(fc.test_tags, {'at_install', 'standard', 'slow'})
        self.assertEqual(fc.test_module, 'base')

    def test_set_tags_multiple_tags(self):
        """Test the set_tags decorator with multiple tags"""

        @tagged('slow', 'nightly')
        class FakeClass(TransactionCase):
            pass

        fc = FakeClass()

        self.assertEqual(fc.test_tags, {'at_install', 'standard', 'slow', 'nightly'})
        self.assertEqual(fc.test_module, 'base')

    def test_inheritance(self):
        """Test inheritance when using the 'tagged' decorator"""

        @tagged('slow')
        class FakeClassA(TransactionCase):
            pass

        class FakeClassC(FakeClassA):
            pass

        fc = FakeClassC()
        self.assertEqual(fc.test_tags, {'at_install', 'standard', 'slow'})

        @tagged('-standard')
        class FakeClassD(FakeClassA):
            pass

        fc = FakeClassD()
        self.assertEqual(fc.test_tags, {'at_install', 'slow'})

    def test_untagging(self):
        """Test that one can remove the 'standard' tag"""

        @tagged('-standard')
        class FakeClassA(TransactionCase):
            pass

        fc = FakeClassA()
        self.assertEqual(fc.test_tags, {'at_install'})
        self.assertEqual(fc.test_module, 'base')

        @tagged('-standard', '-base', '-at_install', 'post_install')
        class FakeClassB(TransactionCase):
            pass

        fc = FakeClassB()
        self.assertEqual(fc.test_tags, {'post_install'})

        @tagged('-standard', '-base', 'fast')
        class FakeClassC(TransactionCase):
            pass

        fc = FakeClassC()
        self.assertEqual(fc.test_tags, {'fast', 'at_install'})

    def test_parental_advisory(self):
        """Explicit test tags on the class should override anything
        """
        @tagged('flow')
        class FakeClassA(TransactionCase):
            pass
        class FakeClassB(FakeClassA):
            test_tags = {'foo', 'bar'}

        self.assertEqual(FakeClassA().test_tags, {'standard', 'at_install', 'flow'})
        self.assertEqual(FakeClassB().test_tags, {'foo', 'bar'})

@tagged('nodatabase')
class TestSelector(TransactionCase):

    def test_selector_parser(self):
        """Test the parser part of the TagsSelector class"""

        tags = TagsSelector('+slow')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('+slow,nightly')
        self.assertEqual({('slow', None, None, None, None), ('nightly', None, None, None, None)}, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('+slow,-standard')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)

        # same with space after the comma
        tags = TagsSelector('+slow, -standard')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)

        # same with space before and after the comma
        tags = TagsSelector('+slow , -standard')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)

        tags = TagsSelector('+slow ,-standard,+js')
        self.assertEqual({('slow', None, None, None, None), ('js', None, None, None, None)}, tags.include)
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)

        # without +
        tags = TagsSelector('slow, ')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        # duplicates
        tags = TagsSelector('+slow,-standard, slow,-standard ')
        self.assertEqual({('slow', None, None, None, None), }, tags.include)
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)

        tags = TagsSelector('')
        self.assertEqual(set(), tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('/module')  # all standard test of a module
        self.assertEqual({('standard', 'module', None, None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('/module/tests/test_file.py')  # all standard test of a module
        self.assertEqual({('standard', None, None, None, 'module.tests.test_file'), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('*/module')  # all tests of a module
        self.assertEqual({(None, 'module', None, None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector(':class')  # all standard test of a class
        self.assertEqual({('standard', None, 'class', None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('.method')
        self.assertEqual({('standard', None, None, 'method', None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector(':class.method')
        self.assertEqual({('standard', None, 'class', 'method', None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('/module:class.method')  # only a specific test func in a module (standard)
        self.assertEqual({('standard', 'module', 'class', 'method', None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('*/module:class.method')  # only a specific test func in a module
        self.assertEqual({(None, 'module', 'class', 'method', None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('-/module:class.method')  # disable a specific test func in a module
        self.assertEqual({('standard', None, None, None, None), }, tags.include)  # all strandard
        self.assertEqual({(None, 'module', 'class', 'method', None), }, tags.exclude)  # exept the test func

        tags = TagsSelector('-*/module:class.method') 
        self.assertEqual({('standard', None, None, None, None), }, tags.include)
        self.assertEqual({(None, 'module', 'class', 'method', None), }, tags.exclude)

        tags = TagsSelector('tag/module')
        self.assertEqual({('tag', 'module', None, None, None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('tag.method')
        self.assertEqual({('tag', None, None, 'method', None), }, tags.include)
        self.assertEqual(set(), tags.exclude)

        tags = TagsSelector('*/module,-standard')  # all non standard test of a module
        self.assertEqual({(None, 'module', None, None, None), }, tags.include)  # all in module
        self.assertEqual({('standard', None, None, None, None), }, tags.exclude)  # exept standard ones


@tagged('nodatabase')
class TestSelectorSelection(TransactionCase):
    def test_selector_selection(self):
        """Test check_tags use cases"""
        class Test_A(TransactionCase):
            pass

        @tagged('stock')
        class Test_B(BaseCase):
            pass

        @tagged('stock', 'slow')
        class Test_C(BaseCase):
            pass

        @tagged('standard', 'slow')
        class Test_D(BaseCase):
            pass

        @tagged('-at_install', 'post_install')
        class Test_E(TransactionCase):
            pass

        no_tags_obj = Test_A()
        stock_tag_obj = Test_B()
        multiple_tags_obj = Test_C()
        multiple_tags_standard_obj = Test_D()
        post_install_obj = Test_E()

        # if 'standard' in not explicitly removed, tests without tags are
        # considered tagged standard and they are run by default if
        # not explicitly deselected with '-standard' or if 'standard' is not
        # selectected along with another test tag
        # same as "--test-tags=''" parameters:
        tags = TagsSelector('')
        self.assertFalse(tags.check(no_tags_obj))

        # same as "--test-tags '+slow'":
        tags = TagsSelector('+slow')
        self.assertFalse(tags.check(no_tags_obj))

        # same as "--test-tags '+slow,+fake'":
        tags = TagsSelector('+slow,fake')
        self.assertFalse(tags.check(no_tags_obj))

        # same as "--test-tags '+slow,+standard'":
        tags = TagsSelector('slow,standard')
        self.assertTrue(no_tags_obj)

        # same as "--test-tags '+slow,-standard'":
        tags = TagsSelector('slow,-standard')
        self.assertFalse(tags.check(no_tags_obj))

        # same as "--test-tags '-slow,-standard'":
        tags = TagsSelector('-slow,-standard')
        self.assertFalse(tags.check(no_tags_obj))

        # same as "--test-tags '-slow,+standard'":
        tags = TagsSelector('-slow,+standard')
        self.assertTrue(tags.check(no_tags_obj))

        tags = TagsSelector('')
        self.assertFalse(tags.check(stock_tag_obj))

        tags = TagsSelector('slow')
        self.assertFalse(tags.check(stock_tag_obj))

        tags = TagsSelector('standard')
        self.assertTrue(tags.check(stock_tag_obj))

        tags = TagsSelector('slow,standard')
        self.assertTrue(tags.check(stock_tag_obj))

        tags = TagsSelector('slow,-standard')
        self.assertFalse(tags.check(stock_tag_obj))

        tags = TagsSelector('+stock')
        self.assertTrue(tags.check(stock_tag_obj))

        tags = TagsSelector('stock,fake')
        self.assertTrue(tags.check(stock_tag_obj))

        tags = TagsSelector('stock,standard')
        self.assertTrue(tags.check(stock_tag_obj))

        tags = TagsSelector('-stock')
        self.assertFalse(tags.check(stock_tag_obj))

        tags = TagsSelector('')
        self.assertFalse(tags.check(multiple_tags_obj))

        tags = TagsSelector('-stock')
        self.assertFalse(tags.check(multiple_tags_obj))

        tags = TagsSelector('-slow')
        self.assertFalse(tags.check(multiple_tags_obj))

        tags = TagsSelector('slow')
        self.assertTrue(tags.check(multiple_tags_obj))

        tags = TagsSelector('slow,stock')
        self.assertTrue(tags.check(multiple_tags_obj))

        tags = TagsSelector('-slow,stock')
        self.assertFalse(tags.check(multiple_tags_obj))

        tags = TagsSelector('slow,stock,-slow')
        self.assertFalse(tags.check(multiple_tags_obj))

        tags = TagsSelector('')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('standard')
        self.assertTrue(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('slow')
        self.assertTrue(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('slow,fake')
        self.assertTrue(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('-slow')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('-standard')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('-slow,-standard')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('standard,-slow')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        tags = TagsSelector('slow,-standard')
        self.assertFalse(tags.check(multiple_tags_standard_obj))

        # Mimic the real post_install use case
        # That uses a second tags selector
        tags = TagsSelector('standard')
        position = TagsSelector('post_install')
        self.assertTrue(tags.check(post_install_obj) and position.check(post_install_obj))

```

  File: tests/test_transactions.py
  Content:
```
from odoo.tests.common import TransactionCase


class TestTransactionEnvs(TransactionCase):
    def test_transation_envs_weakrefs(self):
        transaction = self.env.transaction
        starting_envs = set(transaction.envs)
        base_x = self.env['base'].with_context(test_stuff=False)
        self.assertIn(base_x.env, transaction.envs)
        del base_x
        self.assertEqual(set(transaction.envs), starting_envs)

    def do_stuff_with_env(self):
        base_test = self.env['base'].with_context(test_stuff=False)
        base_test |= self.env['base'].with_context(test_stuff=1)
        base_test |= self.env['base'].with_context(test_stuff=2)
        return base_test

    def test_transation_envs_weakrefs_call(self):
        transaction = self.env.transaction
        starting_envs = set(transaction.envs)
        self.do_stuff_with_env()
        self.assertEqual(set(transaction.envs), starting_envs)

    def test_transation_envs_weakrefs_return(self):
        transaction = self.env.transaction
        starting_envs = set(transaction.envs)
        base_test = self.do_stuff_with_env()
        self.assertEqual(set(transaction.envs), starting_envs | {base_test.env})

    def test_transation_envs_ordered(self):
        transaction = self.env.transaction
        starting_envs = set(transaction.envs)
        # create environments in a certain order, not sorted on item
        items = [3, 8, 1, 5, 2, 7, 6, 9, 0, 4]
        envs = [self.env(context={'item': item}) for item in items]
        # check that those environments appear in order in transaction.envs
        env_items = [env.context['item'] for env in transaction.envs if env not in starting_envs]
        self.assertEqual(env_items, items)
        del envs
        self.assertEqual(set(transaction.envs), starting_envs)

```

  File: tests/test_translate.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
from hashlib import sha256
from unittest.mock import patch
import logging
import time

from psycopg2 import IntegrityError
from psycopg2.extras import Json
import io

from odoo.exceptions import UserError
from odoo.tools import sql
from odoo.tools.translate import quote, unquote, xml_translate, html_translate, TranslationImporter, TranslationModuleReader
from odoo.tests.common import TransactionCase, BaseCase, new_test_user, tagged

_stats_logger = logging.getLogger('odoo.tests.stats')

# a string with various unicode characters
SPECIAL_CHARACTERS = " ¥®°²Æçéðπ⁉€∇⓵▲☑♂♥✓➔『にㄅ㊀中한︸🌈🌍👌😀"


class TranslationToolsTestCase(BaseCase):
    def assertItemsEqual(self, a, b, msg=None):
        self.assertEqual(sorted(a), sorted(b), msg)

    def test_quote_unquote(self):

        def test_string(str):
            quoted = quote(str)
            #print "\n1:", repr(str)
            #print "2:", repr(quoted)
            unquoted = unquote("".join(quoted.split('"\n"')))
            #print "3:", repr(unquoted)
            self.assertEqual(str, unquoted)

        test_string("""test \nall kinds\n \n o\r
         \\\\ nope\n\n"
         """)

        # The ones with 1+ backslashes directly followed by
        # a newline or literal N can fail... we would need a
        # state-machine parser to handle these, but this would
        # be much slower so it's better to avoid them at the moment
        self.assertRaises(AssertionError, quote, """test \nall kinds\n\no\r
         \\\\nope\n\n"
         """)

    def test_translate_xml_base(self):
        """ Test xml_translate() without formatting elements. """
        terms = []
        source = """<form string="Form stuff">
                        <h1>Blah blah blah</h1>
                        Put some more text here
                        <field name="foo"/>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Form stuff', 'Blah blah blah', 'Put some more text here'])

    def test_translate_xml_text(self):
        """ Test xml_translate() on plain text. """
        terms = []
        source = "Blah blah blah"
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms, [source])

    def test_translate_xml_unicode(self):
        """ Test xml_translate() on plain text with unicode characters. """
        terms = []
        source = u"Un heureux évènement"
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms, [source])

    def test_translate_xml_text_entity(self):
        """ Test xml_translate() on plain text with HTML escaped entities. """
        terms = []
        source = "Blah&amp;nbsp;blah&amp;nbsp;blah"
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms, [source])

    def test_translate_xml_inline1(self):
        """ Test xml_translate() with formatting elements. """
        terms = []
        source = """<form string="Form stuff">
                        <h1>Blah <i>blah</i> blah</h1>
                        Put some <b>more text</b> here
                        <field name="foo"/>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Form stuff', 'Blah <i>blah</i> blah', 'Put some <b>more text</b> here'])

    def test_translate_xml_inline2(self):
        """ Test xml_translate() with formatting elements embedding other elements. """
        terms = []
        source = """<form string="Form stuff">
                        <b><h1>Blah <i>blah</i> blah</h1></b>
                        Put <em>some <b>more text</b></em> here
                        <field name="foo"/>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Form stuff', 'Blah <i>blah</i> blah', 'Put <em>some <b>more text</b></em> here'])

    def test_translate_xml_inline3(self):
        """ Test xml_translate() with formatting elements without actual text. """
        terms = []
        source = """<form string="Form stuff">
                        <div>
                            <span class="before"/>
                            <h1>Blah blah blah</h1>
                            <span class="after">
                                <i class="hack"/>
                            </span>
                        </div>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Form stuff', 'Blah blah blah'])

    def test_translate_xml_inline4(self):
        """ Test xml_translate() with inline elements with translated attrs only. """
        terms = []
        source = """<form string="Form stuff">
                        <div>
                            <label for="stuff"/>
                            <span class="fa fa-globe" title="Title stuff"/>
                        </div>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Form stuff', '<span class="fa fa-globe" title="Title stuff"/>'])

    def test_translate_xml_inline5(self):
        """ Test xml_translate() with inline elements with empty translated attrs only. """
        terms = []
        source = """<form string="Form stuff">
                        <div>
                            <label for="stuff"/>
                            <span class="fa fa-globe" title=""/>
                        </div>
                    </form>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms, ['Form stuff'])

    def test_translate_xml_t(self):
        """ Test xml_translate() with t-* attributes. """
        terms = []
        source = """<t t-name="stuff">
                        stuff before
                        <span t-field="o.name"/>
                        stuff after
                    </t>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['stuff before', 'stuff after'])

    def test_translate_xml_off(self):
        """ Test xml_translate() with attribute translate="off". """
        terms = []
        source = """<div>
                        stuff before
                        <div t-translation="off">Do not translate this</div>
                        stuff after
                    </div>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['stuff before', 'stuff after'])

    def test_translate_xml_attribute(self):
        """ Test xml_translate() with <attribute> elements. """
        terms = []
        source = """<field name="foo" position="attributes">
                        <attribute name="string">Translate this</attribute>
                        <attribute name="option">Do not translate this</attribute>
                    </field>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['Translate this'])

    def test_translate_xml_a(self):
        """ Test xml_translate() with <a> elements. """
        terms = []
        source = """<t t-name="stuff">
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a class="nav-link oe_menu_leaf" href="/web#menu_id=42&amp;action=54">
                                    <span class="oe_menu_text">Blah</span>
                                </a>
                            </li>
                        </ul>
                    </t>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms,
            ['<span class="oe_menu_text">Blah</span>'])

    def test_translate_xml_with_namespace(self):
        """ Test xml_translate() on elements with namespaces. """
        terms = []
        # do not slit the long line below, otherwise the result will not match
        source = """<Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2">
                        <cbc:UBLVersionID t-esc="version_id"/>
                        <t t-foreach="[1, 2, 3, 4]" t-as="value">
                            Oasis <cac:Test t-esc="value"/>
                        </t>
                    </Invoice>"""
        result = xml_translate(terms.append, source)
        self.assertEqual(result, source)
        self.assertItemsEqual(terms, ['Oasis'])
        result = xml_translate(lambda term: term, source)
        self.assertEqual(result, source)

    def test_translate_xml_invalid_translations(self):
        """ Test xml_translate() with invalid translations. """
        source = """<form string="Form stuff">
                        <h1>Blah <i>blah</i> blah</h1>
                        Put some <b>more text</b> here
                        <field name="foo"/>
                    </form>"""
        translations = {
            "Put some <b>more text</b> here": "Mettre <b>plus de texte</i> ici",
        }
        expect = """<form string="Form stuff">
                        <h1>Blah <i>blah</i> blah</h1>
                        Mettre <b>plus de texte ici
                        </b><field name="foo"/>
                    </form>"""
        result = xml_translate(translations.get, source)
        self.assertEqual(result, expect)

    def test_translate_xml_illegal_translations(self):
        # attributes
        make_xml = '<form string="{}">test</form>'.format
        attr = 'Damien Roberts" <d.roberts@example.com>'
        escaped_attr = 'Damien Roberts&quot; &lt;d.roberts@example.com&gt;'

        # {legal: legal(not escaped attr)}
        self.assertEqual(
            xml_translate({'X': attr}.get, make_xml('X')),
            make_xml(escaped_attr),
            'attr should be translated and escaped',
        )

        # {legal(not escaped attr): legal}
        self.assertEqual(
            xml_translate({attr: 'X'}.get, make_xml(escaped_attr)),
            make_xml('X'),
            'attrs should be translated by using unescaped old terms',
        )

        # {illegal(escaped attr): legal}
        self.assertEqual(
            xml_translate({escaped_attr: 'X'}.get, make_xml(escaped_attr)),
            make_xml(escaped_attr),
            'attrs cannot be translated by using escaped old terms',
        )

        # text and elements
        make_xml = '<form string="X">{}</form>'.format
        term = '<i class="fa fa-circle" role="img" aria-label="Invalid" title="Invalid"/>'

        # {legal: legal}
        valid = '<i class="fa fa-circle" role="img" aria-label="Non-valide" title="Non-valide"/>X'
        self.assertEqual(
            xml_translate({term: valid}.get, make_xml(term)),
            make_xml(valid),
            'content in inline-block should be treated as one term and translated',
        )

        # {legal: illegal(has no text)}
        invalid = '<i class="fa fa-circle" role="img"/>'
        self.assertEqual(
            xml_translate({term: invalid}.get, make_xml(term)),
            make_xml(term),
            f'translation {invalid!r} has no text and should be dropped as a translation',
        )
        invalid = '  '
        self.assertEqual(
            xml_translate({term: invalid}.get, make_xml(term)),
            make_xml(term),
            f'translation {invalid!r} has no text and should be dropped as a translation',
        )
        invalid = '<i> </i>'
        self.assertEqual(
            xml_translate({term: invalid}.get, make_xml(term)),
            make_xml(term),
            f'translation {invalid!r} has no text and should be dropped as a translation',
        )

        # {legal: illegal(has non-translatable elements)}
        invalid = '<div>X</div>'
        self.assertEqual(
            xml_translate({term: invalid}.get, make_xml(term)),
            make_xml(term),
            f'translation {invalid!r} has non-translatable elements(elements not in TRANSLATED_ELEMENTS)',
        )

    def test_translate_html(self):
        """ Test html_translate(). """
        source = """<blockquote>A <h2>B</h2> C</blockquote>"""
        result = html_translate(lambda term: term, source)
        self.assertEqual(result, source)

    def test_translate_html_nbsp(self):
        """ Test html_translate(). """
        source = """<blockquote>A&nbsp;<h2>B&#160</h2>\xa0C</blockquote>"""
        result = html_translate(lambda term: term, source)
        self.assertEqual(result, '<blockquote>A&nbsp;<h2>B&nbsp;</h2>&nbsp;C</blockquote>')

    def test_translate_html_i(self):
        """ Test xml_translate() and html_translate() with <i> elements. """
        source = """<p>A <i class="fa-check"></i> B</p>"""
        result = xml_translate(lambda term: term, source)
        self.assertEqual(result, """<p>A <i class="fa-check"/> B</p>""")
        result = html_translate(lambda term: term, source)
        self.assertEqual(result, source)


class TestLanguageInstall(TransactionCase):
    def test_language_install(self):
        fr = self.env['res.lang'].with_context(active_test=False).search([('code', '=', 'fr_FR')])
        self.assertTrue(fr)
        wizard = self.env['base.language.install'].create({'lang_ids': fr.ids})
        self.env.flush_all()

        # running the wizard calls _load_module_terms() to load PO files
        loaded = []

        def _load_module_terms(self, modules, langs, overwrite=False):
            loaded.append((modules, langs, overwrite))

        with patch('odoo.addons.base.models.ir_module.Module._load_module_terms', _load_module_terms):
            wizard.lang_install()

        # _load_module_terms is called once with lang='fr_FR' and overwrite=True
        self.assertEqual(len(loaded), 1)
        self.assertEqual(loaded[0][1], ['fr_FR'])
        self.assertEqual(loaded[0][2], True)


@tagged('post_install', '-at_install')
class TestTranslationExport(TransactionCase):

    def test_export_translatable_resources(self):
        """Read files of installed modules and export translatable terms"""
        with self.assertNoLogs('odoo.tools.translate', "ERROR"):
            TranslationModuleReader(self.env.cr)


class TestTranslation(TransactionCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.env['res.lang']._activate_lang('fr_FR')
        cls.env.ref('base.module_base')._update_translations(['fr_FR'])
        cls.customers = cls.env['res.partner.category'].create({'name': 'Customers'})

        cls.customers_xml_id = cls.customers.export_data(['id']).get('datas')[0][0]
        po_string = '''
        #. module: __export__
        #: model:res.partner.category,name:%s
        msgid "Customers"
        msgstr "Clients"
        ''' % cls.customers_xml_id
        with io.BytesIO(bytes(po_string, encoding='utf-8')) as f:
            f.name = 'dummy'
            translation_importer = TranslationImporter(cls.env.cr, verbose=True)
            translation_importer.load(f, 'po', 'fr_FR')
            translation_importer.save(overwrite=True)

    def test_101_create_translated_record(self):
        category = self.customers.with_context({})
        self.assertEqual(category.name, 'Customers', "Error in basic name")

        category_fr = category.with_context({'lang': 'fr_FR'})
        self.assertEqual(category_fr.name, 'Clients', "Translation not found")

    def test_102_duplicate_record(self):
        category = self.customers.with_context({'lang': 'fr_FR'}).copy()

        category_no = category.with_context({})
        self.assertEqual(category_no.name, 'Customers', "Duplication should copy all translations")

        category_fr = category.with_context({'lang': 'fr_FR'})
        self.assertEqual(category_fr.name, 'Clients', "Did not found translation for initial value")

    def test_103_duplicate_record_fr(self):
        category = self.customers.with_context({'lang': 'fr_FR'}).copy({'name': 'Clients (copie)'})

        category_no = category.with_context({})
        self.assertEqual(category_no.name, 'Clients (copie)', "Duplication should set untranslated value")

        category_fr = category.with_context({'lang': 'fr_FR'})
        self.assertEqual(category_fr.name, 'Clients (copie)', "Did not used default value for translated value")

    def test_104_orderby_translated_field(self):
        """ Test search ordered by a translated field. """
        # create a category with a French translation
        padawans = self.env['res.partner.category'].create({'name': 'Padawans'})
        padawans_fr = padawans.with_context(lang='fr_FR')
        padawans_fr.write({'name': 'Apprentis'})
        # search for categories, and sort them by (translated) name
        categories = padawans_fr.search([('id', 'in', [self.customers.id, padawans.id])], order='name')
        self.assertEqual(categories.ids, [padawans.id, self.customers.id],
            "Search ordered by translated name should return Padawans (Apprentis) before Customers (Clients)")

    def test_105_duplicate_record_multi_no_en(self):
        self.env['res.partner'].with_context(active_test=False).search([]).write({'lang': 'fr_FR'})
        self.env['res.lang']._activate_lang('nl_NL')
        self.customers.with_context(lang='nl_NL').name = 'Klanten'
        self.env['res.lang']._activate_lang('zh_CN')
        self.customers.with_context(lang='zh_CN').name = '客户'
        self.env.ref('base.lang_en').active = False
        self.env.ref('base.lang_zh_CN').active = False

        category = self.customers
        translations = category._fields['name']._get_stored_translations(category)
        self.assertDictEqual(
            translations,
            {
                'en_US': 'Customers',
                'fr_FR': 'Clients',
                'nl_NL': 'Klanten',
                'zh_CN': '客户',
            }
        )

        category_copy = self.customers.with_context(lang='fr_FR').copy()
        translations = category_copy._fields['name']._get_stored_translations(category_copy)

        self.assertDictEqual(
            translations,
            {
                'en_US': 'Customers',
                'fr_FR': 'Clients',
                'nl_NL': 'Klanten',
            },
            'English, French and Dutch translation should be copied, Chinese translation should be dropped'
        )

    def test_107_duplicate_record_en(self):
        category = self.customers.with_context({'lang': 'en_US'}).copy()

        category_no = category.with_context({})
        self.assertEqual(category_no.name, 'Customers', "Duplication did not set untranslated value")

        category_fr = category.with_context({'lang': 'fr_FR'})
        self.assertEqual(category_fr.name, 'Clients', "Did not found translation for initial value")

    def test_108_search_en(self):
        CategoryEn = self.env['res.partner.category'].with_context(lang='en_US')
        category_equal = CategoryEn.search([('name', '=', 'Customers')])
        self.assertEqual(category_equal.id, self.customers.id, "Search with '=' doesn't work for English")
        category_ilike = CategoryEn.search([('name', 'ilike', 'stoMer')])
        self.assertIn(self.customers, category_ilike, "Search with 'ilike' doesn't work for English")
        category_eq_ilike = CategoryEn.search([('name', '=ilike', 'CustoMers')])
        self.assertIn(self.customers, category_eq_ilike, "Search with '=ilike' doesn't work for English")
        category_in = CategoryEn.search([('name', 'in', ['Customers'])])
        self.assertIn(self.customers, category_in, "Search with 'in' doesn't work for English")

    def test_109_search_fr(self):
        CategoryFr = self.env['res.partner.category'].with_context(lang='fr_FR')
        category_equal = CategoryFr.search([('name', '=', 'Clients')])
        self.assertEqual(category_equal.id, self.customers.id, "Search with '=' doesn't work for non English")
        category_ilike = CategoryFr.search([('name', 'ilike', 'lIen')])
        self.assertIn(self.customers, category_ilike, "Search with 'ilike' doesn't work for non English")
        category_eq_ilike = CategoryFr.search([('name', '=ilike', 'clieNts')])
        self.assertIn(self.customers, category_eq_ilike, "Search with '=ilike' doesn't work for non English")
        category_in = CategoryFr.search([('name', 'in', ['Clients'])])
        self.assertIn(self.customers, category_in, "Search with 'in' doesn't work for non English")

    def test_110_search_es(self):
        self.env['res.lang']._activate_lang('es_ES')
        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('en_US', 'English (US)'), ('fr_FR', 'French / Français'), ('es_ES', 'Spanish / Español')],
                         langs, "Test did not start with the expected languages")
        CategoryEs = self.env['res.partner.category'].with_context(lang='es_ES')
        category_equal = CategoryEs.search([('name', '=', 'Customers')])
        self.assertEqual(category_equal.id, self.customers.id, "Search with '=' should use the English name if the current language translation is not available")
        category_ilike = CategoryEs.search([('name', 'ilike', 'usTom')])
        self.assertIn(self.customers, category_ilike, "Search with 'ilike' should use the English name if the current language translation is not available")
        category_eq_ilike = CategoryEs.search([('name', '=ilike', 'CustoMers')])
        self.assertIn(self.customers, category_eq_ilike, "Search with '=ilike' should use the English name if the current language translation is not available")
        category_in = CategoryEs.search([('name', 'in', ['Customers'])])
        self.assertIn(self.customers, category_in, "Search with 'in' should use the English name if the current language translation is not available")

    def test_111_prefetch_langs(self):
        category_en = self.customers.with_context(lang='en_US')

        self.env.ref('base.lang_nl').active = True
        category_nl = category_en.with_context(lang='nl_NL')
        category_nl.name = 'Klanten'

        self.assertTrue(self.env.ref('base.lang_fr').active)
        category_fr = category_en.with_context(lang='fr_FR')

        self.assertFalse(self.env.ref('base.lang_zh_CN').active)
        category_zh = category_en.with_context(lang='zh_CN')

        self.env['res.partner'].with_context(active_test=False).search([]).write({'lang': 'fr_FR'})
        self.env.ref('base.lang_en').active = False

        category_fr.with_context(prefetch_langs=True).name
        category_nl.name
        category_en.name
        category_zh.name
        category_fr.invalidate_recordset()

        with self.assertQueryCount(1):
            self.assertEqual(category_fr.with_context(prefetch_langs=True).name, 'Clients')

        with self.assertQueryCount(0):
            self.assertEqual(category_nl.name, 'Klanten')
            self.assertEqual(category_en.name, 'Customers')
            self.assertEqual(category_zh.name, 'Customers')


    # TODO Currently, the unique constraint doesn't work for translatable field
    # def test_111_unique_en(self):
    #     Country = self.env['res.country']
    #     country_1 = Country.create({'name': 'Odoo'})
    #     country_1.with_context(lang='fr_FR').name = 'Odoo_Fr'
    #     country_1.flush_recordset()
    #
    #     country_2 = Country.create({'name': 'Odoo2'})
    #     with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
    #         country_2.name = 'Odoo'
    #         country_2.flush_recordset()
    #
    #     with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
    #         country_3 = Country.create({'name': 'Odoo'})

class TestTranslationWrite(TransactionCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.category = cls.env['res.partner.category'].create({'name': 'Reblochon'})
        cls.category_xml_id = cls.category.export_data(['id']).get('datas')[0][0]

    def test_00(self):
        self.env['res.lang']._activate_lang('fr_FR')

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('en_US', 'English (US)'), ('fr_FR', 'French / Français')], langs,
                         "Test did not started with expected languages")

        category = self.env['res.partner.category'].with_context(lang='en_US').create({'name': 'English'})
        self.assertEqual(category.with_context(lang='en_US').name, 'English')
        self.assertEqual(category.with_context(lang='fr_FR').name, 'English')

        category.with_context(lang='en_US').name = 'English 2'
        self.assertEqual(category.with_context(lang='fr_FR').name, 'English 2')

        category2 = self.env['res.partner.category'].with_context(lang='fr_FR').create({'name': 'French'})
        self.assertEqual(category2.with_context(lang='en_US').name, 'French')
        self.assertEqual(category2.with_context(lang='fr_FR').name, 'French')

        category2.with_context(lang='en_US').name = 'English'
        self.assertEqual(category2.with_context(lang='fr_FR').name, 'French')

        category3 = self.env['res.partner.category'].with_context(lang='en_US').create({'name': 'English'})
        self.assertEqual(category3.with_context(lang='en_US').name, 'English')
        self.assertEqual(category3.with_context(lang='fr_FR').name, 'English')

        category3.with_context(lang='fr_FR').name = 'French 2'
        category3.with_context(lang='en_US').name = 'English 2'
        self.assertEqual(category3.with_context(lang='fr_FR').name, 'French 2')

    def test_03_fr_single(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.partner'].with_context(active_test=False).search([]).write({'lang': 'fr_FR'})
        self.env.ref('base.lang_en').active = False

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('fr_FR', 'French / Français')], langs, "Test did not started with expected languages")

        self.category.with_context(lang='fr_FR').write({'name': 'French Name'})

        fr_name = self.category.with_context(lang='fr_FR').read(['name'])
        self.assertEqual(fr_name[0]['name'], "French Name", "Reference field not updated")

        # read from the cache
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")

        # read from database
        self.category.invalidate_recordset()
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")

    def test_04_fr_multi(self):
        self.env['res.lang']._activate_lang('fr_FR')

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('en_US', 'English (US)'), ('fr_FR', 'French / Français')], langs,
            "Test did not started with expected languages")

        po_string = '''
        #. module: __export__
        #: model:res.partner.category,name:%s
        msgid "Reblochon"
        msgstr "Translated Name"
        ''' % self.category_xml_id
        with io.BytesIO(bytes(po_string, encoding='utf-8')) as f:
            f.name = 'dummy'
            translation_importer = TranslationImporter(self.env.cr, verbose=True)
            translation_importer.load(f, 'po', 'fr_FR')
            translation_importer.save(overwrite=True)

        self.category.with_context(lang='fr_FR').write({'name': 'French Name'})
        self.category.with_context(lang='en_US').write({'name': 'English Name'})

        # read from the cache first
        self.assertEqual(self.category.with_context(lang=None).name, "English Name")
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")
        self.assertEqual(self.category.with_context(lang='en_US').name, "English Name")

        # force save to database and clear the cache: force a clean state
        self.category.invalidate_recordset()

        # read from database
        self.assertEqual(self.category.with_context(lang=None).name, "English Name")
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")
        self.assertEqual(self.category.with_context(lang='en_US').name, "English Name")

    def test_04_fr_multi_no_en(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.lang']._activate_lang('es_ES')
        self.env['res.partner'].with_context(active_test=False).search([]).write({'lang': 'fr_FR'})
        self.env.ref('base.lang_en').active = False

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('fr_FR', 'French / Français'), ('es_ES', 'Spanish / Español')], langs,
                         "Test did not start with the expected languages")

        self.category.with_context(lang='fr_FR').write({'name': 'French Name'})
        self.category.with_context(lang='es_ES').write({'name': 'Spanish Name'})
        self.category.with_context(lang=None).write({'name': 'None Name'})

        # read from the cache first
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")
        self.assertEqual(self.category.with_context(lang='es_ES').name, "Spanish Name")
        self.assertEqual(self.category.with_context(lang=None).name, "None Name")

        # force save to database and clear the cache: force a clean state
        self.category.invalidate_recordset()

        # read from database
        self.assertEqual(self.category.with_context(lang='fr_FR').name, "French Name")
        self.assertEqual(self.category.with_context(lang='es_ES').name, "Spanish Name")
        self.assertEqual(self.category.with_context(lang=None).name, "None Name")

    def test_05_remove_multi_false(self):
        self._test_05_remove_multi(False)

    def _test_05_remove_multi(self, empty_value):
        self.env['res.lang']._activate_lang('fr_FR')

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('en_US', 'English (US)'), ('fr_FR', 'French / Français')], langs,
            "Test did not started with expected languages")

        belgium = self.env.ref('base.be')
        # vat_label is translatable and not required
        belgium.with_context(lang='en_US').write({'vat_label': 'VAT'})
        belgium.with_context(lang='fr_FR').write({'vat_label': 'TVA'})

        # remove the value
        belgium.with_context(lang='fr_FR').write({'vat_label': empty_value})
        # should recover the initial value from db
        self.assertEqual(
            empty_value,
            belgium.with_context(lang='fr_FR').vat_label,
            "Value should be the empty_value"
        )
        self.assertEqual(
            empty_value,
            belgium.with_context(lang='en_US').vat_label,
            "Value should be the empty_value"
        )
        self.assertEqual(
            empty_value,
            belgium.with_context(lang=None).vat_label,
            "Value should be the empty_value"
        )

        belgium.with_context(lang='en_US').write({'vat_label': 'VAT'})
        belgium.with_context(lang='fr_FR').write({'vat_label': 'TVA'})

        # remove the value
        belgium.with_context(lang='en_US').write({'vat_label': empty_value})
        self.assertEqual(
            empty_value,
            belgium.with_context(lang='fr_FR').vat_label,
            "Value should be the empty_value"
        )
        self.assertEqual(
            empty_value,
            belgium.with_context(lang='en_US').vat_label,
            "Value should be the empty_value"
        )
        self.assertEqual(
            empty_value,
            belgium.with_context(lang=None).vat_label,
            "Value should be the empty_value"
        )

    def test_write_empty_and_value(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.lang']._activate_lang('nl_NL')

        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('nl_NL', 'Dutch / Nederlands'), ('en_US', 'English (US)'), ('fr_FR', 'French / Français')], langs,
                         "Test did not started with expected languages")

        belgium = self.env.ref('base.be')
        # vat_label is translatable and not required
        belgium.with_context(lang='en_US').write({'vat_label': 'VAT_US'})
        belgium.with_context(lang='fr_FR').write({'vat_label': 'VAT_FR'})
        belgium.with_context(lang='nl_NL').write({'vat_label': 'VAT_NL'})

        belgium.invalidate_recordset()

        belgium.with_context(lang='en_US').write({'vat_label': False})
        belgium.with_context(lang='fr_FR').write({'vat_label': 'TVA_FR2'})
        self.assertEqual(belgium.with_context(lang='en_US').vat_label, 'TVA_FR2')
        self.assertEqual(belgium.with_context(lang='nl_NL').vat_label, 'TVA_FR2')

        belgium.with_context(lang='fr_FR').write({'vat_label': 'TVA_FR3'})
        belgium.with_context(lang='en_US').write({'vat_label': ''})
        self.assertEqual(belgium.with_context(lang='en_US').vat_label, '')
        self.assertEqual(belgium.with_context(lang='nl_NL').vat_label, '')

    def test_create_empty_false(self):
        self._test_create_empty(False)

    # feature removed
    # def test_cresate_emtpy_empty_string(self):
    #     self._test_create_empty('')

    def _test_create_empty(self, empty_value):
        self.env['res.lang']._activate_lang('fr_FR')
        langs = self.env['res.lang'].get_installed()
        self.assertEqual([('en_US', 'English (US)'), ('fr_FR', 'French / Français')], langs,
                         "Test did not started with expected languages")

        group = self.env['res.groups'].create({'name': 'test_group', 'comment': empty_value})
        self.assertEqual(group.with_context(lang='en_US').comment, empty_value)
        self.assertEqual(group.with_context(lang='fr_FR').comment, empty_value)

        group.with_context(lang='fr_FR').comment = 'French comment'
        self.assertEqual(group.with_context(lang='fr_FR').comment, 'French comment')
        self.assertEqual(group.with_context(lang='en_US').comment, 'French comment')

        group.with_context(lang='fr_FR').comment = 'French comment 2'
        self.assertEqual(group.with_context(lang='fr_FR').comment, 'French comment 2')
        self.assertEqual(group.with_context(lang='en_US').comment, 'French comment')

    def test_update_field_translations(self):
        self.env['res.lang']._activate_lang('fr_FR')
        categoryEN = self.category.with_context(lang='en_US')
        categoryFR = self.category.with_context(lang='fr_FR')

        self.category.update_field_translations('name', {'en_US': 'English Name', 'fr_FR': 'French Name'})
        self.assertEqual(categoryEN.name, 'English Name')
        self.assertEqual(categoryFR.name, 'French Name')

        # void fr_FR translation and fallback to en_US
        self.category.update_field_translations('name', {'fr_FR': False})
        self.assertEqual(categoryEN.name, 'English Name')
        self.assertEqual(categoryFR.name, 'English Name')

        categoryEN.name = 'English Name 2'
        self.assertEqual(categoryEN.name, 'English Name 2')
        self.assertEqual(categoryFR.name, 'English Name 2')

        # cannot void en_US
        self.category.update_field_translations('name', {'en_US': 'English Name', 'fr_FR': 'French Name'})
        self.category.update_field_translations('name', {'en_US': False})
        self.assertEqual(categoryEN.name, 'English Name')
        self.assertEqual(categoryFR.name, 'French Name')

        # empty str is a valid translation
        self.category.update_field_translations('name', {'fr_FR': ''})
        self.assertEqual(categoryEN.name, 'English Name')
        self.assertEqual(categoryFR.name, '')

        self.category.update_field_translations('name', {'en_US': '', 'fr_FR': 'French Name'})
        self.assertEqual(categoryEN.name, '')
        self.assertEqual(categoryFR.name, 'French Name')

        # raise error when the translations are in the form for model_terms translated fields
        with self.assertRaises(UserError):
            self.category.update_field_translations('name', {'fr_FR': {'English Name': 'French Name'}})

    def test_update_field_translations_for_empty(self):
        self.env['res.lang']._activate_lang('nl_NL')
        self.env['res.lang']._activate_lang('fr_FR')
        group = self.env['res.groups'].create({'name': 'test_group', 'comment': False})

        groupEN = group.with_context(lang='en_US')
        groupFR = group.with_context(lang='fr_FR')
        groupNL = group.with_context(lang='nl_NL')
        self.assertEqual(groupEN.comment, False)
        groupFR.update_field_translations('comment', {'nl_NL': 'Dutch Name', 'fr_FR': 'French Name'})
        self.assertEqual(groupEN.comment, 'French Name', 'fr_FR value as the current env.lang is chosen as the default en_US value')
        self.assertEqual(groupFR.comment, 'French Name')
        self.assertEqual(groupNL.comment, 'Dutch Name')

        group.comment = False
        groupFR.update_field_translations('comment', {'nl_NL': False, 'fr_FR': False})
        groupFR.flush_recordset()
        self.cr.execute("SELECT comment FROM res_groups WHERE id = %s", (group.id,))
        (comment,) = self.cr.fetchone()
        self.assertEqual(comment, None)

    def test_field_selection(self):
        """ Test translations of field selections. """
        self.env['res.lang']._activate_lang('fr_FR')
        field = self.env['ir.model']._fields['state']
        self.assertEqual([key for key, _ in field.selection], ['manual', 'base'])

        ir_field = self.env['ir.model.fields']._get('ir.model', 'state')
        ir_field = ir_field.with_context(lang='fr_FR')
        ir_field.selection_ids[0].name = 'Custo'
        ir_field.selection_ids[1].name = 'Pas touche!'

        fg = self.env['ir.model'].fields_get(['state'])
        self.assertEqual(fg['state']['selection'], field.selection)

        fg = self.env['ir.model'].with_context(lang='fr_FR').fields_get(['state'])
        self.assertEqual(fg['state']['selection'],
                         [('manual', 'Custo'), ('base', 'Pas touche!')])

    def test_load_views(self):
        """ Test translations of field descriptions in get_view(). """
        self.env['res.lang']._activate_lang('fr_FR')

        # add translation for the string of field ir.model.name
        ir_model_field = self.env['ir.model.fields']._get('ir.model', 'name')
        LABEL = "Description du Modèle"

        ir_model_field_xml_id = ir_model_field.export_data(['id']).get('datas')[0][0]
        po_string = '''
        #. module: __export__
        #: model:ir.model.fields,field_description:%s
        msgid "Model Description"
        msgstr "%s"
        ''' % (ir_model_field_xml_id, LABEL)
        with io.BytesIO(bytes(po_string, encoding='utf-8')) as f:
            f.name = 'dummy'
            translation_importer = TranslationImporter(self.env.cr, verbose=True)
            translation_importer.load(f, 'po', 'fr_FR')
            translation_importer.save(overwrite=True)

        # check that fields_get() returns the expected label
        model = self.env['ir.model'].with_context(lang='fr_FR')
        info = model.fields_get(['name'])
        self.assertEqual(info['name']['string'], LABEL)

        # check that get_views() also returns the expected label
        info = model.get_views([(False, 'form')])
        self.assertEqual(info['models'][model._name]['name']['string'], LABEL)


class TestXMLTranslation(TransactionCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.env['res.lang']._activate_lang('fr_FR')
        cls.env['res.lang']._activate_lang('nl_NL')
        cls.env.ref('base.module_base')._update_translations(['fr_FR', 'nl_NL'])

    def create_view(self, archf, terms, **kwargs):
        view = self.env['ir.ui.view'].create({
            'name': 'test',
            'model': 'res.partner',
            'arch': archf % terms,
        })
        view.invalidate_recordset()

        val = {'en_US': archf % terms}
        for lang, trans_terms in kwargs.items():
            val[lang] = archf % trans_terms
        query = """UPDATE ir_ui_view
                      SET arch_db = %s
                    WHERE id = %s"""
        self.env.cr.execute(query, (Json(val), view.id))
        return view

    def test_copy(self):
        """ Create a simple view, fill in translations, and copy it. """
        archf = '<form string="%s"><div>%s</div><div>%s</div></form>'
        terms_en = ('Knife', 'Fork', 'Spoon')
        terms_fr = ('Couteau', 'Fourchette', 'Cuiller')
        view0 = self.create_view(archf, terms_en, fr_FR=terms_fr)

        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})

        # check translated field
        self.assertEqual(view0.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view0.with_env(env_fr).arch_db, archf % terms_fr)

        # copy without lang
        view1 = view0.with_env(env_en).copy({})
        self.assertEqual(view1.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view1.with_env(env_fr).arch_db, archf % terms_fr)

        # copy with lang='fr_FR'
        view2 = view0.with_env(env_fr).copy({})
        self.assertEqual(view2.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view2.with_env(env_fr).arch_db, archf % terms_fr)

        # copy with lang='fr_FR' and translate=html_translate
        self.patch(type(self.env['ir.ui.view']).arch_db, 'translate', html_translate)
        view3 = view0.with_env(env_fr).copy({})
        self.assertEqual(view3.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view3.with_env(env_fr).arch_db, archf % terms_fr)

    def test_spaces(self):
        """ Create translations where value has surrounding spaces. """
        archf = '<form string="%s"><div>%s</div><div>%s</div></form>'
        terms_en = ('Knife', 'Fork', 'Spoon')
        terms_fr = (' Couteau', 'Fourchette ', ' Cuiller ')
        self.create_view(archf, terms_en, fr_FR=terms_fr)

    def test_sync(self):
        """ Check translations after minor change in source terms. """
        archf = '<form string="X">%s</form>'
        terms_en = ('Bread and cheeze',)
        terms_fr = ('Pain et fromage',)
        terms_nl = ('Brood and kaas',)
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify source term in view (fixed type in 'cheeze')
        terms_en = ('Bread and cheese',)
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether translations have been synchronized
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        view = self.create_view(archf, terms_fr, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)
        # modify source term in view in another language with close term
        new_terms_fr = ('Pains et fromage',)
        view.with_env(env_fr).write({'arch_db': archf % new_terms_fr})

        # check whether translations have been synchronized
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % new_terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

    def test_sync_xml(self):
        """ Check translations of 'arch' after xml tags changes in source terms. """
        archf = '<form string="X">%s<div>%s</div></form>'
        terms_en = ('Bread and cheese', 'Fork')
        terms_fr = ('Pain et fromage', 'Fourchette')
        terms_nl = ('Brood and kaas', 'Vork')
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify source term in view (add css style)
        terms_en = ('Bread <span style="font-weight:bold">and</span> cheese', 'Fork')
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether translations have been kept
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify source term in view (actual text change)
        terms_en = ('Bread <span style="font-weight:bold">and</span> butter', 'Fork')
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether translations have been reset
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % (terms_en[0], terms_fr[1]))
        self.assertEqual(view.with_env(env_nl).arch_db, archf % (terms_en[0], terms_nl[1]))

    def test_sync_xml_no_en(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.lang']._activate_lang('nl_NL')

        archf = '<form string="X">%s<div>%s</div></form>'
        terms_en = ('Bread and cheese', 'Fork')
        terms_fr = ('Pain et fromage', 'Fourchetta')
        terms_nl = ('Brood and kaas', 'Vork')
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        self.env['res.partner'].with_context(active_test=False).search([]).write({'lang': 'fr_FR'})
        self.env.ref('base.lang_en').active = False

        env_nolang = self.env(context={})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        # style change and typo change
        terms_fr = ('Pain <span style="font-weight:bold">et</span> fromage', 'Fourchette')
        view.with_env(env_fr).write({'arch_db': archf % terms_fr})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

    def test_sync_text_to_xml(self):
        """ Check translations of 'arch' after xml tags changes in source terms. """
        archf = '<form string="X">%s</form>'
        terms_en = ('<span>Hi</span>',)
        terms_fr = ('<span>Salut</span>',)
        terms_nl = ('<span>Hallo</span>',)
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})

        # modify the arch view, keep the same text content: 'Hi'
        terms_en = 'Hi'
        archf = '<form string="X"><setting string="%s"><span color="red"/></setting></form>'
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        # check that we didn't set string="&lt;span&gt;Salut&lt;/span&gt;"
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_en)

    def test_sync_xml_collision(self):
        """ Check translations of 'arch' after xml tags changes in source terms
            when the same term appears in different elements with different
            styles.
        """
        archf = '''<form class="row">
    %s
    <div class="s_table_of_content_vertical_navbar" data-name="Navbar" contenteditable="false">
        <div class="s_table_of_content_navbar" style="top: 76px;"><a href="#table_of_content_heading_1672668075678_4" class="table_of_content_link">%s</a></div>
    </div>
    <div class="s_table_of_content_main" data-name="Content">
        <section class="pb16">
            <h1 data-anchor="true" class="o_default_snippet_text" id="table_of_content_heading_1672668075678_4">%s</h1>
        </section>
    </div>
</form>'''
        terms_en = ('Bread and cheese', 'Knive and Fork', 'Knive <span style="font-weight:bold">and</span> Fork')
        terms_fr = ('Pain et fromage', 'Couteau et Fourchette', 'Couteau et Fourchette')
        terms_nl = ('Brood and kaas', 'Mes en Vork', 'Mes en Vork')
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify source term in view (small change)
        terms_en = ('Bread and cheese', 'Knife and Fork', 'Knife <span style="font-weight:bold">and</span> Fork')
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether translations have been kept
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify source term in view (actual text change)
        terms_en = ('Bread and cheese', 'Fork and Knife', 'Fork <span style="font-weight:bold">and</span> Knife')
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether translations have been reset
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % (terms_fr[0], terms_en[1], terms_en[2]))
        self.assertEqual(view.with_env(env_nl).arch_db, archf % (terms_nl[0], terms_en[1], terms_en[2]))

    def test_sync_xml_inline_modifiers(self):
        """ Check translations of 'arch' after xml tags changes in source terms
            when source term had updated modifiers attributes
        """
        archf = '''<form class="row">
    %s
    <div class="s_table_of_content_vertical_navbar" data-name="Navbar" contenteditable="false">
        <div class="s_table_of_content_navbar" style="top: 76px;"><a href="#table_of_content_heading_1672668075678_4" class="table_of_content_link">%s</a></div>
    </div>
    <div class="s_table_of_content_main" data-name="Content">
        <section class="pb16">
            <h1 data-anchor="true" class="o_default_snippet_text" id="table_of_content_heading_1672668075678_4">%s</h1>
        </section>
    </div>
</form>'''
        terms_en = ('Bread and cheese', 'Knive and Fork', 'Knive <span style="font-weight:bold">and</span> Fork')
        terms_fr = ('Pain et fromage', 'Couteau et Fourchette', 'Couteau <span style="font-weight:bold">et</span> Fourchette')
        terms_nl = ('Brood and kaas', 'Mes en Vork', 'Mes en Vork')
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={"install_mode": True})
        env_en = self.env(context={'lang': 'en_US', "install_mode": True})
        env_fr = self.env(context={'lang': 'fr_FR', "install_mode": True})
        env_nl = self.env(context={'lang': 'nl_NL', "install_mode": True})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify attributes in source term
        terms_en = ('Bread and cheese', 'Knife and Fork', 'Knife <span invisible="1">and</span> Fork')
        view.with_env(env_en).write({'arch_db': archf % terms_en})
        terms_fr = ('Pain et fromage', 'Couteau et Fourchette', 'Couteau <span style="font-weight:bold" invisible="1">et</span> Fourchette')

        # check whether translations have been kept
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

        # modify attributes in source term
        terms_en = ('Bread and cheese', 'Knife and Fork', 'Knife <span readonly="1">and</span> Fork')
        view.with_env(env_en).write({'arch_db': archf % terms_en})
        terms_fr = ('Pain et fromage', 'Couteau et Fourchette', 'Couteau <span style="font-weight:bold" readonly="1">et</span> Fourchette')

        # check whether translations have been kept
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch_db, archf % terms_nl)

    def test_sync_xml_close_terms(self):
        """ Check translations of 'arch' after xml tags changes in source terms. """
        archf = '<form string="X">%s<div>%s</div>%s</form>'
        terms_en = ('RandomRandom1', 'RandomRandom2', 'RandomRandom3')
        terms_fr = ('RandomRandom1', 'AléatoireAléatoire2', 'AléatoireAléatoire3')
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})

        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % terms_fr)

        # modify source term in view
        terms_en = ('RandomRandom1', 'SomethingElse', 'RandomRandom3')
        view.with_env(env_en).write({'arch_db': archf % terms_en})

        # check whether close terms have correct translations
        self.assertEqual(view.with_env(env_nolang).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch_db, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch_db, archf % ('RandomRandom1', 'SomethingElse', 'AléatoireAléatoire3'))

    def test_cache_consistency(self):
        view = self.env["ir.ui.view"].create({
            "name": "test_translate_xml_cache_invalidation",
            "model": "res.partner",
            "arch": "<form><b>content</b></form>",
        })
        view_fr = view.with_context({"lang": "fr_FR"})
        self.assertIn("<b>", view.arch_db)
        self.assertIn("<b>", view_fr.arch_db)

        # write with no lang, and check consistency in other languages
        view.write({"arch_db": "<form><i>content</i></form>"})
        self.assertIn("<i>", view.arch_db)
        self.assertIn("<i>", view_fr.arch_db)

    def test_update_field_translations(self):
        archf = '<form string="X">%s<div>%s</div></form>'
        terms_en = ('Bread and cheese', 'Fork')
        terms_fr = ('Pain et fromage', 'Fourchette')
        terms_nl = ('Brood and kaas', 'Vork')
        view = self.create_view(archf, terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        # cache arch_db
        view.arch_db
        view.with_context(lang='en_US').arch_db
        view.with_context(lang='fr_FR').arch_db
        view_nl = view.with_context(lang='nl_NL').arch_db

        view.update_field_translations('arch_db', {
            'en_US': {'Fork': 'Fork2'},
            'fr_FR': {'Fourchette': 'Fourchette2'}
        })

        self.assertEqual(view.arch_db, '<form string="X">Bread and cheese<div>Fork2</div></form>')
        self.assertEqual(view.with_context(lang='en_US').arch_db, '<form string="X">Bread and cheese<div>Fork2</div></form>')
        self.assertEqual(view.with_context(lang='fr_FR').arch_db, '<form string="X">Pain et fromage<div>Fourchette2</div></form>')
        self.assertEqual(view.with_context(lang='nl_NL').arch_db, view_nl)

        view.invalidate_recordset()
        self.assertEqual(view.arch_db, '<form string="X">Bread and cheese<div>Fork2</div></form>')
        self.assertEqual(view.with_context(lang='en_US').arch_db, '<form string="X">Bread and cheese<div>Fork2</div></form>')
        self.assertEqual(view.with_context(lang='fr_FR').arch_db, '<form string="X">Pain et fromage<div>Fourchette2</div></form>')
        self.assertEqual(view.with_context(lang='nl_NL').arch_db, view_nl)

        # update translations for fallback values and en_US
        self.env['res.lang']._activate_lang('es_ES')
        self.assertEqual(view.with_context(lang='es_ES').arch_db, '<form string="X">Bread and cheese<div>Fork2</div></form>')
        view.update_field_translations('arch_db', {
            'en_US': {'Fork2': 'Fork3'},
            'es_ES': {'Fork2': 'Tenedor3'}
        })
        self.assertEqual(view.with_context(lang='en_US').arch_db, '<form string="X">Bread and cheese<div>Fork3</div></form>')
        self.assertEqual(view.with_context(lang='es_ES').arch_db, '<form string="X">Bread and cheese<div>Tenedor3</div></form>')

    def test_delay_translations(self):
        archf = '<form string="%s"><div>%s</div><div>%s</div></form>'
        terms_en = ('Knife', 'Fork', 'Spoon')
        terms_fr = ('Couteau', 'Fourchette', 'Cuiller')
        view0 = self.create_view(archf, terms_en, fr_FR=terms_fr)

        archf2 = '<form string="%s"><p>%s</p><div>%s</div></form>'
        terms_en2 = ('new Knife', 'Fork', 'Spoon')
        # write en_US with delay_translations
        view0.with_context(lang='en_US', delay_translations=True).arch_db = archf2 % terms_en2
        view0.invalidate_recordset()

        self.assertEqual(
            view0.with_context(lang='en_US').arch_db,
            archf2 % terms_en2,
            'en_US value should be the latest one since it is updated directly'
        )
        self.assertEqual(view0.with_context(lang='en_US', check_translations=True).arch_db, archf2 % terms_en2)

        self.assertEqual(
            view0.with_context(lang='fr_FR').arch_db,
            archf % terms_fr,
            "fr_FR value should keep the same since its translations hasn't been confirmed"
        )
        self.assertEqual(
            view0.with_context(lang='fr_FR', edit_translations=True).arch_db,
            '<form string="'
                '&lt;span '
                     'class=&quot;o_delay_translation&quot; '
                     'data-oe-model=&quot;ir.ui.view&quot; '
                    f'data-oe-id=&quot;{view0.id}&quot; '
                     'data-oe-field=&quot;arch_db&quot; '
                     'data-oe-translation-state=&quot;to_translate&quot; '
                    f'data-oe-translation-initial-sha=&quot;{sha256(terms_en2[0].encode()).hexdigest()}&quot;'
                '&gt;'
                    f'{terms_en2[0]}'
                '&lt;/span&gt;"'
            '>'
                '<p>'
                    '<span '
                         'class="o_delay_translation" '
                         'data-oe-model="ir.ui.view" '
                        f'data-oe-id="{view0.id}" '
                         'data-oe-field="arch_db" '
                         'data-oe-translation-state="translated" '
                        f'data-oe-translation-initial-sha="{sha256(terms_fr[1].encode()).hexdigest()}"'
                    '>'
                        f'{terms_fr[1]}'
                    '</span>'
                '</p>'
                '<div>'
                    '<span '
                         'class="o_delay_translation" '
                         'data-oe-model="ir.ui.view" '
                        f'data-oe-id="{view0.id}" '
                         'data-oe-field="arch_db" '
                         'data-oe-translation-state="translated" '
                        f'data-oe-translation-initial-sha="{sha256(terms_fr[2].encode()).hexdigest()}"'
                    '>'
                        f'{terms_fr[2]}'
                    '</span>'
                '</div>'
            '</form>'
        )
        self.assertEqual(
            view0.with_context(lang='fr_FR', check_translations=True).arch_db,
            archf2 % (terms_en2[0], terms_fr[1], terms_fr[2])
        )

        self.assertEqual(
            view0.with_context(lang='nl_NL').arch_db,
            archf2 % terms_en2,
            "nl_NL value should fallback to en_US value"
        )
        self.assertEqual(
            view0.with_context(lang='nl_NL', check_translations=True).arch_db,
            archf2 % terms_en2
        )

        # update and confirm translations
        view0.update_field_translations('arch_db', {'fr_FR': {}})
        self.assertEqual(
            view0.with_context(lang='fr_FR').arch_db,
            archf2 % (terms_en2[0], terms_fr[1], terms_fr[2])
        )
        self.assertEqual(
            view0.with_context(lang='fr_FR', check_translations=True).arch_db,
            archf2 % (terms_en2[0], terms_fr[1], terms_fr[2])
        )

    def test_delay_translations_no_term(self):
        archf = '<form string="%s"><div>%s</div><div>%s</div></form>'
        terms_en = ('Knife', 'Fork', 'Spoon')
        terms_fr = ('Couteau', 'Fourchette', 'Cuiller')
        view0 = self.create_view(archf, terms_en, fr_FR=terms_fr)

        archf2 = '<form/>'
        # delay_translations only works when the written value has at least one translatable term
        view0.with_context(lang='en_US', delay_translations=True).arch_db = archf2
        for lang in ('en_US', 'fr_FR', 'nl_NL'):
            self.assertEqual(
                view0.with_context(lang=lang).arch_db,
                archf2,
                f'arch_db for {lang} should be {archf2}'
            )
            self.assertEqual(
                view0.with_context(lang=lang, check_translations=True).arch_db,
                archf2,
                f'arch_db for {lang} should be {archf2} when check_translations'
            )


class TestHTMLTranslation(TransactionCase):
    def test_write_non_existing(self):
        html = '''
<h1>My First Heading</h1>
<p>My first paragraph.</p>
'''
        company = self.env['res.company'].browse(9999)
        company.report_footer = html
        self.assertHTMLEqual(company.report_footer, html)
        # flushing on non-existing records does not break for scalar fields; the
        # same behavior is expected for translated fields
        company.flush_recordset()

    def test_delay_translations_no_term(self):
        self.env['res.lang']._activate_lang('fr_FR')
        self.env['res.lang']._activate_lang('nl_NL')
        Company = self.env['res.company']
        company0 = Company.create({'name': 'company_1', 'report_footer': '<h1>Knife</h1>'})
        company0.update_field_translations('report_footer', {'fr_FR': {'Knife': 'Couteau'}})

        for html in ('<h1></h1>', '', False):
            # delay_translations only works when the written value has at least one translatable term
            company0.with_context(lang='en_US', delay_translations=True).report_footer = html
            for lang in ('en_US', 'fr_FR', 'nl_NL'):
                self.assertEqual(
                    company0.with_context(lang=lang).report_footer,
                    html,
                    f'report_footer for {lang} should be {html}'
                )
                self.assertEqual(
                    company0.with_context(lang=lang, check_translations=True).report_footer,
                    html,
                    f'report_footer for {lang} should be {html} when check_translations'
                )


@tagged('post_install', '-at_install')
class TestLanguageInstallPerformance(TransactionCase):
    def test_language_install(self):
        """ Install a language on a complete database. """
        fr_BE = self.env.ref('base.lang_fr_BE')
        self.assertFalse(fr_BE.active)

        t0 = time.time()
        fr_BE.toggle_active()
        t1 = time.time()
        _stats_logger.info("installed language fr_BE in %.3fs", t1 - t0)


class TestTranslationTrigramIndexPatterns(BaseCase):
    def test_value_conversion(self):
        sc = SPECIAL_CHARACTERS
        cases = [
            # pylint: disable=bad-whitespace
            ( 'abc',    '%abc%',      'simple text is not escaped correctly'),
            ( 'a"bc',  r'%a\\"bc%',   '" is not escaped correctly'),
            (r'a\bc',  r'%a\\\\bc%', r'\ is not escaped correctly'),
            ( 'a\nbc', r'%a\\nbc%',  r'\n is not escaped correctly'),
            ( 'a_bc',  r'%a\_bc%',    '_ is not escaped correctly'),
            ( 'a%bc',  r'%a\%bc%',    '% is not escaped correctly'),
            ( 'a_',     '%',          'values with less than 3 characters should be dropped'),
            ( sc,      f'%{sc}%',     'special characters should not be escaped'),
        ]
        for value, expected, message in cases:
            self.assertEqual(sql.value_to_translated_trigram_pattern(value), expected, message)

    def test_pattern_conversion(self):
        sc = SPECIAL_CHARACTERS
        cases = [
            # pylint: disable=bad-whitespace
            ( 'abc',      '%abc%',      'simple pattern is not escaped correctly'),
            ( 'a"bc',    r'%a\\"bc%',   '" is not escaped correctly'),
            (r'a\\bc',   r'%a\\\\bc%', r'\ is not escaped correctly'),
            ( 'a\nbc',   r'%a\\nbc%',  r'\n is not escaped correctly'),
            (r'a\_bc',   r'%a\_bc%',   r"\_ shouldn't be escaped"),
            (r'a\%bc',   r'%a\%bc%',   r"\% shouldn't be escaped"),
            ( 'abc_def',  '%abc%def%',  'wildcard character _ should be changed to %'),
            ( 'abc%def',  '%abc%def%',  "wildcard character % shouldn't be escaped"),
            (r'a\bc',     '%abc%',     r'redundant \ for pattern should be removed'),
            ( 'abc_de',   '%abc%',      'sub patterns less than 3 characters should be dropped'),
            ( 'ab',       '%',          'patterns without trigram should be simplified'),
            ( sc,        f'%{sc}%',     'special characters should not be escaped'),
        ]
        for original_pattern, escaped_pattern, message in cases:
            self.assertEqual(sql.pattern_to_translated_trigram_pattern(original_pattern), escaped_pattern, message)

```

  File: tests/test_tz.py
  Content:
```
import datetime
import logging
import pytz
from unittest.mock import patch

from odoo.tests.common import TransactionCase
from odoo.tools._monkeypatches_pytz import _tz_mapping

_logger = logging.getLogger(__name__)


class TestTZ(TransactionCase):

    def test_tz_legacy(self):
        d = datetime.datetime(1969, 7, 16)
        # See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        def assertTZEqual(tz1, tz2):
            self.assertEqual(tz1.localize(d).strftime('%z'), tz2.localize(d).strftime('%z'))

            # in some version of tzdata the timezones are not symlink, as an example in 2023c-0ubuntu0.20.04.1
            # this as a side effect to have sligh difference in timezones seconds, breaking the following assertions
            # in some cases:
            #
            # self.assertEqual(tz1._utcoffset, tz2._utcoffset)
            # if hasattr(tz2, '_transition_info'):
            #     self.assertEqual(tz1._transition_info, tz2._transition_info)
            #
            # the first one is more robust

        for source, target in _tz_mapping.items():
            with self.subTest(source=source, target=target):
                if source == 'Pacific/Enderbury':  # this one was wrong in some version of tzdata
                    continue
                try:
                    target_tz = pytz.timezone(target)
                except pytz.UnknownTimeZoneError:
                    _logger.info("Skipping test for %s -> %s, target does not exist", source, target)
                    continue
                assertTZEqual(pytz.timezone(source), target_tz)

    def test_dont_adapt_available_tz(self):
        with patch.dict(_tz_mapping, {
            'DeprecatedUtc': 'UTC',
            'America/New_York': 'UTC',
        }):
            self.assertNotIn('DeprecatedUtc', pytz.all_timezones_set, 'DeprecatedUtc is not available')
            self.assertEqual(pytz.timezone('DeprecatedUtc'), pytz.timezone('UTC'), 'DeprecatedUtc does not exist and should have been replaced with UTC')
            self.assertIn('America/New_York', pytz.all_timezones_set, 'America/New_York is available')
            self.assertNotEqual(pytz.timezone('America/New_York'), pytz.timezone('UTC'), 'America/New_York exists and should not have been replaced with UTC')

    def test_cannot_set_deprecated_timezone(self):
        # this should be ok
        self.env.user.tz = "America/New_York"
        if "US/Eastern" not in pytz.all_timezones:
            with self.assertRaises(ValueError):
                self.env.user.tz = "US/Eastern"

    def test_partner_with_old_tz(self):
        # this test makes sence after ubuntu noble without tzdata-legacy installed
        partner = self.env['res.partner'].create({'name': 'test', 'tz': 'UTC'})
        self.env.cr.execute("""UPDATE res_partner set tz='US/Eastern' WHERE id=%s""", (partner.id,))
        partner.invalidate_recordset()
        self.assertEqual(partner.tz, 'US/Eastern')  # tz was update despite selection not existing, but data was not migrated
        self.assertEqual(partner.tz_offset, '-0400', "We don't expect pytz.timezone to fail if the timezone diseapeared when chaging os version")

```

  File: tests/test_uninstall.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

# This assumes an existing but uninitialized database.

from contextlib import contextmanager
import unittest

from odoo import api, registry, SUPERUSER_ID
from odoo.tests import common
from odoo.tests.common import BaseCase

from odoo.modules.registry import Registry


@contextmanager
def environment():
    """ Return an environment with a new cursor for the current database; the
        cursor is committed and closed after the context block.
    """
    reg = registry(common.get_db_name())
    with reg.cursor() as cr:
        yield api.Environment(cr, SUPERUSER_ID, {})


MODULE = 'test_uninstall'
MODEL = 'test_uninstall.model'


class TestUninstall(BaseCase):
    """
    Test the install/uninstall of a test module. The module is available in
    `odoo.tests` which should be present in the addons-path.
    """

    def test_01_install(self):
        """ Check a few things showing the module is installed. """
        with environment() as env:
            module = env['ir.module.module'].search([('name', '=', MODULE)])
            assert len(module) == 1
            module.button_install()
        Registry.new(common.get_db_name(), update_module=True)

        with environment() as env:
            self.assertIn('test_uninstall.model', env.registry)
            self.assertTrue(env['ir.model.data'].search([('module', '=', MODULE)]))
            self.assertTrue(env['ir.model.fields'].search([('model', '=', MODEL)]))

            env.cr.execute(
                r"""
                SELECT conname
                  FROM pg_constraint
                 WHERE conrelid = 'res_users'::regclass
                   AND conname LIKE 'res\_users\_test\_uninstall\_res\_user\_%'
                """
            )
            existing_constraints = [r[0] for r in env.cr.fetchall()]
            self.assertTrue(len(existing_constraints) == 4, existing_constraints)

    def test_02_uninstall(self):
        """ Check a few things showing the module is uninstalled. """
        with environment() as env:
            module = env['ir.module.module'].search([('name', '=', MODULE)])
            assert len(module) == 1
            module.button_uninstall()
        Registry.new(common.get_db_name(), update_module=True)

        with environment() as env:
            self.assertNotIn('test_uninstall.model', env.registry)
            self.assertFalse(env['ir.model.data'].search([('module', '=', MODULE)]))
            self.assertFalse(env['ir.model.fields'].search([('model', '=', MODEL)]))

            env.cr.execute(
                r"""
                SELECT conname
                  FROM pg_constraint
                 WHERE conrelid = 'res_users'::regclass
                   AND conname LIKE 'res\_users\_test\_uninstall\_res\_user\_%'
                """
            )
            remaining_constraints = [r[0] for r in env.cr.fetchall()]
            self.assertFalse(remaining_constraints)


if __name__ == '__main__':
    unittest.main()

```

  File: tests/test_user_has_group.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo.tests.common import TransactionCase
from odoo.exceptions import ValidationError
from odoo import Command


class TestHasGroup(TransactionCase):
    def setUp(self):
        super(TestHasGroup, self).setUp()

        self.group0 = 'test_user_has_group.group0'
        self.group1 = 'test_user_has_group.group1'
        group0, group1 = self.env['res.groups']._load_records([
            dict(xml_id=self.group0, values={'name': 'group0'}),
            dict(xml_id=self.group1, values={'name': 'group1'}),
        ])

        self.test_user = self.env['res.users'].create({
            'login': 'testuser',
            'partner_id': self.env['res.partner'].create({
                'name': "Strawman Test User"
            }).id,
            'groups_id': [Command.set([group0.id])]
        })

        self.grp_internal_xml_id = 'base.group_user'
        self.grp_internal = self.env.ref(self.grp_internal_xml_id)
        self.grp_portal_xml_id = 'base.group_portal'
        self.grp_portal = self.env.ref(self.grp_portal_xml_id)
        self.grp_public_xml_id = 'base.group_public'
        self.grp_public = self.env.ref(self.grp_public_xml_id)

    def test_env_uid(self):
        Users = self.env['res.users'].with_user(self.test_user)
        self.assertTrue(
            Users.has_group(self.group0),
            "the test user should belong to group0"
        )
        self.assertFalse(
            Users.has_group(self.group1),
            "the test user should *not* belong to group1"
        )

    def test_record(self):
        self.assertTrue(
            self.test_user.has_group(self.group0),
            "the test user should belong to group0",
        )
        self.assertFalse(
            self.test_user.has_group(self.group1),
            "the test user shoudl not belong to group1"
        )

    def test_portal_creation(self):
        """Here we check that portal user creation fails if it tries to create a user
           who would also have group_user by implied_group.
           Otherwise, it succeeds with the groups we asked for.
        """
        grp_public = self.env.ref('base.group_public')
        grp_test_portal_xml_id = 'test_user_has_group.portal_implied_group'
        grp_test_portal = self.env['res.groups']._load_records([
            dict(xml_id=grp_test_portal_xml_id, values={'name': 'Test Group Portal'})
        ])
        grp_test_internal1 = self.env['res.groups']._load_records([
            dict(xml_id='test_user_has_group.internal_implied_group1', values={'name': 'Test Group Itnernal 1'})
        ])
        grp_test_internal2_xml_id = 'test_user_has_group.internal_implied_group2'
        grp_test_internal2 = self.env['res.groups']._load_records([
            dict(xml_id=grp_test_internal2_xml_id, values={'name': 'Test Group Internal 2'})
        ])
        self.grp_portal.implied_ids = grp_test_portal

        grp_test_internal1.implied_ids = False
        grp_test_internal2.implied_ids = False

        portal_user = self.env['res.users'].create({
            'login': 'portalTest',
            'name': 'Portal test',
            'sel_groups_%s_%s_%s' % (self.grp_internal.id, self.grp_portal.id, grp_public.id): self.grp_portal.id,
            'sel_groups_%s_%s' % (grp_test_internal1.id, grp_test_internal2.id): grp_test_internal2.id,
        })

        self.assertTrue(
            portal_user.has_group(self.grp_portal_xml_id),
            "The portal user should belong to '%s'" % self.grp_portal_xml_id,
        )
        self.assertTrue(
            portal_user.has_group(grp_test_portal_xml_id),
            "The portal user should belong to '%s'" % grp_test_portal_xml_id,
        )
        self.assertTrue(
            portal_user.has_group(grp_test_internal2_xml_id),
            "The portal user should belong to '%s'" % grp_test_internal2_xml_id
        )
        self.assertFalse(
            portal_user.has_group(self.grp_internal_xml_id),
            "The portal user should not belong to '%s'" % self.grp_internal_xml_id
        )

        portal_user.unlink()  # otherwise, badly modifying the implication would raise

        grp_test_internal1.implied_ids = self.grp_internal
        grp_test_internal2.implied_ids = self.grp_internal

        with self.assertRaises(ValidationError): # current group implications forbid to create a portal user
            portal_user = self.env['res.users'].create({
                'login': 'portalFail',
                'name': 'Portal fail',
                'sel_groups_%s_%s_%s' % (self.grp_internal.id, self.grp_portal.id, grp_public.id): self.grp_portal.id,
                'sel_groups_%s_%s' % (grp_test_internal1.id, grp_test_internal2.id): grp_test_internal2.id,
            })

    def test_portal_write(self):
        """Check that adding a new group to a portal user works as expected,
           except if it implies group_user/public, in chich case it should raise.
        """
        grp_test_portal = self.env["res.groups"].create({"name": "implied by portal"})
        self.grp_portal.implied_ids = grp_test_portal

        portal_user = self.env['res.users'].create({
            'login': 'portalTest2',
            'name': 'Portal test 2',
            'groups_id': [Command.set([self.grp_portal.id])],
            })

        self.assertEqual(
            portal_user.groups_id, (self.grp_portal + grp_test_portal),
            "The portal user should have the implied group.",
        )

        grp_fail = self.env["res.groups"].create(
            {"name": "fail", "implied_ids": [Command.set([self.grp_internal.id])]})

        with self.assertRaises(ValidationError):
            portal_user.write({'groups_id': [Command.link(grp_fail.id)]})

    def test_two_user_types(self):
        #Create a user with two groups of user types kind (Internal and Portal)
        grp_test = self.env['res.groups']._load_records([
            dict(xml_id='test_two_user_types.implied_groups', values={'name': 'Test Group'})
        ])
        grp_test.implied_ids += self.grp_internal
        grp_test.implied_ids += self.grp_portal

        with self.assertRaises(ValidationError):
            self.env['res.users'].create({
                'login': 'test_two_user_types',
                'name': "Test User with two user types",
                'groups_id': [Command.set([grp_test.id])]
            })

        #Add a user with portal to the group Internal
        test_user = self.env['res.users'].create({
                'login': 'test_user_portal',
                'name': "Test User with two user types",
                'groups_id': [Command.set([self.grp_portal.id])]
             })
        with self.assertRaises(ValidationError):
            self.grp_internal.users = [Command.link(test_user.id)]

    def test_two_user_types_implied_groups(self):
        """Contrarily to test_two_user_types, we simply add an implied_id to a group.
           This will trigger the addition of the relevant users to the relevant groups;
           if, say, this was done in SQL and thus bypassing the ORM, it would bypass the constraints
           and thus give us a case uncovered by the aforementioned test.
        """
        grp_test = self.env["res.groups"].create(
            {"name": "test", "implied_ids": [Command.set([self.grp_internal.id])]})

        test_user = self.env['res.users'].create({
            'login': 'test_user_portal',
            'name': "Test User with one user types",
            'groups_id': [Command.set([grp_test.id])]
        })

        with self.assertRaises(ValidationError):
            grp_test.write({'implied_ids': [Command.link(self.grp_portal.id)]})

    def test_demote_user(self):
        """When a user is demoted to the status of portal/public,
           we should strip him of all his (previous) rights
        """
        group_0 = self.env.ref(self.group0)  # the group to which test_user already belongs
        group_U = self.env["res.groups"].create({"name": "U", "implied_ids": [Command.set([self.grp_internal.id])]})
        self.grp_internal.implied_ids = False  # only there to simplify the test by not having to care about its trans_implied_ids

        self.test_user.write({'groups_id': [Command.link(group_U.id)]})
        self.assertEqual(
            self.test_user.groups_id, (group_0 + group_U + self.grp_internal),
            "We should have our 2 groups and the implied user group",
        )

        # Now we demote him. The JS framework sends 3 and 4 commands,
        # which is what we write here, but it should work even with a 5 command or whatever.
        self.test_user.write({'groups_id': [
            Command.unlink(self.grp_internal.id),
            Command.unlink(self.grp_public.id),
            Command.link(self.grp_portal.id),
        ]})

        # if we screw up the removing groups/adding the implied ids, we could end up in two situations:
        # 1. we have a portal user with way too much rights (e.g. 'Contact Creation', which does not imply any other group)
        # 2. because a group may be (transitively) implying group_user, then it would raise an exception
        # so as a compromise we remove all groups when demoting a user
        # (even technical display groups, e.g. TaxB2B, which could be re-added later)
        self.assertEqual(
            self.test_user.groups_id, (self.grp_portal),
            "Here the portal group does not imply any other group, so we should only have this group.",
        )

    def test_implied_groups(self):
        """ We check that the adding of implied ids works correctly for normal users and portal users.
            In the second case, working normally means raising if a group implies to give 'group_user'
            rights to a portal user.
        """
        U = self.env["res.users"]
        G = self.env["res.groups"]
        group_user = self.env.ref('base.group_user')
        group_portal = self.env.ref('base.group_portal')
        group_no_one = self.env.ref('base.group_no_one')

        group_A = G.create({"name": "A"})
        group_AA = G.create({"name": "AA", "implied_ids": [Command.set([group_A.id])]})
        group_B = G.create({"name": "B"})
        group_BB = G.create({"name": "BB", "implied_ids": [Command.set([group_B.id])]})

        # user_a is a normal user, so we expect groups to be added when we add them,
        # as well as 'implied_groups'; otherwise nothing else should happen.
        # By contrast, for a portal user we want implied groups not to be added
        # if and only if it would not give group_user (or group_public) privileges
        user_a = U.create({"name": "a", "login": "a", "groups_id": [Command.set([group_AA.id, group_user.id])]})
        self.assertEqual(user_a.groups_id, (group_AA + group_A + group_user + group_no_one))

        user_b = U.create({"name": "b", "login": "b", "groups_id": [Command.set([group_portal.id, group_AA.id])]})
        self.assertEqual(user_b.groups_id, (group_AA + group_A + group_portal))

        # user_b is not an internal user, but giving it a new group just added a new group
        (user_a + user_b).write({"groups_id": [Command.link(group_BB.id)]})
        self.assertEqual(user_a.groups_id, (group_AA + group_A + group_BB + group_B + group_user + group_no_one))
        self.assertEqual(user_b.groups_id, (group_AA + group_A + group_BB + group_B + group_portal))

        # now we create a group that implies the group_user
        # adding it to a user should work normally, whereas adding it to a portal user should raise
        group_C = G.create({"name": "C", "implied_ids": [Command.set([group_user.id])]})

        user_a.write({"groups_id": [Command.link(group_C.id)]})
        self.assertEqual(user_a.groups_id, (group_AA + group_A + group_BB + group_B + group_C + group_user + group_no_one))

        with self.assertRaises(ValidationError):
            user_b.write({"groups_id": [Command.link(group_C.id)]})

    def test_has_group_cleared_cache_on_write(self):
        self.env.registry.clear_cache()
        self.assertFalse(self.registry._Registry__caches['default'], "Ensure ormcache is empty")

        def populate_cache():
            self.test_user.has_group('test_user_has_group.group0')
            self.assertTrue(self.registry._Registry__caches['default'], "user.has_group cache must be populated")

        populate_cache()

        self.env.ref(self.group0).write({"share": True})
        self.assertFalse(self.registry._Registry__caches['default'], "Writing on group must invalidate user.has_group cache")

        populate_cache()
        # call_cache_clearing_methods is called in res.groups.write to invalidate
        # cache before calling its parent class method (`odoo.models.Model.write`)
        # as explain in the `res.group.write` comment.
        # This verifies that calling `call_cache_clearing_methods()` invalidates
        # the ormcache of method `user.has_group()`
        self.env['ir.model.access'].call_cache_clearing_methods()
        self.assertFalse(
            self.registry._Registry__caches['default'],
            "call_cache_clearing_methods() must invalidate user.has_group cache"
        )

```

  File: tests/test_views.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import ast
import json
import logging
import re
import time

from functools import partial

from lxml import etree
from lxml.builder import E
from psycopg2 import IntegrityError
from psycopg2.extras import Json

from odoo.exceptions import AccessError, ValidationError
from odoo.tests import common, tagged
from odoo.addons.base.tests.common import TransactionCaseWithUserDemo
from odoo.tools import get_cache_key_counter, mute_logger, view_validation, safe_eval
from odoo.addons.base.models import ir_ui_view

_logger = logging.getLogger(__name__)


class ViewXMLID(common.TransactionCase):
    def test_model_data_id(self):
        """ Check whether views know their xmlid record. """
        view = self.env.ref('base.view_company_form')
        self.assertTrue(view)
        self.assertTrue(view.model_data_id)
        self.assertEqual(view.model_data_id.complete_name, 'base.view_company_form')

class ViewCase(TransactionCaseWithUserDemo):
    def setUp(self):
        super(ViewCase, self).setUp()
        self.View = self.env['ir.ui.view']

    def assertValid(self, arch, name='valid view', inherit_id=False):
        return self.View.create({
            'name': name,
            'model': 'ir.ui.view',
            'inherit_id': inherit_id,
            'arch': arch,
        })

    def assertInvalid(self, arch, expected_message=None, name='invalid view', inherit_id=False):
        with mute_logger('odoo.addons.base.models.ir_ui_view'):
            with self.assertRaises(ValidationError) as catcher:
                with self.cr.savepoint():
                    self.View.create({
                        'name': name,
                        'model': 'ir.ui.view',
                        'inherit_id': inherit_id,
                        'arch': arch,
                    })
        message = str(catcher.exception.args[0])
        self.assertEqual(catcher.exception.context['name'], name)
        if expected_message:
            self.assertIn(expected_message, message)
        else:
            _logger.warning(message)

    def assertWarning(self, arch, expected_message=None, name='invalid view'):
        with self.assertLogs('odoo.addons.base.models.ir_ui_view', level="WARNING") as log_catcher:
            self.View.create({
                'name': name,
                'model': 'ir.ui.view',
                'arch': arch,
            })
        self.assertEqual(len(log_catcher.output), 1, "Exactly one warning should be logged")
        message = log_catcher.output[0]
        self.assertIn('View error context', message)
        self.assertIn("'name': '%s'" % name, message)
        if expected_message:
            self.assertIn(expected_message, message)


class TestNodeLocator(common.TransactionCase):
    """
    The node locator returns None when it can not find a node, and the first
    match when it finds something (no jquery-style node sets)
    """

    def test_no_match_xpath(self):
        """
        xpath simply uses the provided @expr pattern to find a node
        """
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(), E.bar(), E.baz()),
            E.xpath(expr="//qux"),
        )
        self.assertIsNone(node)

    def test_match_xpath(self):
        bar = E.bar()
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(), bar, E.baz()),
            E.xpath(expr="//bar"),
        )
        self.assertIs(node, bar)

    def test_no_match_field(self):
        """
        A field spec will match by @name against all fields of the view
        """
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(), E.bar(), E.baz()),
            E.field(name="qux"),
        )
        self.assertIsNone(node)

        node = self.env['ir.ui.view'].locate_node(
            E.root(E.field(name="foo"), E.field(name="bar"), E.field(name="baz")),
            E.field(name="qux"),
        )
        self.assertIsNone(node)

    def test_match_field(self):
        bar = E.field(name="bar")
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.field(name="foo"), bar, E.field(name="baz")),
            E.field(name="bar"),
        )
        self.assertIs(node, bar)

    def test_no_match_other(self):
        """
        Non-xpath non-fields are matched by node name first
        """
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(), E.bar(), E.baz()),
            E.qux(),
        )
        self.assertIsNone(node)

    def test_match_other(self):
        bar = E.bar()
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(), bar, E.baz()),
            E.bar(),
        )
        self.assertIs(bar, node)

    def test_attribute_mismatch(self):
        """
        Non-xpath non-field are filtered by matching attributes on spec and
        matched nodes
        """
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(attr='1'), E.bar(attr='2'), E.baz(attr='3')),
            E.bar(attr='5'),
        )
        self.assertIsNone(node)

    def test_attribute_filter(self):
        match = E.bar(attr='2')
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.bar(attr='1'), match, E.root(E.bar(attr='3'))),
            E.bar(attr='2'),
        )
        self.assertIs(node, match)

    def test_version_mismatch(self):
        """
        A @version on the spec will be matched against the view's version
        """
        node = self.env['ir.ui.view'].locate_node(
            E.root(E.foo(attr='1'), version='4'),
            E.foo(attr='1', version='3'),
        )
        self.assertIsNone(node)


class TestViewInheritance(ViewCase):
    def arch_for(self, name, view_type='form', parent=None):
        """ Generates a trivial view of the specified ``view_type``.

        The generated view is empty but ``name`` is set as its root's ``@string``.

        If ``parent`` is not falsy, generates an extension view (instead of
        a root view) replacing the parent's ``@string`` by ``name``

        :param str name: ``@string`` value for the view root
        :param str view_type:
        :param bool parent:
        :return: generated arch
        :rtype: str
        """
        if not parent:
            element = E(view_type, string=name)
        else:
            element = E(view_type,
                E.attribute(name, name='string'),
                position='attributes'
            )
        return etree.tostring(element, encoding='unicode')

    def makeView(self, name, parent=None, arch=None):
        """ Generates a basic ir.ui.view with the provided name, parent and arch.

        If no parent is provided, the view is top-level.

        If no arch is provided, generates one by calling :meth:`~.arch_for`.

        :param str name:
        :param int parent: id of the parent view, if any
        :param str arch:
        :returns: the created view's id.
        :rtype: int
        """
        view = self.View.create({
            'model': self.model,
            'name': name,
            'arch': arch or self.arch_for(name, parent=parent),
            'inherit_id': parent,
            'priority': 5, # higher than default views
        })
        self.view_ids[name] = view
        return view

    def get_views(self, names):
        return self.View.concat(*(self.view_ids[name] for name in names))

    def setUp(self):
        super(TestViewInheritance, self).setUp()

        self.patch(self.registry, '_init', False)

        self.model = 'ir.ui.view.custom'
        self.view_ids = {}

        self.a = self.makeView("A")
        self.a1 = self.makeView("A1", self.a.id)
        self.a2 = self.makeView("A2", self.a.id)
        self.a11 = self.makeView("A11", self.a1.id)
        self.a11.mode = 'primary'
        self.makeView("A111", self.a11.id)
        self.makeView("A12", self.a1.id)
        self.makeView("A21", self.a2.id)
        self.a22 = self.makeView("A22", self.a2.id)
        self.makeView("A221", self.a22.id)

        self.b = self.makeView('B', arch=self.arch_for("B", 'tree'))
        self.makeView('B1', self.b.id, arch=self.arch_for("B1", 'tree', parent=self.b))
        self.c = self.makeView('C', arch=self.arch_for("C", 'tree'))
        self.c.write({'priority': 1})

    def test_get_inheriting_views(self):
        self.assertEqual(
            self.view_ids['A']._get_inheriting_views(),
            self.get_views('A A1 A2 A12 A21 A22 A221'.split()),
        )
        self.assertEqual(
            self.view_ids['A21']._get_inheriting_views(),
            self.get_views(['A21']),
        )
        self.assertEqual(
            self.view_ids['A11']._get_inheriting_views(),
            self.get_views(['A11', 'A111']),
        )
        self.assertEqual(
            (self.view_ids['A11'] + self.view_ids['A'])._get_inheriting_views(),
            self.get_views('A A1 A2 A11 A111 A12 A21 A22 A221'.split()),
        )

    def test_default_view(self):
        default = self.View.default_view(model=self.model, view_type='form')
        self.assertEqual(default, self.view_ids['A'].id)

        default_tree = self.View.default_view(model=self.model, view_type='tree')
        self.assertEqual(default_tree, self.view_ids['C'].id)

    def test_no_default_view(self):
        self.assertFalse(self.View.default_view(model='no_model.exist', view_type='form'))
        self.assertFalse(self.View.default_view(model=self.model, view_type='graph'))

    def test_no_recursion(self):
        r1 = self.makeView('R1')
        with self.assertRaises(ValidationError), self.cr.savepoint():
            r1.write({'inherit_id': r1.id})

        r2 = self.makeView('R2', r1.id)
        r3 = self.makeView('R3', r2.id)
        with self.assertRaises(ValidationError), self.cr.savepoint():
            r2.write({'inherit_id': r3.id})

        with self.assertRaises(ValidationError), self.cr.savepoint():
            r1.write({'inherit_id': r3.id})

        with self.assertRaises(ValidationError), self.cr.savepoint():
            r1.write({
                'inherit_id': r1.id,
                'arch': self.arch_for('itself', parent=True),
            })

    def test_write_arch(self):
        self.env['res.lang']._activate_lang('fr_FR')

        v = self.makeView("T", arch='<form string="Foo">Bar</form>')
        v.update_field_translations('arch_db', {'fr_FR': {'Foo': 'Fou', 'Bar': 'Barre'}})
        self.assertEqual(v.arch, '<form string="Foo">Bar</form>')

        # modify v to discard translations; this should not invalidate 'arch'!
        v.arch = '<form/>'
        self.assertEqual(v.arch, '<form/>')

    def test_get_combined_arch_query_count(self):
        # If the query count increases, you probably made the view combination
        # fetch an extra field on views. You better fetch that extra field with
        # the query of _get_inheriting_views() and manually feed the cache.
        self.env.invalidate_all()
        with self.assertQueryCount(3):
            # 1: browse([self.view_ids['A']])
            # 2: _get_inheriting_views: id, inherit_id, mode, groups
            # 3: _combine: arch_db
            self.view_ids['A'].get_combined_arch()

    def test_view_validate_button_action_query_count(self):
        _, _, counter = get_cache_key_counter(self.env['ir.model.data']._xmlid_lookup, 'base.action_ui_view')
        hit, miss = counter.hit, counter.miss

        with self.assertQueryCount(7):
            base_view = self.assertValid("""
                <form string="View">
                    <header>
                        <button type="action" name="base.action_ui_view"/>
                        <button type="action" name="base.action_ui_view_custom"/>
                        <button type="action" name="base.action_ui_view"/>
                    </header>
                    <field name="name"/>
                </form>
            """)
        self.assertEqual(counter.hit, hit)
        self.assertEqual(counter.miss, miss + 2)

        with self.assertQueryCount(6):
            self.assertValid("""
                <field name="name" position="replace"/>
            """, inherit_id=base_view.id)
        self.assertEqual(counter.hit, hit + 2)
        self.assertEqual(counter.miss, miss + 2)

    def test_view_validate_attrs_groups_query_count(self):
        _, _, counter = get_cache_key_counter(self.env['ir.model.data']._xmlid_lookup, 'base.group_system')
        hit, miss = counter.hit, counter.miss

        with self.assertQueryCount(4):
            base_view = self.assertValid("""
                <form string="View">
                    <field name="name" groups="base.group_system"/>
                    <field name="priority" groups="base.group_system"/>
                    <field name="inherit_id" groups="base.group_system"/>
                </form>
            """)
        self.assertEqual(counter.hit, hit)
        self.assertEqual(counter.miss, miss + 1)

        with self.assertQueryCount(4):
            self.assertValid("""
                <field name="name" position="replace">
                    <field name="key" groups="base.group_system"/>
                </field>
            """, inherit_id=base_view.id)
        self.assertEqual(counter.hit, hit + 1)
        self.assertEqual(counter.miss, miss + 1)


class TestApplyInheritanceSpecs(ViewCase):
    """ Applies a sequence of inheritance specification nodes to a base
    architecture. IO state parameters (cr, uid, model, context) are used for
    error reporting

    The base architecture is altered in-place.
    """
    def setUp(self):
        super(TestApplyInheritanceSpecs, self).setUp()
        self.base_arch = E.form(
            E.field(name="target"),
            string="Title")
        self.adv_arch = E.form(
            E.field(
                "TEXT1",
                E.field(name="subtarget"),
                "TEXT2",
                E.field(name="anothersubtarget"),
                "TEXT3",
                name="target",
            ),
            string="Title")

    def test_replace_outer(self):
        spec = E.field(
                E.field(name="replacement"),
                name="target", position="replace")

        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(E.field(name="replacement"), string="Title"))

    def test_delete(self):
        spec = E.field(name="target", position="replace")

        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(string="Title"))

    def test_insert_after(self):
        spec = E.field(
                E.field(name="inserted"),
                name="target", position="after")

        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(
                E.field(name="target"),
                E.field(name="inserted"),
                string="Title"
            ))

    def test_insert_before(self):
        spec = E.field(
                E.field(name="inserted"),
                name="target", position="before")

        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(
                E.field(name="inserted"),
                E.field(name="target"),
                string="Title"))

    def test_insert_inside(self):
        default = E.field(E.field(name="inserted"), name="target")
        spec = E.field(E.field(name="inserted 2"), name="target", position='inside')

        self.View.apply_inheritance_specs(self.base_arch, default)
        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(
                E.field(
                    E.field(name="inserted"),
                    E.field(name="inserted 2"),
                    name="target"),
                string="Title"))

    def test_replace_inner(self):
        spec = E.field(
            "TEXT 4",
            E.field(name="replacement"),
            "TEXT 5",
            E.field(name="replacement2"),
            "TEXT 6",
            name="target", position="replace", mode="inner")

        expected = E.form(
            E.field(
                "TEXT 4",
                E.field(name="replacement"),
                "TEXT 5",
                E.field(name="replacement2"),
                "TEXT 6",
                name="target"),
            string="Title")

        # applying spec to both base_arch and adv_arch is expected to give the same result
        self.View.apply_inheritance_specs(self.base_arch, spec)
        self.assertEqual(self.base_arch, expected)

        self.View.apply_inheritance_specs(self.adv_arch, spec)
        self.assertEqual(self.adv_arch, expected)

    def test_unpack_data(self):
        spec = E.data(
                E.field(E.field(name="inserted 0"), name="target"),
                E.field(E.field(name="inserted 1"), name="target"),
                E.field(E.field(name="inserted 2"), name="target"),
                E.field(E.field(name="inserted 3"), name="target"),
            )

        self.View.apply_inheritance_specs(self.base_arch, spec)

        self.assertEqual(
            self.base_arch,
            E.form(
                E.field(
                    E.field(name="inserted 0"),
                    E.field(name="inserted 1"),
                    E.field(name="inserted 2"),
                    E.field(name="inserted 3"),
                    name="target"),
                string="Title"))

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_invalid_position(self):
        spec = E.field(
                E.field(name="whoops"),
                name="target", position="serious_series")

        with self.assertRaises(ValueError):
            self.View.apply_inheritance_specs(self.base_arch, spec)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_incorrect_version(self):
        # Version ignored on //field elements, so use something else
        arch = E.form(E.element(foo="42"))
        spec = E.element(
            E.field(name="placeholder"),
            foo="42", version="7.0")

        with self.assertRaises(ValueError):
            self.View.apply_inheritance_specs(arch, spec)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_target_not_found(self):
        spec = E.field(name="targut")

        with self.assertRaises(ValueError):
            self.View.apply_inheritance_specs(self.base_arch, spec)


class TestApplyInheritanceWrapSpecs(ViewCase):
    def setUp(self):
        super(TestApplyInheritanceWrapSpecs, self).setUp()
        self.base_arch = E.template(E.div(E.p("Content")))

    def apply_spec(self, spec):
        self.View.apply_inheritance_specs(self.base_arch, spec)

    def test_replace(self):
        spec = E.xpath(
            E.div("$0", {'class': "some"}),
            expr="//p", position="replace")

        self.apply_spec(spec)
        self.assertEqual(
            self.base_arch,
            E.template(E.div(
                E.div(E.p('Content'), {'class': 'some'})
            ))
        )


class TestApplyInheritanceMoveSpecs(ViewCase):
    def setUp(self):
        super(TestApplyInheritanceMoveSpecs, self).setUp()
        self.base_arch = E.template(
            E.div(E.p("Content", {'class': 'some'})),
            E.div({'class': 'target'})
        )
        self.wrapped_arch = E.template(
            E.div("aaaa", E.p("Content", {'class': 'some'}), "bbbb"),
            E.div({'class': 'target'})
        )

    def apply_spec(self, arch, spec):
        self.View.apply_inheritance_specs(arch, spec)

    def test_move_replace(self):
        spec = E.xpath(
            E.xpath(expr="//p", position="move"),
            expr="//div[@class='target']", position="replace")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(),
                E.p("Content", {'class': 'some'})
            )
        )
        self.apply_spec(self.wrapped_arch, spec)
        self.assertEqual(
            self.wrapped_arch,
            E.template(
                E.div("aaaabbbb"),
                E.p("Content", {'class': 'some'})
            )
        )

    def test_move_inside(self):
        spec = E.xpath(
            E.xpath(expr="//p", position="move"),
            expr="//div[@class='target']", position="inside")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(),
                E.div(E.p("Content", {'class': 'some'}), {'class': 'target'})
            )
        )
        self.apply_spec(self.wrapped_arch, spec)
        self.assertEqual(
            self.wrapped_arch,
            E.template(
                E.div("aaaabbbb"),
                E.div(E.p("Content", {'class': 'some'}), {'class': 'target'})
            )
        )

    def test_move_before(self):
        spec = E.xpath(
            E.xpath(expr="//p", position="move"),
            expr="//div[@class='target']", position="before")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(""),
                E.p("Content", {'class': 'some'}),
                E.div({'class': 'target'}),
            )
        )
        self.apply_spec(self.wrapped_arch, spec)
        self.assertEqual(
            self.wrapped_arch,
            E.template(
                E.div("aaaabbbb"),
                E.p("Content", {'class': 'some'}),
                E.div({'class': 'target'}),
            )
        )

    def test_move_after(self):
        spec = E.xpath(
            E.xpath(expr="//p", position="move"),
            expr="//div[@class='target']", position="after")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(),
                E.div({'class': 'target'}),
                E.p("Content", {'class': 'some'}),
            )
        )
        self.apply_spec(self.wrapped_arch, spec)
        self.assertEqual(
            self.wrapped_arch,
            E.template(
                E.div("aaaabbbb"),
                E.div({'class': 'target'}),
                E.p("Content", {'class': 'some'}),
            )
        )

    def test_move_with_other_1(self):
        # multiple elements with move in first position
        spec = E.xpath(
            E.xpath(expr="//p", position="move"),
            E.p("Content2", {'class': 'new_p'}),
            expr="//div[@class='target']", position="after")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(),
                E.div({'class': 'target'}),
                E.p("Content", {'class': 'some'}),
                E.p("Content2", {'class': 'new_p'}),
            )
        )

    def test_move_with_other_2(self):
        # multiple elements with move in last position
        spec = E.xpath(
            E.p("Content2", {'class': 'new_p'}),
            E.xpath(expr="//p", position="move"),
            expr="//div[@class='target']", position="after")

        self.apply_spec(self.wrapped_arch, spec)
        self.assertEqual(
            self.wrapped_arch,
            E.template(
                E.div("aaaabbbb"),
                E.div({'class': 'target'}),
                E.p("Content2", {'class': 'new_p'}),
                E.p("Content", {'class': 'some'}),
            )
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_incorrect_move_1(self):
        # cannot move an inexisting element
        spec = E.xpath(
            E.xpath(expr="//p[@name='none']", position="move"),
            expr="//div[@class='target']", position="after")

        with self.assertRaises(ValueError):
            self.apply_spec(self.base_arch, spec)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_incorrect_move_2(self):
        # move xpath cannot contain any children
        spec = E.xpath(
            E.xpath(E.p("Content2", {'class': 'new_p'}), expr="//p", position="move"),
            expr="//div[@class='target']", position="after")

        with self.assertRaises(ValueError):
            self.apply_spec(self.base_arch, spec)

    def test_incorrect_move_3(self):
        # move won't be correctly applied if not a direct child of an xpath
        spec = E.xpath(
            E.div(E.xpath(E.p("Content2", {'class': 'new_p'}), expr="//p", position="move"), {'class': 'wrapper'}),
            expr="//div[@class='target']", position="after")

        self.apply_spec(self.base_arch, spec)
        self.assertEqual(
            self.base_arch,
            E.template(
                E.div(E.p("Content", {'class': 'some'})),
                E.div({'class': 'target'}),
                E.div(E.xpath(E.p("Content2", {'class': 'new_p'}), expr="//p", position="move"), {'class': 'wrapper'}),
            )
        )


class TestApplyInheritedArchs(ViewCase):
    """ Applies a sequence of modificator archs to a base view
    """


class TestNoModel(ViewCase):
    def test_create_view_nomodel(self):
        view = self.View.create({
            'name': 'dummy',
            'arch': '<template name="foo"/>',
            'inherit_id': False,
            'type': 'qweb',
        })
        fields = ['name', 'arch', 'type', 'priority', 'inherit_id', 'model']
        [data] = view.read(fields)
        self.assertEqual(data, {
            'id': view.id,
            'name': 'dummy',
            'arch': '<template name="foo"/>',
            'type': 'qweb',
            'priority': 16,
            'inherit_id': False,
            'model': False,
        })

    text_para = E.p("", {'class': 'legalese'})
    arch = E.body(
        E.div(
            E.h1("Title"),
            id="header"),
        E.p("Welcome!"),
        E.div(
            E.hr(),
            text_para,
            id="footer"),
        {'class': "index"},)

    def test_qweb_translation(self):
        """
        Test if translations work correctly without a model
        """
        self.env['res.lang']._activate_lang('fr_FR')
        ARCH = '<template name="foo">%s</template>'
        TEXT_EN = "Copyright copyrighter"
        TEXT_FR = u"Copyrighter, tous droits réservés"
        view = self.View.create({
            'name': 'dummy',
            'arch': ARCH % TEXT_EN,
            'inherit_id': False,
            'type': 'qweb',
        })
        view.update_field_translations('arch_db', {'fr_FR': {TEXT_EN: TEXT_FR}})
        view = view.with_context(lang='fr_FR')
        self.assertEqual(view.arch, ARCH % TEXT_FR)


class TestTemplating(ViewCase):
    def setUp(self):
        super(TestTemplating, self).setUp()
        self.patch(self.registry, '_init', False)

    def test_branding_inherit(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<root>
                <item order="1"/>
            </root>
            """
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """<xpath expr="//item" position="before">
                <item order="2"/>
            </xpath>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        [initial] = arch.xpath('//item[@order=1]')
        self.assertEqual(
            str(view1.id),
            initial.get('data-oe-id'),
            "initial should come from the root view")
        self.assertEqual(
            '/root[1]/item[1]',
            initial.get('data-oe-xpath'),
            "initial's xpath should be within the root view only")

        [second] = arch.xpath('//item[@order=2]')
        self.assertEqual(
            str(view2.id),
            second.get('data-oe-id'),
            "second should come from the extension view")

    def test_branding_inherit_replace_node(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<hello>
                <world></world>
                <world><t t-esc="hello"/></world>
                <world></world>
            </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """<xpath expr="/hello/world[1]" position="replace">
                <world>Is a ghetto</world>
                <world>Wonder when I'll find paradise</world>
            </xpath>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # First world - has been replaced by inheritance
        [initial] = arch.xpath('/hello[1]/world[1]')
        self.assertEqual(
            '/xpath/world[1]',
            initial.get('data-oe-xpath'),
            'Inherited nodes have correct xpath')

        # Second world added by inheritance
        [initial] = arch.xpath('/hello[1]/world[2]')
        self.assertEqual(
            '/xpath/world[2]',
            initial.get('data-oe-xpath'),
            'Inherited nodes have correct xpath')

        # Third world - is not editable
        [initial] = arch.xpath('/hello[1]/world[3]')
        self.assertFalse(
            initial.get('data-oe-xpath'),
            'node containing t-esc is not branded')

        # The most important assert
        # Fourth world - should have a correct oe-xpath, which is 3rd in main view
        [initial] = arch.xpath('/hello[1]/world[4]')
        self.assertEqual(
            '/hello[1]/world[3]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_replace_node2(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<hello>
                <world></world>
                <world><t t-esc="hello"/></world>
                <world></world>
            </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """<xpath expr="/hello/world[1]" position="replace">
                <war>Is a ghetto</war>
                <world>Wonder when I'll find paradise</world>
            </xpath>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        [initial] = arch.xpath('/hello[1]/war[1]')
        self.assertEqual(
            '/xpath/war',
            initial.get('data-oe-xpath'),
            'Inherited nodes have correct xpath')

        # First world: from inheritance
        [initial] = arch.xpath('/hello[1]/world[1]')
        self.assertEqual(
            '/xpath/world',
            initial.get('data-oe-xpath'),
            'Inherited nodes have correct xpath')

        # Second world - is not editable
        [initial] = arch.xpath('/hello[1]/world[2]')
        self.assertFalse(
            initial.get('data-oe-xpath'),
            'node containing t-esc is not branded')

        # The most important assert
        # Third world - should have a correct oe-xpath, which is 3rd in main view
        [initial] = arch.xpath('/hello[1]/world[3]')
        self.assertEqual(
            '/hello[1]/world[3]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_remove_node(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            # The t-esc node is to ensure branding is distributed to both
            # <world/> elements from the start
            'arch': """
                <hello>
                    <world></world>
                    <world></world>

                    <t t-esc="foo"/>
                </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="/hello/world[1]" position="replace"/>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # Only remaining world but still the second in original view
        [initial] = arch.xpath('/hello[1]/world[1]')
        self.assertEqual(
            '/hello[1]/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_remove_node2(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <hello>
                    <world></world>
                    <world></world>
                </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="/hello/world[1]" position="replace"/>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # Note: this test is a variant of the test_branding_inherit_remove_node
        # -> in this case, we expect the branding to not be distributed on the
        # <hello/> element anymore but on the only remaining world.
        [initial] = arch.xpath('/hello[1]')
        self.assertIsNone(
            initial.get('data-oe-model'),
            "The inner content of the root was xpath'ed, it should not receive branding anymore")

        # Only remaining world but still the second in original view
        [initial] = arch.xpath('/hello[1]/world[1]')
        self.assertEqual(
            '/hello[1]/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_multi_replace_node(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <hello>
                    <world class="a"></world>
                    <world class="b"></world>
                    <world class="c"></world>
                </hello>
            """
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="//world" position="replace">
                        <world class="new_a"></world>
                        <world class="z"></world>
                    </xpath>
                </data>
            """
        })
        self.View.create({  # Inherit from the child view and target the added element
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view2.id,
            'arch': """
                <data>
                    <xpath expr="//world[hasclass('new_a')]" position="replace">
                        <world class="another_new_a"></world>
                    </xpath>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # Check if the replacement inside the child view did not mess up the
        # branding of elements in that child view
        [initial] = arch.xpath('//world[hasclass("z")]')
        self.assertEqual(
            '/data/xpath/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

        # Check if the replacement of the first worlds did not mess up the
        # branding of the last world.
        [initial] = arch.xpath('//world[hasclass("c")]')
        self.assertEqual(
            '/hello[1]/world[3]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_multi_replace_node2(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <hello>
                    <world class="a"></world>
                    <world class="b"></world>
                    <world class="c"></world>
                </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="//world" position="replace">
                        <world class="new_a"></world>
                        <world class="z"></world>
                    </xpath>
                </data>
            """
        })
        self.View.create({  # Inherit from the parent view but actually target
                            # the element added by the first child view
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="//world" position="replace">
                        <world class="another_new_a"></world>
                    </xpath>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # Check if the replacement inside the child view did not mess up the
        # branding of elements in that child view
        [initial] = arch.xpath('//world[hasclass("z")]')
        self.assertEqual(
            '/data/xpath/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

        # Check if the replacement of the first worlds did not mess up the
        # branding of the last world.
        [initial] = arch.xpath('//world[hasclass("c")]')
        self.assertEqual(
            '/hello[1]/world[3]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_remove_added_from_inheritance(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <hello>
                    <world class="a"></world>
                    <world class="b"></world>
                </hello>
            """
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            # Note: class="x" instead of t-field="x" in this arch, should lead
            # to the same result that this test is ensuring but was actually
            # a different case in old stable versions.
            'arch': """
                <data>
                    <xpath expr="//world[hasclass('a')]" position="after">
                        <world t-field="x"></world>
                        <world class="y"></world>
                    </xpath>
                </data>
            """
        })
        self.View.create({  # Inherit from the child view and target the added element
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view2.id,
            'arch': """
                <data>
                    <xpath expr="//world[@t-field='x']" position="replace"/>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # Check if the replacement inside the child view did not mess up the
        # branding of elements in that child view, should not be the case as
        # that root level branding is not distributed.
        [initial] = arch.xpath('//world[hasclass("y")]')
        self.assertEqual(
            '/data/xpath/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

        # Check if the child view replacement of added nodes did not mess up
        # the branding of last world in the parent view.
        [initial] = arch.xpath('//world[hasclass("b")]')
        self.assertEqual(
            '/hello[1]/world[2]',
            initial.get('data-oe-xpath'),
            "The node's xpath position should be correct")

    def test_branding_inherit_remove_node_processing_instruction(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <html>
                    <head>
                        <hello></hello>
                    </head>
                    <body>
                        <world></world>
                    </body>
                </html>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <xpath expr="//hello" position="replace"/>
                    <xpath expr="//world" position="replace"/>
                </data>
            """
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)

        head = arch.xpath('//head')[0]
        head_child = head[0]
        self.assertEqual(
            head_child.target,
            'apply-inheritance-specs-node-removal',
            "A node was removed at the start of the <head>, a processing instruction should exist as first child node")
        self.assertEqual(
            head_child.text,
            'hello',
            "The processing instruction should mention the tag of the node that was removed")

        body = arch.xpath('//body')[0]
        body_child = body[0]
        self.assertEqual(
            body_child.target,
            'apply-inheritance-specs-node-removal',
            "A node was removed at the start of the <body>, a processing instruction should exist as first child node")
        self.assertEqual(
            body_child.text,
            'world',
            "The processing instruction should mention the tag of the node that was removed")

        self.View.distribute_branding(arch)

        # Test that both head and body have their processing instruction
        # 'apply-inheritance-specs-node-removal' removed after branding
        # distribution. Note: test head and body separately as the code in
        # charge of the removal is different in each case.
        self.assertEqual(
            len(head),
            0,
            "The processing instruction of the <head> should have been removed")
        self.assertEqual(
            len(body),
            0,
            "The processing instruction of the <body> should have been removed")

    def test_branding_inherit_top_t_field(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """
                <hello>
                    <world></world>
                    <world t-field="a"/>
                    <world></world>
                    <world></world>
                </hello>
            """
        })
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <xpath expr="/hello/world[3]" position="after">
                    <world t-field="b"/>
                </xpath>
            """
        })
        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        # First t-field should have an indication of xpath
        [node] = arch.xpath('//*[@t-field="a"]')
        self.assertEqual(
            node.get('data-oe-xpath'),
            '/hello[1]/world[2]',
            'First t-field has indication of xpath')

        # Second t-field, from inheritance, should also have an indication of xpath
        [node] = arch.xpath('//*[@t-field="b"]')
        self.assertEqual(
            node.get('data-oe-xpath'),
            '/xpath/world',
            'Inherited t-field has indication of xpath')

        # The most important assert
        # The last world xpath should not have been impacted by the t-field from inheritance
        [node] = arch.xpath('//world[last()]')
        self.assertEqual(
            node.get('data-oe-xpath'),
            '/hello[1]/world[4]',
            "The node's xpath position should be correct")

        # Also test inherit via non-xpath t-field node, direct children of data,
        # is not impacted by the feature
        self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <world t-field="a" position="replace">
                        <world t-field="z"/>
                    </world>
                </data>
            """
        })
        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        node = arch.xpath('//world')[1]
        self.assertEqual(
            node.get('t-field'),
            'z',
            "The node has properly been replaced")

    def test_branding_primary_inherit(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<root>
                <item order="1"/>
            </root>
            """
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'mode': 'primary',
            'inherit_id': view1.id,
            'arch': """<xpath expr="//item" position="after">
                <item order="2"/>
            </xpath>
            """
        })

        arch_string = view2.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        [initial] = arch.xpath('//item[@order=1]')
        self.assertEqual(
            initial.get('data-oe-id'),
            str(view1.id),
            "initial should come from the root view")
        self.assertEqual(
            initial.get('data-oe-xpath'),
            '/root[1]/item[1]',
            "initial's xpath should be within the inherited view only")

        [second] = arch.xpath('//item[@order=2]')
        self.assertEqual(
            second.get('data-oe-id'),
            str(view2.id),
            "second should come from the extension view")
        self.assertEqual(
            second.get('data-oe-xpath'),
            '/xpath/item',
            "second xpath should be on the inheriting view only")

    def test_branding_distribute_inner(self):
        """ Checks that the branding is correctly distributed within a view
        extension
        """
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<root>
                <item order="1"/>
            </root>"""
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """<xpath expr="//item" position="before">
                <item order="2">
                    <content t-att-href="foo">bar</content>
                </item>
            </xpath>"""
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        self.assertEqual(
            arch,
            E.root(
                E.item(
                    E.content("bar", {
                        't-att-href': "foo",
                        'data-oe-model': 'ir.ui.view',
                        'data-oe-id': str(view2.id),
                        'data-oe-field': 'arch',
                        'data-oe-xpath': '/xpath/item/content[1]',
                    }), {
                        'order': '2',
                    }),
                E.item({
                    'order': '1',
                    'data-oe-model': 'ir.ui.view',
                    'data-oe-id': str(view1.id),
                    'data-oe-field': 'arch',
                    'data-oe-xpath': '/root[1]/item[1]',
                })
            )
        )

    def test_branding_attribute_groups(self):
        view = self.View.create({
            'name': "Base View",
            'type': 'qweb',
            'arch': """<root>
                <item groups="base.group_no_one"/>
            </root>""",
        })

        arch_string = view.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        self.assertEqual(arch, E.root(E.item({
            'groups': 'base.group_no_one',
            'data-oe-model': 'ir.ui.view',
            'data-oe-id': str(view.id),
            'data-oe-field': 'arch',
            'data-oe-xpath': '/root[1]/item[1]',
        })))

    def test_call_no_branding(self):
        view = self.View.create({
            'name': "Base View",
            'type': 'qweb',
            'arch': """<root>
                <item><span t-call="foo"/></item>
            </root>""",
        })

        arch_string = view.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        self.assertEqual(arch, E.root(E.item(E.span({'t-call': "foo"}))))

    def test_esc_no_branding(self):
        view = self.View.create({
            'name': "Base View",
            'type': 'qweb',
            'arch': """<root>
                <item><span t-esc="foo"/></item>
            </root>""",
        })

        arch_string = view.with_context(inherit_branding=True).get_combined_arch()
        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        self.assertEqual(arch, E.root(E.item(E.span({'t-esc': "foo"}))))

    def test_ignore_unbrand(self):
        view1 = self.View.create({
            'name': "Base view",
            'type': 'qweb',
            'arch': """<root>
                <item order="1" t-ignore="true">
                    <t t-esc="foo"/>
                </item>
            </root>"""
        })
        view2 = self.View.create({
            'name': "Extension",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """<xpath expr="//item[@order='1']" position="inside">
                <item order="2">
                    <content t-att-href="foo">bar</content>
                </item>
            </xpath>"""
        })

        arch_string = view1.with_context(inherit_branding=True).get_combined_arch()

        arch = etree.fromstring(arch_string)
        self.View.distribute_branding(arch)

        self.assertEqual(
            arch,
            E.root(
                E.item(
                    {'t-ignore': 'true', 'order': '1'},
                    E.t({'t-esc': 'foo'}),
                    E.item(
                        {'order': '2'},
                        E.content(
                            {'t-att-href': 'foo'},
                            "bar")
                    )
                )
            ),
            "t-ignore should apply to injected sub-view branding, not just to"
            " the main view's"
        )


class TestViews(ViewCase):

    def test_nonexistent_attribute_removal(self):
        self.View.create({
            'name': 'Test View',
            'model': 'ir.ui.view',
            'inherit_id': self.ref('base.view_view_tree'),
            'arch': """<?xml version="1.0"?>
                        <xpath expr="//field[@name='name']" position="attributes">
                            <attribute name="non_existing_attribute"></attribute>
                        </xpath>
                    """,
        })

    def _insert_view(self, **kw):
        """Insert view into database via a query to passtrough validation"""
        kw.pop('id', None)
        kw.setdefault('mode', 'extension' if kw.get('inherit_id') else 'primary')
        kw.setdefault('active', True)
        if 'arch_db' in kw:
            arch_db = kw['arch_db']
            if kw.get('inherit_id'):
                self.cr.execute('SELECT type FROM ir_ui_view WHERE id = %s', [kw['inherit_id']])
                kw['type'] = self.cr.fetchone()[0]
            else:
                kw['type'] = etree.fromstring(arch_db).tag
            kw['arch_db'] = Json({'en_US': arch_db}) if self.env.lang == 'en_US' else Json({'en_US': arch_db, self.env.lang: arch_db})

        keys = sorted(kw)
        fields = ','.join('"%s"' % (k.replace('"', r'\"'),) for k in keys)
        params = ','.join('%%(%s)s' % (k,) for k in keys)

        query = 'INSERT INTO ir_ui_view(%s) VALUES(%s) RETURNING id' % (fields, params)
        self.cr.execute(query, kw)
        return self.cr.fetchone()[0]

    def test_view_root_node_matches_view_type(self):
        view = self.View.create({
            'name': 'foo',
            'model': 'ir.ui.view',
            'arch': """
                <form>
                </form>
            """,
        })
        self.assertEqual(view.type, 'form')

        with self.assertRaises(ValidationError):
            self.View.create({
                'name': 'foo',
                'model': 'ir.ui.view',
                'type': 'form',
                'arch': """
                    <data>
                        <div>
                        </div>
                        <form>
                        </form>
                    </data>
                """,
            })

    def test_custom_view_validation(self):
        model = 'ir.actions.act_url'
        validate = partial(self.View._validate_custom_views, model)

        # validation of a single view
        vid = self._insert_view(
            name='base view',
            model=model,
            priority=1,
            arch_db="""<?xml version="1.0"?>
                        <tree string="view">
                          <field name="url"/>
                        </tree>
                    """,
        )
        self.assertTrue(validate())     # single view

        # validation of a inherited view
        self._insert_view(
            name='inherited view',
            model=model,
            priority=1,
            inherit_id=vid,
            arch_db="""<?xml version="1.0"?>
                        <xpath expr="//field[@name='url']" position="before">
                          <field name="name"/>
                        </xpath>
                    """,
        )
        self.assertTrue(validate())     # inherited view

        # validation of a second inherited view (depending on 1st)
        self._insert_view(
            name='inherited view 2',
            model=model,
            priority=5,
            inherit_id=vid,
            arch_db="""<?xml version="1.0"?>
                        <xpath expr="//field[@name='name']" position="after">
                          <field name="target"/>
                        </xpath>
                    """,
        )
        self.assertTrue(validate())     # inherited view

    def test_view_inheritance(self):
        view1 = self.View.create({
            'name': "bob",
            'model': 'ir.ui.view',
            'arch': """
                <form string="Base title">
                    <separator name="separator" string="Separator" colspan="4"/>
                    <footer>
                        <button name="action_archive" type="object" string="Next button" class="btn-primary"/>
                        <button string="Skip" special="cancel" class="btn-secondary"/>
                    </footer>
                </form>
            """
        })
        view2 = self.View.create({
            'name': "edmund",
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <form position="attributes">
                        <attribute name="string">Replacement title</attribute>
                    </form>
                    <footer position="replace">
                        <footer>
                            <button name="action_archive" type="object" string="New button"/>
                        </footer>
                    </footer>
                    <separator name="separator" position="replace">
                        <p>Replacement data</p>
                    </separator>
                </data>
            """
        })
        view3 = self.View.create({
            'name': 'jake',
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'priority': 17,
            'arch': """
                <footer position="attributes">
                    <attribute name="thing">bob tata lolo</attribute>
                    <attribute name="thing" add="bibi and co" remove="tata" separator=" " />
                    <attribute name="otherthing">bob, tata,lolo</attribute>
                    <attribute name="otherthing" remove="tata, bob"/>
                </footer>
            """
        })

        view = self.View.with_context(check_view_ids=[view2.id, view3.id]).get_view(view2.id, 'form')
        self.assertEqual(
            etree.fromstring(
                view['arch'],
                parser=etree.XMLParser(remove_blank_text=True)
            ),
            E.form(
                E.p("Replacement data"),
                E.footer(
                    E.button(name="action_archive", type="object", string="New button"),
                    thing="bob lolo bibi and co", otherthing="lolo"
                ),
                string="Replacement title"))

    def test_view_inheritance_text_inside(self):
        """ Test view inheritance when adding elements and text. """
        view1 = self.View.create({
            'name': "alpha",
            'model': 'ir.ui.view',
            'arch': '<form string="F">(<div/>)</form>',
        })
        view2 = self.View.create({
            'name': "beta",
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'arch': '<div position="inside">a<p/>b<p/>c</div>',
        })
        view = self.View.with_context(check_view_ids=view2.ids).get_view(view1.id)
        self.assertEqual(
            view['arch'],
            '<form string="F">(<div>a<p/>b<p/>c</div>)</form>',
        )

    def test_view_inheritance_text_after(self):
        """ Test view inheritance when adding elements and text. """
        view1 = self.View.create({
            'name': "alpha",
            'model': 'ir.ui.view',
            'arch': '<form string="F">(<div/>)</form>',
        })
        view2 = self.View.create({
            'name': "beta",
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'arch': '<div position="after">a<p/>b<p/>c</div>',
        })
        view = self.View.with_context(check_view_ids=view2.ids).get_view(view1.id)
        self.assertEqual(
            view['arch'],
            '<form string="F">(<div/>a<p/>b<p/>c)</form>',
        )

    def test_view_inheritance_text_before(self):
        """ Test view inheritance when adding elements and text. """
        view1 = self.View.create({
            'name': "alpha",
            'model': 'ir.ui.view',
            'arch': '<form string="F">(<div/>)</form>',
        })
        view2 = self.View.create({
            'name': "beta",
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'arch': '<div position="before">a<p/>b<p/>c</div>',
        })
        view = self.View.with_context(check_view_ids=view2.ids).get_view(view1.id)
        self.assertEqual(
            view['arch'],
            '<form string="F">(a<p/>b<p/>c<div/>)</form>',
        )

    def test_view_inheritance_divergent_models(self):
        view1 = self.View.create({
            'name': "bob",
            'model': 'ir.ui.view.custom',
            'arch': """
                <form string="Base title">
                    <separator name="separator" string="Separator" colspan="4"/>
                    <footer>
                        <button name="action_archive" type="object" string="Next button" class="btn-primary"/>
                        <button string="Skip" special="cancel" class="btn-secondary"/>
                    </footer>
                </form>
            """
        })
        view2 = self.View.create({
            'name': "edmund",
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'arch': """
                <data>
                    <form position="attributes">
                        <attribute name="string">Replacement title</attribute>
                    </form>
                    <footer position="replace">
                        <footer>
                            <button name="action_unarchive" type="object" string="New button"/>
                        </footer>
                    </footer>
                    <separator name="separator" position="replace">
                        <p>Replacement data</p>
                    </separator>
                </data>
            """
        })
        view3 = self.View.create({
            'name': 'jake',
            'model': 'ir.ui.menu',
            'inherit_id': view1.id,
            'priority': 17,
            'arch': """
                <footer position="attributes">
                    <attribute name="thing">bob</attribute>
                </footer>
            """
        })

        view = self.View.with_context(check_view_ids=[view2.id, view3.id]) \
                        .get_view(view2.id, view_type='form')
        self.assertEqual(
            etree.fromstring(
                view['arch'],
                parser=etree.XMLParser(remove_blank_text=True)
            ),
            E.form(
                E.p("Replacement data"),
                E.footer(
                    E.button(name="action_unarchive", type="object", string="New button")),
                string="Replacement title"
            ))

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_invalid_field(self):
        self.assertInvalid("""
                <form string="View">
                    <field name="name"/>
                    <field name="not_a_field"/>
                </form>
            """, 'Field "not_a_field" does not exist in model "ir.ui.view"')
        self.assertInvalid("""
                <form string="View">
                    <field/>
                </form>
            """, 'Field tag must have a "name" attribute defined')

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_invalid_subfield(self):
        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_children_ids">
                    <tree name="Children">
                        <field name="name"/>
                        <field name="not_a_field"/>
                    </tree>
                </field>
            </form>
        """
        self.assertInvalid(
            arch,
            '''Field "not_a_field" does not exist in model "ir.ui.view"''',
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_context_in_view(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_id" context="{'stuff': model}"/>
            </form>
        """
        self.assertValid(arch % '<field name="model"/>')
        self.assertInvalid(
            arch % '',
            """Field 'model' used in context ({'stuff': model}) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_context_in_subview(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id" context="{'stuff': model}"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('', '<field name="model"/>'))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in context ({'stuff': model}) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('<field name="model"/>', ''),
            """Field 'model' used in context ({'stuff': model}) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_context_in_subview_with_parent(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id" context="{'stuff': parent.model}"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('<field name="model"/>', ''))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in context ({'stuff': parent.model}) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="model"/>'),
            """Field 'model' used in context ({'stuff': parent.model}) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_context_in_subsubview_with_parent(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_children_ids">
                            <form string="Children">
                                <field name="name"/>%s
                                <field name="inherit_id" context="{'stuff': parent.parent.model}"/>
                            </form>
                        </field>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('<field name="model"/>', '', ''))
        self.assertInvalid(
            arch % ('', '', ''),
            """Field 'model' used in context ({'stuff': parent.parent.model}) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="model"/>', ''),
            """Field 'model' used in context ({'stuff': parent.parent.model}) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '', '<field name="model"/>'),
            """Field 'model' used in context ({'stuff': parent.parent.model}) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_id_case(self):
        # id is read by default and should be usable in domains
        self.assertValid("""
            <form string="View">
                <field name="inherit_id" domain="[('id', '=', False)]"/>
            </form>
        """)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_boolean_case(self):
        arch = """
            <form string="View">
                %s
                <field name="inherit_id" domain="[(%s, '=', %s)]"/>
            </form>
        """
        self.assertValid(arch % ('', '1', '1'))
        self.assertValid(arch % ('', '0', '1'))
        # self.assertInvalid(arch % ('', '1', '0'))
        self.assertValid(arch % ('<field name="name"/>', '1', '0 if name else 1'))
        # self.assertInvalid(arch % ('<field name="name"/><field name="type"/>', "'tata' if name else 'tutu'", 'type'), 'xxxx')
        self.assertInvalid(
            arch % ('', '1', '0 if name else 1'),
            """Field 'name' used in domain of <field name="inherit_id"> ([(1, '=', 0 if name else 1)]) must be present in view but is missing""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_in_view(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_id" domain="[('model', '=', model)]"/>
            </form>
        """
        self.assertValid(arch % '<field name="model"/>')
        self.assertInvalid(
            arch % '',
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', model)]) must be present in view but is missing.""",
        )

    def test_domain_unknown_field(self):
        self.assertInvalid("""
                <form string="View">
                    <field name="name"/>
                    <field name="inherit_id" domain="[('invalid_field', '=', 'res.users')]"/>
                </form>
            """,
            '''Unknown field "ir.ui.view.invalid_field" in domain of <field name="inherit_id"> ([('invalid_field', '=', 'res.users')])''',
        )

    def test_domain_field_searchable(self):
        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" domain="[('%s', '=', 'test')]"/>
            </form>
        """
        # computed field with a search method
        self.assertValid(arch % 'model_data_id')
        # computed field, not stored, no search
        self.assertInvalid(
            arch % 'xml_id',
            '''Unsearchable field 'xml_id' in path 'xml_id' in domain of <field name="inherit_id"> ([('xml_id', '=', 'test')])''',
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_field_no_comodel(self):
        self.assertInvalid("""
            <form string="View">
                <field name="name" domain="[('test', '=', 'test')]"/>
            </form>
        """, "Domain on non-relational field \"name\" makes no sense (domain:[('test', '=', 'test')])")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_in_subview(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id" domain="[('model', '=', model)]"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('', '<field name="model"/>'))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', model)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('<field name="model"/>', ''),
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_in_subview_with_parent(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id" domain="[('model', '=', parent.model)]"/>
                    </form>
                </field>%s
            </form>
        """
        self.assertValid(arch % ('<field name="model"/>', '', ''))
        self.assertValid(arch % ('', '', '<field name="model"/>'))
        self.assertInvalid(
            arch % ('', '', ''),
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', parent.model)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="model"/>', ''),
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', parent.model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_field_in_view(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', model)]")

        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_id"/>
            </form>
        """
        self.assertValid(arch % '<field name="model"/>')
        self.assertInvalid(
            arch % '',
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_field_in_subview(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', model)]")

        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('', '<field name="model"/>'))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', model)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('<field name="model"/>', ''),
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_field_in_subview_with_parent(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', parent.model)]")

        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('<field name="model"/>', ''))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', parent.model)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="model"/>'),
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', parent.model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_field_in_noneditable_subview(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', model)]")

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_children_ids">
                    <tree string="Children"%s>
                        <field name="name"/>
                        <field name="inherit_id"/>
                    </tree>
                </field>
            </form>
        """
        self.assertValid(arch % '')
        self.assertInvalid(
            arch % ' editable="bottom"',
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_readonly_field_in_view(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', model)]")

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" readonly="1"/>
            </form>
        """
        self.assertValid(arch)

        self.patch(field, 'readonly', True)
        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_id"/>
            </form>
        """
        self.assertValid(arch)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_on_readonly_field_in_subview(self):
        field = self.env['ir.ui.view']._fields['inherit_id']
        self.patch(field, 'domain', "[('model', '=', model)]")

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="inherit_children_ids"%s>
                    <form string="Children">
                        <field name="name"/>
                        <field name="inherit_id"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ' readonly="1"')
        self.assertInvalid(
            arch % '',
            """Field 'model' used in domain of python field 'inherit_id' ([('model', '=', model)]) must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_in_filter(self):
        arch = """
            <search string="Search">
                <field name="%s"/>
                <filter string="Dummy" name="draft" domain="[('%s', '=', 'dummy')]"/>
            </search>
        """
        self.assertValid(arch % ('name', 'name'))
        self.assertValid(arch % ('name', 'inherit_children_ids.name'))
        self.assertInvalid(
            arch % ('invalid_field', 'name'),
            'Field "invalid_field" does not exist in model "ir.ui.view"',
        )
        self.assertInvalid(
            arch % ('name', 'invalid_field'),
            """Unknown field "ir.ui.view.invalid_field" in domain of <filter name="draft"> ([('invalid_field', '=', 'dummy')])""",
        )
        self.assertInvalid(
            arch % ('name', 'inherit_children_ids.invalid_field'),
            """Unknown field "ir.ui.view.invalid_field" in domain of <filter name="draft"> ([('inherit_children_ids.invalid_field', '=', 'dummy')])""",
        )
        # todo add check for non searchable fields and group by

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_group_by_in_filter(self):
        arch = """
            <search string="Search">
                <filter string="Date" name="month" domain="[]" context="{'group_by':'%s'}"/>
            </search>
        """
        self.assertValid(arch % 'name')
        self.assertInvalid(
            arch % 'invalid_field',
            """Unknown field "invalid_field" in "group_by" value in context="{'group_by':'invalid_field'}""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_domain_invalid_in_filter(self):
        # invalid domain: it should be a list of tuples
        self.assertInvalid(
            """ <search string="Search">
                    <filter string="Dummy" name="draft" domain="['name', '=', 'dummy']"/>
                </search>
            """,
            '''Invalid domain of <filter name="draft">: "['name', '=', 'dummy']"''',
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_searchpanel(self):
        arch = """
            <search>
                %s
                <searchpanel>
                    %s
                    <field name="groups_id" select="multi" domain="[('%s', '=', %s)]" enable_counters="1"/>
                </searchpanel>
            </search>
        """
        self.assertValid(arch % ('', '<field name="inherit_id"/>', 'view_access', 'inherit_id'))
        self.assertInvalid(
            arch % ('<field name="inherit_id"/>', '', 'view_access', 'inherit_id'),
            """Field 'inherit_id' used in domain of <field name="groups_id"> ([('view_access', '=', inherit_id)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="inherit_id"/>', 'view_access', 'view_access'),
            """Field 'view_access' used in domain of <field name="groups_id"> ([('view_access', '=', view_access)]) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="inherit_id"/>', 'inherit_id', 'inherit_id'),
            """Unknown field "res.groups.inherit_id" in domain of <field name="groups_id"> ([('inherit_id', '=', inherit_id)])""",
        )
        self.assertInvalid(
            arch % ('', '<field name="inherit_id" select="multi"/>', 'view_access', 'inherit_id'),
            """Field 'inherit_id' used in domain of <field name="groups_id"> ([('view_access', '=', inherit_id)]) is present in view but is in select multi.""",
        )

        arch = """
            <search>
                <searchpanel>
                    <field name="inherit_id" enable_counters="1"/>
                </searchpanel>
                <searchpanel>
                    <field name="inherit_id" enable_counters="1"/>
                </searchpanel>
            </search>
        """
        self.assertInvalid(arch, "Search tag can only contain one search panel")

    def test_groups_field(self):
        arch = """
            <form string="View">
                <field name="name" groups="%s"/>
            </form>
        """
        self.assertValid(arch % 'base.group_no_one')
        self.assertWarning(arch % 'base.dummy')

    def test_attrs_groups_behavior(self):
        view = self.View.create({
            'name': 'foo',
            'model': 'res.partner',
            'arch': """
                <form>
                    <field name="name"/>
                    <field name="company_id" groups="base.group_system"/>
                    <div id="foo"/>
                    <div id="bar" groups="base.group_system"/>
                </form>
            """,
        })
        user_demo = self.user_demo
        # Make sure demo doesn't have the base.group_system
        self.assertFalse(self.env['res.partner'].with_user(user_demo).env.user.has_group('base.group_system'))
        arch = self.env['res.partner'].with_user(user_demo).get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        self.assertTrue(tree.xpath('//field[@name="name"]'))
        self.assertFalse(tree.xpath('//field[@name="company_id"]'))
        self.assertTrue(tree.xpath('//div[@id="foo"]'))
        self.assertFalse(tree.xpath('//div[@id="bar"]'))

        user_admin = self.env.ref('base.user_admin')
        # Make sure admin has the base.group_system
        self.assertTrue(self.env['res.partner'].with_user(user_admin).env.user.has_group('base.group_system'))
        arch = self.env['res.partner'].with_user(user_admin).get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        self.assertTrue(tree.xpath('//field[@name="name"]'))
        self.assertTrue(tree.xpath('//field[@name="company_id"]'))
        self.assertTrue(tree.xpath('//div[@id="foo"]'))
        self.assertTrue(tree.xpath('//div[@id="bar"]'))

    def test_attrs_groups_validation(self):
        def validate(arch, valid=False, parent=False):
            parent = 'parent.' if parent else ''
            if valid:
                self.assertValid(arch % {'attrs': f"""invisible="{parent}name == 'foo'" """})
                self.assertValid(arch % {'attrs': f"""domain="[('name', '!=', {parent}name)]" """})
                self.assertValid(arch % {'attrs': f"""context="{{'default_name': {parent}name}}" """})
                self.assertValid(arch % {'attrs': f"""decoration-info="{parent}name == 'foo'" """})
            else:
                self.assertInvalid(
                    arch % {'attrs': f"""invisible="{parent}name == 'foo'" """},
                    f"""Field 'name' used in modifier 'invisible' ({parent}name == 'foo') is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""domain="[('name', '!=', {parent}name)]" """},
                    f"""Field 'name' used in domain of <field name="inherit_id"> ([('name', '!=', {parent}name)]) is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""context="{{'default_name': {parent}name}}" """},
                    f"""Field 'name' used in context ({{'default_name': {parent}name}}) is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""decoration-info="{parent}name == 'foo'" """},
                    f"""Field 'name' used in decoration-info="{parent}name == 'foo'" is restricted to the group(s)""",
                )


        # Assert using a field restricted to a group
        # in another field without the same group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field without the same group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field with the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field available for everyone
        # in a child field restricted to a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a field available for everyone
        # in another field restricted to a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" %(attrs)s groups="base.group_system"/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a group
        # in another field with the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available twice for 2 diffent groups
        # in another field restricted to one of the 2 groups is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_portal"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a group only
        # in other fields restricted to at least one different group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field available twice for 2 different groups
        # in other fields restricted to the same 2 group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="name" groups="base.group_portal"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available for 2 diffent groups,
        # in another field restricted to one of the 2 groups is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_portal,base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available for 1 group only
        # in another field restricted 2 groups is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_portal,base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to a group
        # in another field restricted to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a parent field restricted to a group
        # in a child field restricted to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a field restricted to a group
        # in another field restricted to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_erp_manager" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field restricted to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_erp_manager" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a field within a block restricted to a group
        # in another field not restricted to the same group is invalid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field within a block restricted to a group
        # in another field within the same block restricted to a group is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within the same block restricted to a group and additional groups on the field node is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                    <field name="inherit_id" %(attrs)s groups="base.group_multi_currency,base.group_multi_company"/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to the same group is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <group groups="base.group_system">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to a group including the group for which the field is available
        # is valid
        validate("""
            <form string="View">
                <group groups="base.group_erp_manager">
                    <field name="name"/>
                </group>
                <group groups="base.group_system">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to a group not including the group for which the field is available
        # is invalid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <group groups="base.group_erp_manager">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted to the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids" groups="base.group_system">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted
        # to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_children_ids" groups="base.group_system">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted
        # to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids" groups="base.group_erp_manager">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a field restricted to users not having a group
        # in another field not restricted to any group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field not restricted to any group
        # in another field restricted to users not having a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to users not having multiple groups
        # in another field restricted to users not having one of the group only is invalid
        # e.g.
        # if the user is portal, the field "name" will not be in the view
        # but the field "inherit_id" where "name" is used will be in the view
        # making it invalid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system,!base.group_portal"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to users not having a group
        # in another field restricted to users not having multiple group including the one above is valid
        # e.g.
        # if the user is portal, the field "name" will be in the view
        # but the field "inherit_id" where "name" is used will not be in the view
        # making it valid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_user"/>
                <field name="inherit_id" groups="!base.group_user,!base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a non group
        # in another field for which the non group is not implied is invalid
        # e.g.
        # if the user is employee, the field "name" will not be in the view
        # but the field "inherit_id" where "name" is used will be in the view,
        # making it invalid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_user"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to a non group
        # in another field restricted to a non group implied in the non group of the available field is valid
        # e.g.
        # if the user is employee, the field "name" will be in the view
        # but the field "inherit_id", where "name" is used, will not be in the view,
        # therefore making it valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="inherit_id" groups="!base.group_user" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to non-admins, itself in a block restricted to employees,
        # in another field restricted to a block restricted to employees
        # is invalid
        # e.g.
        # if the user is admin, the field "name" will not be in the view
        # but the field "inherit_id", where "name" is used, will be in the view,
        # threfore making it invalid
        validate("""
            <form string="View">
                <group groups="base.group_user">
                    <field name="name" groups="!base.group_system"/>
                </group>
                <group groups="base.group_user">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=False)

        # Assert using a field restricted to a group
        # in another field restricted the opposite group is invalid
        # e.g.
        # if the user is admin, the field "name" will be in the view
        # but the field "inherit_id", where "name" is used, will not be in the view,
        # therefore making it invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field without any group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field using the group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field using the !group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field restricted to any other group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a 'base.group_no_one' in another
        # field with a group implied 'base.group_no_one' is invalid. The group
        # 'base.group_no_one' must be in the view because it's depending of the
        # session.
        validate("""
            <form string="View">
                <field name="name" groups="base.group_no_one"/>
                <field name="inherit_id" %(attrs)s groups="base.group_user"/>
            </form>
        """, valid=False)
        validate("""
            <form string="View">
                <field name="name" groups="base.group_no_one"/>
                <group groups="base.group_no_one">
                    <field name="inherit_id" %(attrs)s groups="base.group_user"/>
                </group>
            </form>
        """, valid=True)

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_empty_groups_attrib(self):
        """Ensure we allow empty groups attribute"""
        view = self.View.create({
            'name': 'foo',
            'model': 'res.partner',
            'arch': """
                <form>
                    <field name="name" groups="" />
                </form>
            """,
        })
        arch = self.env['res.partner'].get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        nodes = tree.xpath("//field[@name='name' and not (@groups)]")
        self.assertEqual(1, len(nodes))

    def test_invisible_groups_with_groups_in_model(self):
        """Tests the attrs is well processed to modifiers for a field node combining:
        - a `groups` attribute on the field node in the view architecture
        - a `groups` attribute on the field in the Python model
        This is an edge case and it worths a unit test."""
        self.patch(type(self.env['res.partner']).name, 'groups', 'base.group_system')
        self.env.user.groups_id += self.env.ref('base.group_multi_company')
        view = self.View.create({
            'name': 'foo',
            'model': 'res.partner',
            'arch': """
                <form>
                    <field name="active"/>
                    <field name="name" groups="base.group_multi_company" invisible="active"/>
                </form>
            """,
        })
        arch = self.env['res.partner'].get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        node_field_name = tree.xpath('//field[@name="name"]')[0]
        self.assertEqual(node_field_name.get('invisible'), "active")

    def test_button(self):
        arch = """
            <form>
                <button type="object" name="%s"/>
            </form>
        """
        self.assertValid(arch % 'action_archive', name='valid button name')
        self.assertInvalid(
            arch % 'wtfzzz', 'wtfzzz is not a valid action on ir.ui.view',
            name='button name is not even a method',
        )
        self.assertInvalid(
            arch % '_check_xml',
            '_check_xml on ir.ui.view is private and cannot be called from a button',
            name='button name is a private method',
        )
        self.assertWarning(arch % 'postprocess_and_fields', name='button name is a method that requires extra arguments')
        arch = """
            <form>
                <button type="action" name="%s"/>
            </form>
        """
        self.assertInvalid(arch % 0, 'Action 0 (id: 0) does not exist for button of type action.')
        self.assertInvalid(arch % 'base.random_xmlid', 'Invalid xmlid base.random_xmlid for button of type action')
        self.assertInvalid('<form><button type="action"/></form>', 'Button must have a name')
        self.assertInvalid('<form><button special="dummy"/></form>', "Invalid special 'dummy' in button")
        self.assertInvalid(arch % 'base.partner_root', "base.partner_root is of type res.partner, expected a subclass of ir.actions.actions")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_tree(self):
        arch = """
            <tree>
                <field name="name"/>
                <button type='object' name="action_archive"/>
                %s
            </tree>
        """
        self.assertValid(arch % '')
        self.assertInvalid(arch % '<group/>', "Tree child can only have one of field, button, control, groupby, widget, header tag (not group)")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_tree_groupby(self):
        arch = """
            <tree>
                <field name="name"/>
                <groupby name="%s">
                    <button type="object" name="action_archive"/>
                </groupby>
            </tree>
        """
        self.assertValid(arch % ('model_data_id'))
        self.assertInvalid(arch % ('type'), "Field 'type' found in 'groupby' node can only be of type many2one, found selection")
        self.assertInvalid(arch % ('dummy'), "Field 'dummy' found in 'groupby' node does not exist in model ir.ui.view")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_tree_groupby_many2one(self):
        arch = """
            <tree>
                <field name="name"/>
                %s
                <groupby name="model_data_id">
                    %s
                    <button type="object" name="action_archive" invisible="noupdate" string="Button1"/>
                </groupby>
            </tree>
        """
        self.assertValid(arch % ('', '<field name="noupdate"/>'))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'noupdate' used in modifier 'invisible' (noupdate) must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('<field name="noupdate"/>', ''),
            '''Field "noupdate" does not exist in model "ir.ui.view"''',
        )
        self.assertInvalid(
            arch % ('', '<field name="noupdate"/><field name="fake_field"/>'),
            '''Field "fake_field" does not exist in model "ir.model.data"''',
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_check_xml_on_reenable(self):
        view1 = self.View.create({
            'name': 'valid _check_xml',
            'model': 'ir.ui.view',
            'arch': """
                <form string="View">
                    <field name="name"/>
                </form>
            """,
        })
        view2 = self.View.create({
            'name': 'valid _check_xml',
            'model': 'ir.ui.view',
            'inherit_id': view1.id,
            'active': False,
            'arch': """
                <field name="foo" position="after">
                    <field name="bar"/>
                </field>
            """
        })
        with self.assertRaises(ValidationError):
            view2.active = True

        # Re-enabling the view and correcting it at the same time should not raise the `_check_xml` constraint.
        view2.write({
            'active': True,
            'arch': """
                <field name="name" position="after">
                    <span>bar</span>
                </field>
            """,
        })

    def test_for_in_label(self):
        self.assertValid('<form><field name="model"/><label for="model"/></form>')
        self.assertInvalid(
            '<form><field name="model"/><label/></form>',
            """Label tag must contain a "for". To match label style without corresponding field or button, use 'class="o_form_label"'""",
        )
        self.assertInvalid(
            '<form><label for="model"/></form>',
            """Name or id 'model' in <label for="..."> must be present in view but is missing.""",
        )

    def test_col_colspan_numerical(self):
        self.assertValid('<form><group col="5"></group></form>')
        self.assertInvalid(
            '<form><group col="alpha"></group></form>',
            "'col' value must be an integer (alpha)",
        )
        self.assertValid('<form><div colspan="5"></div></form>')
        self.assertInvalid(
            '<form><div colspan="alpha"></div></form>',
            "'colspan' value must be an integer (alpha)",
        )

    def test_valid_alerts(self):
        self.assertValid('<form><div class="alert alert-success" role="alert"/></form>')
        self.assertValid('<form><div class="alert alert-success" role="alertdialog"/></form>')
        self.assertValid('<form><div class="alert alert-success" role="status"/></form>')
        self.assertWarning('<form><div class="alert alert-success"/></form>')

    def test_valid_prohibited_none_role(self):
        self.assertWarning('<form><div role="none"/></form>')
        self.assertWarning('<form><div role="presentation"/></form>')

    def test_valid_alternative_image_text(self):
        self.assertValid('<form><img src="a" alt="a image"></img></form>')
        self.assertWarning('<form><img src="a"></img></form>')

    def test_valid_accessibility_icon_text(self):
        self.assertWarning(
            '<form><span class="fa fa-warning"/></form>',
            'A <span> with fa class (fa fa-warning) must have title in its tag, parents, descendants or have text'
        )
        self.assertWarning(
            '<form><button icon="fa-warning"/></form>',
            'A button with icon attribute (fa-warning) must have title in its tag, parents, descendants or have text'
        )
        self.assertValid('<form><button icon="fa-warning"/>text</form>')
        self.assertValid('<form><span class="fa fa-warning"/>text</form>')
        self.assertValid('<form>text<span class="fa fa-warning"/></form>')
        self.assertValid('<form><span class="fa fa-warning">text</span></form>')
        self.assertValid('<form><span title="text" class="fa fa-warning"/></form>')
        self.assertValid('<form><span aria-label="text" class="fa fa-warning"/></form>')

    def test_valid_simili_button(self):
        self.assertWarning('<form><a class="btn"/></form>')
        self.assertValid('<form><a class="btn" role="button"/></form>')

    def test_valid_dialog(self):
        self.assertWarning('<form><div class="modal"/></form>')
        self.assertValid('<form><div role="dialog" class="modal"></div></form>')
        self.assertWarning('<form><div class="modal-header"/></form>')
        self.assertValid('<form><header class="modal-header"/></form>')
        self.assertWarning('<form><div class="modal-footer"/></form>')
        self.assertValid('<form><footer class="modal-footer"/></form>')
        self.assertWarning('<form><div class="modal-body"/></form>')
        self.assertValid('<form><main class="modal-body"/></form>')

    def test_valid_simili_dropdown(self):
        self.assertValid('<form><ul class="dropdown-menu" role="menu"></ul></form>')
        self.assertWarning('<form><ul class="dropdown-menu"></ul></form>')

    def test_valid_simili_progressbar(self):
        self.assertValid('<form><div class="o_progressbar" role="progressbar" aria-valuenow="14" aria-valuemin="0" aria-valuemax="100">14%</div></form>')
        self.assertWarning('<form><div class="o_progressbar" aria-valuenow="14" aria-valuemin="0" aria-valuemax="100">14%</div></form>')
        self.assertWarning('<form><div class="o_progressbar" role="progressbar" aria-valuemin="0" aria-valuemax="100">14%</div></form>')
        self.assertWarning('<form><div class="o_progressbar" role="progressbar" aria-valuenow="14" aria-valuemax="100">14%</div></form>')
        self.assertWarning('<form><div class="o_progressbar" role="progressbar" aria-valuenow="14" aria-valuemin="0" >14%</div></form>')

    def test_valid_simili_tabpanel(self):
        self.assertValid('<form><div class="tab-pane" role="tabpanel"/></form>')
        self.assertWarning('<form><div class="tab-pane"/></form>')

    def test_valid_simili_tablist(self):
        self.assertValid('<form><div class="nav-tabs" role="tablist"/></form>')
        self.assertWarning('<form><div class="nav-tabs"/></form>')

    def test_valid_simili_tab(self):
        self.assertValid('<form><a data-bs-toggle="tab" role="tab" aria-controls="test"/></form>')
        self.assertWarning('<form><a data-bs-toggle="tab" aria-controls="test"/></form>')
        self.assertWarning('<form><a data-bs-toggle="tab" role="tab"/></form>')
        self.assertWarning('<form><a data-bs-toggle="tab" role="tab" aria-controls="#test"/></form>')

    def test_valid_focusable_button(self):
        self.assertValid('<form><a class="btn" role="button"/></form>')
        self.assertValid('<form><button class="btn" role="button"/></form>')
        self.assertValid('<form><select class="btn" role="button"/></form>')
        self.assertValid('<form><input type="button" class="btn" role="button"/></form>')
        self.assertValid('<form><input type="submit" class="btn" role="button"/></form>')
        self.assertValid('<form><input type="reset" class="btn" role="button"/></form>')
        self.assertValid('<form><div type="reset" class="btn btn-group" role="button"/></form>')
        self.assertValid('<form><div type="reset" class="btn btn-toolbar" role="button"/></form>')
        self.assertValid('<form><div type="reset" class="btn btn-addr" role="button"/></form>')
        self.assertWarning('<form><div class="btn" role="button"/></form>')
        self.assertWarning('<form><input type="email" class="btn" role="button"/></form>')

    def test_partial_validation(self):
        self.View = self.View.with_context(load_all_views=True)

        # base view
        view0 = self.assertValid("""
            <form string="View">
                <field name="model"/>
                <field name="inherit_id" domain="[('model', '=', model)]"/>
            </form>
        """)

        # added elements should be validated
        self.assertInvalid(
            """<form position="inside">
                <field name="groups_id" domain="[('invalid_field', '=', 'dummy')]"/>
            </form>""",
            """Unknown field "res.groups.invalid_field" in domain of <field name="groups_id"> ([('invalid_field', '=', 'dummy')]))""",
            inherit_id=view0.id,
        )
        view1 = self.assertValid(
            """<form position="inside">
                <field name="name"/>
            </form>""",
            inherit_id=view0.id,
        )
        view2 = self.assertValid(
            """<form position="inside">
                <field name="groups_id" domain="[('name', '=', name)]"/>
                <label for="groups_id"/>
            </form>""",
            inherit_id=view1.id,
        )

        # modifying attributes should validate the target element
        self.assertInvalid(
            """<field name="inherit_id" position="attributes">
                <attribute name="domain">[('invalid_field', '=', 'dummy')]</attribute>
            </field>""",
            """Unknown field "ir.ui.view.invalid_field" in domain of <field name="inherit_id"> ([('invalid_field', '=', 'dummy')]))""",
            inherit_id=view0.id,
        )

        # replacing an element should validate the whole view
        self.assertInvalid(
            """<field name="model" position="replace"/>""",
            """Field 'model' used in domain of <field name="inherit_id"> ([('model', '=', model)]) must be present in view but is missing.""",
            inherit_id=view0.id,
        )

        # moving an element should have no impact; this test checks that the
        # implementation does not flag the inner element to be validated, which
        # prevents to locate the corresponding element inside the arch
        self.assertValid(
            """<field name="groups_id" position="before">
                <label for="groups_id" position="move"/>
            </field>""",
            inherit_id=view2.id,
        )

        # modifying a view extension should validate the other views
        with mute_logger('odoo.addons.base.models.ir_ui_view'):
            with self.assertRaises(ValidationError):
                with self.cr.savepoint():
                    view1.arch = """<form position="inside">
                        <field name="type"/>
                    </form>"""

    def test_graph_fields(self):
        self.assertValid('<graph string="Graph"><field name="model" type="row"/><field name="inherit_id" type="measure"/></graph>')
        self.assertInvalid(
            '<graph string="Graph"><label for="model"/><field name="model" type="row"/><field name="inherit_id" type="measure"/></graph>',
            'A <graph> can only contains <field> nodes, found a <label>'
        )

    def test_graph_attributes(self):
        self.assertValid('<graph string="Graph" cumulated="1" ><field name="model" type="row"/><field name="inherit_id" type="measure"/></graph>')

    def test_view_ref(self):
        view = self.assertValid(
            """
                <form>
                    <field name="groups_id" class="canary"/>
                </form>
            """
        )
        self.env["ir.model.data"].create({
            'module': 'base',
            'name': 'test_views_test_view_ref',
            'model': 'ir.ui.view',
            'res_id': view.id,
        })
        view_data = self.env['ir.ui.view'].with_context(form_view_ref='base.test_views_test_view_ref').get_view()
        self.assertEqual(view.id, view_data['id'], "The view returned should be test_views_test_view_ref")
        view_data = self.env['ir.ui.view'].with_context(form_view_ref='base.test_views_test_view_ref').get_view(view.id)
        tree = etree.fromstring(view_data['arch'])
        field_groups_id = tree.xpath('//field[@name="groups_id"]')[0]
        self.assertEqual(
            len(field_groups_id.xpath(".//*[@class='canary']")),
            0,
            "The view test_views_test_view_ref should not be in the views of the many2many field groups_id"
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_forbidden_owl_directives_in_form(self):
        arch = "<form>%s</form>"

        self.assertInvalid(
            arch % ('<span t-esc="x"/>'),
            """Error while validating view near:

<form __validate__="1"><span t-esc="x"/></form>
Forbidden owl directive used in arch (t-esc).""",
        )

        self.assertInvalid(
            arch % ('<span t-on-click="x.doIt()"/>'),
            """Error while validating view near:

<form __validate__="1"><span t-on-click="x.doIt()"/></form>
Forbidden owl directive used in arch (t-on-click).""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_forbidden_owl_directives_in_kanban(self):
        arch = "<kanban><templates><t t-name='kanban-box'>%s</t></templates></kanban>"

        self.assertValid(arch % ('<span t-esc="record.resId"/>'))
        self.assertValid(arch % ('<t t-debug=""/>'))

        self.assertInvalid(
            arch % ('<span t-on-click="x.doIt()"/>'),
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><span t-on-click="x.doIt()"/></t></templates></kanban>
Forbidden owl directive used in arch (t-on-click).""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_forbidden_data_tooltip_attributes_in_form(self):
        arch = "<form>%s</form>"

        self.assertInvalid(
            arch % ('<span data-tooltip="Test"/>'),
            """Error while validating view near:

<form __validate__="1"><span data-tooltip="Test"/></form>
Forbidden attribute used in arch (data-tooltip)."""
        )

        self.assertInvalid(
            arch % ('<span data-tooltip-template="test"/>'),
            """Error while validating view near:

<form __validate__="1"><span data-tooltip-template="test"/></form>
Forbidden attribute used in arch (data-tooltip-template)."""
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_forbidden_data_tooltip_attributes_in_kanban(self):
        arch = "<kanban><templates><t t-name='kanban-box'>%s</t></templates></kanban>"

        self.assertInvalid(
            arch % ('<span data-tooltip="Test"/>'),
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><span data-tooltip="Test"/></t></templates></kanban>
Forbidden attribute used in arch (data-tooltip)."""
        )

        self.assertInvalid(
            arch % ('<span data-tooltip-template="test"/>'),
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><span data-tooltip-template="test"/></t></templates></kanban>
Forbidden attribute used in arch (data-tooltip-template)."""
        )

        self.assertInvalid(
            arch % ('<span t-att-data-tooltip="test"/>'),
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><span t-att-data-tooltip="test"/></t></templates></kanban>
Forbidden attribute used in arch (t-att-data-tooltip)."""
        )

        self.assertInvalid(
            arch % ('<span t-attf-data-tooltip-template="{{ test }}"/>'),
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><span t-attf-data-tooltip-template="{{ test }}"/></t></templates></kanban>
Forbidden attribute used in arch (t-attf-data-tooltip-template)."""
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_forbidden_use_of___comp___in_kanban(self):
        arch = "<kanban><templates><t t-name='kanban-box'>%s</t></templates></kanban>"
        self.assertInvalid(
            arch % '<t t-esc="__comp__.props.resId"/>',
            """Error while validating view near:

<kanban __validate__="1"><templates><t t-name="kanban-box"><t t-esc="__comp__.props.resId"/></t></templates></kanban>
Forbidden use of `__comp__` in arch."""
        )


@tagged('post_install', '-at_install')
class TestDebugger(common.TransactionCase):
    def test_t_debug_in_qweb_based_views(self):
        View = self.env['ir.ui.view']
        views_with_t_debug = View.search([["arch_db", "like", "t-debug="]])
        self.assertEqual([v.xml_id for v in views_with_t_debug], [])


class TestViewTranslations(common.TransactionCase):
    # these tests are essentially the same as in test_translate.py, but they use
    # the computed field 'arch' instead of the translated field 'arch_db'

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.env['res.lang']._activate_lang('fr_FR')
        cls.env['res.lang']._activate_lang('nl_NL')
        cls.env['ir.module.module']._load_module_terms(['base'], ['fr_FR', 'nl_NL'])

    def create_view(self, archf, terms, **kwargs):
        view = self.env['ir.ui.view'].create({
            'name': 'test',
            'model': 'res.partner',
            'arch': archf % terms,
        })
        # DLE P70: `_sync_terms_translations`, which delete translations for which there is no value, is called sooner than before
        # because it's called in `_write`, which is called by `flush`, which is called by the `search`.
        # `arch_db` is in `_write` instead of `create` because `arch_db` is the inverse of `arch`.
        # We need to flush `arch_db` before creating the translations otherwise the translation for which there is no value will be deleted,
        # while the `test_sync_update` specifically needs empty translations
        self.env.flush_all()
        val = {'en_US': archf % terms}
        for lang, trans_terms in kwargs.items():
            val[lang] = archf % trans_terms
        query = "UPDATE ir_ui_view SET arch_db = %s WHERE id = %s"
        self.env.cr.execute(query, [Json(val), view.id])
        self.env.invalidate_all()
        return view

    def test_sync(self):
        """ Check translations of 'arch' after minor change in source terms. """
        archf = '<form string="X">%s</form>'
        terms_en = ('Bread and cheeze',)
        terms_fr = ('Pain et fromage',)
        terms_nl = ('Brood and kaas',)
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_nl)

        # modify source term in view (fixed type in 'cheeze')
        terms_en = ('Bread and cheese',)
        view.with_env(env_en).write({'arch': archf % terms_en})

        # check whether translations have been synchronized
        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_nl)

        view = self.create_view(archf, terms_fr, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)
        # modify source term in view in another language with close term
        new_terms_fr = ('Pains et fromage',)
        view.with_env(env_fr).write({'arch': archf % new_terms_fr})

        # check whether translations have been synchronized
        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % new_terms_fr)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_nl)

    def test_sync_xml(self):
        """ Check translations of 'arch' after xml tags changes in source terms. """
        archf = '<form string="X">%s</form>'
        terms_en = ('Bread and cheese',)
        terms_fr = ('Pain et fromage',)
        terms_nl = ('Brood and kaas',)
        view = self.create_view(archf, terms_en, en_US=terms_en, fr_FR=terms_fr, nl_NL=terms_nl)

        env_nolang = self.env(context={})
        env_en = self.env(context={'lang': 'en_US'})
        env_fr = self.env(context={'lang': 'fr_FR'})
        env_nl = self.env(context={'lang': 'nl_NL'})

        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_nl)

        # modify source term in view (add css style)
        terms_en = ('Bread <span style="font-weight:bold">and</span> cheese',)
        view.with_env(env_en).write({'arch': archf % terms_en})

        # check whether translations have been kept
        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % terms_fr)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_nl)

        # modify source term in view (actual text change)
        terms_en = ('Bread <span style="font-weight:bold">and</span> butter',)
        view.with_env(env_en).write({'arch': archf % terms_en})

        # check whether translations have been reset
        self.assertEqual(view.with_env(env_nolang).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_en).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_fr).arch, archf % terms_en)
        self.assertEqual(view.with_env(env_nl).arch, archf % terms_en)

    def test_sync_update(self):
        """ Check translations after major changes in source terms. """
        archf = '<form string="X"><div>%s</div><div>%s</div></form>'
        terms_src = ('Subtotal', 'Subtotal:')
        terms_en = ('', 'Sub total:')
        view = self.create_view(archf, terms_src, en_US=terms_en)

        # modifying the arch should sync existing translations without errors
        new_arch = archf % ('Subtotal', 'Subtotal : <br/>')
        view.write({"arch": new_arch})
        self.assertEqual(view.arch, new_arch)

    def test_cache_consistency(self):
        view = self.env["ir.ui.view"].create({
            "name": "test_translate_xml_cache_invalidation",
            "model": "res.partner",
            "arch": "<form><b>content</b></form>",
        })
        view_fr = view.with_context({"lang": "fr_FR"})
        self.assertIn("<b>", view.arch_db)
        self.assertIn("<b>", view.arch)
        self.assertIn("<b>", view_fr.arch_db)
        self.assertIn("<b>", view_fr.arch)

        # write with no lang, and check consistency in other languages
        view.write({"arch": "<form><i>content</i></form>"})
        self.assertIn("<i>", view.arch_db)
        self.assertIn("<i>", view.arch)
        self.assertIn("<i>", view_fr.arch_db)
        self.assertIn("<i>", view_fr.arch)


class ViewModeField(ViewCase):
    """
    This should probably, eventually, be folded back into other test case
    classes, integrating the test (or not) of the mode field to regular cases
    """

    def testModeImplicitValue(self):
        """ mode is auto-generated from inherit_id:
        * inherit_id -> mode=extension
        * not inherit_id -> mode=primary
        """
        view = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>'
        })
        self.assertEqual(view.mode, 'primary')

        view2 = self.View.create({
            'inherit_id': view.id,
            'arch': '<qweb/>'
        })
        self.assertEqual(view2.mode, 'extension')

        view2.write({'inherit_id': None})
        self.assertEqual(view2.mode, 'primary')

        view2.write({'inherit_id': view.id})
        self.assertEqual(view2.mode, 'extension')

    @mute_logger('odoo.sql_db')
    def testModeExplicit(self):
        view = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>'
        })
        view2 = self.View.create({
            'inherit_id': view.id,
            'mode': 'primary',
            'arch': '<qweb/>'
        })
        self.assertEqual(view.mode, 'primary')
        self.assertEqual(view2.mode, 'primary')

        with self.assertRaises(IntegrityError):
            self.View.create({
                'inherit_id': None,
                'mode': 'extension',
                'arch': '<qweb/>'
            })

    @mute_logger('odoo.sql_db')
    def testPurePrimaryToExtension(self):
        """
        A primary view with inherit_id=None can't be converted to extension
        """
        view_pure_primary = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>'
        })
        with self.assertRaises(IntegrityError):
            view_pure_primary.write({'mode': 'extension'})
            view_pure_primary.env.flush_all()

    def testInheritPrimaryToExtension(self):
        """
        A primary view with an inherit_id can be converted to extension
        """
        base = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>',
        })
        view = self.View.create({
            'inherit_id': base.id,
            'mode': 'primary',
            'arch': '<qweb/>'
        })

        view.write({'mode': 'extension'})

    def testDefaultExtensionToPrimary(self):
        """
        An extension view can be converted to primary
        """
        base = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>',
        })
        view = self.View.create({
            'inherit_id': base.id,
            'arch': '<qweb/>'
        })

        view.write({'mode': 'primary'})

    def testChangeInheritOfPrimary(self):
        """
        A primary view with an inherit_id must remain primary when changing the inherit_id
        """
        base1 = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>',
        })
        base2 = self.View.create({
            'inherit_id': None,
            'arch': '<qweb/>',
        })
        view = self.View.create({
            'mode': 'primary',
            'inherit_id': base1.id,
            'arch': '<qweb/>',
        })
        self.assertEqual(view.mode, 'primary')
        view.write({'inherit_id': base2.id})
        self.assertEqual(view.mode, 'primary')


class TestDefaultView(ViewCase):
    def testDefaultViewBase(self):
        self.View.create({
            'inherit_id': False,
            'priority': 10,
            'mode': 'primary',
            'arch': '<qweb/>',
        })
        view2 = self.View.create({
            'inherit_id': False,
            'priority': 1,
            'mode': 'primary',
            'arch': '<qweb/>',
        })

        default = self.View.default_view(False, 'qweb')
        self.assertEqual(
            default, view2.id,
            "default_view should get the view with the lowest priority for "
            "a (model, view_type) pair"
        )

    def testDefaultViewPrimary(self):
        view1 = self.View.create({
            'inherit_id': False,
            'priority': 10,
            'mode': 'primary',
            'arch': '<qweb/>',
        })
        self.View.create({
            'inherit_id': False,
            'priority': 5,
            'mode': 'primary',
            'arch': '<qweb/>',
        })
        view3 = self.View.create({
            'inherit_id': view1.id,
            'priority': 1,
            'mode': 'primary',
            'arch': '<qweb/>',
        })

        default = self.View.default_view(False, 'qweb')
        self.assertEqual(
            default, view3.id,
            "default_view should get the view with the lowest priority for "
            "a (model, view_type) pair in all the primary tables"
        )


class TestViewCombined(ViewCase):
    """
    * When asked for a view, instead of looking for the closest parent with
      inherit_id=False look for mode=primary
    * If root.inherit_id, resolve the arch for root.inherit_id (?using which
      model?), then apply root's inheritance specs to it
    * Apply inheriting views on top
    """

    def setUp(self):
        super(TestViewCombined, self).setUp()

        self.a1 = self.View.create({
            'model': 'a',
            'arch': '<qweb><a1/></qweb>'
        })
        self.a2 = self.View.create({
            'model': 'a',
            'inherit_id': self.a1.id,
            'priority': 5,
            'arch': '<xpath expr="//a1" position="after"><a2/></xpath>'
        })
        self.a3 = self.View.create({
            'model': 'a',
            'inherit_id': self.a1.id,
            'arch': '<xpath expr="//a1" position="after"><a3/></xpath>'
        })
        # mode=primary should be an inheritance boundary in both direction,
        # even within a model it should not extend the parent
        self.a4 = self.View.create({
            'model': 'a',
            'inherit_id': self.a1.id,
            'mode': 'primary',
            'arch': '<xpath expr="//a1" position="after"><a4/></xpath>',
        })

        self.b1 = self.View.create({
            'model': 'b',
            'inherit_id': self.a3.id,
            'mode': 'primary',
            'arch': '<xpath expr="//a1" position="after"><b1/></xpath>'
        })
        self.b2 = self.View.create({
            'model': 'b',
            'inherit_id': self.b1.id,
            'arch': '<xpath expr="//a1" position="after"><b2/></xpath>'
        })

        self.c1 = self.View.create({
            'model': 'c',
            'inherit_id': self.a1.id,
            'mode': 'primary',
            'arch': '<xpath expr="//a1" position="after"><c1/></xpath>'
        })
        self.c2 = self.View.create({
            'model': 'c',
            'inherit_id': self.c1.id,
            'priority': 5,
            'arch': '<xpath expr="//a1" position="after"><c2/></xpath>'
        })
        self.c3 = self.View.create({
            'model': 'c',
            'inherit_id': self.c2.id,
            'priority': 10,
            'arch': '<xpath expr="//a1" position="after"><c3/></xpath>'
        })

        self.d1 = self.View.create({
            'model': 'd',
            'inherit_id': self.b1.id,
            'mode': 'primary',
            'arch': '<xpath expr="//a1" position="after"><d1/></xpath>'
        })

    def test_basic_read(self):
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.a1.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.a1(),
                E.a3(),
                E.a2(),
            ), arch)

    def test_read_from_child(self):
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.a3.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.a1(),
                E.a3(),
                E.a2(),
            ), arch)

    def test_read_from_child_primary(self):
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.a4.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.a1(),
                E.a4(),
                E.a3(),
                E.a2(),
            ), arch)

    def test_cross_model_simple(self):
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.c2.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.a1(),
                E.c3(),
                E.c2(),
                E.c1(),
                E.a3(),
                E.a2(),
            ), arch)

    def test_cross_model_double(self):
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.d1.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.a1(),
                E.d1(),
                E.b2(),
                E.b1(),
                E.a3(),
                E.a2(),
            ), arch)

    def test_primary_after_extensions(self):
        # Here is a tricky use-case:                        a*
        #  - views a and d are primary                     / \
        #  - views b and c are extensions                 b   c
        #  - depth-first order is: a, b, d, c             |
        #  - combination order is: a, b, c, d             d*
        #
        # The arch of d has been chosen to fail if d is applied before c.
        # Because this child of 'b' is primary, it must be applied *after* the
        # other extensions of a!
        a = self.View.create({
            'model': 'a',
            'arch': '<qweb><a/></qweb>',
        })
        b = self.View.create({
            'model': 'a',
            'inherit_id': a.id,
            'arch': '<a position="after"><b/></a>'
        })
        c = self.View.create({  # pylint: disable=unused-variable
            'model': 'a',
            'inherit_id': a.id,
            'arch': '<a position="after"><c/></a>'
        })
        d = self.View.create({  # pylint: disable=unused-variable
            'model': 'a',
            'inherit_id': b.id,
            'mode': 'primary',
            'arch': '<a position="replace"/>',
        })


class TestOptionalViews(ViewCase):
    """
    Tests ability to enable/disable inherited views, formerly known as
    inherit_option_id
    """

    def setUp(self):
        super(TestOptionalViews, self).setUp()
        self.v0 = self.View.create({
            'model': 'a',
            'arch': '<qweb><base/></qweb>',
        })
        self.v1 = self.View.create({
            'model': 'a',
            'inherit_id': self.v0.id,
            'active': True,
            'priority': 10,
            'arch': '<xpath expr="//base" position="after"><v1/></xpath>',
        })
        self.v2 = self.View.create({
            'model': 'a',
            'inherit_id': self.v0.id,
            'active': True,
            'priority': 9,
            'arch': '<xpath expr="//base" position="after"><v2/></xpath>',
        })
        self.v3 = self.View.create({
            'model': 'a',
            'inherit_id': self.v0.id,
            'active': False,
            'priority': 8,
            'arch': '<xpath expr="//base" position="after"><v3/></xpath>'
        })

    def test_applied(self):
        """ mandatory and enabled views should be applied
        """
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.v0.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.base(),
                E.v1(),
                E.v2(),
            )
        )

    def test_applied_state_toggle(self):
        """ Change active states of v2 and v3, check that the results
        are as expected
        """
        self.v2.toggle_active()
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.v0.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.base(),
                E.v1(),
            )
        )

        self.v3.toggle_active()
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.v0.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.base(),
                E.v1(),
                E.v3(),
            )
        )

        self.v2.toggle_active()
        context = {'check_view_ids': self.View.search([]).ids}
        arch = self.v0.with_context(context).get_combined_arch()
        self.assertEqual(
            etree.fromstring(arch),
            E.qweb(
                E.base(),
                E.v1(),
                E.v2(),
                E.v3(),
            )
        )


class TestXPathExtentions(common.BaseCase):
    def test_hasclass(self):
        tree = E.node(
            E.node({'class': 'foo bar baz'}),
            E.node({'class': 'foo bar'}),
            {'class': "foo"})

        self.assertEqual(
            len(tree.xpath('//node[hasclass("foo")]')),
            3)
        self.assertEqual(
            len(tree.xpath('//node[hasclass("bar")]')),
            2)
        self.assertEqual(
            len(tree.xpath('//node[hasclass("baz")]')),
            1)
        self.assertEqual(
            len(tree.xpath('//node[hasclass("foo")][not(hasclass("bar"))]')),
            1)
        self.assertEqual(
            len(tree.xpath('//node[hasclass("foo", "baz")]')),
            1)


class TestQWebRender(ViewCase):

    def test_render(self):
        view1 = self.View.create({
            'name': "dummy",
            'type': 'qweb',
            'arch': """
                <t t-name="base.dummy">
                    <div><span>something</span></div>
                </t>
        """
        })
        view2 = self.View.create({
            'name': "dummy_ext",
            'type': 'qweb',
            'inherit_id': view1.id,
            'arch': """
                <xpath expr="//div" position="inside">
                    <span>another thing</span>
                </xpath>
            """
        })
        view3 = self.View.create({
            'name': "dummy_primary_ext",
            'type': 'qweb',
            'inherit_id': view1.id,
            'mode': 'primary',
            'arch': """
                <xpath expr="//div" position="inside">
                    <span>another primary thing</span>
                </xpath>
            """
        })

        # render view and child view with an id
        content1 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id])._render(view1.id)
        content2 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id])._render(view2.id)

        self.assertEqual(content1, content2)

        # render view and child view with an xmlid
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')" % view1.id)
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy_ext', 'ir.ui.view', %s, 'base')" % view2.id)

        content1 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id])._render('base.dummy')
        content2 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id])._render('base.dummy_ext')

        self.assertEqual(content1, content2)

        # render view and primary extension with an id
        content1 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id, view3.id])._render(view1.id)
        content3 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id, view3.id])._render(view3.id)

        self.assertNotEqual(content1, content3)

        # render view and primary extension with an xmlid
        self.env.cr.execute("INSERT INTO ir_model_data(name, model, res_id, module)"
                            "VALUES ('dummy_primary_ext', 'ir.ui.view', %s, 'base')" % view3.id)

        content1 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id, view3.id])._render('base.dummy')
        content3 = self.env['ir.qweb'].with_context(check_view_ids=[view1.id, view2.id, view3.id])._render('base.dummy_primary_ext')

        self.assertNotEqual(content1, content3)


class TestValidationTools(common.BaseCase):

    def test_get_expression_identities(self):
        self.assertEqual(
            view_validation.get_expression_field_names("context_today().strftime('%Y-%m-%d')"),
            set(),
        )
        self.assertEqual(
            view_validation.get_expression_field_names("field and field[0] or not field2"),
            {'field', 'field2'},
        )
        self.assertEqual(
            view_validation.get_expression_field_names("context_today().strftime('%Y-%m-%d') or field"),
            {'field'},
        )
        self.assertEqual(
            view_validation.get_expression_field_names("(datetime.datetime.combine(context_today(), datetime.time(x,y,z)).to_utc()).strftime('%Y-%m-%d %H:%M:%S')"),
            {'x', 'y', 'z'},
        )
        self.assertEqual(
            view_validation.get_expression_field_names("set(field).intersection([1, 2])"),
            {'field'},
        )

class TestAccessRights(TransactionCaseWithUserDemo):

    @common.users('demo')
    def test_access(self):
        # a user can not access directly a view
        with self.assertRaises(AccessError):
            self.env['ir.ui.view'].search([("model", '=', "res.partner"), ('type', '=', 'form')])

        # but can call view_get
        self.env['res.partner'].get_view(view_type='form')

        # unless he does not have access to the model
        with self.assertRaises(AccessError):
            self.env['ir.ui.view'].get_view(view_type='form')

@common.tagged('post_install', '-at_install', '-standard', 'migration')
class TestAllViews(common.TransactionCase):
    def test_views(self):
        views = self.env['ir.ui.view'].with_context(lang=None).search([])
        for index, view in enumerate(views):
            if index % 500 == 0:
                _logger.info('checked %s/%s views', index, len(views))
            with self.subTest(name=view.name):
                view._check_xml()

@common.tagged('post_install', '-at_install', '-standard', 'render_all_views')
class TestRenderAllViews(TransactionCaseWithUserDemo):

    @common.users('demo', 'admin')
    def test_render_all_views(self):
        env = self.env(context={'lang': 'en_US'})
        count = 0
        elapsed = 0
        for model in env.values():
            if not model._abstract and model.check_access_rights('read', False):
                with self.subTest(model=model):
                    times = []
                    for _ in range(5):
                        env.invalidate_all()
                        before = time.perf_counter()
                        model.get_view()
                        times.append(time.perf_counter() - before)
                    count += 1
                    elapsed += min(times)

        _logger.info('Rendered %d views as %s using (best of 5) %ss',
            count, self.env.user.name, elapsed)


class CompRegexTest(common.TransactionCase):
    def test_comp_regex(self):
        self.assertIsNone(re.search(ir_ui_view.COMP_REGEX, ""))
        self.assertIsNone(re.search(ir_ui_view.COMP_REGEX, "__comp__2"))
        self.assertIsNone(re.search(ir_ui_view.COMP_REGEX, "__comp___that"))
        self.assertIsNone(re.search(ir_ui_view.COMP_REGEX, "a__comp__"))

        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__ "))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, " __comp__ "))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__.props"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__ .props"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__['props']"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__ ['props']"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__[\"props\"]"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "__comp__ [\"props\"]"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "    __comp__     [\"props\"]    "))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "record ? __comp__ : false"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "!__comp__.props.resId"))
        self.assertIsNotNone(re.search(ir_ui_view.COMP_REGEX, "{{ __comp__ }}"))


@common.tagged('at_install', 'modifiers')
class ViewModifiers(ViewCase):

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_01_modifiers(self):
        def _test_modifiers(what, expected_vnames):
            if isinstance(what, dict):
                node = etree.Element('field', {k: str(v) for k, v in what.items()})
            else:
                node = etree.fromstring(what) if isinstance(what, str) else what
            modifiers = {attr: node.attrib[attr] for attr in node.attrib if attr in ir_ui_view.VIEW_MODIFIERS}
            vnames = set()
            for attr, expr in modifiers.items():
                vnames |= view_validation.get_expression_field_names(expr) - {'id'}
            assert vnames == expected_vnames, f"{vnames!r} != {expected_vnames!r}"

        str_true = "True"

        _test_modifiers('<field name="a"/>', set())
        _test_modifiers('<field name="a" invisible="1"/>', set())
        _test_modifiers('<field name="a" readonly="1"/>', set())
        _test_modifiers('<field name="a" required="1"/>', set())
        _test_modifiers('<field name="a" invisible="0"/>', set())
        _test_modifiers('<field name="a" readonly="0"/>', set())
        _test_modifiers('<field name="a" required="0"/>', set())
        # TODO: Order is not guaranteed
        _test_modifiers('<field name="a" invisible="1" required="1"/>',
            set(),
        )
        _test_modifiers('<field name="a" invisible="1" required="0"/>',
            set(),
        )
        _test_modifiers('<field name="a" invisible="0" required="1"/>',
            set(),
        )
        _test_modifiers("""<field name="a" invisible="b == 'c'"/>""",
            {"b"},
        )
        _test_modifiers("""<field name="a" invisible="b == 'c'"/>""",
            {"b"},
        )
        _test_modifiers("""<field name="a" invisible="b == 'c'"/>""",
            {"b"},
        )
        _test_modifiers("""<field name="a" invisible="(b == 'c' or e == 'f')"/>""",
            {"b", "e"},
        )
        _test_modifiers("""<field name="a" invisible="b == 'c'"/>""",
            {"b"},
        )
        _test_modifiers("""<field name="a" invisible="user_id == uid"/>""",
            {"user_id"},
        )
        _test_modifiers("""<field name="a" invisible="(user_id == other_field)"/>""",
            {"user_id", "other_field"},
        )
        _test_modifiers("""<field name="a" invisible="a == parent.b"/>""",
            {"a", "parent.b"},
        )
        _test_modifiers("""<field name="a" invisible="a == context.get('b')"/>""",
            {"a"},
        )
        _test_modifiers("""<field name="a" invisible="a == context['b']"/>""",
            {"a"},
        )
        _test_modifiers("""<field name="a" invisible="company_id == allowed_company_ids[0]"/>""",
            {"company_id"},
        )
        _test_modifiers("""<field name="a" invisible="company_id == (field_1 or False)"/>""",
            {"company_id", "field_1"},
        )

        # fields in a tree view
        tree = etree.fromstring('''
            <tree>
                <header>
                    <button name="a" invisible="1"/>
                </header>
                <field name="a"/>
                <field name="a" invisible="0"/>
                <field name="a" column_invisible="1"/>
                <field name="a" invisible="b == 'c'"/>
                <field name="a" invisible="(b == 'c')"/>
            </tree>
        ''')
        _test_modifiers(tree[0][0], set())
        _test_modifiers(tree[1], set())
        _test_modifiers(tree[2], set())
        _test_modifiers(tree[3], set())
        _test_modifiers(tree[4], {"b"})
        _test_modifiers(tree[5], {"b"})

        # The dictionary is supposed to be the result of fields_get().
        _test_modifiers({}, set())
        _test_modifiers({"invisible": str_true}, set())
        _test_modifiers({"invisible": False}, set())

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_03_modifier_attribute_is_boolean(self):
        arch = """
            <form string="View">
                <field name="model"/>
                <field name="name" readonly="%s"/>
            </form>
        """
        self.assertValid(arch % '1')
        self.assertValid(arch % '0')
        self.assertValid(arch % 'True')
        self.assertValid(arch % "[('model', '=', '1')]")

    def test_04_modifier_attribute_using_context(self):
        view = self.assertValid("""
            <form string="View">
                <field name="name"
                    invisible="context.get('foo')"
                    readonly="context.get('bar')"
                    required="context.get('baz')"
                />
            </form>
        """)
        arch = self.View.with_context(foo=True).get_view(view.id)['arch']
        field_node = etree.fromstring(arch).xpath('//field[@name="name"]')[0]
        self.assertEqual(field_node.get('invisible'), "context.get('foo')")
        self.assertEqual(field_node.get('readonly'), "context.get('bar')")
        self.assertEqual(field_node.get('required'), "context.get('baz')")

    def test_05_modifier_attribute_priority(self):
        view = self.assertValid("""
            <form string="View">
                <field name="type" invisible="1"/>
                <field name="name" invisible="context.get('foo') and type == 'tree'"/>
            </form>
        """)
        for type_value, context, expected in [
            ('tree', {}, False),
            ('form', {}, False),
            ('tree', {'foo': True}, True),
            ('form', {'foo': True}, False),
        ]:
            arch = self.View.with_context(**context).get_view(view.id)['arch']
            field_node = etree.fromstring(arch).xpath('//field[@name="name"]')[0]
            result = field_node.get('invisible')
            result = safe_eval.safe_eval(result, {'context': context, 'type': type_value})
            self.assertEqual(bool(result), expected, f"With context: {context}")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_10_raise_for_old_attributes(self):
        arch = """
            <form string="View">
                <field name="name"/>
                <field name="model"/>
                <field name="inherit_id" attrs="{'readonly': [('model', '=', 'ir.ui.view')]"/>
            </form>
        """
        self.assertInvalid(arch, """no longer used""")

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="model"/>
                <field name="inherit_id" states="draft,done"/>
            </form>
        """
        self.assertInvalid(arch, """no longer used""")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_11_attrs_field(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_id"
                       readonly="model == 'ir.ui.view'"/>
            </form>
        """
        self.assertValid(arch % '<field name="model"/>')
        self.assertInvalid(
            arch % '',
            """Field 'model' used in modifier 'readonly' (model == 'ir.ui.view') must be present in view but is missing""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_12_invalid_syntax(self):
        arch = """
            <form string="View">
                <field name="name"/>
                <field name="model"/>
                <field name="inherit_id"
                       readonly="model 'ir.ui.view'"/>
            </form>
        """
        self.assertInvalid(
            arch,
            """Invalid modifier 'readonly'""",
        )

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="model"/>
                <field name="inherit_id"
                       readonly="bidule.get('truc') or context.get('truc')"/>
            </form>
        """
        self.assertInvalid(
            arch,
            """Field 'bidule' used in modifier 'readonly' (bidule.get('truc') or context.get('truc')) must be present in view but is missing.""",
        )

        arch = """
            <form string="View">
                <field name="name"/>
                <field name="model"/>
                <field name="inherit_id"
                       readonly="context.get('truc') or bidule.get('toto')"/>
            </form>
        """
        self.assertInvalid(
            arch,
            """must be present in view but is missing""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_13_attrs_states_invisible_to_modifier(self):
        view = self.View.create({
            'name': 'foo',
            'model': 'ir.module.module',
            'arch': """
                <form string="View">
                    <group invisible="state != 'finished'">
                        <field name="category_id" invisible="not state" />
                        <field name="state" invisible="name not in ['qweb-pdf', 'qweb-html', 'qweb-text']"/>
                        <field name="name" invisible="name != 'bidule' and category_id != uid and state not in ('draf', 'finished')"/>
                    </group>
                </form>
            """,
        })
        arch = self.env['ir.module.module'].get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)

        invisible = tree.xpath('//group')[0].get('invisible')
        self.assertEqual(invisible, "state != 'finished'")

        invisible = tree.xpath('//field[@name="category_id"]')[0].get('invisible')
        self.assertEqual(invisible, "not state")

        invisible = tree.xpath('//field[@name="state"]')[0].get('invisible')
        self.assertEqual(invisible, "name not in ['qweb-pdf', 'qweb-html', 'qweb-text']")

        invisible = tree.xpath('//field[@name="name"]')[0].get('invisible')
        self.assertEqual(invisible, "name != 'bidule' and category_id != uid and state not in ('draf', 'finished')")

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_14_attrs_subfield(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id"
                               readonly="model == 'ir.ui.view'"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('', '<field name="model"/>'))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in modifier 'readonly' (model == 'ir.ui.view') must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('<field name="model"/>', ''),
            """Field 'model' used in modifier 'readonly' (model == 'ir.ui.view') must be present in view but is missing.""",
        )

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_15_attrs_subfield_with_parent(self):
        arch = """
            <form string="View">
                <field name="name"/>%s
                <field name="inherit_children_ids">
                    <form string="Children">
                        <field name="name"/>%s
                        <field name="inherit_id"
                               readonly="parent.model == 'ir.ui.view'"/>
                    </form>
                </field>
            </form>
        """
        self.assertValid(arch % ('<field name="model"/>', ''))
        self.assertInvalid(
            arch % ('', ''),
            """Field 'model' used in modifier 'readonly' (parent.model == 'ir.ui.view') must be present in view but is missing.""",
        )
        self.assertInvalid(
            arch % ('', '<field name="model"/>'),
            """Field 'model' used in modifier 'readonly' (parent.model == 'ir.ui.view') must be present in view but is missing.""",
        )

    def test_16_attrs_groups_behavior(self):
        view = self.View.create({
            'name': 'foo',
            'model': 'res.partner',
            'arch': """
                <form>
                    <field name="name"/>
                    <field name="company_id" groups="base.group_system"/>
                    <div id="foo"/>
                    <div id="bar" groups="base.group_system"/>
                </form>
            """,
        })
        user_demo = self.user_demo
        # Make sure demo doesn't have the base.group_system
        self.assertFalse(self.env['res.partner'].with_user(user_demo).env.user.has_group('base.group_system'))
        arch = self.env['res.partner'].with_user(user_demo).get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        self.assertTrue(tree.xpath('//field[@name="name"]'))
        self.assertFalse(tree.xpath('//field[@name="company_id"]'))
        self.assertTrue(tree.xpath('//div[@id="foo"]'))
        self.assertFalse(tree.xpath('//div[@id="bar"]'))

        user_admin = self.env.ref('base.user_admin')
        # Make sure admin has the base.group_system
        self.assertTrue(self.env['res.partner'].with_user(user_admin).env.user.has_group('base.group_system'))
        arch = self.env['res.partner'].with_user(user_admin).get_view(view_id=view.id)['arch']
        tree = etree.fromstring(arch)
        self.assertTrue(tree.xpath('//field[@name="name"]'))
        self.assertTrue(tree.xpath('//field[@name="company_id"]'))
        self.assertTrue(tree.xpath('//div[@id="foo"]'))
        self.assertTrue(tree.xpath('//div[@id="bar"]'))

    @mute_logger('odoo.addons.base.models.ir_ui_view')
    def test_17_attrs_groups_validation(self):
        def validate(arch, valid=False, parent=False):
            parent = 'parent.' if parent else ''
            if valid:
                self.assertValid(arch % {'attrs': f"""invisible="{parent}name == 'foo'" """})
                self.assertValid(arch % {'attrs': f"""domain="[('name', '!=', {parent}name)]" """})
                self.assertValid(arch % {'attrs': f"""context="{{'default_name': {parent}name}}" """})
                self.assertValid(arch % {'attrs': f"""decoration-info="{parent}name == 'foo'" """})
            else:
                self.assertInvalid(
                    arch % {'attrs': f"""invisible="{parent}name == 'foo'" """},
                    f"""Field 'name' used in modifier 'invisible' ({parent}name == 'foo') is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""domain="[('name', '!=', {parent}name)]" """},
                    f"""Field 'name' used in domain of <field name="inherit_id"> ([('name', '!=', {parent}name)]) is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""context="{{'default_name': {parent}name}}" """},
                    f"""Field 'name' used in context ({{'default_name': {parent}name}}) is restricted to the group(s)""",
                )
                self.assertInvalid(
                    arch % {'attrs': f"""decoration-info="{parent}name == 'foo'" """},
                    f"""Field 'name' used in decoration-info="{parent}name == 'foo'" is restricted to the group(s)""",
                )


        # Assert using a field restricted to a group
        # in another field without the same group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field without the same group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field with the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field available for everyone
        # in a child field restricted to a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a field available for everyone
        # in another field restricted to a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" %(attrs)s groups="base.group_system"/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a group
        # in another field with the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available twice for 2 diffent groups
        # in another field restricted to one of the 2 groups is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_portal"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a group only
        # in other fields restricted to at least one different group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field available twice for 2 different groups
        # in other fields restricted to the same 2 group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="name" groups="base.group_portal"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available for 2 diffent groups,
        # in another field restricted to one of the 2 groups is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_portal,base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field available for 1 group only
        # in another field restricted 2 groups is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_portal,base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to a group
        # in another field restricted to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a parent field restricted to a group
        # in a child field restricted to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_system" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a field restricted to a group
        # in another field restricted to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_erp_manager" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field restricted to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids">
                    <tree editable="bottom">
                        <field name="inherit_id" groups="base.group_erp_manager" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a field within a block restricted to a group
        # in another field not restricted to the same group is invalid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field within a block restricted to a group
        # in another field within the same block restricted to a group is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within the same block restricted to a group and additional groups on the field node is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                    <field name="inherit_id" %(attrs)s groups="base.group_multi_currency,base.group_multi_company"/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to the same group is valid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <group groups="base.group_system">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to a group including the group for which the field is available
        # is valid
        validate("""
            <form string="View">
                <group groups="base.group_erp_manager">
                    <field name="name"/>
                </group>
                <group groups="base.group_system">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=True)

        # Assert using a field within a block restricted to a group
        # in another field within a block restricted to a group not including the group for which the field is available
        # is invalid
        validate("""
            <form string="View">
                <group groups="base.group_system">
                    <field name="name"/>
                </group>
                <group groups="base.group_erp_manager">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=False)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted to the same group is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids" groups="base.group_system">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted
        # to a group including the group for which the field is available is valid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_erp_manager"/>
                <field name="inherit_children_ids" groups="base.group_system">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=True, parent=True)

        # Assert using a parent field restricted to a group
        # in a child field under a relational field restricted
        # to a group not including the group for which the field is available is invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_children_ids" groups="base.group_erp_manager">
                    <tree editable="bottom">
                        <field name="inherit_id" %(attrs)s/>
                    </tree>
                </field>
            </form>
        """, valid=False, parent=True)

        # Assert using a field restricted to users not having a group
        # in another field not restricted to any group is invalid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field not restricted to any group
        # in another field restricted to users not having a group is valid
        validate("""
            <form string="View">
                <field name="name"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to users not having multiple groups
        # in another field restricted to users not having one of the group only is invalid
        # e.g.
        # if the user is portal, the field "name" will not be in the view
        # but the field "inherit_id" where "name" is used will be in the view
        # making it invalid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system,!base.group_portal"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to users not having a group
        # in another field restricted to users not having multiple group including the one above is valid
        # e.g.
        # if the user is portal, the field "name" will be in the view
        # but the field "inherit_id" where "name" is used will not be in the view
        # making it valid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_user"/>
                <field name="inherit_id" groups="!base.group_user,!base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to a non group
        # in another field for which the non group is not implied is invalid
        # e.g.
        # if the user is employee, the field "name" will not be in the view
        # but the field "inherit_id" where "name" is used will be in the view,
        # making it invalid.
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_user"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert using a field restricted to a non group
        # in another field restricted to a non group implied in the non group of the available field is valid
        # e.g.
        # if the user is employee, the field "name" will be in the view
        # but the field "inherit_id", where "name" is used, will not be in the view,
        # therefore making it valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="inherit_id" groups="!base.group_user" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert using a field restricted to non-admins, itself in a block restricted to employees,
        # in another field restricted to a block restricted to employees
        # is invalid
        # e.g.
        # if the user is admin, the field "name" will not be in the view
        # but the field "inherit_id", where "name" is used, will be in the view,
        # threfore making it invalid
        validate("""
            <form string="View">
                <group groups="base.group_user">
                    <field name="name" groups="!base.group_system"/>
                </group>
                <group groups="base.group_user">
                    <field name="inherit_id" %(attrs)s/>
                </group>
            </form>
        """, valid=False)

        # Assert using a field restricted to a group
        # in another field restricted the opposite group is invalid
        # e.g.
        # if the user is admin, the field "name" will be in the view
        # but the field "inherit_id", where "name" is used, will not be in the view,
        # therefore making it invalid
        validate("""
            <form string="View">
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=False)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field without any group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field using the group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field using the !group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="!base.group_system" %(attrs)s/>
            </form>
        """, valid=True)

        # Assert having two times the same field with a mutually exclusive group
        # and using that field in another field restricted to any other group is valid
        validate("""
            <form string="View">
                <field name="name" groups="!base.group_system"/>
                <field name="name" groups="base.group_system"/>
                <field name="inherit_id" groups="base.group_portal" %(attrs)s/>
            </form>
        """, valid=True)

```

  File: tests/test_xmlrpc.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import collections
import time
from xmlrpc.client import Binary

from odoo.exceptions import AccessDenied, AccessError
from odoo.http import _request_stack

import odoo
import odoo.tools
from odoo.tests import common
from odoo.service import common as auth, model
from odoo.tools import DotDict


@common.tagged('post_install', '-at_install')
class TestXMLRPC(common.HttpCase):

    def setUp(self):
        super(TestXMLRPC, self).setUp()
        self.admin_uid = self.env.ref('base.user_admin').id

    def xmlrpc(self, model, method, *args, **kwargs):
        return self.xmlrpc_object.execute_kw(
            common.get_db_name(), self.admin_uid, 'admin',
            model, method, args, kwargs
        )

    def test_01_xmlrpc_login(self):
        """ Try to login on the common service. """
        db_name = common.get_db_name()
        uid = self.xmlrpc_common.login(db_name, 'admin', 'admin')
        self.assertEqual(uid, self.admin_uid)

    def test_xmlrpc_ir_model_search(self):
        """ Try a search on the object service. """
        o = self.xmlrpc_object
        db_name = common.get_db_name()
        ids = o.execute(db_name, self.admin_uid, 'admin', 'ir.model', 'search', [])
        self.assertIsInstance(ids, list)
        ids = o.execute(db_name, self.admin_uid, 'admin', 'ir.model', 'search', [], {})
        self.assertIsInstance(ids, list)

    def test_xmlrpc_read_group(self):
        groups = self.xmlrpc_object.execute(
            common.get_db_name(), self.admin_uid, 'admin',
            'res.partner', 'read_group', [], ['is_company', 'color'], ['parent_id']
        )

    def test_xmlrpc_name_search(self):
        self.xmlrpc_object.execute(
            common.get_db_name(), self.admin_uid, 'admin',
            'res.partner', 'name_search', "admin"
        )

    def test_xmlrpc_html_field(self):
        sig = '<p>bork bork bork <span style="font-weight: bork">bork</span><br></p>'
        r = self.env['res.users'].create({
            'name': 'bob',
            'login': 'bob',
            'signature': sig
        })
        self.assertEqual(str(r.signature), sig)
        [x] = self.xmlrpc('res.users', 'read', r.id, ['signature'])
        self.assertEqual(x['signature'], sig)

    def test_xmlrpc_frozendict_marshalling(self):
        """ Test that the marshalling of a frozendict object works properly over XMLRPC """
        self.env.ref('base.user_admin').tz = "Europe/Brussels"
        ctx = self.xmlrpc_object.execute(
            common.get_db_name(), self.admin_uid, 'admin',
            'res.users', 'context_get',
        )
        self.assertEqual(ctx['lang'], 'en_US')
        self.assertEqual(ctx['tz'], 'Europe/Brussels')

    def test_xmlrpc_defaultdict_marshalling(self):
        """
        Test that the marshalling of a collections.defaultdict object
        works properly over XMLRPC
        """
        self.patch(self.registry['res.users'], 'context_get',
                   odoo.api.model(lambda *_: collections.defaultdict(int)))
        self.assertEqual(self.xmlrpc('res.users', 'context_get'), {})

    def test_xmlrpc_remove_control_characters(self):
        record = self.env['res.users'].create({
            'name': 'bob with a control character: \x03',
            'login': 'bob',
        })
        self.assertEqual(record.name, 'bob with a control character: \x03')
        [record_data] = self.xmlrpc('res.users', 'read', record.id, ['name'])
        self.assertEqual(record_data['name'], 'bob with a control character: ')

    def test_jsonrpc_read_group(self):
        self._json_call(
            common.get_db_name(), self.admin_uid, 'admin',
            'res.partner', 'read_group', [], ['is_company', 'color'], ['parent_id']
        )

    def test_jsonrpc_name_search(self):
        # well that's some sexy sexy call right there
        self._json_call(
            common.get_db_name(),
            self.admin_uid, 'admin',
            'res.partner', 'name_search', 'admin'
        )

    def _json_call(self, *args):
        self.opener.post("http://%s:%s/jsonrpc" % (common.HOST, odoo.tools.config['http_port']), json={
            'jsonrpc': '2.0',
            'id': None,
            'method': 'call',
            'params': {
                'service': 'object',
                'method': 'execute',
                'args': args
            }
        })

    def test_xmlrpc_attachment_raw(self):
        ids = self.env['ir.attachment'].create({'name': 'n', 'raw': b'\x01\x09'}).ids
        [att] = self.xmlrpc_object.execute(
            common.get_db_name(), self.admin_uid, 'admin',
            'ir.attachment', 'read', ids, ['raw'])
        self.assertEqual(att['raw'], '\t',
            "on read, binary data should be decoded as a string and stripped from control character")

# really just for the test cursor
@common.tagged('post_install', '-at_install')
class TestAPIKeys(common.HttpCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls._user = cls.env['res.users'].create({
            'name': "Bylan",
            'login': 'byl',
            'password': 'ananananan',
            'tz': 'Australia/Eucla',
        })

    def setUp(self):
        super().setUp()
        # needs a fake request in order to call methods protected with check_identity
        fake_req = DotDict({
            # various things go and access request items
            'httprequest': DotDict({
                'environ': {'REMOTE_ADDR': 'localhost'},
                'cookies': {},
            }),
            # bypass check_identity flow
            'session': {'identity-check-last': time.time()},
            'geoip': {},
        })
        _request_stack.push(fake_req)
        self.addCleanup(_request_stack.pop)

    def test_trivial(self):
        uid = auth.dispatch('authenticate', [self.env.cr.dbname, 'byl', 'ananananan', {}])
        self.assertEqual(uid, self._user.id)

        ctx = model.dispatch('execute_kw', [
            self.env.cr.dbname, uid, 'ananananan',
            'res.users', 'context_get', []
        ])
        self.assertEqual(ctx['tz'], 'Australia/Eucla')

    def test_wrongpw(self):
        # User.authenticate raises but RPC.authenticate returns False
        uid = auth.dispatch('authenticate', [self.env.cr.dbname, 'byl', 'aws', {}])
        self.assertFalse(uid)
        with self.assertRaises(AccessDenied):
            model.dispatch('execute_kw', [
                self.env.cr.dbname, self._user.id, 'aws',
                'res.users', 'context_get', []
            ])

    def test_key(self):
        env = self.env(user=self._user)
        r = env['res.users.apikeys.description'].create({
            'name': 'a',
        }).make_key()
        k = r['context']['default_key']

        uid = auth.dispatch('authenticate', [self.env.cr.dbname, 'byl', 'ananananan', {}])
        self.assertEqual(uid, self._user.id)

        uid = auth.dispatch('authenticate', [self.env.cr.dbname, 'byl', k, {}])
        self.assertEqual(uid, self._user.id)

        ctx = model.dispatch('execute_kw', [
            self.env.cr.dbname, uid, k,
            'res.users', 'context_get', []
        ])
        self.assertEqual(ctx['tz'], 'Australia/Eucla')

    def test_delete(self):
        env = self.env(user=self._user)
        env['res.users.apikeys.description'].create({'name': 'b',}).make_key()
        env['res.users.apikeys.description'].create({'name': 'b',}).make_key()
        env['res.users.apikeys.description'].create({'name': 'b',}).make_key()
        k0, k1, k2 = env['res.users.apikeys'].search([])

        # user can remove their own keys
        k0.remove()
        self.assertFalse(k0.exists())

        # admin can remove user keys
        k1.with_user(self.env.ref('base.user_admin')).remove    ()
        self.assertFalse(k1.exists())

        # other user can't remove user keys
        u = self.env['res.users'].create({
            'name': 'a',
            'login': 'a',
            'groups_id': self.env.ref('base.group_user').ids,
        })
        with self.assertRaises(AccessError):
            k2.with_user(u).remove()

    def test_disabled(self):
        env = self.env(user=self._user)
        k = env['res.users.apikeys.description'].create({'name': 'b',}).make_key()['context']['default_key']

        self._user.active = False

        with self.assertRaises(AccessDenied):
            model.dispatch('execute_kw', [
                self.env.cr.dbname, self._user.id, 'ananananan',
                'res.users', 'context_get', []
            ])

        with self.assertRaises(AccessDenied):
            model.dispatch('execute_kw', [
                self.env.cr.dbname, self._user.id, k,
                'res.users', 'context_get', []
            ])

```

  File: tests/tommy_small.jpeg
  Content:
```
Error reading file: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
```

Other_files:
  File: populate/__init__.py
  Content:
```
from . import ir_filters
from . import res_partner
from . import res_company
from . import res_currency
from . import res_user

```

  File: populate/ir_filters.py
  Content:
```
from odoo import models
from odoo.tools import populate


class Filter(models.Model):
    _inherit = "ir.filters"

    # Based on the sizes of res.users, 10 filters per user.
    _populate_sizes = {
        'small': 100,
        'medium': 10000,
        'large': 100000,
    }
    _populate_dependencies = ['res.users']

    def _populate_factories(self):
        return [
            ('name', populate.constant('filter_{counter}')),
            ('user_id', populate.randomize(self.env.registry.populated_models['res.users'])),
            ('domain', populate.iterate(["[('id', '=', 1)]", "[('id', '=', 2)]", "[('id', '=', 3)]"])),
            ('context', populate.iterate(["{{}}", "{{'group_by': ['create_date:month']}}"])),
            ('sort', populate.iterate(["[]"])),
            ('model_id', populate.randomize(
                list(dict(self._fields['model_id'].get_description(self.env, ['selection'])['selection']).keys())
            )),
            ('is_default', populate.cartesian([True, False], [0.1, 0.9])),
            ('action_id', populate.randomize(self.env['ir.actions.actions'].search([]).ids)),
        ]

```

  File: populate/res_company.py
  Content:
```
import collections
import logging

from odoo import models, Command
from odoo.tools import populate

_logger = logging.getLogger(__name__)


class Partner(models.Model):
    _inherit = "res.company"

    _populate_sizes = {
        'small': 5,
        'medium': 10,
        'large': 50,
    }

    def _populate_factories(self):
        # Activate currency to avoid fail iterator
        (self.env.ref('base.USD') | self.env.ref('base.EUR')).active = True
        last_id = self.env["res.company"].search([], order="id desc", limit=1).id

        # remaining: paperformat_id, parent_id, partner_id, font, report_header, external_report_layout_id, report_footer
        def get_name(values=None, counter=0, **kwargs):
            return 'company_%s_%s' % (last_id + counter + 1, self.env['res.currency'].browse(values['currency_id']).name)

        active_currencies = self.env['res.currency'].search([('active', '=', True)]).ids
        return [
            ('name', populate.constant('company_{counter}')),
            ('sequence', populate.randint(0, 100)),
            ('company_registry', populate.iterate([False, 'company_registry_{counter}'])),
            ('primary_color', populate.iterate([False, '', '#ff7755'])),
            ('secondary_color', populate.iterate([False, '', '#ffff55'], seed='primary_color')),
            ('currency_id', populate.iterate(active_currencies)),
            ('name', populate.compute(get_name)),
        ]

    def _populate(self, size):
        records = super()._populate(size)
        self.env.ref('base.user_admin').write({'company_ids': [Command.link(rec.id) for rec in records]})  # add all created companies on user admin
        return records

```

  File: populate/res_currency.py
  Content:
```
from dateutil.relativedelta import relativedelta
from datetime import date

from odoo import models, Command
from odoo.tools import populate


class ResCurrencyRate(models.Model):
    _inherit = "res.currency.rate"

    _populate_sizes = {
        'small': 100,
        'medium': 1000,
        'large': 10000,
    }

    def _populate_factories(self):
        def get_rate(random, values, **kwargs):
            basis = sum(
                ord(c) for c in
                self.env['res.currency'].browse(values['currency_id']).name
            ) % 20
            return basis + random.uniform(-1, 1)

        def get_date(random, values, **kwargs):
            return date(2020, 1, 1) - relativedelta(days=kwargs['counter'])

        company_ids = self.env['res.company'].search([
            ('id', 'in', self.env.registry.populated_models['res.company']),
        ])
        return [
            ('currency_id', populate.randomize(self.env['res.currency'].search([('active', '=', True)]).ids)),
            ('company_id', populate.randomize(company_ids.root_id.ids)),
            ('name', populate.compute(get_date)),
            ('rate', populate.compute(get_rate)),
        ]

```

  File: populate/res_partner.py
  Content:
```

import collections
import logging

from odoo import models
from odoo.tools import populate

_logger = logging.getLogger(__name__)


class Partner(models.Model):
    _inherit = "res.partner"
    _populate_dependencies = ["res.company", "res.partner.industry"]

    _populate_sizes = {
        'small': 100,
        'medium': 2000,
        'large': 100000,
    }

    def _populate_factories(self):

        # example of more complex generator composed of multiple sub generators
        # this define one subgenerator per "country"
        address_factories_groups = [
            [ # Falsy, 2 records
                ('street', populate.iterate([False, ''])),
                ('street2', populate.iterate([False, ''])),
                ('city', populate.iterate([False, ''])),
                ('zip', populate.iterate([False, ''])),
                ('country_id', populate.iterate([False])),
            ], [  # BE, 1 record
                ('street', populate.iterate(['Boulevard Tintin {counter}'])),
                ('city', populate.iterate(['Brussels'])),
                ('zip', populate.iterate([1020])),
                ('country_id', populate.iterate([self.env.ref('base.be').id])),
            ], [  # US, 3 records
                ('street', populate.iterate(['Main street', '3th street {counter}', False])),
                ('street2', populate.iterate([False, '', 'Behind the tree {counter}'], [90, 5, 5])),
                ('city', populate.randomize(['Sans Fransisco', 'Los Angeles', '', False])),
                ('zip', populate.iterate([False, '', '50231'])),
                ('country_id', populate.iterate([self.env.ref('base.us').id])),
            ], [  # IN, 2 records
                ('street', populate.iterate(['Main Street', 'Some Street {counter}'])),
                ('city', populate.iterate(['ગાંધીનગર (Gandhinagar)'])),
                ('zip', populate.randomize(['382002', '382008'])),
                ('country_id', populate.randomize([self.env.ref('base.in').id])),
            ], [  # other corner cases, 4 records
                ('street', populate.iterate(['万泉寺村', 'საბჭოს სკვერი {counter}', '10th Street {counter}'])),
                ('city', populate.iterate(['北京市', 'თბილისი', 'دبي'])),
                ('zip', populate.iterate([False, 'UF47', '0', '10201'])),
                ('country_id', populate.randomize([False] + self.env['res.country'].search([]).ids)),
            ]
        ]

        def generate_address(iterator, *args):
            address_generators = [populate.chain_factories(address_factories, self._name) for address_factories in address_factories_groups]
            # first, exhaust all address_generators
            for adress_generator in address_generators:
                for adress_values in adress_generator:
                    if adress_values['__complete']:
                        break
                    values = next(iterator)  # only consume main iterator if usefull
                    yield {**values, **adress_values}

            # then, go pseudorandom between generators
            r = populate.Random('res.partner+address_generator_selector')
            for values in iterator:
                adress_generator = r.choice(address_generators)
                adress_values = next(adress_generator)
                yield {**adress_values, **values}

        # state based on country
        states = self.env['res.country.state'].search([])
        states_per_country = collections.defaultdict(list)
        for state in states:
            states_per_country[state.country_id.id].append(state.id)

        def get_state(values=None, random=None, **kwargs):
            country_id = values['country_id']
            if not country_id:
                return False
            return random.choice([False] + states_per_country[country_id])

        def get_name(values=None, counter=0, **kwargs):
            is_company = values['is_company']
            complete = values['__complete']
            return  '%s_%s_%s' % ('company' if is_company else 'partner', int(complete), counter)

        industry_ids = self.env.registry.populated_models['res.partner.industry']
        company_ids = self.env.registry.populated_models['res.company']

        # not defined fields: vat, partner_longitude, date, partner_latitude, color, company_name, employee, lang, user_id
        return [
            ('active', populate.cartesian([True, False], [0.9, 0.1])),
            ('employee', populate.cartesian([True, False], [0.1, 0.9])),
            ('email', populate.iterate(
                [False, '', 'email{counter}@example.com', '<contact 万> contact{counter}@anotherexample.com', 'invalid_email'])),
            ('type', populate.constant('contact')),  # todo add more logic, manage 'invoice', 'delivery', 'other'
            ('is_company', populate.iterate([True, False], [0.05, 0.95])),
            ('_address', generate_address),
            ('state_id', populate.compute(get_state)),
            ('phone', populate.randomize([False, '', '+3212345678', '003212345678', '12345678'])),
            ('mobile', populate.randomize([False, '', '+32412345678', '0032412345678', '412345678'])),
            ('title', populate.randomize(self.env['res.partner.title'].search([]).ids)),
            ('function', populate.randomize(
                [False, '', 'President of Sales', 'Senior Consultant', 'Product owner', 'Functional Consultant', 'Chief Executive Officer'],
                [50, 10, 2, 20, 5, 10, 1])),
            ('tz', populate.randomize([tz for tz in self.env['res.partner']._fields['tz'].get_values(self.env)])),
            ('website', populate.randomize([False, '', 'http://www.example.com'])),
            ('name', populate.compute(get_name)),  # keep after is_company
            ('ref', populate.randomize([False, '', '{counter}', 'p-{counter}'], [10, 10, 30, 50])),
            ('industry_id', populate.randomize(
                [False] + industry_ids,
                [0.5] + ([0.5/(len(industry_ids) or 1)] * len(industry_ids)))),
            ('comment', populate.iterate([False, '', 'This is a partner {counter}'])),
            ('company_id', populate.iterate(
                [False, self.env.ref('base.main_company').id] + company_ids,
                [1, 1] + [1/(len(company_ids) or 1)]*len(company_ids))),
            ('parent_id', populate.constant(False)),  # will be setted in _populate override
        ]

    def _populate(self, size):
        records = super()._populate(size)
        # set parent_ids
        self._populate_set_companies(records)
        return records

    def _populate_set_companies(self, records):
        _logger.info('Setting companies')
        r_company = populate.Random('res.partner+company_has_partners')
        r_partner = populate.Random('res.partner+partner_has_company')
        r_company_pick = populate.Random('res.partner+partner_company_pick=')

        companies = records.filtered(lambda p: p.is_company and r_company.getrandbits(1))  # 50% change to have partners
        partners = records.filtered(lambda p: not p.is_company and r_partner.getrandbits(1))  # 50% change to have a company

        companies_partners = collections.defaultdict(lambda: self.env['res.partner'])
        for partner in partners:
            companies_partners[r_company_pick.choice(companies)] |= partner

        # batching company write improves performances a lot (~40% faster for total partner creation).
        for count, (company, partners) in enumerate(companies_partners.items(), start=1):
            if count % 100 == 0:
                _logger.info('Setting company: %s/%s', count, len(companies))
            partners.write({'parent_id': company.id})
            partners._onchange_company_id()

class ResPartnerIndustry(models.Model):
    _inherit = "res.partner.industry"

    _populate_sizes = {
        'small': 15,
        'medium': 60,
        'large': 300,
    }

    def _populate_factories(self):
        return [
            ('active', populate.cartesian([False, True], [0.1, 0.9])),
            ('name', populate.cartesian(
                [False, 'Industry name', 'Industry name {counter}'],
                [0.08, 0.01, 0.9])),
            ('full_name', populate.iterate([False, 'Industry full name %s']))
        ]

```

  File: populate/res_user.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import logging

from odoo import models
from odoo.tools import populate

_logger = logging.getLogger(__name__)


class Users(models.Model):
    _inherit = "res.users"

    _populate_sizes = {
        'small': 10,
        'medium': 1000,
        'large': 10000,
    }

    _populate_dependencies = ["res.partner"]

    def _populate_factories(self):
        last_id = self.env["res.users"].search([], order="id desc", limit=1).id

        def generate_partner_id(iterator, *args):
            partner_factories = self.env['res.partner']._populate_factories()
            partner_generator = populate.chain_factories(partner_factories, self._name)
            for dependant_values in partner_generator:
                values = next(iterator)
                yield {**dependant_values, **values, '__complete': values['__complete']}

        def get_company_ids(values, **kwargs):
            return [(6, 0, [values['company_id']])]

        def compute_login(values=None, counter=0, **kwargs):
            return f'user_login_{last_id + counter + 1}'

        def compute_name(values=None, counter=0, **kwargs):
            return f'user_{last_id + counter + 1}'

        return [
            ('active', populate.cartesian([True, False], [0.9, 0.1])),
            ('partner_id', generate_partner_id),
            ('company_id', populate.randomize(self.env.registry.populated_models['res.company'])),
            ('company_ids', populate.compute(get_company_ids)),
            ('login', populate.compute(compute_login)),
            ('name', populate.compute(compute_name)),
        ]

    def _populate(self, size):
        self = self.with_context(no_reset_password=True)  # avoid sending reset password email
        return super(Users, self)._populate(size)

```

  File: report/__init__.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import report_base_report_irmodulereference
```

  File: report/corporate_defaults.xml
  Content:
```
<?xml version="1.0"?>
<corporate-header>
    <corporation type="zoom" name="company_id">
        <report_header type="field" name="report_header"/>
        <report_footer type="field" name="report_footer"/>
        <title type="field" name="partner_id.title"/>
        <name type="field" name="partner_id.name"/>
        <street type="field" name="street"/>
        <zip type="field" name="zip"/>
        <city type="field" name="city"/>
        <state type="field" name="state_id.name"/>
        <country type="field" name="country_id.name"/>
        <phone type="field" name="phone"/>
        <email type="field" name="email"/>
    </corporation>
    <user>
        <name type="field" name="name"/>
        <signature type="field" name="signature"/>
    </user>
</corporate-header>

```

  File: report/corporate_defaults.xsl
  Content:
```
<?xml version = '1.0' encoding="utf-8"?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">
	<xsl:variable name="signature" select="//corporate-header/user/signature"/>
	<xsl:variable name="title">Odoo Report</xsl:variable>
	<xsl:variable name="leftMargin">1cm</xsl:variable>
	<xsl:variable name="rightMargin">1cm</xsl:variable>
	<xsl:variable name="topMargin">1cm</xsl:variable>
	<xsl:variable name="bottomMargin">1cm</xsl:variable>
	<xsl:variable name="pageSize">21cm,29.7cm</xsl:variable>

	<xsl:variable name="page_format">a4_letter</xsl:variable>

	<xsl:template name="first_page_graphics_corporation">
		<!--logo-->
		<setFont name="Helvetica" size="14"/>
		<fill color="black"/>
		<stroke color="black"/>
		<drawString x="1cm" y="27.6cm"><xsl:value-of select="//corporate-header/corporation/name"/></drawString>
		<lines>1cm 28.4cm 20cm 28.4cm</lines>
		<lines>1cm 25.4cm 7cm 25.4cm</lines>

		<setFont name="Helvetica" size="10"/>
		<drawRightString x="20cm" y="28.5cm"><xsl:value-of select="//corporate-header/corporation/rml_header1"/></drawRightString>
		<drawString x="1cm" y="27cm"><xsl:value-of select="//corporate-header/corporation/street"/></drawString>
		<drawString x="1cm" y="26.5cm">
			<xsl:value-of select="//corporate-header/corporation/zip"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="//corporate-header/corporation/city"/>
			<xsl:text> - </xsl:text>
			<xsl:value-of select="//corporate-header/corporation/country"/>
		</drawString>
		<drawString x="1cm" y="26cm">Phone:</drawString>
		<drawRightString x="7cm" y="26cm"><xsl:value-of select="//corporate-header/corporation/phone"/></drawRightString>
		<drawString x="1cm" y="25.5cm">Mail:</drawString>
		<drawRightString x="7cm" y="25.5cm"><xsl:value-of select="//corporate-header/corporation/email"/></drawRightString>


		<!--page bottom-->

		<lines>1.5cm 2.2cm 19.9cm 2.2cm</lines>
		<drawCentredString x="10.5cm" y="1.7cm"><xsl:value-of select="//corporate-header/corporation/rml_footer"/></drawCentredString>
		<drawCentredString x="10.5cm" y="0.8cm">Your contact : <xsl:value-of select="//corporate-header/user/name"/></drawCentredString>

	</xsl:template>


	<xsl:template name="other_pages_graphics_corporation">
		<!--logo-->
		<setFont name="Helvetica" size="14"/>
		<fill color="black"/>
		<stroke color="black"/>
		<drawString x="1cm" y="27.6cm"><xsl:value-of select="//corporate-header/corporation/name"/></drawString>
		<lines>1cm 25.4cm 20cm 25.4cm</lines>
<!--		<lines>1cm 25.7cm 7cm 25.7cm</lines>-->

		<setFont name="Helvetica" size="10"/>
		<drawRightString x="1cm" y="27.5cm"><xsl:value-of select="//corporate-header/corporation/rml_header1"/></drawRightString>
		<drawString x="1cm" y="27cm"><xsl:value-of select="//corporate-header/corporation/street"/></drawString>
		<drawString x="1cm" y="26.5cm">
			<xsl:value-of select="//corporate-header/corporation/zip"/>
			<xsl:text> </xsl:text>
			<xsl:value-of select="//corporate-header/corporation/city"/>
			<xsl:text> - </xsl:text>
			<xsl:value-of select="//corporate-header/corporation/country"/>
		</drawString>
		<drawString x="1cm" y="26cm">Phone:</drawString>
		<drawRightString x="7cm" y="26cm"><xsl:value-of select="//corporate-header/corporation/phone"/></drawRightString>
		<drawString x="1cm" y="25.5cm">Mail:</drawString>
		<drawRightString x="7cm" y="25.5cm"><xsl:value-of select="//corporate-header/corporation/email"/></drawRightString>

		<!--page bottom-->

		<lines>1.5cm 1.2cm 19.9cm 1.2cm</lines>
		<drawCentredString x="10.5cm" y="1.7cm"><xsl:value-of select="//corporate-header/corporation/rml_footer"/></drawCentredString>
<!--		<drawCentredString x="10.5cm" y="0.8cm">Your contact : <xsl:value-of select="//corporate-header/user/name"/></drawCentredString>-->
	</xsl:template>

	<xsl:template name="first_page_frames">
		<xsl:if test="$page_format='a4_normal'">
			<frame id="main" x1="1cm" y1="2.5cm" width="19.0cm" height="22.0cm"/>
		</xsl:if>

		<xsl:if test="$page_format='a4_letter'">
			<frame id="address" x1="11cm" y1="21.5cm" width="6cm" height="4cm"/>
			<frame id="main" x1="1cm" y1="2.5cm" width="19.0cm" height="17.5cm"/>
		</xsl:if>
	</xsl:template>

	<xsl:template name="other_pages_frames">
		<frame id="main" x1="1cm" y1="2.5cm" width="19.0cm" height="22cm"/>
	</xsl:template>

</xsl:stylesheet>

```

  File: report/corporate_odt_header.xml
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<office:document-styles xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" office:version="1.1">
	<office:font-face-decls>
		<style:font-face style:name="Helvetica" svg:font-family="Helvetica"/>
		<style:font-face style:name="Times" svg:font-family="Times"/>
		<style:font-face style:name="Helvetica1" svg:font-family="Helvetica" style:font-family-generic="swiss"/>
		<style:font-face style:name="Monospace" svg:font-family="Monospace" style:font-pitch="fixed"/>
		<style:font-face style:name="DejaVu Sans" svg:font-family="&apos;DejaVu Sans&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
	</office:font-face-decls>
	<office:styles>
		<style:default-style style:family="graphic">
			<style:graphic-properties draw:shadow-offset-x="0.3cm" draw:shadow-offset-y="0.3cm" draw:start-line-spacing-horizontal="0.283cm" draw:start-line-spacing-vertical="0.283cm" draw:end-line-spacing-horizontal="0.283cm" draw:end-line-spacing-vertical="0.283cm" style:flow-with-text="true"/>
			<style:paragraph-properties style:text-autospace="ideograph-alpha" style:line-break="strict" style:writing-mode="lr-tb" style:font-independent-line-spacing="false">
				<style:tab-stops/>
			</style:paragraph-properties>
			<style:text-properties style:use-window-font-color="true" fo:font-size="12pt" fo:language="en" fo:country="IN" style:letter-kerning="true" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none"/>
		</style:default-style>
		<style:default-style style:family="paragraph">
			<style:paragraph-properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:tab-stop-distance="1.251cm" style:writing-mode="page"/>
			<style:text-properties style:use-window-font-color="true" style:font-name="Times" fo:font-size="12pt" fo:language="en" fo:country="IN" style:letter-kerning="true" style:font-name-asian="DejaVu Sans" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-name-complex="DejaVu Sans" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
		</style:default-style>
		<style:default-style style:family="table">
			<style:table-properties table:border-model="collapsing"/>
		</style:default-style>
		<style:default-style style:family="table-row">
			<style:table-row-properties fo:keep-together="always"/>
		</style:default-style>
		<style:style style:name="Standard" style:family="paragraph" style:class="text"/>
			<style:style style:name="Text_20_body" style:display-name="Text body" style:family="paragraph" style:parent-style-name="Standard" style:class="text">
			<style:paragraph-properties fo:margin-top="0cm" fo:margin-bottom="0.212cm"/>
		</style:style>
		<style:style style:name="Heading" style:family="paragraph" style:parent-style-name="Standard" style:next-style-name="Text_20_body" style:class="text">
				<style:paragraph-properties fo:margin-top="0.423cm" fo:margin-bottom="0.212cm" fo:keep-with-next="always"/>
				<style:text-properties style:font-name="Helvetica" fo:font-size="14pt" style:font-name-asian="DejaVu Sans" style:font-size-asian="14pt" style:font-name-complex="DejaVu Sans" style:font-size-complex="14pt"/>
		</style:style>
		<style:style style:name="List" style:family="paragraph" style:parent-style-name="Text_20_body" style:class="list">
			<style:text-properties style:font-name="Times" style:font-size-asian="12pt"/>
		</style:style>
		<style:style style:name="Header" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
			<style:paragraph-properties text:number-lines="false" text:line-number="0">
				<style:tab-stops>
					<style:tab-stop style:position="8.498cm" style:type="center"/>
					<style:tab-stop style:position="16.999cm" style:type="right"/>
				</style:tab-stops>
			</style:paragraph-properties>
			<style:text-properties fo:color="#0000ff" style:font-size-asian="10.5pt"/>
		</style:style>
		<style:style style:name="Footer" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
			<style:paragraph-properties text:number-lines="false" text:line-number="0">
				<style:tab-stops>
					<style:tab-stop style:position="8.498cm" style:type="center"/>
					<style:tab-stop style:position="16.999cm" style:type="right"/>
				</style:tab-stops>
			</style:paragraph-properties>
		</style:style>
		<style:style style:name="Table_20_Contents" style:display-name="Table Contents" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
			<style:paragraph-properties text:number-lines="false" text:line-number="0"/>
		</style:style>
		<style:style style:name="Table_20_Heading" style:display-name="Table Heading" style:family="paragraph" style:parent-style-name="Table_20_Contents" style:class="extra">
			<style:paragraph-properties fo:text-align="center" style:justify-single-word="false" text:number-lines="false" text:line-number="0"/>
			<style:text-properties fo:font-weight="bold" style:fw-asian="bold" style:fw-complex="bold"/>
		</style:style>
		<style:style style:name="Caption" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
			<style:paragraph-properties fo:margin-top="0.212cm" fo:margin-bottom="0.212cm" text:number-lines="false" text:line-number="0"/>
			<style:text-properties style:font-name="Times" fo:font-size="12pt" fo:font-style="italic" style:font-size-asian="12pt" style:fst-asian="italic" style:font-size-complex="12pt" style:fst-complex="italic"/>
		</style:style>
		<style:style style:name="Index" style:family="paragraph" style:parent-style-name="Standard" style:class="index">
			<style:paragraph-properties text:number-lines="false" text:line-number="0"/>
			<style:text-properties style:font-name="Times" style:font-size-asian="12pt"/>
		</style:style>
		<style:style style:name="Footnote_20_Symbol" style:display-name="Footnote Symbol" style:family="text"/>
		<style:style style:name="Endnote_20_Symbol" style:display-name="Endnote Symbol" style:family="text"/>
			<style:style style:name="Graphics" style:family="graphic">
			<style:graphic-properties text:anchor-type="paragraph" svg:x="0cm" svg:y="0cm" style:wrap="dynamic" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph" style:horizontal-pos="center" style:horizontal-rel="paragraph"/>
		</style:style>
		<text:outline-style>
			<text:outline-level-style text:level="1" style:num-format="">
			<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="2" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="3" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="4" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="5" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="6" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="7" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="8" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="9" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
			<text:outline-level-style text:level="10" style:num-format="">
				<style:list-level-properties text:min-label-distance="0.381cm"/>
			</text:outline-level-style>
		</text:outline-style>
		<text:notes-configuration text:note-class="footnote" text:citation-style-name="Footnote_20_Symbol" style:num-format="1" text:start-value="0" text:footnotes-position="page" text:start-numbering-at="page"/>
		<text:notes-configuration text:note-class="endnote" text:citation-style-name="Endnote_20_Symbol" text:master-page-name="Endnote" style:num-format="1" text:start-value="0"/>
		<text:linenumbering-configuration text:number-lines="false" text:offset="0.499cm" style:num-format="1" text:number-position="left" text:increment="5"/>
	</office:styles>
	<office:automatic-styles>
		<style:style style:name="Table2" style:family="table">
			<style:table-properties style:width="16.999cm" table:align="margins"/>
		</style:style>
		<style:style style:name="Table2.A" style:family="table-column">
			<style:table-column-properties style:column-width="4.235cm" style:rel-column-width="16329*"/>
		</style:style>
		<style:style style:name="Table2.B" style:family="table-column">
			<style:table-column-properties style:column-width="12.764cm" style:rel-column-width="49206*"/>
		</style:style>
		<style:style style:name="Table2.A1" style:family="table-cell">
			<style:table-cell-properties style:vertical-align="bottom" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="none" fo:border-bottom="0.018cm solid #000000"/>
		</style:style>
		<style:style style:name="Table3" style:family="table">
			<style:table-properties style:width="7.936cm" table:align="left"/>
		</style:style>
		<style:style style:name="Table3.A" style:family="table-column">
			<style:table-column-properties style:column-width="1.933cm"/>
		</style:style>
		<style:style style:name="Table3.B" style:family="table-column">
			<style:table-column-properties style:column-width="6.003cm"/>
		</style:style>
		<style:style style:name="Table3.A1" style:family="table-cell">
			<style:table-cell-properties style:vertical-align="bottom" fo:padding="0.097cm" fo:border="none"/>
		</style:style>
		<style:style style:name="Table3.A2" style:family="table-cell">
			<style:table-cell-properties style:vertical-align="bottom" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="none" fo:border-bottom="0.018cm solid #000000"/>
		</style:style>
		<style:style style:name="Table1" style:family="table">
			<style:table-properties style:width="16.999cm" table:align="margins"/>
		</style:style>
		<style:style style:name="Table1.A" style:family="table-column">
			<style:table-column-properties style:column-width="16.999cm" style:rel-column-width="65535*"/>
		</style:style>
		<style:style style:name="Table1.A1" style:family="table-cell">
			<style:table-cell-properties fo:background-color="transparent" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="0.018cm solid #000000" fo:border-bottom="none">
			<style:background-image/>
			</style:table-cell-properties>
		</style:style>
		<style:style style:name="P1" style:family="paragraph" style:parent-style-name="Header">
			<style:text-properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="30pt" style:font-name-asian="Monospace" style:font-size-asian="30pt" style:font-name-complex="Monospace" style:font-size-complex="30pt"/>
			</style:style>
		<style:style style:name="P2" style:family="paragraph" style:parent-style-name="Table_20_Contents">
			<style:paragraph-properties fo:text-align="end" style:justify-single-word="false"/>
			<style:text-properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
		</style:style>
		<style:style style:name="P3" style:family="paragraph" style:parent-style-name="Header">
			<style:text-properties style:font-name="Monospace" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
		</style:style>
		<style:style style:name="P4" style:family="paragraph" style:parent-style-name="Table_20_Contents">
			<style:text-properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-size-asian="8.75pt" style:font-size-complex="10pt"/>
		</style:style>
		<style:style style:name="P5" style:family="paragraph" style:parent-style-name="Table_20_Contents">
			<style:paragraph-properties fo:text-align="end" style:justify-single-word="false"/>
			<style:text-properties fo:color="#0000ff" style:font-name="Monospace" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
		</style:style>
		<style:style style:name="P6" style:family="paragraph" style:parent-style-name="Header">
			<style:text-properties style:font-name="Helvetica1" fo:font-size="10pt" style:font-size-asian="8.75pt" style:font-size-complex="10pt"/>
		</style:style>
		<style:style style:name="P7" style:family="paragraph" style:parent-style-name="Footer">
			<style:paragraph-properties fo:text-align="center" style:justify-single-word="false"/>
			<style:text-properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
		</style:style>
		<style:page-layout style:name="pm1">
			<style:page-layout-properties fo:page-width="20.999cm" fo:page-height="29.699cm" style:num-format="1" style:print-orientation="portrait" fo:margin-top="2cm" fo:margin-bottom="2cm" fo:margin-left="2cm" fo:margin-right="2cm" style:writing-mode="lr-tb" style:footnote-max-height="0cm">
				<style:footnote-sep style:width="0.018cm" style:distance-before-sep="0.101cm" style:distance-after-sep="0.101cm" style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
			</style:page-layout-properties>
			<style:header-style>
				<style:header-footer-properties fo:min-height="0cm" fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-bottom="0.499cm"/>
			</style:header-style>
			<style:footer-style>
				<style:header-footer-properties fo:min-height="0cm" fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0.499cm"/>
			</style:footer-style>
		</style:page-layout>
		<style:page-layout style:name="pm2">
			<style:page-layout-properties fo:page-width="20.999cm" fo:page-height="29.699cm" style:num-format="1" style:print-orientation="portrait" fo:margin-top="2cm" fo:margin-bottom="2cm" fo:margin-left="2cm" fo:margin-right="2cm" style:writing-mode="lr-tb" style:footnote-max-height="0cm">
				<style:footnote-sep style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
			</style:page-layout-properties>
			<style:header-style/>
			<style:footer-style/>
		</style:page-layout>
		</office:automatic-styles>
		<office:master-styles>
			<style:master-page style:name="Standard" style:page-layout-name="pm1">
				<style:header>
				<table:table table:name="Table2" table:style-name="Table2">
					<table:table-column table:style-name="Table2.A"/>
					<table:table-column table:style-name="Table2.B"/>
					<table:table-row>
						<table:table-cell table:style-name="Table2.A1" office:value-type="string">
							<text:p text:style-name="P1">Tiny sprl</text:p>
						</table:table-cell>
						<table:table-cell table:style-name="Table2.A1" office:value-type="string">
							<text:p text:style-name="P2"/>
						</table:table-cell>
					</table:table-row>
				</table:table>
			<text:p text:style-name="P3"/>
			<text:p text:style-name="P3">- </text:p>
			<table:table table:name="Table3" table:style-name="Table3">
				<table:table-column table:style-name="Table3.A"/>
				<table:table-column table:style-name="Table3.B"/>
				<table:table-row>
					<table:table-cell table:style-name="Table3.A1" office:value-type="string">
						<text:p text:style-name="P4">Phone :</text:p>
					</table:table-cell>
					<table:table-cell table:style-name="Table3.A1" office:value-type="string">
						<text:p text:style-name="P5"/>
					</table:table-cell>
				</table:table-row>
				<table:table-row>
					<table:table-cell table:style-name="Table3.A2" office:value-type="string">
						<text:p text:style-name="P4">Mail :</text:p>
					</table:table-cell>
					<table:table-cell table:style-name="Table3.A2" office:value-type="string">
						<text:p text:style-name="P5"/>
					</table:table-cell>
				</table:table-row>
			</table:table>
			<text:p text:style-name="P6"/>
		</style:header>
		<style:footer>
			<table:table table:name="Table1" table:style-name="Table1">
				<table:table-column table:style-name="Table1.A"/>
				<table:table-row>
					<table:table-cell table:style-name="Table1.A1" office:value-type="string">
						<text:p text:style-name="P7"/>
						<text:p text:style-name="P7"/>
						<text:p text:style-name="P7">Contact : Administrator</text:p>
					</table:table-cell>
				</table:table-row>
			</table:table>
		</style:footer>
	</style:master-page>
	<style:master-page style:name="Endnote" style:page-layout-name="pm2"/>
	</office:master-styles>
</office:document-styles>
```

  File: report/corporate_sxw_header.xml
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<office:document-styles xmlns:office="http://openoffice.org/2000/office" xmlns:style="http://openoffice.org/2000/style" xmlns:text="http://openoffice.org/2000/text" xmlns:table="http://openoffice.org/2000/table" xmlns:draw="http://openoffice.org/2000/drawing" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="http://openoffice.org/2000/meta" xmlns:number="http://openoffice.org/2000/datastyle" xmlns:svg="http://www.w3.org/2000/svg" xmlns:chart="http://openoffice.org/2000/chart" xmlns:dr3d="http://openoffice.org/2000/dr3d" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="http://openoffice.org/2000/form" xmlns:script="http://openoffice.org/2000/script" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" office:version="1.0">
    <office:font-decls>
        <style:font-decl style:name="Helvetica" fo:font-family="Helvetica"/>
        <style:font-decl style:name="Times" fo:font-family="Times"/>
        <style:font-decl style:name="Helvetica1" fo:font-family="Helvetica" style:font-family-generic="swiss"/>
        <style:font-decl style:name="Monospace" fo:font-family="Monospace" style:font-pitch="fixed"/>
        <style:font-decl style:name="DejaVu Sans" fo:font-family="&apos;DejaVu Sans&apos;" style:font-family-generic="system" style:font-pitch="variable"/>
    </office:font-decls>
    <office:styles>
        <style:default-style style:family="graphics">
            <style:properties draw:shadow-offset-x="0.3cm" draw:shadow-offset-y="0.3cm" draw:start-line-spacing-horizontal="0.283cm" draw:start-line-spacing-vertical="0.283cm" draw:end-line-spacing-horizontal="0.283cm" draw:end-line-spacing-vertical="0.283cm" style:text-autospace="ideograph-alpha" style:line-break="strict" style:writing-mode="lr-tb" style:font-independent-line-spacing="false" style:use-window-font-color="true" fo:font-size="12pt" fo:language="en" fo:country="IN" style:letter-kerning="true" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none">
                <style:tab-stops/>
            </style:properties>
        </style:default-style>
        <style:default-style style:family="paragraph">
            <style:properties fo:hyphenation-ladder-count="no-limit" style:text-autospace="ideograph-alpha" style:punctuation-wrap="hanging" style:line-break="strict" style:tab-stop-distance="1.251cm" style:writing-mode="page" style:use-window-font-color="true" style:font-name="Times" fo:font-size="12pt" fo:language="en" fo:country="IN" style:letter-kerning="true" style:font-name-asian="DejaVu Sans" style:font-size-asian="10.5pt" style:language-asian="zxx" style:country-asian="none" style:font-name-complex="DejaVu Sans" style:font-size-complex="12pt" style:language-complex="zxx" style:country-complex="none" fo:hyphenate="false" fo:hyphenation-remain-char-count="2" fo:hyphenation-push-char-count="2"/>
        </style:default-style>
        <style:default-style style:family="table">
            <style:properties table:border-model="collapsing"/>
        </style:default-style>
        <style:default-style style:family="table-row">
            <style:properties fo:keep-together="always"/>
        </style:default-style>
        <style:style style:name="Standard" style:family="paragraph" style:class="text"/>
        <style:style style:name="Text body" style:family="paragraph" style:parent-style-name="Standard" style:class="text">
            <style:properties fo:margin-top="0cm" fo:margin-bottom="0.212cm"/>
        </style:style>
        <style:style style:name="Heading" style:family="paragraph" style:parent-style-name="Standard" style:next-style-name="Text body" style:class="text">
            <style:properties fo:margin-top="0.423cm" fo:margin-bottom="0.212cm" fo:keep-with-next="true" style:font-name="Helvetica" fo:font-size="14pt" style:font-name-asian="DejaVu Sans" style:font-size-asian="14pt" style:font-name-complex="DejaVu Sans" style:font-size-complex="14pt"/>
        </style:style>
        <style:style style:name="List" style:family="paragraph" style:parent-style-name="Text body" style:class="list">
            <style:properties style:font-name="Times" style:font-size-asian="12pt"/>
        </style:style>
        <style:style style:name="Header" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
            <style:properties text:number-lines="false" text:line-number="0" fo:color="#0000ff" style:font-size-asian="10.5pt">
                <style:tab-stops>
                    <style:tab-stop style:position="8.498cm" style:type="center"/>
                    <style:tab-stop style:position="16.999cm" style:type="right"/>
                </style:tab-stops>
            </style:properties>
        </style:style>
        <style:style style:name="Footer" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
            <style:properties text:number-lines="false" text:line-number="0">
                <style:tab-stops>
                    <style:tab-stop style:position="8.498cm" style:type="center"/>
                    <style:tab-stop style:position="16.999cm" style:type="right"/>
                </style:tab-stops>
            </style:properties>
        </style:style>
        <style:style style:name="Table Contents" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
            <style:properties text:number-lines="false" text:line-number="0"/>
        </style:style>
        <style:style style:name="Table Heading" style:family="paragraph" style:parent-style-name="Table Contents" style:class="extra">
            <style:properties fo:text-align="center" style:justify-single-word="false" text:number-lines="false" text:line-number="0" fo:font-weight="bold" style:fw-asian="bold" style:fw-complex="bold"/>
        </style:style>
        <style:style style:name="Caption" style:family="paragraph" style:parent-style-name="Standard" style:class="extra">
            <style:properties fo:margin-top="0.212cm" fo:margin-bottom="0.212cm" text:number-lines="false" text:line-number="0" style:font-name="Times" fo:font-size="12pt" fo:font-style="italic" style:font-size-asian="12pt" style:fst-asian="italic" style:font-size-complex="12pt" style:fst-complex="italic"/>
        </style:style>
        <style:style style:name="Index" style:family="paragraph" style:parent-style-name="Standard" style:class="index">
            <style:properties text:number-lines="false" text:line-number="0" style:font-name="Times" style:font-size-asian="12pt"/>
        </style:style>
        <style:style style:name="Footnote Symbol" style:family="text"/>
        <style:style style:name="Endnote Symbol" style:family="text"/>
        <style:style style:name="Graphics" style:family="graphics">
            <style:properties text:anchor-type="paragraph" svg:x="0cm" svg:y="0cm" style:wrap="dynamic" style:number-wrapped-paragraphs="no-limit" style:wrap-contour="false" style:vertical-pos="top" style:vertical-rel="paragraph" style:horizontal-pos="center" style:horizontal-rel="paragraph"/>
        </style:style>
        <text:outline-style>
            <text:outline-level-style text:level="1" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="2" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="3" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="4" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="5" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="6" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="7" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="8" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="9" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
            <text:outline-level-style text:level="10" style:num-format="">
                <style:properties text:min-label-distance="0.381cm"/>
            </text:outline-level-style>
        </text:outline-style>
        <text:footnotes-configuration text:citation-style-name="Footnote Symbol" style:num-format="1" text:start-value="0" text:footnotes-position="page" text:start-numbering-at="page"/>
        <text:endnotes-configuration text:citation-style-name="Endnote Symbol" text:master-page-name="Endnote" style:num-format="1" text:start-value="0"/>
        <text:linenumbering-configuration text:number-lines="false" text:offset="0.499cm" style:num-format="1" text:number-position="left" text:increment="5"/>
    </office:styles>
    <office:automatic-styles>
        <style:style style:name="Table2" style:family="table">
            <style:properties style:width="16.999cm" table:align="margins"/>
        </style:style>
        <style:style style:name="Table2.A" style:family="table-column">
            <style:properties style:column-width="4.235cm" style:rel-column-width="16329*"/>
        </style:style>
        <style:style style:name="Table2.B" style:family="table-column">
            <style:properties style:column-width="12.764cm" style:rel-column-width="49206*"/>
        </style:style>
        <style:style style:name="Table2.A1" style:family="table-cell">
            <style:properties fo:vertical-align="bottom" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="none" fo:border-bottom="0.018cm solid #000000"/>
        </style:style>
        <style:style style:name="Table3" style:family="table">
            <style:properties style:width="7.936cm" table:align="left"/>
        </style:style>
        <style:style style:name="Table3.A" style:family="table-column">
            <style:properties style:column-width="1.933cm"/>
        </style:style>
        <style:style style:name="Table3.B" style:family="table-column">
            <style:properties style:column-width="6.003cm"/>
        </style:style>
        <style:style style:name="Table3.A1" style:family="table-cell">
            <style:properties fo:vertical-align="bottom" fo:padding="0.097cm" fo:border="none"/>
        </style:style>
        <style:style style:name="Table3.A2" style:family="table-cell">
            <style:properties fo:vertical-align="bottom" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="none" fo:border-bottom="0.018cm solid #000000"/>
        </style:style>
        <style:style style:name="Table1" style:family="table">
            <style:properties style:width="16.999cm" table:align="margins"/>
        </style:style>
        <style:style style:name="Table1.A" style:family="table-column">
            <style:properties style:column-width="16.999cm" style:rel-column-width="65535*"/>
        </style:style>
        <style:style style:name="Table1.A1" style:family="table-cell">
            <style:properties fo:background-color="transparent" fo:padding="0.097cm" fo:border-start="none" fo:border-end="none" fo:border-top="0.018cm solid #000000" fo:border-bottom="none">
                <style:background-image/>
            </style:properties>
        </style:style>
        <style:style style:name="P1" style:family="paragraph" style:parent-style-name="Header">
            <style:properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="30pt" style:font-name-asian="Monospace" style:font-size-asian="30pt" style:font-name-complex="Monospace" style:font-size-complex="30pt"/>
        </style:style>
        <style:style style:name="P2" style:family="paragraph" style:parent-style-name="Table Contents">
            <style:properties fo:text-align="end" style:justify-single-word="false" fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P3" style:family="paragraph" style:parent-style-name="Header">
            <style:properties style:font-name="Monospace" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P4" style:family="paragraph" style:parent-style-name="Table Contents">
            <style:properties fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-size-asian="8.75pt" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P5" style:family="paragraph" style:parent-style-name="Table Contents">
            <style:properties fo:text-align="end" style:justify-single-word="false" fo:color="#0000ff" style:font-name="Monospace" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P6" style:family="paragraph" style:parent-style-name="Header">
            <style:properties style:font-name="Helvetica1" fo:font-size="10pt" style:font-size-asian="8.75pt" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P7" style:family="paragraph" style:parent-style-name="Footer">
            <style:properties fo:text-align="center" style:justify-single-word="false" fo:color="#0000ff" style:font-name="Helvetica1" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="P8" style:family="paragraph" style:parent-style-name="Footer">
            <style:properties fo:text-align="center" style:justify-single-word="false" style:font-name="Helvetica1" fo:font-size="10pt" style:font-size-asian="10pt" style:font-size-complex="10pt"/>
        </style:style>
        <style:style style:name="T1" style:family="text">
            <style:properties fo:color="#0000ff"/>
        </style:style>
        <style:style style:name="T2" style:family="text">
            <style:properties fo:color="#0000ff" fo:font-size="10pt" style:font-name-asian="Monospace" style:font-size-asian="10pt" style:font-name-complex="Monospace" style:font-size-complex="10pt"/>
        </style:style>
        <style:page-master style:name="pm1">
            <style:properties fo:page-width="20.999cm" fo:page-height="29.699cm" style:num-format="1" style:print-orientation="portrait" fo:margin-top="2cm" fo:margin-bottom="2cm" fo:margin-left="2cm" fo:margin-right="2cm" style:writing-mode="lr-tb" style:footnote-max-height="0cm">
                <style:footnote-sep style:width="0.018cm" style:distance-before-sep="0.101cm" style:distance-after-sep="0.101cm" style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
            </style:properties>
            <style:header-style>
                <style:properties fo:min-height="0cm" fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-bottom="0.499cm"/>
            </style:header-style>
            <style:footer-style>
                <style:properties fo:min-height="0cm" fo:margin-left="0cm" fo:margin-right="0cm" fo:margin-top="0.499cm"/>
            </style:footer-style>
        </style:page-master>
        <style:page-master style:name="pm2">
            <style:properties fo:page-width="20.999cm" fo:page-height="29.699cm" style:num-format="1" style:print-orientation="portrait" fo:margin-top="2cm" fo:margin-bottom="2cm" fo:margin-left="2cm" fo:margin-right="2cm" style:writing-mode="lr-tb" style:footnote-max-height="0cm">
                <style:footnote-sep style:adjustment="left" style:rel-width="25%" style:color="#000000"/>
            </style:properties>
            <style:header-style/>
            <style:footer-style/>
        </style:page-master>
    </office:automatic-styles>
    <office:master-styles>
        <style:master-page style:name="Standard" style:page-master-name="pm1">
            <style:header>
                <table:table table:name="Table2" table:style-name="Table2">
                    <table:table-column table:style-name="Table2.A"/>
                    <table:table-column table:style-name="Table2.B"/>
                    <table:table-row>
                        <table:table-cell table:style-name="Table2.A1" table:value-type="string">
                            <text:p text:style-name="P1">[[ company.partner_id.name ]]</text:p>
                        </table:table-cell>
                        <table:table-cell table:style-name="Table2.A1" table:value-type="string">
                            <text:p text:style-name="P2">[[ company.report_header ]]</text:p>
                        </table:table-cell>
                    </table:table-row>
                </table:table>
                <text:p text:style-name="P3">[[ company.partner_id.street ]]</text:p>
                <text:p text:style-name="P3">[[ company.partner_id.zip ]] [[ company.partner_id.city ]] - [[ company.partner_id.country_id and company.partner_id.country_id.name ]]</text:p>
                <table:table table:name="Table3" table:style-name="Table3">
                    <table:table-column table:style-name="Table3.A"/>
                    <table:table-column table:style-name="Table3.B"/>
                    <table:table-row>
                        <table:table-cell table:style-name="Table3.A1" table:value-type="string">
                            <text:p text:style-name="P4">Phone :</text:p>
                        </table:table-cell>
                        <table:table-cell table:style-name="Table3.A1" table:value-type="string">
                            <text:p text:style-name="P5">[[ company.partner_id.phone ]]</text:p>
                        </table:table-cell>
                    </table:table-row>
                    <table:table-row>
                        <table:table-cell table:style-name="Table3.A2" table:value-type="string">
                            <text:p text:style-name="P4">Mail :</text:p>
                        </table:table-cell>
                        <table:table-cell table:style-name="Table3.A2" table:value-type="string">
                            <text:p text:style-name="P5">[[ company.partner_id.email ]]</text:p>
                        </table:table-cell>
                    </table:table-row>
                </table:table>
                <text:p text:style-name="P6"/>
            </style:header>
            <style:footer>
                <table:table table:name="Table1" table:style-name="Table1">
                    <table:table-column table:style-name="Table1.A"/>
                    <table:table-row>
                        <table:table-cell table:style-name="Table1.A1" table:value-type="string">
                            <text:p text:style-name="P7">[[ company.report_footer ]]</text:p>
                            <text:p text:style-name="P7">Contact : [[ user.name ]]</text:p>
                        </table:table-cell>
                    </table:table-row>
                </table:table>
            </style:footer>
        </style:master-page>
        <style:master-page style:name="Endnote" style:page-master-name="pm2"/>
    </office:master-styles>
</office:document-styles>

```

  File: report/custom_default_printscreen.xsl
  Content:
```
<?xml version = '1.0' encoding="utf-8"?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">
	<xsl:template name="first_page_graphics_corporation">
		<!--logo-->
		<fill color="black"/>
        <stroke color="black"/>
        <setFont name="DejaVuSans" size="8"/>
        <drawString x="1.3cm" y="19.5cm"><xsl:value-of select="//header-date"/></drawString>
        <setFont name="DejaVuSans-Bold" size="10"/>
        <drawString x="13.8cm" y="19.5cm"><xsl:value-of select="//company"/></drawString>
        <stroke color="#000000"/>
        <lines size="8">1.3cm 19.3cm 28.5cm 19.3cm</lines>
	</xsl:template>

   <xsl:template name="first_page_frames">
			<frame id="col1" x1="2.0cm" y1="2.5cm" width="24.7cm" height="16cm"/>
	</xsl:template>

</xsl:stylesheet>

```

  File: report/custom_new.xsl
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">

	<xsl:import href="../../base/report/custom_default_printscreen.xsl"/>
	<xsl:import href="../../base/report/custom_rml_printscreen.xsl"/>
	<xsl:template match="/">
		<xsl:call-template name="rml">
			<xsl:with-param name="pageSize" select="report/config/PageSize"/>
			<xsl:with-param name="page_format" select="report/config/PageFormat"/>
		</xsl:call-template>
	</xsl:template>

	<!-- stylesheet -->

	<xsl:template name="stylesheet">
		<paraStyle name="title" fontName="Helvetica-Bold" fontSize="22" alignment="center"/>
		<paraStyle name="test" alignment="left" />
        <paraStyle name="float_right" alignment="left"/>
        <paraStyle name="tbl_heading" alignment="left"/>
		<blockTableStyle id="products">
			<!--<blockBackground colorName="grey" start="0,0" stop="-1,0"/> -->
			<lineStyle kind="LINEBELOW" colorName="#000000" start="0,0" stop="-1,0"/>
			<blockValign value="TOP"/>
			 <blockAlignment value="RIGHT"/>
			 <lineStyle kind="LINEBELOW" colorName="#e6e6e6" start="0,1" stop="-1,-1"/>
			<!-- <lineStyle kind="GRID" colorName="black"/> -->
		</blockTableStyle>
	</xsl:template>

	<xsl:template name="story">
		<xsl:apply-templates select="report"/>
	</xsl:template>

	<xsl:template match="report">
		<xsl:apply-templates select="config"/>
		<!--<setNextTemplate name="other_pages"/>-->
		<blockTable style="products">
		<xsl:if test="string-length(./config/tableSize)&gt;1">
			<xsl:attribute name="colWidths">
				 <xsl:value-of select="./config/tableSize"/>
			</xsl:attribute>
		</xsl:if>

		<xsl:apply-templates select="header"/>
		<xsl:apply-templates select="lines"/>
		</blockTable>
	</xsl:template>

	<xsl:template match="config">
		<para style="title">
		<xsl:value-of select="report-header"/>
		</para>
		<spacer length="1cm" width="2mm"/>
	</xsl:template>

	<xsl:template match="header">
		<tr>
		<xsl:for-each select="field">
			<td>
			<para style="tbl_heading"><font fontName="Helvetica-Bold" fontSize="9">
			<xsl:value-of select="."/></font>
			</para>
			</td>
		</xsl:for-each>
		</tr>
	</xsl:template>

	<xsl:template match="lines">
		<xsl:apply-templates select="row"/>
	</xsl:template>

	<xsl:template match="row">
		<tr>
		<xsl:apply-templates select="col"/>
		</tr>
	</xsl:template>

	<xsl:template match="col">
		<td>
			<xsl:choose>
				<xsl:when test="@para='yes'">
					<xsl:choose>
						<xsl:when test="@tree='yes'">
							<para style="test">
								<xsl:attribute name="leftIndent"><xsl:value-of select="@space"/></xsl:attribute>
								<font fontName="Helvetica" fontSize="9">
								<xsl:value-of select="."/>
								</font>
							</para>
						</xsl:when>
                       <xsl:when test="@tree='float'">
                           <para style="float_right"><font fontName="Helvetica" fontSize="9">
                               <xsl:value-of select="."/>
                               </font></para>
                       </xsl:when>

						<xsl:otherwise>
							<para style="test">
								<font fontName="Helvetica" fontSize="9">
								<xsl:value-of select="."/>
								</font>
							</para>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="@para='group'">
					<xsl:choose>
						<xsl:when test="@tree='yes'">
							<para>
								<xsl:attribute name="leftIndent"><xsl:value-of select="@space"/></xsl:attribute>
								<font fontName="Helvetica-bold" fontSize="9">
								<xsl:value-of select="."/>
								</font>
							</para>
						</xsl:when>
                       <xsl:when test="@tree='float'">
                           <para style="float_right"><font fontName="Helvetica-bold" fontSize="9" color="black">
                               <xsl:value-of select="."/>
                               </font></para>
                       </xsl:when>
                       <xsl:when test="@tree='undefined'">
                            <para>
                                <xsl:attribute name="leftIndent">
                                    <xsl:value-of select="@space"/>
                                </xsl:attribute>
                                <font fontName="Helvetica-Bold" fontSize="9" color="gray">
                                    <xsl:value-of select="."/>
                                </font>
                            </para>
                       </xsl:when>

						<xsl:otherwise>
							<para>
								<font fontName="Helvetica-bold" fontSize="9" color="black">
								<xsl:value-of select="."/>
								</font>
							</para>
						</xsl:otherwise>
					</xsl:choose>

				</xsl:when>
				<xsl:otherwise>
					<xpre>
						<xsl:value-of select="."/>
					</xpre>
				</xsl:otherwise>
			</xsl:choose>
		</td>
	</xsl:template>


<!--	<xsl:template match="col">
		<td>
		<xsl:if test="@tree='yes'">
			<xsl:choose>
				<xsl:when test="@para='yes'">
					<para>
						<xsl:attribute name="leftIndent"><xsl:value-of select="@space"/></xsl:attribute>
						<xsl:value-of select="."/>
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xpre>
						<xsl:value-of select="."/>
					</xpre>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
		<xsl:if test="@tree!='yes'">
			<xpre>
			<xsl:value-of select="."/>
			</xpre>
		</xsl:if>
		</td>
	</xsl:template>
-->
</xsl:stylesheet>

```

  File: report/custom_report.xml
  Content:
```
<?xml version="1.0"?>
<odoo>
    <data>
        
    </data>
</odoo>

```

  File: report/custom_rml_printscreen.xsl
  Content:
```
<?xml version = '1.0' encoding="utf-8"?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:fo="http://www.w3.org/1999/XSL/Format">

	<xsl:template name="first_page_graphics_report"/>

	<xsl:template name="rml">
		<document filename="example.pdf">
			<template leftMargin="2.0cm" rightMargin="2.0cm" topMargin="2.0cm" bottomMargin="2.0cm" title="Report" author="Generated by Odoo, Fabien Pinckaers" allowSplitting="20">
				<pageTemplate id="first_page">
					<pageGraphics>
						<xsl:call-template name="first_page_graphics_corporation"/>
					</pageGraphics>

					<xsl:call-template name="first_page_frames"/>
				</pageTemplate>
			</template>

			<stylesheet>
			    <xsl:call-template name="stylesheet"/>
		    </stylesheet>

			<story>
				<xsl:call-template name="story"/>
			</story>

		</document>
    </xsl:template>
</xsl:stylesheet>

```

  File: report/custom_view.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
    </data>
</odoo>

```

  File: report/ir_model_report.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
        <record id="report_ir_model_overview" model="ir.actions.report">
            <field name="name">Model Overview</field>
            <field name="model">ir.model</field>
            <field name="report_type">qweb-pdf</field>
            <field name="report_name">base.report_irmodeloverview</field>
            <field name="report_file">base.report_irmodeloverview</field>
            <field name="binding_model_id" ref="model_ir_model"/>
            <field name="binding_type">report</field>
        </record>

</odoo>


```

  File: report/ir_model_templates.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
<template id="report_irmodeloverview">
    <t t-call="web.html_container">
        <t t-foreach="docs" t-as="o">
            <div class="article" t-att-data-oe-model="o._name" t-att-data-oe-id="o.id">
                <table class="table table-bordered mb64">
                    <tr>
                        <td colspan="12">
                            <strong>Object: <span t-field="o.model"/>
                            <p>Name: <span t-field="o.name"/></p></strong>
                        </td>
                        <td colspan="8">
                            <p>Type: <span t-field="o.state"/></p>
                            <p t-if="o.transient">Transient: True</p>
                            <p t-if="not o.transient">Transient: False</p>
                            <p>Apps: <span t-field="o.modules"/></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="20"><u><strong>Security</strong></u></td>
                    </tr>
                    <tr>
                        <td colspan="4"><strong>Group</strong></td>
                        <td><strong>R</strong></td>
                        <td><strong>W</strong></td>
                        <td><strong>C</strong></td>
                        <td><strong>U</strong></td>
                        <td colspan="12"><strong>Name</strong></td>
                    </tr>
                    <tr t-foreach="o.access_ids" t-as="access">
                        <td colspan="4"><span t-field="access.group_id"/></td>
                        <td><t t-if="access.perm_read">X</t></td>
                        <td><t t-if="access.perm_write">X</t></td>
                        <td><t t-if="access.perm_create">X</t></td>
                        <td><t t-if="access.perm_unlink">X</t></td>
                        <td colspan="12"><span t-field="access.name"/></td>
                    </tr>
                    <tr>
                        <td colspan="20"><u><strong>Fields</strong></u></td>
                    </tr>
                    <tr>
                        <td colspan="3"><strong>Name</strong></td>
                        <td colspan="3"><strong>Label</strong></td>
                        <td colspan="2"><strong>Type</strong></td>
                        <td colspan="4"><strong>Attribute</strong></td>
                        <td><strong>Rq</strong></td>
                        <td><strong>Ro</strong></td>
                        <td><strong>Tr</strong></td>
                        <td><strong>Idx</strong></td>
                        <td colspan="4"><strong>Apps</strong></td>
                    </tr>
                    <tr t-foreach="o.field_id" t-as="field">
                        <td colspan="3"><span t-field="field.name"/></td>
                        <td colspan="3"><span t-field="field.field_description"/></td>
                        <td colspan="2"><span t-field="field.ttype"/></td>
                        <td colspan="4">
                            <p t-if="field.relation"><span>- relation = <span t-field="field.relation"/></span></p>
                            <p t-if="field.relation_field"><span>- field = <span t-field="field.relation_field"/></span></p>
                            <div t-if="field.selection_ids">
                                <span>- selection = [
                                    <t t-foreach="field.selection_ids" t-as="selection">
                                        (<span t-field="selection.value"/>, <span t-field="selection.name"/>),
                                    </t>]
                                </span>
                            </div>
                            <div t-if="field.size"><span>- size = <span t-field="field.size"/></span></div>
                            <div t-if="field.on_delete"><span>- ondelete = <span t-field="field.on_delete"/></span></div>
                            <div t-if="field.domain"><span>- domain = <span t-field="field.domain"/></span></div>
                            <div t-if="field.groups"><span>- groups = <span t-esc="', '.join(g.name for g in field.groups)"/></span></div>
                        </td>
                        <td><t t-if="field.required">X</t></td>
                        <td><t t-if="field.readonly">X</t></td>
                        <td><t t-if="field.translate">X</t></td>
                        <td><t t-if="field.index">X</t></td>
                        <td colspan="4"><span t-field="field.modules"/></td>
                    </tr>
                    <tr>
                        <td colspan="20"><u><strong>Views</strong></u></td>
                    </tr>
                    <tr>
                        <td><strong>Seq</strong></td>
                        <td><strong>Type</strong></td>
                        <td colspan="4"><strong>Name</strong></td>
                        <td colspan="6"><strong>XML ID</strong></td>
                        <td colspan="8"><strong>Inherited</strong></td>
                    </tr>
                    <tr t-foreach="o.view_ids" t-as="view">
                        <td><span t-field="view.priority"/></td>
                        <td><span t-field="view.type"/></td>
                        <td colspan="4"><span t-field="view.name"/></td>
                        <td colspan="6"><span t-field="view.xml_id"/></td>
                        <td colspan="8" t-if="view.inherit_id.xml_id"><span t-field="view.inherit_id.xml_id"/></td>
                        <td colspan="8" t-if="not view.inherit_id.xml_id"><span t-field="view.inherit_id.name"/></td>
                    </tr>
                </table>
            </div>
        </t>
    </t>
</template>
</odoo>

```

  File: report/ir_module_report_templates.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
<data>
<template id="report_irmodulereference">
    <t t-call="web.html_container">
        <t t-foreach="docs" t-as="o">
            <t t-call="web.internal_layout">
                <div class="page">
                    <h3 class="text-center">Introspection report on objects</h3>
                        <table class="table table-bordered mt32">
                            <thead>
                                <tr>
                                    <th class="text-center"><span>Module</span></th>
                                    <th class="text-center"><span>Name</span></th>
                                    <th class="text-center"><span>Version</span></th>
                                    <th class="text-center"><span>Directory</span></th>
                                    <th class="text-center"><span>Web</span></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="text-center">
                                    <td><span t-field="o.name"/></td>
                                    <td><span t-field="o.shortdesc"/></td>
                                    <td><span t-field="o.latest_version"/></td>
                                    <td><span t-field="o.name"/></td>
                                    <td><span t-field="o.website"/></td>
                                </tr>
                            </tbody>
                        </table>
                        <span t-field="o.description"/>
                        <div>
                            <strong>Reports:</strong>
                        </div>
                        <span t-field="o.reports_by_module"/>
                        <div>
                            <strong>Menu:</strong>
                        </div>
                        <span t-field="o.menus_by_module"/>
                        <div>
                            <strong>View:</strong>
                        </div>
                        <span t-field="o.views_by_module"/>
                        <div>
                            <strong>Dependencies:</strong>
                        </div>
                        <div t-foreach="o.dependencies_id" t-as="dependency_id">
                            <span t-field="dependency_id.name"/> - <span t-field="dependency_id.module_id.state"/>
                        </div>

                        <table t-foreach="findobj(o)" t-as="obj" class="table table-sm mt16 mb32">
                            <tr>
                                <th colspan="2"><span>Object:</span> <span t-esc="obj.model"/></th>
                            </tr>
                            <tr t-foreach="findfields(obj.model, o)" t-as="field">
                                <td class="col-3"><t t-esc="field[0]"/></td>
                                <td>
                                    <span t-esc="field[1].get('string','Unknown')"/><span>, </span><span t-esc="field[1].get('type')"/><span t-if="field[1].get('required')">, required</span><span t-if="field[1].get('readonly',False)">, readonly</span>
                                    <div t-esc="field[1].get('help', '')"/>
                                </td>
                            </tr>
                        </table>
                </div>
            </t>
        </t>
    </t>
</template>
</data>
</odoo>

```

  File: report/ir_module_reports.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="ir_module_reference_print" model="ir.actions.report">
            <field name="name">Technical guide</field>
            <field name="model">ir.module.module</field>
            <field name="report_type">qweb-pdf</field>
            <field name="report_name">base.report_irmodulereference</field>
            <field name="report_file">base.report_irmodulereference</field>
            <field name="binding_model_id" ref="model_ir_module_module"/>
            <field name="binding_type">report</field>
        </record>

    </data>
</odoo>

```

  File: report/mako_footer.html
  Content:
```
<footer>
<table width="400" border="0" cellspacing="0" cellpadding="0">
	<tr>
		<td>
			<hr width="100%" height="27.7">
		</td>
	</tr>
	<tr>
		<td>
			% if company['rml_footer']:
				<p align="center"><small><b>${company.rml_footer}</b></small></p>
			%endif
		</td>
	</tr>
	<tr>
		<td>
			% if user['name']:
				<p align="center"><small><b>Contact : ${user.name}</b></small></p>
			%endif
		</td>
	</tr>
</table>
</footer>

```

  File: report/mako_header.html
  Content:
```
<header>
<link type="text/css" rel="stylesheet" href="${css_path}/mako_template.css" media="print,screen"></link>
% if company.logo:
	<img src ="data:image/gif;base64,${company.logo}" border="0"/>
%endif
<table width="400" border="0" cellspacing="0" cellpadding="0">
	<tr>
 		<td>
			% if company['partner_id']['name']:
				<small>${company.partner_id.name}</small></br>
			%endif
		</td>
	</tr>

	<tr>
 		<td>
			% if company['partner_id']['street']:
				<small>${company.partner_id.street}</small></br>
			%endif
		</td>
	</tr>

	<tr>
		<td>
			% if company['partner_id']['zip']:
				<small>${company.partner_id.zip}
				${company.partner_id.city}-${company.partner_id.country_id and company.partner_id.country_id.name}</small></br>
			%endif
		</td>
	</tr>

	<tr>
 		<td>
			% if company['partner_id']['phone']:
				<small><b>Phone:</b>${company.partner_id.phone}</small></br>
			%endif
		</td>
	</tr>

	<tr>
 		<td>
			% if company['partner_id']['email']:
				<small><b>Mail:</b>${company.partner_id.email}</small></br></<address>
			%endif
		</td>
	</tr>

	<tr>
 		<td>
			% if company['rml_header1']:
				<small><p align="right"><small>${company.rml_header1}</small></br></p></small>
			%endif
		</td>
	</tr>

	<tr>
 		<td>
			<small><hr width="100%" height="27.7"></small>
		</td>
	</tr>
</table>
</header>
```

  File: report/mako_template.css
  Content:
```
img {
	width: 50px;
	height: 42px;
}

table {
	width: 100%;
	white-space: nowrap;
}
table th{
	border-bottom: 1px solid black;
	font-weight: bold;
	font-family: Verdana;
	white-space: nowrap;
	padding-right: 10px;
}

```

  File: report/report_base_report_irmodulereference.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, models


class IrModelReferenceReport(models.AbstractModel):
    _name = 'report.base.report_irmodulereference'
    _description = 'Module Reference Report (base)'

    @api.model
    def _object_find(self, module):
        Data = self.env['ir.model.data'].sudo()
        data = Data.search([('model','=','ir.model'), ('module','=',module.name)])
        res_ids = data.mapped('res_id')
        return self.env['ir.model'].browse(res_ids)

    def _fields_find(self, model, module):
        Data = self.env['ir.model.data'].sudo()
        fname_wildcard = 'field_' + model.replace('.', '_') + '_%'
        data = Data.search([('model', '=', 'ir.model.fields'), ('module', '=', module.name), ('name', 'like', fname_wildcard)])
        if data:
            res_ids = data.mapped('res_id')
            fnames = self.env['ir.model.fields'].browse(res_ids).mapped('name')
            return sorted(self.env[model].fields_get(fnames).items())
        return []

    @api.model
    def _get_report_values(self, docids, data=None):
        report = self.env['ir.actions.report']._get_report_from_name('base.report_irmodulereference')
        selected_modules = self.env['ir.module.module'].browse(docids)
        return {
            'doc_ids': docids,
            'doc_model': report.model,
            'docs': selected_modules,
            'findobj': self._object_find,
            'findfields': self._fields_find,
        }

```

  File: rng/activity_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">

    <include href="common.rng"/>

    <define name="activity">
        <element name="activity">
            <attribute name="string"/>
            <optional><attribute name="create"/></optional>
            <optional><attribute name="js_class"/></optional>
            <interleave>
                <zeroOrMore><ref name="field"/></zeroOrMore>
                <optional>
                    <element name="templates">
                        <oneOrMore>
                            <ref name="any"/>
                        </oneOrMore>
                    </element>
                </optional>
            </interleave>
        </element>
    </define>

    <start>
        <ref name="activity"/>
    </start>

</grammar>

```

  File: rng/calendar_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->
    <rng:include href="common.rng"/>
    <rng:define name="calendar">
        <rng:element name="calendar">
            <rng:optional><rng:attribute name="string" /></rng:optional>
            <rng:optional><rng:attribute name="date_start" /></rng:optional>
            <rng:optional><rng:attribute name="date_stop" /></rng:optional>
            <rng:optional><rng:attribute name="date_delay" /></rng:optional>
            <rng:optional><rng:attribute name="all_day" /></rng:optional>
            <rng:optional><rng:attribute name="form_view_id" /></rng:optional>
            <rng:optional><rng:attribute name="event_limit" /></rng:optional>
            <rng:optional><rng:attribute name="create_name_field" /></rng:optional>
            <rng:optional><rng:attribute name="quick_create" /></rng:optional>
            <rng:optional><rng:attribute name="quick_create_view_id" /></rng:optional>
            <rng:optional><rng:attribute name="color" /></rng:optional>
            <rng:optional><rng:attribute name="event_open_popup" /></rng:optional>
            <rng:optional><rng:attribute name="show_unusual_days" /></rng:optional>
            <rng:optional><rng:attribute name="js_class"/></rng:optional>
            <rng:optional><rng:attribute name="hide_time"/></rng:optional>
            <rng:optional><rng:attribute name="hide_date"/></rng:optional>
            <rng:optional><rng:attribute name="create"/></rng:optional>
            <rng:optional><rng:attribute name="delete"/></rng:optional>
            <rng:optional><rng:attribute name="scales"/></rng:optional>
            <rng:optional><rng:attribute name="banner_route"/></rng:optional>
            <rng:optional>
                <rng:attribute name="mode">
                    <rng:choice>
                        <rng:value>year</rng:value>
                        <rng:value>month</rng:value>
                        <rng:value>week</rng:value>
                        <rng:value>day</rng:value>
                    </rng:choice>
                </rng:attribute>
            </rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field"/>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>
    <rng:start>
        <rng:choice>
            <rng:ref name="calendar" />
        </rng:choice>
    </rng:start>
</rng:grammar>

```

  File: rng/common.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->

    <rng:define name="overload">
        <rng:optional>
            <!--
                Alter matched element with content
            -->
            <rng:choice>
                <rng:attribute name="position">
                    <rng:choice>
                        <!-- Insert content before first child -->
                        <rng:value>before</rng:value>
                        <!-- Insert content after last child -->
                        <rng:value>after</rng:value>
                        <!-- Replace all children with content -->
                        <rng:value>inside</rng:value>
                        <!-- Replace matched element itself with content -->
                        <rng:value>replace</rng:value>
                    </rng:choice>
                </rng:attribute>
                <rng:group>
                    <rng:attribute name="position">
                        <!-- Edit element attributes -->
                        <rng:value>attributes</rng:value>
                    </rng:attribute>
                    <rng:oneOrMore>
                        <rng:element name="attribute">
                            <rng:attribute name="name"><rng:text/></rng:attribute>
                            <rng:text />
                        </rng:element>
                    </rng:oneOrMore>
                </rng:group>
            </rng:choice>
        </rng:optional>
    </rng:define>

    <rng:define name="access_rights">
        <rng:optional>
            <rng:attribute name="groups"/>
        </rng:optional>
    </rng:define>

    <rng:define name="container">
        <rng:optional><rng:attribute name="col"/></rng:optional>
        <rng:zeroOrMore>
            <rng:choice>
                <rng:ref name="field"/>
                <rng:ref name="group"/>
                <rng:ref name="button"/>
                <rng:ref name="label" />
                <rng:ref name="separator"/>
                <rng:ref name="image"/>
                <rng:ref name="filter"/>
                <rng:ref name="html"/>
                <rng:element name="newline"><rng:empty/></rng:element>
            </rng:choice>
        </rng:zeroOrMore>
    </rng:define>

    <rng:define name="image">
        <rng:element name="image">
            <rng:attribute name="name"/>
        </rng:element>
    </rng:define>

    <rng:define name="html">
        <rng:element name="html">
            <rng:zeroOrMore>
                    <rng:text/>
                    <rng:ref name="any"/>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="label">
        <rng:element name="label">
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:optional><rng:attribute name="align"/></rng:optional>
            <rng:optional><rng:attribute name="nolabel"/></rng:optional>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:optional><rng:attribute name="angle"/></rng:optional>
            <rng:optional><rng:attribute name="fill"/></rng:optional>
            <rng:optional><rng:attribute name="help"/></rng:optional>
            <rng:optional><rng:attribute name="width"/></rng:optional>
            <rng:optional><rng:attribute name="wrap"/></rng:optional>
            <rng:optional><rng:attribute name="name"/></rng:optional>
            <rng:optional>
                <!-- @for: allows to explicitely link a label to a field -->
                <rng:attribute name="for"/>
            </rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:text/>
                    <rng:ref name="field"/>
                    <rng:ref name="group"/>
                    <rng:ref name="button"/>
                    <rng:ref name="label" />
                    <rng:ref name="separator"/>
                    <rng:ref name="image"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="any">
        <rng:element>
            <rng:anyName/>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:attribute>
                        <rng:anyName/>
                    </rng:attribute>
                    <rng:text/>
                    <rng:ref name="any"/>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="separator">
        <rng:element name="separator">
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:optional><rng:attribute name="name"/></rng:optional>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="rowspan"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:optional><rng:attribute name="col"/></rng:optional>
            <rng:optional><rng:attribute name="select"/></rng:optional>
            <rng:optional><rng:attribute name="orientation"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="separator"/>
                    <rng:ref name="button"/>
                    <rng:ref name="field"/>
                    <rng:ref name="label" />
                    <rng:ref name="group" />
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="xpath">
        <rng:element name="xpath">
            <rng:optional><rng:attribute name="expr"/></rng:optional>
            <rng:ref name="overload"/>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="any"/>
                    <rng:ref name="button"/>
                    <rng:ref name="html"/>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="data">
        <rng:element name="data">
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="field"/>
                    <rng:ref name="label"/>
                    <rng:ref name="separator"/>
                    <rng:ref name="xpath"/>
                    <rng:ref name="button"/>
                    <rng:ref name="group"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="field">
        <rng:element name="field">
            <rng:attribute name="name" />
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:optional><rng:attribute name="domain_filter"/></rng:optional>
            <rng:optional><rng:attribute name="class"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:optional><rng:attribute name="completion"/></rng:optional>
            <rng:optional><rng:attribute name="width"/></rng:optional>
            <rng:optional><rng:attribute name="type"/></rng:optional>
            <rng:optional><rng:attribute name="ref"/></rng:optional>
            <rng:optional><rng:attribute name="eval"/></rng:optional>
            <rng:optional><rng:attribute name="search"/></rng:optional>
            <rng:optional><rng:attribute name="model"/></rng:optional>
            <rng:optional><rng:attribute name="use"/></rng:optional>
            <rng:optional><rng:attribute name="on_change"/></rng:optional>
            <rng:optional><rng:attribute name="domain"/></rng:optional>
            <rng:optional><rng:attribute name="filter_domain"/></rng:optional>
            <rng:optional><rng:attribute name="column_invisible"/></rng:optional>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:optional><rng:attribute name="password"/></rng:optional>
            <rng:optional><rng:attribute name="comparator"/></rng:optional>
            <rng:optional><rng:attribute name="sum"/></rng:optional>
            <rng:optional><rng:attribute name="bold"/></rng:optional>
            <rng:optional><rng:attribute name="avg"/></rng:optional>
            <rng:optional><rng:attribute name="select"/></rng:optional>
            <rng:optional><rng:attribute name="hierarchize"/></rng:optional>
            <rng:optional><rng:attribute name="expand"/></rng:optional>
            <rng:optional><rng:attribute name="group"/></rng:optional>
            <rng:optional><rng:attribute name="color"/></rng:optional>
            <rng:optional><rng:attribute name="groupby"/></rng:optional>
            <rng:optional><rng:attribute name="enable_counters"/></rng:optional>
            <rng:optional><rng:attribute name="limit"/></rng:optional>
            <rng:optional><rng:attribute name="operator"/></rng:optional>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="nolabel"/></rng:optional>
            <rng:optional><rng:attribute name="required"/></rng:optional>
            <rng:optional><rng:attribute name="readonly"/></rng:optional>
            <rng:optional><rng:attribute name="view_mode"/></rng:optional>
            <rng:optional><rng:attribute name="widget"/></rng:optional>
            <rng:optional><rng:attribute name="context"/></rng:optional>
            <rng:optional><rng:attribute name="digits"/></rng:optional>
            <rng:optional><rng:attribute name="icon"/></rng:optional>
            <rng:optional><rng:attribute name="mode"/></rng:optional>
            <rng:optional><rng:attribute name="size"/></rng:optional>
            <rng:optional><rng:attribute name="filename"/></rng:optional>
            <rng:optional><rng:attribute name="height"/></rng:optional>
            <rng:optional><rng:attribute name="rowspan"/></rng:optional>
            <rng:optional><rng:attribute name="align"/></rng:optional>
            <rng:optional><rng:attribute name="selection"/></rng:optional>
            <rng:optional><rng:attribute name="default_focus"/></rng:optional>
            <rng:optional><rng:attribute name="filters"/></rng:optional>
            <rng:optional><rng:attribute name="statusbar_visible"/></rng:optional>
            <rng:optional><rng:attribute name="can_create" /></rng:optional>
            <rng:optional><rng:attribute name="can_write" /></rng:optional>
            <rng:optional><rng:attribute name="interval" /></rng:optional>
            <rng:optional><rng:attribute name="avatar_field" /></rng:optional>
            <rng:optional><rng:attribute name="write_model" /></rng:optional>
            <rng:optional><rng:attribute name="write_field" /></rng:optional>
            <rng:optional><rng:attribute name="filter_field" /></rng:optional>
            <rng:optional><rng:attribute name="text" /></rng:optional>
            <rng:optional><rng:attribute name="optional" /></rng:optional>
            <rng:optional><rng:attribute name="add-label"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-bf"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-it"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-danger"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-info"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-muted"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-primary"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-success"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-warning"/></rng:optional>
            <rng:optional><rng:attribute name="kanban_view_ref" /></rng:optional>
            <rng:optional>
                <rng:attribute name="force_save">
                    <rng:choice>
                      <rng:value>1</rng:value>
                      <rng:value>0</rng:value>
                    </rng:choice>
                </rng:attribute>
            </rng:optional>
            <!-- Widget *static* options defined as an arbitrary JSON dict, with
                 widget-dependent parameters. To be ignored if widget/client does
                 not support them. -->
            <rng:optional><rng:attribute name="options"/></rng:optional>
            <rng:optional><rng:attribute name="placeholder"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="data"/>
                    <rng:ref name="field"/>
                    <rng:ref name="label"/>
                    <rng:ref name="separator"/>
                    <rng:ref name="xpath"/>
                    <rng:ref name="button"/>
                    <rng:ref name="group"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="group">
        <rng:element name="group">
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="rowspan"/></rng:optional>
            <rng:optional><rng:attribute name="expand"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:optional><rng:attribute name="fill"/></rng:optional>
            <rng:optional><rng:attribute name="height"/></rng:optional>
            <rng:optional><rng:attribute name="width"/></rng:optional>
            <rng:optional><rng:attribute name="name"/></rng:optional>
            <rng:optional><rng:attribute name="color" /></rng:optional>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field"/>
            </rng:zeroOrMore>
            <rng:ref name="container"/>
        </rng:element>
    </rng:define>

    <rng:define name="button">
        <rng:element name="button">
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:optional><rng:attribute name="column_invisible"/></rng:optional>
            <rng:optional><rng:attribute name="disabled"/></rng:optional>
            <rng:optional><rng:attribute name="name" /></rng:optional>
            <rng:optional><rng:attribute name="icon" /></rng:optional>
            <rng:optional><rng:attribute name="string" /></rng:optional>
            <rng:optional><rng:attribute name="type" /></rng:optional>
            <rng:optional><rng:attribute name="special" /></rng:optional>
            <rng:optional><rng:attribute name="align" /></rng:optional>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="target"/></rng:optional>
            <rng:optional><rng:attribute name="readonly"/></rng:optional>
            <rng:optional><rng:attribute name="context"/></rng:optional>
            <rng:optional><rng:attribute name="confirm"/></rng:optional>
            <rng:optional><rng:attribute name="help"/></rng:optional>
            <rng:optional><rng:attribute name="class"/></rng:optional>
            <rng:optional><rng:attribute name="default_focus"/></rng:optional>
            <rng:optional><rng:attribute name="tabindex"/></rng:optional>
            <rng:optional><rng:attribute name="title"/></rng:optional>
            <rng:optional><rng:attribute name="aria-label"/></rng:optional>
            <rng:optional><rng:attribute name="aria-pressed"/></rng:optional>
            <rng:optional><rng:attribute name="display"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="field" />
                    <rng:ref name="xpath" />
                    <rng:ref name="separator"/>
                    <rng:ref name="button"/>
                    <rng:ref name="group"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>

        </rng:element>
    </rng:define>

    <rng:define name="filter">
        <rng:element name="filter">
            <rng:ref name="overload"/>
            <rng:ref name="access_rights"/>
            <rng:attribute name="name"/>
            <rng:optional><rng:attribute name="icon"/></rng:optional>
            <rng:optional><rng:attribute name="invisible"/></rng:optional>
            <rng:optional><rng:attribute name="separator" /></rng:optional>
            <rng:optional><rng:attribute name="string" /></rng:optional>
            <rng:optional><rng:attribute name="type" /></rng:optional>
            <rng:optional><rng:attribute name="align" /></rng:optional>
            <rng:optional><rng:attribute name="colspan"/></rng:optional>
            <rng:optional><rng:attribute name="readonly"/></rng:optional>
            <rng:optional><rng:attribute name="context"/></rng:optional>
            <rng:optional><rng:attribute name="help"/></rng:optional>
            <rng:optional><rng:attribute name="domain"/></rng:optional>
            <rng:optional><rng:attribute name="date"/></rng:optional>
            <rng:optional><rng:attribute name="default_period"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="field" />
                    <rng:ref name="xpath" />
                    <rng:ref name="separator"/>
                    <rng:ref name="button"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>

        </rng:element>
    </rng:define>

    <rng:define name="create">
        <rng:element name="create">
            <rng:ref name="overload"/>
            <rng:attribute name="string"/>
            <rng:optional><rng:attribute name="context"/></rng:optional>
            <rng:optional><rng:attribute name="name"/></rng:optional>
        </rng:element>
    </rng:define>

    <rng:define name="control">
        <rng:element name="control">
            <rng:ref name="overload"/>
            <rng:oneOrMore>
                <rng:choice>
                    <rng:ref name="create"/>
                    <rng:ref name="button"/>
                </rng:choice>
            </rng:oneOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="widget">
        <rng:element name="widget">
            <rng:attribute name="name"/>
            <rng:optional><rng:attribute name="options"/></rng:optional>
            <rng:optional><rng:attribute name="width"/></rng:optional>
        </rng:element>
    </rng:define>

</rng:grammar>

```

  File: rng/graph_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->
    <rng:include href="common.rng"/>
    <rng:define name="graph">
        <rng:element name="graph">
            <rng:optional><rng:attribute name="string" /></rng:optional>
            <rng:optional>
                <rng:attribute name="type">
                    <rng:choice>
                        <rng:value>bar</rng:value>
                        <rng:value>pie</rng:value>
                        <rng:value>line</rng:value>
                    </rng:choice>
                </rng:attribute>
            </rng:optional>
            <rng:optional><rng:attribute name="js_class"/></rng:optional>
            <rng:optional><rng:attribute name="stacked"/></rng:optional>
            <rng:optional><rng:attribute name="order"/></rng:optional>
            <rng:optional><rng:attribute name="disable_linking"/></rng:optional>
            <rng:optional><rng:attribute name="sample"/></rng:optional>
            <rng:optional><rng:attribute name="banner_route"/></rng:optional>
            <rng:optional><rng:attribute name="cumulated"/></rng:optional>
            <rng:optional><rng:attribute name="cumulated_start"/></rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field"/>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>
    <rng:start>
        <rng:choice>
            <rng:ref name="graph" />
        </rng:choice>
    </rng:start>
</rng:grammar>

```

  File: rng/pivot_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->
    <rng:include href="common.rng"/>
    <rng:define name="pivot">
        <rng:element name="pivot">
            <rng:optional><rng:attribute name="sample"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:optional><rng:attribute name="stacked"/></rng:optional>
            <rng:optional><rng:attribute name="display_quantity"/></rng:optional>
            <rng:optional><rng:attribute name="disable_linking"/></rng:optional>
            <rng:optional><rng:attribute name="js_class"/></rng:optional>
            <rng:optional><rng:attribute name="default_order"/></rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field"/>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>
    <rng:start>
        <rng:choice>
            <rng:ref name="pivot" />
        </rng:choice>
    </rng:start>
</rng:grammar>

```

  File: rng/search_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->
    <rng:include href="common.rng"/>

    <rng:define name="searchpanel">
        <rng:element name="searchpanel">
            <rng:ref name="overload"/>
            <rng:optional><rng:attribute name="view_types"/></rng:optional>
            <rng:optional><rng:attribute name="class"/></rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field" />
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="search">
        <rng:element name="search">
            <rng:ref name="overload"/>
            <rng:optional><rng:attribute name="string"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:ref name="field"/>
                    <rng:ref name="group"/>
                    <rng:ref name="separator"/>
                    <rng:ref name="filter"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                    <rng:ref name="searchpanel"/>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>
    <rng:start>
        <rng:choice>
            <rng:ref name="search" />
        </rng:choice>
    </rng:start>
</rng:grammar>

```

  File: rng/tree_view.rng
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<rng:grammar xmlns:rng="http://relaxng.org/ns/structure/1.0"
             xmlns:a="http://relaxng.org/ns/annotation/1.0"
             datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
    <!-- Handling of element overloading when inheriting from a base
         template
    -->
    <rng:include href="common.rng"/>

    <rng:define name="groupby">
        <rng:element name="groupby">
            <rng:attribute name="name"/>
            <rng:optional><rng:attribute name="expand"/></rng:optional>
            <rng:zeroOrMore>
                <rng:ref name="field"/>
            </rng:zeroOrMore>
            <rng:zeroOrMore>
                <rng:ref name="button"/>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>

    <rng:define name="tree">
        <rng:element name="tree">
            <rng:ref name="overload"/>
            <rng:optional><rng:attribute name="name"/></rng:optional>
            <rng:optional><rng:attribute name="create"/></rng:optional>
            <rng:optional><rng:attribute name="delete"/></rng:optional>
            <rng:optional><rng:attribute name="edit"/></rng:optional>
            <rng:optional><rng:attribute name="multi_edit"/></rng:optional>
            <rng:optional><rng:attribute name="export_xlsx"/></rng:optional>
            <rng:optional><rng:attribute name="duplicate"/></rng:optional>
            <rng:optional><rng:attribute name="import"/></rng:optional>
            <rng:optional><rng:attribute name="string"/></rng:optional> <!-- deprecated, has no effect anymore -->
            <rng:optional><rng:attribute name="class"/></rng:optional>
            <!-- Allows to take a custom View widget for handling -->
            <rng:optional><rng:attribute name="js_class"/></rng:optional>
            <rng:optional><rng:attribute name="default_order"/></rng:optional>
            <rng:optional><rng:attribute name="default_group_by"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-bf"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-it"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-danger"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-info"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-muted"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-primary"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-success"/></rng:optional>
            <rng:optional><rng:attribute name="decoration-warning"/></rng:optional>
            <rng:optional><rng:attribute name="banner_route"/></rng:optional>
            <rng:optional><rng:attribute name="sample"/></rng:optional>
            <rng:optional><rng:attribute name="action"/></rng:optional>
            <rng:optional><rng:attribute name="type"/></rng:optional>
            <rng:optional><rng:attribute name="open_form_view"/></rng:optional>
            <rng:optional>
                <rng:attribute name="limit">
                    <rng:data type="int"/>
                </rng:attribute>
            </rng:optional>
            <rng:optional>
                <rng:attribute name="count_limit">
                    <rng:data type="int"/>
                </rng:attribute>
            </rng:optional>
            <rng:optional>
                <rng:attribute name="groups_limit">
                    <rng:data type="int"/>
                </rng:attribute>
            </rng:optional>
            <rng:optional>
                <rng:attribute name="editable">
                    <rng:choice>
                        <rng:value>top</rng:value>
                        <rng:value>bottom</rng:value>
                    </rng:choice>
                </rng:attribute>
            </rng:optional>
            <rng:optional><rng:attribute name="expand"/></rng:optional>
            <rng:zeroOrMore>
                <rng:choice>
                    <rng:element name="header">
                        <rng:zeroOrMore>
                            <rng:ref name="button"/>
                        </rng:zeroOrMore>
                    </rng:element>
                    <rng:ref name="control"/>
                    <rng:ref name="field"/>
                    <rng:ref name="widget"/>
                    <rng:ref name="separator"/>
                    <rng:ref name="tree"/>
                    <rng:ref name="groupby"/>
                    <rng:ref name="button"/>
                    <rng:ref name="filter"/>
                    <rng:ref name="html"/>
                    <rng:element name="newline"><rng:empty/></rng:element>
                </rng:choice>
            </rng:zeroOrMore>
        </rng:element>
    </rng:define>
    <rng:start>
        <rng:choice>
            <rng:ref name="tree" />
        </rng:choice>
    </rng:start>
</rng:grammar>

```

  File: wizard/__init__.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from . import base_module_update
from . import base_language_install
from . import base_import_language
from . import base_module_upgrade
from . import base_module_uninstall
from . import base_export_language
from . import base_partner_merge

```

  File: wizard/base_export_language.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import ast
import base64
import contextlib
import io

from odoo import api, fields, models, tools, _

NEW_LANG_KEY = '__new__'

class BaseLanguageExport(models.TransientModel):
    _name = "base.language.export"
    _description = 'Language Export'

    @api.model
    def _get_languages(self):
        langs = self.env['res.lang'].get_installed()
        return [(NEW_LANG_KEY, _('New Language (Empty translation template)'))] + \
               langs
   
    name = fields.Char('File Name', readonly=True)
    lang = fields.Selection(_get_languages, string='Language', required=True, default=NEW_LANG_KEY)
    format = fields.Selection([('csv','CSV File'), ('po','PO File'), ('tgz', 'TGZ Archive')],
                              string='File Format', required=True, default='po')
    export_type = fields.Selection([('module', 'Module'), ('model', 'Model')],
                                   string='Export Type', required=True, default='module')
    modules = fields.Many2many('ir.module.module', 'rel_modules_langexport', 'wiz_id', 'module_id',
                               string='Apps To Export', domain=[('state','=','installed')])
    model_id = fields.Many2one('ir.model', string='Model to Export', domain=[('transient', '=', False)])
    model_name = fields.Char(string="Model Name", related="model_id.model")
    domain = fields.Char(string="Model Domain", default='[]')
    data = fields.Binary('File', readonly=True, attachment=False)
    state = fields.Selection([('choose', 'choose'), ('get', 'get')], # choose language or get the file
                             default='choose')

    def act_getfile(self):
        this = self[0]
        lang = this.lang if this.lang != NEW_LANG_KEY else False

        with contextlib.closing(io.BytesIO()) as buf:
            if this.export_type == 'model':
                ids = self.env[this.model_name].search(ast.literal_eval(this.domain)).ids
                tools.trans_export_records(lang, this.model_name, ids, buf, this.format, self._cr)
            else:
                mods = sorted(this.mapped('modules.name')) or ['all']
                tools.trans_export(lang, mods, buf, this.format, self._cr)
            out = base64.encodebytes(buf.getvalue())

        filename = 'new'
        if lang:
            filename = tools.get_iso_codes(lang)
        elif this.export_type == 'model':
            filename = this.model_name.replace('.', '_')
        elif len(mods) == 1:
            filename = mods[0]
        extension = this.format
        if not lang and extension == 'po':
            extension = 'pot'
        name = "%s.%s" % (filename, extension)
        this.write({'state': 'get', 'data': out, 'name': name})
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'base.language.export',
            'view_mode': 'form',
            'res_id': this.id,
            'views': [(False, 'form')],
            'target': 'new',
        }

```

  File: wizard/base_export_language_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <record id="wizard_lang_export" model="ir.ui.view">
            <field name="name">Export Translations</field>
            <field name="model">base.language.export</field>
            <field name="arch" type="xml">
                <form string="Export Translations">
                    <field invisible="1" name="state"/>
                    <field name="name" invisible="1"/>
                    <group invisible="state != 'choose'" string="Export Settings">
                        <field name="lang"/>
                        <field name="format"/>
                        <field name="export_type"/>
                        <field name="modules" widget="many2many_tags" options="{'no_create': True}" invisible="export_type == 'model'"/>
                        <field name="model_id" options="{'no_create': True}" invisible="export_type == 'module'"/>
                        <field name="model_name" invisible="1"/>
                        <field name="domain" widget="domain" options="{'model': 'model_name'}" invisible="export_type == 'module'"/>
                    </group>
                    <div invisible="state != 'get'">
                        <h2>Export Complete</h2>
                        <p>Here is the exported translation file: <field name="data" readonly="1" filename="name"/></p>
                        <p>This file was generated using the universal <strong>Unicode/UTF-8</strong> file encoding, please be sure to view and edit
                           using the same encoding.</p>
                        <p>The next step depends on the file format:
                            <ul>
                            <li>CSV format: you may edit it directly with your favorite spreadsheet software,
                                the rightmost column (value) contains the translations</li>
                            <li>PO(T) format: you should edit it with a PO editor such as
                                <a href="http://www.poedit.net/" target="_blank">POEdit</a>, or your preferred text editor</li>
                            <li>TGZ format: bundles multiple PO(T) files as a single archive</li>
                            </ul>
                        </p>
                        <p>For more details about translating Odoo in your language, please refer to the
                           <a href="https://github.com/odoo/odoo/wiki/Translations" target="_blank">documentation</a>.</p>
                    </div>
                    <footer invisible="state != 'choose'">
                        <button name="act_getfile" string="Export" type="object" class="btn-primary" data-hotkey="q"/>
                        <button special="cancel" data-hotkey="x" string="Cancel" type="object" class="btn-secondary"/>
                    </footer>
                    <footer invisible="state != 'get'">
                        <button special="cancel" data-hotkey="x" string="Close" type="object" class="btn-primary"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_wizard_lang_export" model="ir.actions.act_window">
            <field name="name">Export Translation</field>
            <field name="res_model">base.language.export</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>
        <menuitem action="action_wizard_lang_export" id="menu_wizard_lang_export" parent="menu_translation_export"/>
    </data>
</odoo>

```

  File: wizard/base_import_language.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import base64
import logging
import operator
from tempfile import TemporaryFile
from os.path import splitext

from odoo import api, fields, models, tools, sql_db, _
from odoo.exceptions import UserError
from odoo.tools.translate import TranslationImporter

_logger = logging.getLogger(__name__)


class BaseLanguageImport(models.TransientModel):
    _name = "base.language.import"
    _description = "Language Import"

    name = fields.Char('Language Name', required=True)
    code = fields.Char('ISO Code', size=6, required=True,
                       help="ISO Language and Country code, e.g. en_US")
    data = fields.Binary('File', required=True, attachment=False)
    filename = fields.Char('File Name', required=True)
    overwrite = fields.Boolean('Overwrite Existing Terms',
                               default=True,
                               help="If you enable this option, existing translations (including custom ones) "
                                    "will be overwritten and replaced by those in this file")

    def import_lang(self):
        Lang = self.env["res.lang"]
        for overwrite, base_lang_imports in tools.groupby(self, operator.itemgetter('overwrite')):
            translation_importer = TranslationImporter(self.env.cr)
            for base_lang_import in base_lang_imports:
                if not Lang._activate_lang(base_lang_import.code):
                    Lang._create_lang(base_lang_import.code, lang_name=base_lang_import.name)
                try:
                    with TemporaryFile('wb+') as buf:
                        buf.write(base64.decodebytes(base_lang_import.data))
                        fileformat = splitext(base_lang_import.filename)[-1][1:].lower()
                        translation_importer.load(buf, fileformat, base_lang_import.code)
                except Exception as e:
                    _logger.warning('Could not import the file due to a format mismatch or it being malformed.')
                    raise UserError(
                        _('File %r not imported due to format mismatch or a malformed file.'
                          ' (Valid formats are .csv, .po)\n\nTechnical Details:\n%s',
                          base_lang_import.filename, tools.ustr(e))
                    )
            translation_importer.save(overwrite=overwrite)
        return True

```

  File: wizard/base_import_language_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="view_base_import_language" model="ir.ui.view">
            <field name="name">Import Translation</field>
            <field name="model">base.language.import</field>
            <field name="arch" type="xml">
                <form string="Import Translation">
                    <group>
                        <field name="name" placeholder="e.g. English"/>
                        <field name="code" string="Code" placeholder="e.g. en_US"/>
                        <field name="data" filename="filename" options="{'accepted_file_extensions': '.csv,.po'}"/>
                        <field name="filename" invisible="1"/>
                        <field name="overwrite" groups="base.group_no_one"/>
                    </group>
                    <footer>
                        <button name="import_lang" string="Import" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x" />
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_view_base_import_language" model="ir.actions.act_window">
            <field name="name">Import Translation</field>
            <field name="res_model">base.language.import</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>

        <menuitem
        action="action_view_base_import_language"
        id="menu_view_base_import_language"
        parent="menu_translation_export"/>

    </data>
</odoo>

```

  File: wizard/base_language_install.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models, _


class BaseLanguageInstall(models.TransientModel):
    _name = "base.language.install"
    _description = "Install Language"

    @api.model
    def _default_lang_ids(self):
        """ Display the selected language when using the 'Update Terms' action
            from the language list view
        """
        if self._context.get('active_model') == 'res.lang':
            return self._context.get('active_ids') or [self._context.get('active_id')]
        return False

    # add a context on the field itself, to be sure even inactive langs are displayed
    lang_ids = fields.Many2many('res.lang', 'res_lang_install_rel',
                                'language_wizard_id', 'lang_id', 'Languages',
                                default=_default_lang_ids, context={'active_test': False}, required=True)
    overwrite = fields.Boolean('Overwrite Existing Terms',
                               default=True,
                               help="If you check this box, your customized translations will be overwritten and replaced by the official ones.")
    first_lang_id = fields.Many2one('res.lang',
                                    compute='_compute_first_lang_id',
                                    help="Used when the user only selects one language and is given the option to switch to it")

    def _compute_first_lang_id(self):
        self.first_lang_id = False
        for lang_installer in self.filtered('lang_ids'):
            lang_installer.first_lang_id = lang_installer.lang_ids[0]

    def lang_install(self):
        self.ensure_one()
        mods = self.env['ir.module.module'].search([('state', '=', 'installed')])
        self.lang_ids.active = True
        mods._update_translations(self.lang_ids.mapped('code'), self.overwrite)

        if len(self.lang_ids) == 1:
            return {
                'type': 'ir.actions.act_window',
                'res_model': 'base.language.install',
                'res_id': self.id,
                'view_mode': 'form',
                'target': 'new',
                'views': [[self.env.ref('base.language_install_view_form_lang_switch').id, 'form']],
            }

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'context': dict(self._context, active_ids=self.ids),
            'target': 'new',
            'params': {
                'message': _("The languages that you selected have been successfully installed.\
                            Users can choose their favorite language in their preferences."),
                'type': 'success',
                'sticky': False,
                'next': {'type': 'ir.actions.act_window_close'},
            }
        }

    def reload(self):
        return {
            'type': 'ir.actions.client',
            'tag': 'reload',
        }

    def switch_lang(self):
        self.env.user.lang = self.first_lang_id.code
        return {
            'type': 'ir.actions.client',
            'tag': 'reload_context',
        }

```

  File: wizard/base_language_install_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="base.language_install_view_form_lang_switch" model="ir.ui.view">
            <field name="name">Switch to language</field>
            <field name="model">base.language.install</field>
            <field name="priority">100</field>
            <field name="arch" type="xml">
                <form string="Switch to language">
                    <div>
                        <strong>
                            <field name="first_lang_id" readonly="True" options="{'no_open': True}" />
                        </strong>
                        has been successfully installed.
                            Users can choose their favorite language in their preferences.
                    </div>
                    <footer>
                        <button name="reload" string="Close" type="object" class="btn-primary" data-hotkey="q"/>
                        <button name="switch_lang" type="object" class="btn-primary ms-1" data-hotkey="w">
                            Switch to <field name="first_lang_id" readonly="True" options="{'no_open': True}"/> &amp; Close
                        </button>
                    </footer>
                </form>
           </field>
        </record>

        <record id="view_base_language_install" model="ir.ui.view">
            <field name="name">Load a Translation</field>
            <field name="model">base.language.install</field>
            <field name="arch" type="xml">
                <form string="Load a Translation">
                    <group>
                        <field name="lang_ids" widget="many2many_tags"
                            context="{'active_test': False}" options="{'no_quick_create': True, 'no_create_edit': True}"/>
                        <field name="overwrite" groups="base.group_no_one"/>
                    </group>
                    <footer>
                        <button name="lang_install" string="Add" data-hotkey="q" type="object" class="btn-primary"/>
                        <button special="cancel" data-hotkey="x" string="Cancel" class="btn-secondary"/>
                    </footer>
                </form>
           </field>
        </record>

        <record id="action_view_base_language_install" model="ir.actions.act_window">
            <field name="name">Add Languages</field>
            <field name="res_model">base.language.install</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>
    </data>
</odoo>

```

  File: wizard/base_module_uninstall.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import api, fields, models


class BaseModuleUninstall(models.TransientModel):
    _name = "base.module.uninstall"
    _description = "Module Uninstall"

    show_all = fields.Boolean()
    module_id = fields.Many2one(
        'ir.module.module', string="Module", required=True,
        domain=[('state', 'in', ['installed', 'to upgrade', 'to install'])],
        ondelete='cascade', readonly=True,
    )
    module_ids = fields.Many2many('ir.module.module', string="Impacted modules",
                                  compute='_compute_module_ids')
    model_ids = fields.Many2many('ir.model', string="Impacted data models",
                                 compute='_compute_model_ids')

    def _get_modules(self):
        """ Return all the modules impacted by self. """
        return self.module_id.downstream_dependencies(self.module_id)

    @api.depends('module_id', 'show_all')
    def _compute_module_ids(self):
        for wizard in self:
            modules = wizard._get_modules().sorted(lambda m: (not m.application, m.sequence))
            wizard.module_ids = modules if wizard.show_all else modules.filtered('application')

    def _get_models(self):
        """ Return the models (ir.model) to consider for the impact. """
        return self.env['ir.model'].search([('transient', '=', False)])

    @api.depends('module_ids')
    def _compute_model_ids(self):
        ir_models = self._get_models()
        ir_models_xids = ir_models._get_external_ids()
        for wizard in self:
            if wizard.module_id:
                module_names = set(wizard._get_modules().mapped('name'))

                def lost(model):
                    xids = ir_models_xids.get(model.id, ())
                    return xids and all(xid.split('.')[0] in module_names for xid in xids)

                # find the models that have all their XIDs in the given modules
                self.model_ids = ir_models.filtered(lost).sorted('name')

    @api.onchange('module_id')
    def _onchange_module_id(self):
        # if we select a technical module, show technical modules by default
        if not self.module_id.application:
            self.show_all = True

    def action_uninstall(self):
        modules = self.module_id
        return modules.button_immediate_uninstall()

```

  File: wizard/base_module_uninstall_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="view_base_module_uninstall" model="ir.ui.view">
            <field name="name">Uninstall module</field>
            <field name="model">base.module.uninstall</field>
            <field name="arch" type="xml">
                <form string="Uninstall module">
                    <div class="alert alert-warning oe_button_box" role="alert">
                        <p class="mt-3">
                            Uninstalling modules can be risky, we recommend you to try it on a duplicate or test database first.
                        </p>
                    </div>
                    <field name="module_id" invisible="1"/>
                    <div class="d-flex bd-highlight">
                        <div class="me-auto p-2 bd-highlight"><h3>Apps to Uninstall</h3></div>
                        <div class="p-2 bd-highlight"><field name="show_all"/> Show All</div>
                    </div>
                    <field name="module_ids" mode="kanban" class="o_modules_field">
                        <kanban create="false" class="o_modules_kanban">
                            <field name="icon"/>
                            <field name="state"/>
                            <field name="summary"/>
                                <templates>
                                    <t t-name="kanban-box">
                                        <div class="oe_module_vignette">
                                            <t t-set="installed" t-value="record.state.raw_value == 'installed'" />
                                            <img t-attf-src="#{record.icon.value}" class="oe_module_icon" alt="Icon" />
                                            <div class="oe_module_desc" t-att-title="record.shortdesc.value">
                                                <h4 class="o_kanban_record_title">
                                                    <field name="shortdesc" />&amp;nbsp;
                                                </h4>
                                                <p class="oe_module_name">
                                                    <field groups="!base.group_no_one" name="summary" />
                                                    <code groups="base.group_no_one">
                                                        <field name="name" /></code>
                                                </p>
                                            </div>
                                        </div>
                                    </t>
                                </templates>
                        </kanban>
                    </field>
                    <h3>Documents to Delete</h3>
                    <field name="model_ids" string="Models" nolabel="1">
                        <tree string="Models">
                            <field name="name" string="Document"/>
                            <field name="count"/>
                        </tree>
                    </field>
                    <footer>
                        <button string="Uninstall" class="btn-secondary" type="object" name="action_uninstall" data-hotkey="q"/>
                        <button string="Discard" class="btn-primary" special="cancel" data-hotkey="x"/>
                    </footer>
                </form>
            </field>
        </record>

    </data>
</odoo>

```

  File: wizard/base_module_update.py
  Content:
```
# -*- coding: utf-8 -*-

from odoo import api, fields, models


class BaseModuleUpdate(models.TransientModel):
    _name = "base.module.update"
    _description = "Update Module"

    updated = fields.Integer('Number of modules updated', readonly=True)
    added = fields.Integer('Number of modules added', readonly=True)
    state = fields.Selection([('init', 'init'), ('done', 'done')], 'Status', readonly=True, default='init')

    def update_module(self):
        for this in self:
            updated, added = self.env['ir.module.module'].update_list()
            this.write({'updated': updated, 'added': added, 'state': 'done'})
        return False

    def action_module_open(self):
        res = {
            'domain': str([]),
            'name': 'Modules',
            'view_mode': 'tree,form',
            'res_model': 'ir.module.module',
            'view_id': False,
            'type': 'ir.actions.act_window',
        }
        return res

```

  File: wizard/base_module_update_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="view_base_module_update" model="ir.ui.view">
            <field name="name">Module Update</field>
            <field name="model">base.module.update</field>
            <field name="arch" type="xml">
                <form string="Update Module List">
                    <field name="state" invisible="1"/>
                    <separator string="Module Update Result" invisible="state != 'done'"/>
                    <group invisible="state != 'init'">
                        <span class="o_form_label" colspan="2">Click on Update below to start the process...</span>
                    </group>
                    <group invisible="state != 'done'" >
                        <field name="updated"/>
                        <field name="added" />
                    </group>
                    <footer>
                        <div invisible="state != 'init'" class="d-flex gap-1">
                            <button name="update_module" string="Update" type="object" class="btn-primary" data-hotkey="q"/>
                            <button special="cancel" data-hotkey="x" string="Cancel" class="btn-secondary"/>
                        </div>
                        <div invisible="state != 'done'" class="d-flex gap-1">
                            <button name="action_module_open" string="Open Apps" type="object" class="btn-primary" data-hotkey="q"/>
                            <button special="cancel" data-hotkey="x" string="Close" class="btn-secondary"/>
                        </div>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_view_base_module_update" model="ir.actions.act_window">
            <field name="name">Module Update</field>
            <field name="res_model">base.module.update</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>

        <menuitem
            name="Update Apps List"
            action="action_view_base_module_update"
            id="menu_view_base_module_update"
            groups="base.group_no_one"
            parent="menu_management"
            sequence="40"/>

    </data>
</odoo>

```

  File: wizard/base_module_upgrade.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

import odoo
from odoo import api, fields, models, _
from odoo.exceptions import UserError


class BaseModuleUpgrade(models.TransientModel):
    _name = "base.module.upgrade"
    _description = "Upgrade Module"

    @api.model
    @api.returns('ir.module.module')
    def get_module_list(self):
        states = ['to upgrade', 'to remove', 'to install']
        return self.env['ir.module.module'].search([('state', 'in', states)])

    @api.model
    def _default_module_info(self):
        return "\n".join("%s: %s" % (mod.name, mod.state) for mod in self.get_module_list())

    module_info = fields.Text('Apps to Update', readonly=True, default=_default_module_info)

    @api.model
    def get_view(self, view_id=None, view_type='form', **options):
        res = super().get_view(view_id, view_type, **options)
        if view_type != 'form':
            return res

        if not self.get_module_list():
            res['arch'] = '''<form string="Upgrade Completed">
                                <separator string="Upgrade Completed" colspan="4"/>
                                <footer>
                                    <button name="config" string="Start Configuration" type="object" class="btn-primary" data-hotkey="q"/>
                                    <button special="cancel" data-hotkey="x" string="Close" class="btn-secondary"/>
                                </footer>
                             </form>'''

        return res

    def upgrade_module_cancel(self):
        Module = self.env['ir.module.module']
        to_install = Module.search([('state', 'in', ['to upgrade', 'to remove'])])
        to_install.write({'state': 'installed'})
        to_uninstall = Module.search([('state', '=', 'to install')])
        to_uninstall.write({'state': 'uninstalled'})
        return {'type': 'ir.actions.act_window_close'}

    def upgrade_module(self):
        Module = self.env['ir.module.module']

        # install/upgrade: double-check preconditions
        mods = Module.search([('state', 'in', ['to upgrade', 'to install'])])
        if mods:
            query = """ SELECT d.name
                        FROM ir_module_module m
                        JOIN ir_module_module_dependency d ON (m.id = d.module_id)
                        LEFT JOIN ir_module_module m2 ON (d.name = m2.name)
                        WHERE m.id = any(%s) and (m2.state IS NULL or m2.state = %s) """
            self._cr.execute(query, (mods.ids, 'uninstalled'))
            unmet_packages = [row[0] for row in self._cr.fetchall()]
            if unmet_packages:
                raise UserError(_('The following modules are not installed or unknown: %s', '\n\n' + '\n'.join(unmet_packages)))

        # terminate transaction before re-creating cursor below
        self._cr.commit()
        odoo.modules.registry.Registry.new(self._cr.dbname, update_module=True)
        self._cr.reset()

        return {'type': 'ir.actions.act_window_close'}

    def config(self):
        # pylint: disable=next-method-called
        return self.env['res.config'].next()

```

  File: wizard/base_module_upgrade_views.xml
  Content:
```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>

        <record id="view_base_module_upgrade" model="ir.ui.view">
            <field name="name">Module Upgrade</field>
            <field name="model">base.module.upgrade</field>
            <field name="arch" type="xml">
                <form string="System Update">
                    <p>This module will trigger the uninstallation of below modules.</p>
                    <p><strong>This operation will permanently erase all data currently stored by the modules!</strong></p>
                    <p>If you wish to cancel the process, press the cancel button below</p>
                    <separator string="Impacted Apps"/>
                    <field name="module_info"/>
                    <footer>
                        <button name="upgrade_module" string="Confirm" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" name="upgrade_module_cancel" type="object" data-hotkey="x"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_view_base_module_upgrade" model="ir.actions.act_window">
            <field name="name">Apply Schedule Upgrade</field>
            <field name="res_model">base.module.upgrade</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
        </record>

        <menuitem
           name="Apply Scheduled Upgrades"
           action="action_view_base_module_upgrade"
           groups="base.group_no_one"
           id="menu_view_base_module_upgrade"
           parent="menu_management"
           sequence="50"/>

       <record id="view_base_module_upgrade_install" model="ir.ui.view">
            <field name="name">Module Upgrade Install</field>
            <field name="model">base.module.upgrade</field>
            <field name="priority" eval="20"/>
            <field name="arch" type="xml">
                <form string="Apply Schedule Upgrade">
                    <div><span class="o_form_label">The selected modules have been updated/installed!</span></div>
                    <div><span class="o_form_label">We suggest to reload the menu tab to see the new menus (Ctrl+T then Ctrl+R)."</span></div>
                    <footer>
                        <button name="config" string="Start configuration" type="object" class="btn-primary" data-hotkey="q"/>
                        <button string="Cancel" class="btn-secondary" special="cancel" data-hotkey="x"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_view_base_module_upgrade_install" model="ir.actions.act_window">
            <field name="name">Module Upgrade Install</field>
            <field name="res_model">base.module.upgrade</field>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_base_module_upgrade_install"/>
            <field name="target">new</field>
        </record>

    </data>
</odoo>

```

  File: wizard/base_partner_merge.py
  Content:
```
# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from ast import literal_eval
from collections import defaultdict
import functools
import itertools
import logging
import psycopg2
import datetime

from odoo import api, fields, models, Command
from odoo import SUPERUSER_ID, _
from odoo.exceptions import ValidationError, UserError
from odoo.tools import mute_logger

_logger = logging.getLogger('odoo.addons.base.partner.merge')

class MergePartnerLine(models.TransientModel):

    _name = 'base.partner.merge.line'
    _description = 'Merge Partner Line'
    _order = 'min_id asc'

    wizard_id = fields.Many2one('base.partner.merge.automatic.wizard', 'Wizard')
    min_id = fields.Integer('MinID')
    aggr_ids = fields.Char('Ids', required=True)


class MergePartnerAutomatic(models.TransientModel):
    """
        The idea behind this wizard is to create a list of potential partners to
        merge. We use two objects, the first one is the wizard for the end-user.
        And the second will contain the partner list to merge.
    """

    _name = 'base.partner.merge.automatic.wizard'
    _description = 'Merge Partner Wizard'

    @api.model
    def default_get(self, fields):
        res = super(MergePartnerAutomatic, self).default_get(fields)
        active_ids = self.env.context.get('active_ids')
        if self.env.context.get('active_model') == 'res.partner' and active_ids:
            if 'state' in fields:
                res['state'] = 'selection'
            if 'partner_ids' in fields:
                res['partner_ids'] = [Command.set(active_ids)]
            if 'dst_partner_id' in fields:
                res['dst_partner_id'] = self._get_ordered_partner(active_ids)[-1].id
        return res

    # Group by
    group_by_email = fields.Boolean('Email')
    group_by_name = fields.Boolean('Name')
    group_by_is_company = fields.Boolean('Is Company')
    group_by_vat = fields.Boolean('VAT')
    group_by_parent_id = fields.Boolean('Parent Company')

    state = fields.Selection([
        ('option', 'Option'),
        ('selection', 'Selection'),
        ('finished', 'Finished')
    ], readonly=True, required=True, string='State', default='option')

    number_group = fields.Integer('Group of Contacts', readonly=True)
    current_line_id = fields.Many2one('base.partner.merge.line', string='Current Line')
    line_ids = fields.One2many('base.partner.merge.line', 'wizard_id', string='Lines')
    partner_ids = fields.Many2many('res.partner', string='Contacts', context={'active_test': False})
    dst_partner_id = fields.Many2one('res.partner', string='Destination Contact')

    exclude_contact = fields.Boolean('A user associated to the contact')
    exclude_journal_item = fields.Boolean('Journal Items associated to the contact')
    maximum_group = fields.Integer('Maximum of Group of Contacts')

    # ----------------------------------------
    # Update method. Core methods to merge steps
    # ----------------------------------------

    def _get_fk_on(self, table):
        """ return a list of many2one relation with the given table.
            :param table : the name of the sql table to return relations
            :returns a list of tuple 'table name', 'column name'.
        """
        query = """
            SELECT cl1.relname as table, att1.attname as column
            FROM pg_constraint as con, pg_class as cl1, pg_class as cl2, pg_attribute as att1, pg_attribute as att2
            WHERE con.conrelid = cl1.oid
                AND con.confrelid = cl2.oid
                AND array_lower(con.conkey, 1) = 1
                AND con.conkey[1] = att1.attnum
                AND att1.attrelid = cl1.oid
                AND cl2.relname = %s
                AND att2.attname = 'id'
                AND array_lower(con.confkey, 1) = 1
                AND con.confkey[1] = att2.attnum
                AND att2.attrelid = cl2.oid
                AND con.contype = 'f'
        """
        self._cr.execute(query, (table,))
        return self._cr.fetchall()

    @api.model
    def _update_foreign_keys(self, src_partners, dst_partner):
        """ Update all foreign key from the src_partner to dst_partner. All many2one fields will be updated.
            :param src_partners : merge source res.partner recordset (does not include destination one)
            :param dst_partner : record of destination res.partner
        """
        _logger.debug('_update_foreign_keys for dst_partner: %s for src_partners: %s', dst_partner.id, str(src_partners.ids))

        # find the many2one relation to a partner
        Partner = self.env['res.partner']
        relations = self._get_fk_on('res_partner')

        # this guarantees cache consistency
        self.env.invalidate_all()

        for table, column in relations:
            if 'base_partner_merge_' in table:  # ignore two tables
                continue

            # get list of columns of current table (exept the current fk column)
            query = "SELECT column_name FROM information_schema.columns WHERE table_name LIKE '%s'" % (table)
            self._cr.execute(query, ())
            columns = []
            for data in self._cr.fetchall():
                if data[0] != column:
                    columns.append(data[0])

            # do the update for the current table/column in SQL
            query_dic = {
                'table': table,
                'column': column,
                'value': columns[0],
            }
            if len(columns) <= 1:
                # unique key treated
                query = """
                    UPDATE "%(table)s" as ___tu
                    SET "%(column)s" = %%s
                    WHERE
                        "%(column)s" = %%s AND
                        NOT EXISTS (
                            SELECT 1
                            FROM "%(table)s" as ___tw
                            WHERE
                                "%(column)s" = %%s AND
                                ___tu.%(value)s = ___tw.%(value)s
                        )""" % query_dic
                for partner in src_partners:
                    self._cr.execute(query, (dst_partner.id, partner.id, dst_partner.id))
            else:
                try:
                    with mute_logger('odoo.sql_db'), self._cr.savepoint():
                        query = 'UPDATE "%(table)s" SET "%(column)s" = %%s WHERE "%(column)s" IN %%s' % query_dic
                        self._cr.execute(query, (dst_partner.id, tuple(src_partners.ids),))
                except psycopg2.Error:
                    # updating fails, most likely due to a violated unique constraint
                    # keeping record with nonexistent partner_id is useless, better delete it
                    query = 'DELETE FROM "%(table)s" WHERE "%(column)s" IN %%s' % query_dic
                    self._cr.execute(query, (tuple(src_partners.ids),))

    @api.model
    def _update_reference_fields(self, src_partners, dst_partner):
        """ Update all reference fields from the src_partner to dst_partner.
            :param src_partners : merge source res.partner recordset (does not include destination one)
            :param dst_partner : record of destination res.partner
        """
        _logger.debug('_update_reference_fields for dst_partner: %s for src_partners: %r', dst_partner.id, src_partners.ids)

        def update_records(model, src, field_model='model', field_id='res_id'):
            Model = self.env[model] if model in self.env else None
            if Model is None:
                return
            records = Model.sudo().search([(field_model, '=', 'res.partner'), (field_id, '=', src.id)])
            try:
                with mute_logger('odoo.sql_db'), self._cr.savepoint():
                    records.sudo().write({field_id: dst_partner.id})
                    records.env.flush_all()
            except psycopg2.Error:
                # updating fails, most likely due to a violated unique constraint
                # keeping record with nonexistent partner_id is useless, better delete it
                records.sudo().unlink()

        update_records = functools.partial(update_records)

        for partner in src_partners:
            update_records('calendar', src=partner, field_model='model_id.model')
            update_records('ir.attachment', src=partner, field_model='res_model')
            update_records('mail.followers', src=partner, field_model='res_model')
            update_records('mail.activity', src=partner, field_model='res_model')
            update_records('mail.message', src=partner)
            update_records('ir.model.data', src=partner)

        records = self.env['ir.model.fields'].sudo().search([('ttype', '=', 'reference')])
        for record in records:
            try:
                Model = self.env[record.model]
                field = Model._fields[record.name]
            except KeyError:
                # unknown model or field => skip
                continue

            if Model._abstract or field.compute is not None:
                continue

            for partner in src_partners:
                records_ref = Model.sudo().search([(record.name, '=', 'res.partner,%d' % partner.id)])
                values = {
                    record.name: 'res.partner,%d' % dst_partner.id,
                }
                records_ref.sudo().write(values)

        self.env.flush_all()

        # Company-dependent fields
        with self._cr.savepoint():
            params = {
                'destination_id': f'res.partner,{dst_partner.id}',
                'source_ids': tuple(f'res.partner,{src}' for src in src_partners.ids),
            }
            self._cr.execute("""
        UPDATE ir_property AS _ip1
        SET res_id = %(destination_id)s
        WHERE res_id IN %(source_ids)s
        AND NOT EXISTS (
             SELECT
             FROM ir_property AS _ip2
             WHERE _ip2.res_id = %(destination_id)s
             AND _ip2.fields_id = _ip1.fields_id
             AND _ip2.company_id = _ip1.company_id
        )""", params)

    def _get_summable_fields(self):
        """ Returns the list of fields that should be summed when merging partners
        """
        return []

    @api.model
    def _update_values(self, src_partners, dst_partner):
        """ Update values of dst_partner with the ones from the src_partners.
            :param src_partners : recordset of source res.partner
            :param dst_partner : record of destination res.partner
        """
        _logger.debug('_update_values for dst_partner: %s for src_partners: %r', dst_partner.id, src_partners.ids)

        model_fields = dst_partner.fields_get().keys()
        summable_fields = self._get_summable_fields()

        def write_serializer(item):
            if isinstance(item, models.BaseModel):
                return item.id
            else:
                return item

        # get all fields that are not computed or x2many
        values = dict()
        values_by_company = defaultdict(dict)   # {company: vals}
        for column in model_fields:
            field = dst_partner._fields[column]
            if field.type not in ('many2many', 'one2many') and field.compute is None:
                for item in itertools.chain(src_partners, [dst_partner]):
                    if item[column]:
                        if column in summable_fields and values.get(column):
                            values[column] += write_serializer(item[column])
                        else:
                            values[column] = write_serializer(item[column])
            elif field.company_dependent and column in summable_fields:
                # sum the values of partners for each company; use sudo() to
                # compute the sum on all companies, including forbidden ones
                partners = (src_partners + dst_partner).sudo()
                for company in self.env['res.company'].sudo().search([]):
                    values_by_company[company][column] = sum(
                        partners.with_company(company).mapped(column)
                    )

        # remove fields that can not be updated (id and parent_id)
        values.pop('id', None)
        parent_id = values.pop('parent_id', None)
        dst_partner.write(values)
        for company, vals in values_by_company.items():
            dst_partner.with_company(company).sudo().write(vals)
        # try to update the parent_id
        if parent_id and parent_id != dst_partner.id:
            try:
                dst_partner.write({'parent_id': parent_id})
            except ValidationError:
                _logger.info('Skip recursive partner hierarchies for parent_id %s of partner: %s', parent_id, dst_partner.id)

    def _merge(self, partner_ids, dst_partner=None, extra_checks=True):
        """ private implementation of merge partner
            :param partner_ids : ids of partner to merge
            :param dst_partner : record of destination res.partner
            :param extra_checks: pass False to bypass extra sanity check (e.g. email address)
        """
        # super-admin can be used to bypass extra checks
        if self.env.is_admin():
            extra_checks = False

        Partner = self.env['res.partner']
        partner_ids = Partner.browse(partner_ids).exists()
        if len(partner_ids) < 2:
            return

        if len(partner_ids) > 3:
            raise UserError(_("For safety reasons, you cannot merge more than 3 contacts together. You can re-open the wizard several times if needed."))

        # check if the list of partners to merge contains child/parent relation
        child_ids = self.env['res.partner']
        for partner_id in partner_ids:
            child_ids |= Partner.search([('id', 'child_of', [partner_id.id])]) - partner_id
        if partner_ids & child_ids:
            raise UserError(_("You cannot merge a contact with one of his parent."))

        # check if the list of partners to merge are linked to more than one user
        if len(partner_ids.with_context(active_test=False).user_ids) > 1:
            raise UserError(_("You cannot merge contacts linked to more than one user even if only one is active."))

        if extra_checks and len(set(partner.email for partner in partner_ids)) > 1:
            raise UserError(_("All contacts must have the same email. Only the Administrator can merge contacts with different emails."))

        # remove dst_partner from partners to merge
        if dst_partner and dst_partner in partner_ids:
            src_partners = partner_ids - dst_partner
        else:
            ordered_partners = self._get_ordered_partner(partner_ids.ids)
            dst_partner = ordered_partners[-1]
            src_partners = ordered_partners[:-1]
        _logger.info("dst_partner: %s", dst_partner.id)

        # Make the company of all related users consistent with destination partner company
        if dst_partner.company_id:
            partner_ids.mapped('user_ids').sudo().write({
                'company_ids': [Command.link(dst_partner.company_id.id)],
                'company_id': dst_partner.company_id.id
            })

        # call sub methods to do the merge
        self._update_foreign_keys(src_partners, dst_partner)
        self._update_reference_fields(src_partners, dst_partner)
        self._update_values(src_partners, dst_partner)

        self._log_merge_operation(src_partners, dst_partner)

        # delete source partner, since they are merged
        src_partners.unlink()

    def _log_merge_operation(self, src_partners, dst_partner):
        _logger.info('(uid = %s) merged the partners %r with %s', self._uid, src_partners.ids, dst_partner.id)

    # ----------------------------------------
    # Helpers
    # ----------------------------------------

    @api.model
    def _generate_query(self, fields, maximum_group=100):
        """ Build the SQL query on res.partner table to group them according to given criteria
            :param fields : list of column names to group by the partners
            :param maximum_group : limit of the query
        """
        # make the list of column to group by in sql query
        sql_fields = []
        for field in fields:
            if field in ['email', 'name']:
                sql_fields.append('lower(%s)' % field)
            elif field in ['vat']:
                sql_fields.append("replace(%s, ' ', '')" % field)
            else:
                sql_fields.append(field)
        group_fields = ', '.join(sql_fields)

        # where clause : for given group by columns, only keep the 'not null' record
        filters = []
        for field in fields:
            if field in ['email', 'name', 'vat']:
                filters.append((field, 'IS NOT', 'NULL'))
        criteria = ' AND '.join('%s %s %s' % (field, operator, value) for field, operator, value in filters)

        # build the query
        text = [
            "SELECT min(id), array_agg(id)",
            "FROM res_partner",
        ]

        if criteria:
            text.append('WHERE %s' % criteria)

        text.extend([
            "GROUP BY %s" % group_fields,
            "HAVING COUNT(*) >= 2",
            "ORDER BY min(id)",
        ])

        if maximum_group:
            text.append("LIMIT %s" % maximum_group,)

        return ' '.join(text)

    @api.model
    def _compute_selected_groupby(self):
        """ Returns the list of field names the partner can be grouped (as merge
            criteria) according to the option checked on the wizard
        """
        groups = []
        group_by_prefix = 'group_by_'

        for field_name in self._fields:
            if field_name.startswith(group_by_prefix):
                if field_name in self and self[field_name]:
                    groups.append(field_name[len(group_by_prefix):])

        if not groups:
            raise UserError(_("You have to specify a filter for your selection."))

        return groups

    @api.model
    def _partner_use_in(self, aggr_ids, models):
        """ Check if there is no occurence of this group of partner in the selected model
            :param aggr_ids : stringified list of partner ids separated with a comma (sql array_agg)
            :param models : dict mapping a model name with its foreign key with res_partner table
        """
        return any(
            self.env[model].search_count([(field, 'in', aggr_ids)])
            for model, field in models.items()
        )

    @api.model
    def _get_ordered_partner(self, partner_ids):
        """ Helper : returns a `res.partner` recordset ordered by create_date/active fields
            :param partner_ids : list of partner ids to sort
        """
        return self.env['res.partner'].browse(partner_ids).sorted(
            key=lambda p: (not p.active, (p.create_date or datetime.datetime(1970, 1, 1))),
            reverse=True,
        )

    def _compute_models(self):
        """ Compute the different models needed by the system if you want to exclude some partners. """
        model_mapping = {}
        if self.exclude_contact:
            model_mapping['res.users'] = 'partner_id'
        if 'account.move.line' in self.env and self.exclude_journal_item:
            model_mapping['account.move.line'] = 'partner_id'
        return model_mapping

    # ----------------------------------------
    # Actions
    # ----------------------------------------

    def action_skip(self):
        """ Skip this wizard line. Don't compute any thing, and simply redirect to the new step."""
        if self.current_line_id:
            self.current_line_id.unlink()
        return self._action_next_screen()

    def _action_next_screen(self):
        """ return the action of the next screen ; this means the wizard is set to treat the
            next wizard line. Each line is a subset of partner that can be merged together.
            If no line left, the end screen will be displayed (but an action is still returned).
        """
        self.env.invalidate_all() # FIXME: is this still necessary?
        values = {}
        if self.line_ids:
            # in this case, we try to find the next record.
            current_line = self.line_ids[0]
            current_partner_ids = literal_eval(current_line.aggr_ids)
            values.update({
                'current_line_id': current_line.id,
                'partner_ids': [Command.set(current_partner_ids)],
                'dst_partner_id': self._get_ordered_partner(current_partner_ids)[-1].id,
                'state': 'selection',
            })
        else:
            values.update({
                'current_line_id': False,
                'partner_ids': [],
                'state': 'finished',
            })

        self.write(values)

        return {
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'res_id': self.id,
            'view_mode': 'form',
            'target': 'new',
        }

    def _process_query(self, query):
        """ Execute the select request and write the result in this wizard
            :param query : the SQL query used to fill the wizard line
        """
        self.ensure_one()
        model_mapping = self._compute_models()

        # group partner query
        self._cr.execute(query) # pylint: disable=sql-injection

        counter = 0
        for min_id, aggr_ids in self._cr.fetchall():
            # To ensure that the used partners are accessible by the user
            partners = self.env['res.partner'].search([('id', 'in', aggr_ids)])
            if len(partners) < 2:
                continue

            # exclude partner according to options
            if model_mapping and self._partner_use_in(partners.ids, model_mapping):
                continue

            self.env['base.partner.merge.line'].create({
                'wizard_id': self.id,
                'min_id': min_id,
                'aggr_ids': partners.ids,
            })
            counter += 1

        self.write({
            'state': 'selection',
            'number_group': counter,
        })

        _logger.info("counter: %s", counter)

    def action_start_manual_process(self):
        """ Start the process 'Merge with Manual Check'. Fill the wizard according to the group_by and exclude
            options, and redirect to the first step (treatment of first wizard line). After, for each subset of
            partner to merge, the wizard will be actualized.
                - Compute the selected groups (with duplication)
                - If the user has selected the 'exclude_xxx' fields, avoid the partners
        """
        self.ensure_one()
        groups = self._compute_selected_groupby()
        query = self._generate_query(groups, self.maximum_group)
        self._process_query(query)
        return self._action_next_screen()

    def action_start_automatic_process(self):
        """ Start the process 'Merge Automatically'. This will fill the wizard with the same mechanism as 'Merge
            with Manual Check', but instead of refreshing wizard with the current line, it will automatically process
            all lines by merging partner grouped according to the checked options.
        """
        self.ensure_one()
        self.action_start_manual_process()  # here we don't redirect to the next screen, since it is automatic process
        self.env.invalidate_all() # FIXME: is this still necessary?

        for line in self.line_ids:
            partner_ids = literal_eval(line.aggr_ids)
            self._merge(partner_ids)
            line.unlink()
            self._cr.commit()  # TODO JEM : explain why

        self.write({'state': 'finished'})
        return {
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'res_id': self.id,
            'view_mode': 'form',
            'target': 'new',
        }

    def parent_migration_process_cb(self):
        self.ensure_one()

        query = """
            SELECT
                min(p1.id),
                array_agg(DISTINCT p1.id)
            FROM
                res_partner as p1
            INNER join
                res_partner as p2
            ON
                p1.email = p2.email AND
                p1.name = p2.name AND
                (p1.parent_id = p2.id OR p1.id = p2.parent_id)
            WHERE
                p2.id IS NOT NULL
            GROUP BY
                p1.email,
                p1.name,
                CASE WHEN p1.parent_id = p2.id THEN p2.id
                    ELSE p1.id
                END
            HAVING COUNT(*) >= 2
            ORDER BY
                min(p1.id)
        """

        self._process_query(query)

        for line in self.line_ids:
            partner_ids = literal_eval(line.aggr_ids)
            self._merge(partner_ids)
            line.unlink()
            self._cr.commit()

        self.write({'state': 'finished'})

        self._cr.execute("""
            UPDATE
                res_partner
            SET
                is_company = NULL,
                parent_id = NULL
            WHERE
                parent_id = id
        """)

        return {
            'type': 'ir.actions.act_window',
            'res_model': self._name,
            'res_id': self.id,
            'view_mode': 'form',
            'target': 'new',
        }

    def action_update_all_process(self):
        self.ensure_one()
        self.parent_migration_process_cb()

        # NOTE JEM : seems louche to create a new wizard instead of reuse the current one with updated options.
        # since it is like this from the initial commit of this wizard, I don't change it. yet ...
        wizard = self.create({'group_by_vat': True, 'group_by_email': True, 'group_by_name': True})
        wizard.action_start_automatic_process()

        # NOTE JEM : no idea if this query is usefull
        self._cr.execute("""
            UPDATE
                res_partner
            SET
                is_company = NULL
            WHERE
                parent_id IS NOT NULL AND
                is_company IS NOT NULL
        """)

        return self._action_next_screen()

    def action_merge(self):
        """ Merge Contact button. Merge the selected partners, and redirect to
            the end screen (since there is no other wizard line to process.
        """
        if not self.partner_ids:
            self.write({'state': 'finished'})
            return {
                'type': 'ir.actions.act_window',
                'res_model': self._name,
                'res_id': self.id,
                'view_mode': 'form',
                'target': 'new',
            }

        self._merge(self.partner_ids.ids, self.dst_partner_id)

        if self.current_line_id:
            self.current_line_id.unlink()

        return self._action_next_screen()

```

  File: wizard/base_partner_merge_views.xml
  Content:
```
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
        <record id="action_partner_deduplicate" model="ir.actions.act_window">
            <field name="name">Deduplicate Contacts</field>
            <field name="res_model">base.partner.merge.automatic.wizard</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
            <field name="context">{'active_test': False}</field>
        </record>

        <record id="base_partner_merge_automatic_wizard_form" model="ir.ui.view">
            <field name='name'>base.partner.merge.automatic.wizard.form</field>
            <field name='model'>base.partner.merge.automatic.wizard</field>
            <field name='arch' type='xml'>
                <form string='Automatic Merge Wizard' class="o_partner_merge_wizard">
                    <sheet>
                        <group invisible="state != 'finished'">
                            <h2 colspan="2">There are no more contacts to merge for this request</h2>
                            <button name="%(action_partner_deduplicate)d" string="Deduplicate the other Contacts" class="oe_highlight" type="action" colspan="2"/>
                        </group>
                        <p class="oe_grey" invisible="state != 'option'">
                            Select the list of fields used to search for
                            duplicated records. If you select several fields,
                            Odoo will propose you to merge only those having
                            all these fields in common. (not one of the fields).
                        </p>
                        <group invisible="state not in ('selection', 'finished') or number_group == 0">
                            <field name="state" invisible="1" />
                            <field name="number_group"/>
                        </group>
                        <group string="Search duplicates based on duplicated data in"
                            invisible="state not in ('option',)">
                            <field name='group_by_email' />
                            <field name='group_by_name' />
                            <field name='group_by_is_company' />
                            <field name='group_by_vat' />
                            <field name='group_by_parent_id' />
                        </group>
                        <group string="Exclude contacts having"
                            invisible="state not in ('option',)">
                            <field name='exclude_contact' />
                            <field name='exclude_journal_item' />
                        </group>
                        <separator string="Options" invisible="state not in ('option',)"/>
                        <group invisible="state not in ('option', 'finished')">
                            <field name='maximum_group' readonly="state == 'finished'"/>
                        </group>
                        <separator string="Merge the following contacts"
                            invisible="state in ('option', 'finished')"/>
                        <group invisible="state in ('option', 'finished')" col="1">
                            <p class="oe_grey">
                                Selected contacts will be merged together.
                                All documents linked to one of these contacts
                                will be redirected to the destination contact.
                                You can remove contacts from this list to avoid merging them.
                            </p>
                            <group col="2">
                                <field name="dst_partner_id"
                                    domain="[('id', 'in', partner_ids or False)]"
                                    required="state == 'selection'"
                                    context="{'partner_show_db_id': True}"/>
                            </group>
                            <field name="partner_ids" nolabel="1">
                                <tree string="Partners">
                                    <field name="id" />
                                    <field name="display_name" />
                                    <field name="email" />
                                    <field name="is_company" />
                                    <field name="vat" />
                                    <field name="country_id" />
                                </tree>
                            </field>
                        </group>
                    </sheet>
                    <footer>
                        <button name='action_merge' string='Merge Contacts'
                            class='oe_highlight'
                            type='object' data-hotkey="q"
                            invisible="state in ('option', 'finished')" />
                        <button name='action_skip' string='Skip these contacts'
                            type='object'
                            invisible="state != 'selection'" />
                        <button name='action_start_manual_process'
                            string='Merge with Manual Check' data-hotkey="w"
                            type='object'  class='oe_highlight'
                            invisible="state != 'option'" />
                        <button name='action_start_automatic_process'
                            string='Merge Automatically' data-hotkey="l"
                            type='object' class='oe_highlight'
                            confirm="Are you sure to execute the automatic merge of your contacts?"
                            invisible="state != 'option'" />
                        <button name='action_update_all_process'
                            string='Merge Automatically all process'
                            type='object' data-hotkey="y"
                            confirm="Are you sure to execute the list of automatic merges of your contacts?"
                            invisible="state != 'option'" />
                        <button special="cancel" data-hotkey="x" string="Cancel" type="object" class="btn btn-secondary oe_inline" invisible="state == 'finished'"/>
                        <button special="cancel" data-hotkey="x" string="Close" type="object" class="btn btn-secondary oe_inline" invisible="state != 'finished'"/>
                    </footer>
                </form>
            </field>
        </record>

        <record id="action_partner_merge" model="ir.actions.act_window">
            <field name="name">Merge</field>
            <field name="res_model">base.partner.merge.automatic.wizard</field>
            <field name="view_mode">form</field>
            <field name="target">new</field>
            <field name="binding_model_id" ref="base.model_res_partner"/>
            <field name="binding_view_types">list</field>
        </record>
</odoo>

```

